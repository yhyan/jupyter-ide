(self["webpackChunk_jupyterlab_application_top"]=self["webpackChunk_jupyterlab_application_top"]||[]).push([[9640],{43233:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true});t.DataConnector=void 0;class s{async list(e){throw new Error("DataConnector#list method has not been implemented.")}async remove(e){throw new Error("DataConnector#remove method has not been implemented.")}async save(e,t){throw new Error("DataConnector#save method has not been implemented.")}}t.DataConnector=s},19640:function(e,t,s){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,s,r){if(r===undefined)r=s;Object.defineProperty(e,r,{enumerable:true,get:function(){return t[s]}})}:function(e,t,s,r){if(r===undefined)r=s;e[r]=t[s]});var n=this&&this.__exportStar||function(e,t){for(var s in e)if(s!=="default"&&!Object.prototype.hasOwnProperty.call(t,s))r(t,e,s)};Object.defineProperty(t,"__esModule",{value:true});n(s(43233),t);n(s(38817),t);n(s(96163),t);n(s(20947),t);n(s(79112),t)},38817:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true})},96163:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true});t.RestorablePool=void 0;const r=s(9727);const n=s(72189);const i=s(75138);class a{constructor(e){this._added=new i.Signal(this);this._current=null;this._currentChanged=new i.Signal(this);this._hasRestored=false;this._isDisposed=false;this._objects=new Set;this._restore=null;this._restored=new r.PromiseDelegate;this._updated=new i.Signal(this);this.namespace=e.namespace}get added(){return this._added}get current(){return this._current}set current(e){if(this._current===e){return}if(e!==null&&this._objects.has(e)){this._current=e;this._currentChanged.emit(this._current)}}get currentChanged(){return this._currentChanged}get isDisposed(){return this._isDisposed}get restored(){return this._restored.promise}get size(){return this._objects.size}get updated(){return this._updated}async add(e){var t,s;if(e.isDisposed){const t="A disposed object cannot be added.";console.warn(t,e);throw new Error(t)}if(this._objects.has(e)){const t="This object already exists in the pool.";console.warn(t,e);throw new Error(t)}this._objects.add(e);e.disposed.connect(this._onInstanceDisposed,this);if(o.injectedProperty.get(e)){return}if(this._restore){const{connector:r}=this._restore;const n=this._restore.name(e);if(n){const i=`${this.namespace}:${n}`;const a=(s=(t=this._restore).args)===null||s===void 0?void 0:s.call(t,e);o.nameProperty.set(e,i);await r.save(i,{data:a})}}this._added.emit(e)}dispose(){if(this.isDisposed){return}this._current=null;this._isDisposed=true;this._objects.clear();i.Signal.clearData(this)}find(e){const t=this._objects.values();for(const s of t){if(e(s)){return s}}return undefined}forEach(e){this._objects.forEach(e)}filter(e){const t=[];this.forEach((s=>{if(e(s)){t.push(s)}}));return t}inject(e){o.injectedProperty.set(e,true);return this.add(e)}has(e){return this._objects.has(e)}async restore(e){if(this._hasRestored){throw new Error("This pool has already been restored.")}this._hasRestored=true;const{command:t,connector:s,registry:r,when:n}=e;const i=this.namespace;const a=n?[s.list(i)].concat(n):[s.list(i)];this._restore=e;const[o]=await Promise.all(a);const c=await Promise.all(o.ids.map((async(e,n)=>{const i=o.values[n];const a=i&&i.data;if(a===undefined){return s.remove(e)}return r.execute(t,a).catch((()=>s.remove(e)))})));this._restored.resolve();return c}async save(e){var t,s;const r=o.injectedProperty.get(e);if(!this._restore||!this.has(e)||r){return}const{connector:n}=this._restore;const i=this._restore.name(e);const a=o.nameProperty.get(e);const c=i?`${this.namespace}:${i}`:"";if(a&&a!==c){await n.remove(a)}o.nameProperty.set(e,c);if(c){const r=(s=(t=this._restore).args)===null||s===void 0?void 0:s.call(t,e);await n.save(c,{data:r})}if(a!==c){this._updated.emit(e)}}_onInstanceDisposed(e){this._objects.delete(e);if(e===this._current){this._current=null;this._currentChanged.emit(this._current)}if(o.injectedProperty.get(e)){return}if(!this._restore){return}const{connector:t}=this._restore;const s=o.nameProperty.get(e);if(s){void t.remove(s)}}}t.RestorablePool=a;var o;(function(e){e.injectedProperty=new n.AttachedProperty({name:"injected",create:()=>false});e.nameProperty=new n.AttachedProperty({name:"name",create:()=>""})})(o||(o={}))},20947:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true});t.StateDB=void 0;const r=s(75138);class n{constructor(e={}){this._changed=new r.Signal(this);const{connector:t,transform:s}=e;this._connector=t||new n.Connector;if(!s){this._ready=Promise.resolve(undefined)}else{this._ready=s.then((e=>{const{contents:t,type:s}=e;switch(s){case"cancel":return;case"clear":return this._clear();case"merge":return this._merge(t||{});case"overwrite":return this._overwrite(t||{});default:return}}))}}get changed(){return this._changed}async clear(){await this._ready;await this._clear()}async fetch(e){await this._ready;return this._fetch(e)}async list(e){await this._ready;return this._list(e)}async remove(e){await this._ready;await this._remove(e);this._changed.emit({id:e,type:"remove"})}async save(e,t){await this._ready;await this._save(e,t);this._changed.emit({id:e,type:"save"})}async toJSON(){await this._ready;const{ids:e,values:t}=await this._list();return t.reduce(((t,s,r)=>{t[e[r]]=s;return t}),{})}async _clear(){await Promise.all((await this._list()).ids.map((e=>this._remove(e))))}async _fetch(e){const t=await this._connector.fetch(e);if(t){return JSON.parse(t).v}}async _list(e=""){const{ids:t,values:s}=await this._connector.list(e);return{ids:t,values:s.map((e=>JSON.parse(e).v))}}async _merge(e){await Promise.all(Object.keys(e).map((t=>e[t]&&this._save(t,e[t]))))}async _overwrite(e){await this._clear();await this._merge(e)}async _remove(e){return this._connector.remove(e)}async _save(e,t){return this._connector.save(e,JSON.stringify({v:t}))}}t.StateDB=n;(function(e){class t{constructor(){this._storage={}}async fetch(e){return this._storage[e]}async list(e=""){return Object.keys(this._storage).reduce(((t,s)=>{if(e===""?true:e===s.split(":")[0]){t.ids.push(s);t.values.push(this._storage[s])}return t}),{ids:[],values:[]})}async remove(e){delete this._storage[e]}async save(e,t){this._storage[e]=t}}e.Connector=t})(n=t.StateDB||(t.StateDB={}))},79112:(e,t,s)=>{"use strict";Object.defineProperty(t,"__esModule",{value:true});t.IStateDB=void 0;const r=s(9727);t.IStateDB=new r.Token("@jupyterlab/coreutils:IStateDB")}}]);