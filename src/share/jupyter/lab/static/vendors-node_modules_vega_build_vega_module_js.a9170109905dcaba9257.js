(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega_build_vega_module_js"],{

/***/ "./node_modules/d3-array/src/ascending.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/ascending.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}


/***/ }),

/***/ "./node_modules/d3-array/src/bisect.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/bisect.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bisectRight": () => (/* binding */ bisectRight),
/* harmony export */   "bisectLeft": () => (/* binding */ bisectLeft),
/* harmony export */   "bisectCenter": () => (/* binding */ bisectCenter),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _bisector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisector.js */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");




const ascendingBisect = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_ascending_js__WEBPACK_IMPORTED_MODULE_1__.default);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = (0,_bisector_js__WEBPACK_IMPORTED_MODULE_0__.default)(_number_js__WEBPACK_IMPORTED_MODULE_2__.default).center;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (bisectRight);


/***/ }),

/***/ "./node_modules/d3-array/src/bisector.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/bisector.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;
    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    while (lo < hi) {
      const mid = (lo + hi) >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {left, center, right};
}

function ascendingComparator(f) {
  return (d, x) => (0,_ascending_js__WEBPACK_IMPORTED_MODULE_0__.default)(f(d), x);
}


/***/ }),

/***/ "./node_modules/d3-array/src/deviation.js":
/*!************************************************!*\
  !*** ./node_modules/d3-array/src/deviation.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ deviation)
/* harmony export */ });
/* harmony import */ var _variance_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./variance.js */ "./node_modules/d3-array/src/variance.js");


function deviation(values, valueof) {
  const v = (0,_variance_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, valueof);
  return v ? Math.sqrt(v) : v;
}


/***/ }),

/***/ "./node_modules/d3-array/src/fsum.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/fsum.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Adder": () => (/* binding */ Adder),
/* harmony export */   "fsum": () => (/* binding */ fsum),
/* harmony export */   "fcumsum": () => (/* binding */ fcumsum)
/* harmony export */ });
// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
class Adder {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j],
        hi = x + y,
        lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
}

function fsum(values, valueof) {
  const adder = new Adder();
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        adder.add(value);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        adder.add(value);
      }
    }
  }
  return +adder;
}

function fcumsum(values, valueof) {
  const adder = new Adder();
  let index = -1;
  return Float64Array.from(values, valueof === undefined
      ? v => adder.add(+v || 0)
      : v => adder.add(+valueof(v, ++index, values) || 0)
  );
}


/***/ }),

/***/ "./node_modules/d3-array/src/max.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/max.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
function max(values, valueof) {
  let max;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (max < value || (max === undefined && value >= value))) {
        max = value;
      }
    }
  }
  return max;
}


/***/ }),

/***/ "./node_modules/d3-array/src/mean.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-array/src/mean.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mean)
/* harmony export */ });
function mean(values, valueof) {
  let count = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        ++count, sum += value;
      }
    }
  }
  if (count) return sum / count;
}


/***/ }),

/***/ "./node_modules/d3-array/src/median.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/median.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quantile_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quantile.js */ "./node_modules/d3-array/src/quantile.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values, valueof) {
  return (0,_quantile_js__WEBPACK_IMPORTED_MODULE_0__.default)(values, 0.5, valueof);
}


/***/ }),

/***/ "./node_modules/d3-array/src/merge.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/merge.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ merge)
/* harmony export */ });
function* flatten(arrays) {
  for (const array of arrays) {
    yield* array;
  }
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}


/***/ }),

/***/ "./node_modules/d3-array/src/min.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/min.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
function min(values, valueof) {
  let min;
  if (valueof === undefined) {
    for (const value of values) {
      if (value != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null
          && (min > value || (min === undefined && value >= value))) {
        min = value;
      }
    }
  }
  return min;
}


/***/ }),

/***/ "./node_modules/d3-array/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-array/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "numbers": () => (/* binding */ numbers)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x === null ? NaN : +x;
}

function* numbers(values, valueof) {
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-array/src/permute.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-array/src/permute.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(source, keys) {
  return Array.from(keys, key => source[key]);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile),
/* harmony export */   "quantileSorted": () => (/* binding */ quantileSorted)
/* harmony export */ });
/* harmony import */ var _max_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./max.js */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var _min_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./min.js */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var _quickselect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./quickselect.js */ "./node_modules/d3-array/src/quickselect.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-array/src/number.js");





function quantile(values, p, valueof) {
  values = Float64Array.from((0,_number_js__WEBPACK_IMPORTED_MODULE_0__.numbers)(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values);
  if (p >= 1) return (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0,_max_js__WEBPACK_IMPORTED_MODULE_2__.default)((0,_quickselect_js__WEBPACK_IMPORTED_MODULE_3__.default)(values, i0).subarray(0, i0 + 1)),
      value1 = (0,_min_js__WEBPACK_IMPORTED_MODULE_1__.default)(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p, valueof = _number_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}


/***/ }),

/***/ "./node_modules/d3-array/src/quickselect.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-array/src/quickselect.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quickselect)
/* harmony export */ });
/* harmony import */ var _ascending_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ascending.js */ "./node_modules/d3-array/src/ascending.js");


// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k, left = 0, right = array.length - 1, compare = _ascending_js__WEBPACK_IMPORTED_MODULE_0__.default) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    const t = array[k];
    let i = left;
    let j = right;

    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;
      while (compare(array[i], t) < 0) ++i;
      while (compare(array[j], t) > 0) --j;
    }

    if (compare(array[left], t) === 0) swap(array, left, j);
    else ++j, swap(array, j, right);

    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
  return array;
}

function swap(array, i, j) {
  const t = array[i];
  array[i] = array[j];
  array[j] = t;
}


/***/ }),

/***/ "./node_modules/d3-array/src/range.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/range.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}


/***/ }),

/***/ "./node_modules/d3-array/src/sum.js":
/*!******************************************!*\
  !*** ./node_modules/d3-array/src/sum.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sum)
/* harmony export */ });
function sum(values, valueof) {
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value = +value) {
        sum += value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index, values)) {
        sum += value;
      }
    }
  }
  return sum;
}


/***/ }),

/***/ "./node_modules/d3-array/src/ticks.js":
/*!********************************************!*\
  !*** ./node_modules/d3-array/src/ticks.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "tickIncrement": () => (/* binding */ tickIncrement),
/* harmony export */   "tickStep": () => (/* binding */ tickStep)
/* harmony export */ });
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    if (r0 * step < start) ++r0;
    if (r1 * step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    if (r0 / step < start) ++r0;
    if (r1 / step > stop) --r1;
    ticks = new Array(n = r1 - r0 + 1);
    while (++i < n) ticks[i] = (r0 + i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}


/***/ }),

/***/ "./node_modules/d3-array/src/variance.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-array/src/variance.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ variance)
/* harmony export */ });
function variance(values, valueof) {
  let count = 0;
  let delta;
  let mean = 0;
  let sum = 0;
  if (valueof === undefined) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        delta = value - mean;
        mean += delta / ++count;
        sum += delta * (value - mean);
      }
    }
  }
  if (count > 1) return sum / (count - 1);
}


/***/ }),

/***/ "./node_modules/d3-color/src/color.js":
/*!********************************************!*\
  !*** ./node_modules/d3-color/src/color.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "darker": () => (/* binding */ darker),
/* harmony export */   "brighter": () => (/* binding */ brighter),
/* harmony export */   "default": () => (/* binding */ color),
/* harmony export */   "rgbConvert": () => (/* binding */ rgbConvert),
/* harmony export */   "rgb": () => (/* binding */ rgb),
/* harmony export */   "Rgb": () => (/* binding */ Rgb),
/* harmony export */   "hslConvert": () => (/* binding */ hslConvert),
/* harmony export */   "hsl": () => (/* binding */ hsl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");


function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Rgb, rgb, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(")
      + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
      + Math.max(0, Math.min(255, Math.round(this.b) || 0))
      + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_0__.default)(Hsl, hsl, (0,_define_js__WEBPACK_IMPORTED_MODULE_0__.extend)(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(")
        + (this.h || 0) + ", "
        + (this.s || 0) * 100 + "%, "
        + (this.l || 0) * 100 + "%"
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}


/***/ }),

/***/ "./node_modules/d3-color/src/cubehelix.js":
/*!************************************************!*\
  !*** ./node_modules/d3-color/src/cubehelix.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cubehelix),
/* harmony export */   "Cubehelix": () => (/* binding */ Cubehelix)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_2__.default)(Cubehelix, cubehelix, (0,_define_js__WEBPACK_IMPORTED_MODULE_2__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.brighter : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? _color_js__WEBPACK_IMPORTED_MODULE_0__.darker : Math.pow(_color_js__WEBPACK_IMPORTED_MODULE_0__.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/define.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-color/src/define.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "extend": () => (/* binding */ extend)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}


/***/ }),

/***/ "./node_modules/d3-color/src/lab.js":
/*!******************************************!*\
  !*** ./node_modules/d3-color/src/lab.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gray": () => (/* binding */ gray),
/* harmony export */   "default": () => (/* binding */ lab),
/* harmony export */   "Lab": () => (/* binding */ Lab),
/* harmony export */   "lch": () => (/* binding */ lch),
/* harmony export */   "hcl": () => (/* binding */ hcl),
/* harmony export */   "Hcl": () => (/* binding */ Hcl)
/* harmony export */ });
/* harmony import */ var _define_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./define.js */ "./node_modules/d3-color/src/define.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-color/src/math.js");




// https://observablehq.com/@mbostock/lab-and-rgb
const K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb)) o = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Lab, lab, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color_js__WEBPACK_IMPORTED_MODULE_0__.Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0,_define_js__WEBPACK_IMPORTED_MODULE_1__.default)(Hcl, hcl, (0,_define_js__WEBPACK_IMPORTED_MODULE_1__.extend)(_color_js__WEBPACK_IMPORTED_MODULE_0__.Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));


/***/ }),

/***/ "./node_modules/d3-color/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-color/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "degrees": () => (/* binding */ degrees)
/* harmony export */ });
const radians = Math.PI / 180;
const degrees = 180 / Math.PI;


/***/ }),

/***/ "./node_modules/d3-delaunay/src/delaunay.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-delaunay/src/delaunay.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunay)
/* harmony export */ });
/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! delaunator */ "./node_modules/delaunator/index.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./polygon.js */ "./node_modules/d3-delaunay/src/polygon.js");
/* harmony import */ var _voronoi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./voronoi.js */ "./node_modules/d3-delaunay/src/voronoi.js");





const tau = 2 * Math.PI, pow = Math.pow;

function pointX(p) {
  return p[0];
}

function pointY(p) {
  return p[1];
}

// A triangulation is collinear if all its triangles have a non-null area
function collinear(d) {
  const {triangles, coords} = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i],
          b = 2 * triangles[i + 1],
          c = 2 * triangles[i + 2],
          cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
    if (cross > 1e-10) return false;
  }
  return true;
}

function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}

class Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new Delaunay("length" in points
        ? flatArray(points, fx, fy, that)
        : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;

    // check for collinear
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
        .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
        bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
        r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new delaunator__WEBPACK_IMPORTED_MODULE_0__.default(points);
    } else {
      delete this.collinear;
    }

    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);

    // Compute an index from each point to an (arbitrary) incoming halfedge
    // Used to give the first neighbor of each point; for this reason,
    // on the hull we give priority to exterior halfedges
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }

    // degenerate case: 1 or 2 (distinct) points
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      this.triangles[1] = hull[1];
      this.triangles[2] = hull[1];
      inedges[hull[0]] = 1;
      if (hull.length === 2) inedges[hull[1]] = 0;
    }
  }
  voronoi(bounds) {
    return new _voronoi_js__WEBPACK_IMPORTED_MODULE_1__.default(this, bounds);
  }
  *neighbors(i) {
    const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

    // degenerate case with several collinear points
    if (collinear) {
      const l = collinear.indexOf(i);
      if (l > 0) yield collinear[l - 1];
      if (l < collinear.length - 1) yield collinear[l + 1];
      return;
    }

    const e0 = inedges[i];
    if (e0 === -1) return; // coincident point
    let e = e0, p0 = -1;
    do {
      yield p0 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p0) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c;
    while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
    return c;
  }
  _step(i, x, y) {
    const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c = i;
    let dc = pow(x - points[i * 2], 2) + pow(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow(x - points[t * 2], 2) + pow(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow(x - points[e * 2], 2) + pow(y - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c;
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, halfedges, triangles} = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context.moveTo(points[ti], points[ti + 1]);
      context.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context);
    return buffer && buffer.value();
  }
  renderPoints(context, r = 2) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points} = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i], y = points[i + 1];
      context.moveTo(x + r, y);
      context.arc(x, y, r, 0, tau);
    }
    return buffer && buffer.value();
  }
  renderHull(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {hull, points} = this;
    const h = hull[0] * 2, n = hull.length;
    context.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h = 2 * hull[i];
      context.lineTo(points[h], points[h + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  hullPolygon() {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_2__.default : undefined;
    const {points, triangles} = this;
    const t0 = triangles[i *= 3] * 2;
    const t1 = triangles[i + 1] * 2;
    const t2 = triangles[i + 2] * 2;
    context.moveTo(points[t0], points[t0 + 1]);
    context.lineTo(points[t1], points[t1 + 1]);
    context.lineTo(points[t2], points[t2 + 1]);
    context.closePath();
    return buffer && buffer.value();
  }
  *trianglePolygons() {
    const {triangles} = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_3__.default;
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
}

function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array[i * 2] = fx.call(that, p, i, points);
    array[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array;
}

function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}


/***/ }),

/***/ "./node_modules/d3-delaunay/src/path.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-delaunay/src/path.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Path)
/* harmony export */ });
const epsilon = 1e-6;

class Path {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
  }
  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }
  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x0 = x + r;
    const y0 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x0},${y0}`;
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._ += "L" + x0 + "," + y0;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
  }
  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
}


/***/ }),

/***/ "./node_modules/d3-delaunay/src/polygon.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-delaunay/src/polygon.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Polygon)
/* harmony export */ });
class Polygon {
  constructor() {
    this._ = [];
  }
  moveTo(x, y) {
    this._.push([x, y]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x, y) {
    this._.push([x, y]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}


/***/ }),

/***/ "./node_modules/d3-delaunay/src/voronoi.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-delaunay/src/voronoi.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-delaunay/src/path.js");
/* harmony import */ var _polygon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polygon.js */ "./node_modules/d3-delaunay/src/polygon.js");



class Voronoi {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const {delaunay: {points, hull, triangles}, vectors} = this;

    // Compute circumcenters.
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t1 = triangles[i] * 2;
      const t2 = triangles[i + 1] * 2;
      const t3 = triangles[i + 2] * 2;
      const x1 = points[t1];
      const y1 = points[t1 + 1];
      const x2 = points[t2];
      const y2 = points[t2 + 1];
      const x3 = points[t3];
      const y3 = points[t3 + 1];

      const dx = x2 - x1;
      const dy = y2 - y1;
      const ex = x3 - x1;
      const ey = y3 - y1;
      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const ab = (dx * ey - dy * ex) * 2;

      if (!ab) {
        // degenerate case (collinear diagram)
        x = (x1 + x3) / 2 - 1e8 * ey;
        y = (y1 + y3) / 2 + 1e8 * ex;
      }
      else if (Math.abs(ab) < 1e-8) {
        // almost equal points (degenerate triangle)
        x = (x1 + x3) / 2;
        y = (y1 + y3) / 2;
      } else {
        const d = 1 / ab;
        x = x1 + (ey * bl - dy * cl) * d;
        y = y1 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }

    // Compute exterior cell rays.
    let h = hull[hull.length - 1];
    let p0, p1 = h * 4;
    let x0, x1 = points[2 * h];
    let y0, y1 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p0 = p1, x0 = x1, y0 = y1;
      p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
      vectors[p0 + 2] = vectors[p1] = y0 - y1;
      vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
    }
  }
  render(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context);
    }
    let h0, h1 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h0 = h1, h1 = hull[i];
      const t = Math.floor(inedges[h1] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v = h0 * 4;
      const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context);
    }
    return buffer && buffer.value();
  }
  renderBounds(context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer && buffer.value();
  }
  renderCell(i, context) {
    const buffer = context == null ? context = new _path_js__WEBPACK_IMPORTED_MODULE_0__.default : undefined;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
    for (let i = 2; i < n; i += 2) {
      if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
        context.lineTo(points[i], points[i + 1]);
    }
    context.closePath();
    return buffer && buffer.value();
  }
  *cellPolygons() {
    const {delaunay: {points}} = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new _polygon_js__WEBPACK_IMPORTED_MODULE_1__.default;
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x0, y0, x1, y1, context) {
    let S;
    const c0 = this._regioncode(x0, y0);
    const c1 = this._regioncode(x1, y1);
    if (c0 === 0 && c1 === 0) {
      context.moveTo(x0, y0);
      context.lineTo(x1, y1);
    } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
      context.moveTo(S[0], S[1]);
      context.lineTo(S[2], S[3]);
    }
  }
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      // find the common edge
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] == cj[aj]
          && ci[ai + 1] == cj[aj + 1]
          && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
          && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
          ) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
    const e0 = inedges[i];
    if (e0 === -1) return null; // coincident point
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break; // bad triangulation
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    // degenerate case (1 valid point: return the box)
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const {vectors: V} = this;
    const v = i * 4;
    return V[v] || V[v + 1]
        ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
        : this._clipFinite(i, points);
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
    let c0, c1 = this._regioncode(x1, y1);
    let e0, e1;
    for (let j = 0; j < n; j += 2) {
      x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x1, y1);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x1, y1);
        else P = [x1, y1];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x0, y0, x1, y1, c0, c1) {
    while (true) {
      if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
      if (c0 & c1) return null;
      let x, y, c = c0 || c1;
      if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
      else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
      else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
      else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
      if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
      else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 0b0101: e0 = 0b0100; continue; // top-left
        case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
        case 0b0110: e0 = 0b0010; continue; // top-right
        case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
        case 0b1010: e0 = 0b1000; continue; // bottom-right
        case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
        case 0b1001: e0 = 0b0001; continue; // bottom-left
        case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    if (P.length > 4) {
      for (let i = 0; i < P.length; i+= 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k]
        || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
          P.splice(j, 2), i -= 2;
      }
    }
    return j;
  }
  _project(x0, y0, vx, vy) {
    let t = Infinity, c, x, y;
    if (vy < 0) { // top
      if (y0 <= this.ymin) return null;
      if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
    } else if (vy > 0) { // bottom
      if (y0 >= this.ymax) return null;
      if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
    }
    if (vx > 0) { // right
      if (x0 >= this.xmax) return null;
      if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
    } else if (vx < 0) { // left
      if (x0 <= this.xmin) return null;
      if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 0b0001
        : x === this.xmax ? 0b0010 : 0b0000)
        | (y === this.ymin ? 0b0100
        : y === this.ymax ? 0b1000 : 0b0000);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 0b0001
        : x > this.xmax ? 0b0010 : 0b0000)
        | (y < this.ymin ? 0b0100
        : y > this.ymax ? 0b1000 : 0b0000);
  }
}


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-dsv/src/dsv.js":
/*!****************************************!*\
  !*** ./node_modules/d3-dsv/src/dsv.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "] || \"\"";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

function pad(value, width) {
  var s = value + "", length = s.length;
  return length < width ? new Array(width - length + 1).join(0) + s : s;
}

function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6)
    : year > 9999 ? "+" + pad(year, 6)
    : pad(year, 4);
}

function formatDate(date) {
  var hours = date.getUTCHours(),
      minutes = date.getUTCMinutes(),
      seconds = date.getUTCSeconds(),
      milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date"
      : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2)
      + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z"
      : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z"
      : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z"
      : "");
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }

  function formatBody(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(value) {
    return value == null ? ""
        : value instanceof Date ? formatDate(value)
        : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
        : value;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatBody: formatBody,
    formatRows: formatRows,
    formatRow: formatRow,
    formatValue: formatValue
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/center.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/center.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__.default)(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__.default)(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/manyBody.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/manyBody.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "./node_modules/d3-force/src/simulation.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__.default)(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
        if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += x * x;
      if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__.default)(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__.default)("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-format/src/defaultLocale.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/defaultLocale.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formatPrefix": () => (/* binding */ formatPrefix),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-format/src/locale.js");


var locale;
var format;
var formatPrefix;

defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-format/src/exponent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/exponent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(Math.abs(x)), x ? x[1] : NaN;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatDecimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatDecimal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "formatDecimalParts": () => (/* binding */ formatDecimalParts)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return Math.abs(x = Math.round(x)) >= 1e21
      ? x.toLocaleString("en").replace(/,/g, "")
      : x.toString(10);
}

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimalParts(1.23) returns ["123", 0].
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatGroup.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatGroup.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatNumerals.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/formatNumerals.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatPrefixAuto.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-format/src/formatPrefixAuto.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "prefixExponent": () => (/* binding */ prefixExponent),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


var prefixExponent;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatRounded.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-format/src/formatRounded.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, p) {
  var d = (0,_formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.formatDecimalParts)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatSpecifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/formatSpecifier.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatSpecifier),
/* harmony export */   "FormatSpecifier": () => (/* binding */ FormatSpecifier)
/* harmony export */ });
// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
  this.align = specifier.align === undefined ? ">" : specifier.align + "";
  this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === undefined ? undefined : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === undefined ? "" : specifier.type + "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width === undefined ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};


/***/ }),

/***/ "./node_modules/d3-format/src/formatTrim.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-format/src/formatTrim.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}


/***/ }),

/***/ "./node_modules/d3-format/src/formatTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-format/src/formatTypes.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatDecimal.js */ "./node_modules/d3-format/src/formatDecimal.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatRounded.js */ "./node_modules/d3-format/src/formatRounded.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": _formatDecimal_js__WEBPACK_IMPORTED_MODULE_0__.default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => (0,_formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default)(x * 100, p),
  "r": _formatRounded_js__WEBPACK_IMPORTED_MODULE_1__.default,
  "s": _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_2__.default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
});


/***/ }),

/***/ "./node_modules/d3-format/src/identity.js":
/*!************************************************!*\
  !*** ./node_modules/d3-format/src/identity.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/d3-format/src/locale.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-format/src/locale.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");
/* harmony import */ var _formatGroup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatGroup.js */ "./node_modules/d3-format/src/formatGroup.js");
/* harmony import */ var _formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatNumerals.js */ "./node_modules/d3-format/src/formatNumerals.js");
/* harmony import */ var _formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatSpecifier.js */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var _formatTrim_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatTrim.js */ "./node_modules/d3-format/src/formatTrim.js");
/* harmony import */ var _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatTypes.js */ "./node_modules/d3-format/src/formatTypes.js");
/* harmony import */ var _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatPrefixAuto.js */ "./node_modules/d3-format/src/formatPrefixAuto.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/d3-format/src/identity.js");









var map = Array.prototype.map,
    prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var group = locale.grouping === undefined || locale.thousands === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatGroup_js__WEBPACK_IMPORTED_MODULE_1__.default)(map.call(locale.grouping, Number), locale.thousands + ""),
      currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
      currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
      decimal = locale.decimal === undefined ? "." : locale.decimal + "",
      numerals = locale.numerals === undefined ? _identity_js__WEBPACK_IMPORTED_MODULE_0__.default : (0,_formatNumerals_js__WEBPACK_IMPORTED_MODULE_2__.default)(map.call(locale.numerals, String)),
      percent = locale.percent === undefined ? "%" : locale.percent + "",
      minus = locale.minus === undefined ? "" : locale.minus + "",
      nan = locale.nan === undefined ? "NaN" : locale.nan + "";

  function newFormat(specifier) {
    specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!_formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type]) precision === undefined && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = _formatTypes_js__WEBPACK_IMPORTED_MODULE_4__.default[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision === undefined ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Determine the sign. -0 is not less than 0, but 1 / -0 is!
        var valueNegative = value < 0 || 1 / value < 0;

        // Perform the initial formatting.
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = (0,_formatTrim_js__WEBPACK_IMPORTED_MODULE_5__.default)(value);

        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
        if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto_js__WEBPACK_IMPORTED_MODULE_6__.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0,_formatSpecifier_js__WEBPACK_IMPORTED_MODULE_3__.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_7__.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionFixed.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionFixed.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step) {
  return Math.max(0, -(0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionPrefix.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionPrefix.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(value) / 3))) * 3 - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(Math.abs(step)));
}


/***/ }),

/***/ "./node_modules/d3-format/src/precisionRound.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-format/src/precisionRound.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _exponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exponent.js */ "./node_modules/d3-format/src/exponent.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(max) - (0,_exponent_js__WEBPACK_IMPORTED_MODULE_0__.default)(step)) + 1;
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "round": () => (/* binding */ round),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "sqrt1_2": () => (/* binding */ sqrt1_2),
/* harmony export */   "sqrt2": () => (/* binding */ sqrt2),
/* harmony export */   "sqrtPi": () => (/* binding */ sqrtPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "sinci": () => (/* binding */ sinci),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tanh": () => (/* binding */ tanh),
/* harmony export */   "sinh": () => (/* binding */ sinh),
/* harmony export */   "cosh": () => (/* binding */ cosh),
/* harmony export */   "arsinh": () => (/* binding */ arsinh),
/* harmony export */   "arcosh": () => (/* binding */ arcosh)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mollweide.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mollweide.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mollweideBromleyTheta": () => (/* binding */ mollweideBromleyTheta),
/* harmony export */   "mollweideBromleyRaw": () => (/* binding */ mollweideBromleyRaw),
/* harmony export */   "mollweideRaw": () => (/* binding */ mollweideRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi), i = 30, delta;
  do phi -= delta = (phi + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) - cpsinPhi) / (1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi));
  while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return phi / 2;
}

function mollweideBromleyRaw(cx, cy, cp) {

  function forward(lambda, phi) {
    return [cx * lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi = mollweideBromleyTheta(cp, phi)), cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
  }

  forward.invert = function(x, y) {
    return y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y / cy), [x / (cx * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y)), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((2 * y + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(2 * y)) / cp)];
  };

  return forward;
}

var mollweideRaw = mollweideBromleyRaw(_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2 / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi, _math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2, _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__.default)(mollweideRaw)
      .scale(169.529);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/area.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/area.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "areaRingSum": () => (/* binding */ areaRingSum),
/* harmony export */   "areaStream": () => (/* binding */ areaStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");





var areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();

// hello?

var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_2__.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  sphere: function() {
    areaSum.add(_math_js__WEBPACK_IMPORTED_MODULE_2__.tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  lambda0 = lambda, cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi), sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_2__.radians;
  phi = phi / 2 + _math_js__WEBPACK_IMPORTED_MODULE_2__.quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(phi),
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.cos)(adLambda),
      v = k * sdLambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sin)(adLambda);
  areaRingSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.atan2)(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, areaStream);
  return areaSum * 2;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/bounds.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/bounds.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");






var lambda0, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00, phi00, // first point
    p0, // previous 3D point
    deltaSum,
    ranges,
    range;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonStart();
  },
  polygonEnd: function() {
    _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area_js__WEBPACK_IMPORTED_MODULE_1__.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi1 = 90;
    else if (deltaSum < -_math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  },
  sphere: function() {
    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)([lambda * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians, phi * _math_js__WEBPACK_IMPORTED_MODULE_2__.radians]);
  if (p0) {
    var normal = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(equatorial, normal);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianNormalizeInPlace)(inflection);
    inflection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees * sign,
        phii,
        antimeridian = (0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180;
    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math_js__WEBPACK_IMPORTED_MODULE_2__.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);
  _area_js__WEBPACK_IMPORTED_MODULE_1__.areaStream.lineEnd();
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(deltaSum) > _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_4__.default)(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;

  return lambda0 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0, phi0], [lambda1, phi1]];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/cartesian.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/cartesian.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spherical": () => (/* binding */ spherical),
/* harmony export */   "cartesian": () => (/* binding */ cartesian),
/* harmony export */   "cartesianDot": () => (/* binding */ cartesianDot),
/* harmony export */   "cartesianCross": () => (/* binding */ cartesianCross),
/* harmony export */   "cartesianAddInPlace": () => (/* binding */ cartesianAddInPlace),
/* harmony export */   "cartesianScale": () => (/* binding */ cartesianScale),
/* harmony export */   "cartesianNormalizeInPlace": () => (/* binding */ cartesianNormalizeInPlace)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


function spherical(cartesian) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);
  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/centroid.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/centroid.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./noop.js */ "./node_modules/d3-geo/src/noop.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stream.js */ "./node_modules/d3-geo/src/stream.js");





var W0, W1,
    X0, Y0, Z0,
    X1, Y1, Z1,
    X2, Y2, Z2,
    lambda00, phi00, // first point
    x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  centroidPointCartesian(cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi);
  x0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda);
  y0 = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda);
  z0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi *= _math_js__WEBPACK_IMPORTED_MODULE_1__.radians;
  var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi),
      x = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(lambda),
      y = cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda),
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(cx, cy, cz),
      w = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2.add(v * cx);
  Y2.add(v * cy);
  Z2.add(v * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 = 0;
  X2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Y2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  Z2 = new d3_array__WEBPACK_IMPORTED_MODULE_2__.Adder();
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_3__.default)(object, centroidStream);

  var x = +X2,
      y = +Y2,
      z = +Z2,
      m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) x = X0, y = Y0, z = Z0;
    m = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.hypot)(x, y, z);
    // If the feature still has an undefined ccentroid, then return.
    if (m < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon2) return [NaN, NaN];
  }

  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan2)(y, x) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / m) * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
}


/***/ }),

/***/ "./node_modules/d3-geo/src/circle.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/circle.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "circleStream": () => (/* binding */ circleStream),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-geo/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rotation.js */ "./node_modules/d3-geo/src/rotation.js");





// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      sinRadius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.spherical)([cosRadius, -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(t), -sinRadius * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesian)(point), point[0] -= cosRadius;
  (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalizeInPlace)(point);
  var radius = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var center = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([0, 0]),
      radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(90),
      precision = (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, x[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
        p = precision.apply(this, arguments) * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians;
    ring = [];
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_3__.rotateRadians)(-c[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, -c[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_2__.default)(+_), circle) : precision;
  };

  return circle;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/antimeridian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/antimeridian.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi]
));

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi,
          delta = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - lambda0);
      if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math_js__WEBPACK_IMPORTED_MODULE_1__.pi) { // line crosses antimeridian
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda0 - sign0) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda0 -= sign0 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; // handle degeneracies
        if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(lambda1 - sign1) < _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) lambda1 -= sign1 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0 - lambda1);
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(sinLambda0Lambda1) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon
      ? (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.atan)(((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi0) * (cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi1)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda1)
          - (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(phi1) * (cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(phi0)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * _math_js__WEBPACK_IMPORTED_MODULE_1__.halfPi;
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(0, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, -phi);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, 0);
    stream.point(-_math_js__WEBPACK_IMPORTED_MODULE_1__.pi, phi);
  } else if ((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(from[0] - to[0]) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon) {
    var lambda = from[0] < to[0] ? _math_js__WEBPACK_IMPORTED_MODULE_1__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_1__.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/buffer.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/buffer.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var lines = [],
      line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/circle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/circle.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _circle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../circle.js */ "./node_modules/d3-geo/src/circle.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/clip/index.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var cr = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(radius),
      delta = 6 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,
      smallRadius = cr > 0,
      notHemisphere = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(cr) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    (0,_circle_js__WEBPACK_IMPORTED_MODULE_1__.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? _math_js__WEBPACK_IMPORTED_MODULE_0__.pi : -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point2) || (0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !(0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_2__.default)(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(a),
        pb = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesian)(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(pa, pb),
        n2n2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianCross)(n1, n2),
        A = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n1, c1),
        B = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(n2, c2);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, u),
        uu = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(u, u),
        t2 = w * w - uu * ((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianDot)(A, A) - 1);

    if (t2 < 0) return;

    var t = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(t2),
        q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w - t) / uu);
    (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q, A);
    q = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon,
        meridian = polar || delta < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(q[0] - lambda0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianScale)(u, (-w + t) / uu);
      (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.cartesianAddInPlace)(q1, A);
      return [q, (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_3__.spherical)(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : _math_js__WEBPACK_IMPORTED_MODULE_0__.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return (0,_index_js__WEBPACK_IMPORTED_MODULE_4__.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math_js__WEBPACK_IMPORTED_MODULE_0__.pi, radius - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _polygonContains_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../polygonContains.js */ "./node_modules/d3-geo/src/polygonContains.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(segments);
        var startInside = (0,_polygonContains_js__WEBPACK_IMPORTED_MODULE_2__.default)(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_4__.epsilon : _math_js__WEBPACK_IMPORTED_MODULE_4__.halfPi - b[1]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/line.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/clip/line.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rectangle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rectangle.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ clipRectangle)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ "./node_modules/d3-geo/src/clip/buffer.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-geo/src/clip/line.js");
/* harmony import */ var _rejoin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rejoin.js */ "./node_modules/d3-geo/src/clip/rejoin.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/merge.js");






var clipMax = 1e9, clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 0 : 3
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[0] - x1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 2 : 1
        : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(p[1] - y0) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = (0,_buffer_js__WEBPACK_IMPORTED_MODULE_1__.default)(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          (0,_rejoin_js__WEBPACK_IMPORTED_MODULE_3__.default)(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if ((0,_line_js__WEBPACK_IMPORTED_MODULE_4__.default)(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/clip/rejoin.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/clip/rejoin.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _pointEqual_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../pointEqual.js */ "./node_modules/d3-geo/src/pointEqual.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    if ((0,_pointEqual_js__WEBPACK_IMPORTED_MODULE_0__.default)(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      // handle degenerate cases by moving the point
      p1[0] += 2 * _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/compose.js":
/*!********************************************!*\
  !*** ./node_modules/d3-geo/src/compose.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/constant.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/constant.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/graticule.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/graticule.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ graticule),
/* harmony export */   "graticule10": () => (/* binding */ graticule10)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function graticuleX(y0, y1, dy) {
  var y = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(y0, y1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(x0, x1 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(X0 / DX) * DX, X1, DX).map(X)
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(x0 / dx) * dx, x1, dx).filter(function(x) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(x % DX) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(x))
        .concat((0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)((0,_math_js__WEBPACK_IMPORTED_MODULE_1__.ceil)(y0 / dy) * dy, y1, dy).filter(function(y) { return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.abs)(y % DY) > _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 90 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]])
      .extentMinor([[-180, -80 - _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon], [180, 80 + _math_js__WEBPACK_IMPORTED_MODULE_1__.epsilon]]);
}

function graticule10() {
  return graticule()();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/identity.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/identity.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => x);


/***/ }),

/***/ "./node_modules/d3-geo/src/math.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/math.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "epsilon2": () => (/* binding */ epsilon2),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "quarterPi": () => (/* binding */ quarterPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "degrees": () => (/* binding */ degrees),
/* harmony export */   "radians": () => (/* binding */ radians),
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan": () => (/* binding */ atan),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "ceil": () => (/* binding */ ceil),
/* harmony export */   "exp": () => (/* binding */ exp),
/* harmony export */   "floor": () => (/* binding */ floor),
/* harmony export */   "hypot": () => (/* binding */ hypot),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "pow": () => (/* binding */ pow),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sign": () => (/* binding */ sign),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "tan": () => (/* binding */ tan),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin),
/* harmony export */   "haversin": () => (/* binding */ haversin)
/* harmony export */ });
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var floor = Math.floor;
var hypot = Math.hypot;
var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/noop.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-geo/src/noop.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ noop)
/* harmony export */ });
function noop() {}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/area.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/path/area.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    x00,
    y00,
    x0,
    y0;

var areaStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
    areaSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.abs)(areaRingSum));
    areaRingSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
  },
  result: function() {
    var area = areaSum / 2;
    areaSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (areaStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/bounds.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/bounds.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");


var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;

var boundsStream = {
  point: boundsPoint,
  lineStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  polygonEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  result: function() {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (boundsStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/centroid.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-geo/src/path/centroid.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


// TODO Enforce positive area for exterior, negative area for interior?

var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;

var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
        : Z1 ? [X1 / Z1, Y1 / Z1]
        : Z0 ? [X0 / Z0, Y0 / Z0]
        : [NaN, NaN];
    X0 = Y0 = Z0 =
    X1 = Y1 = Z1 =
    X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0, dy = y - y0, z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(dx * dx + dy * dy);

  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;

  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (centroidStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/context.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/context.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathContext)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");



function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
        break;
      }
    }
  },
  result: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default
};


/***/ }),

/***/ "./node_modules/d3-geo/src/path/index.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/path/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _area_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./area.js */ "./node_modules/d3-geo/src/path/area.js");
/* harmony import */ var _bounds_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");
/* harmony import */ var _centroid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./centroid.js */ "./node_modules/d3-geo/src/path/centroid.js");
/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./context.js */ "./node_modules/d3-geo/src/path/context.js");
/* harmony import */ var _measure_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./measure.js */ "./node_modules/d3-geo/src/path/measure.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-geo/src/path/string.js");









/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_area_js__WEBPACK_IMPORTED_MODULE_1__.default));
    return _area_js__WEBPACK_IMPORTED_MODULE_1__.default.result();
  };

  path.measure = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_measure_js__WEBPACK_IMPORTED_MODULE_2__.default));
    return _measure_js__WEBPACK_IMPORTED_MODULE_2__.default.result();
  };

  path.bounds = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_bounds_js__WEBPACK_IMPORTED_MODULE_3__.default));
    return _bounds_js__WEBPACK_IMPORTED_MODULE_3__.default.result();
  };

  path.centroid = function(object) {
    (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projectionStream(_centroid_js__WEBPACK_IMPORTED_MODULE_4__.default));
    return _centroid_js__WEBPACK_IMPORTED_MODULE_4__.default.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity_js__WEBPACK_IMPORTED_MODULE_5__.default) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string_js__WEBPACK_IMPORTED_MODULE_6__.default) : new _context_js__WEBPACK_IMPORTED_MODULE_7__.default(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/path/measure.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo/src/path/measure.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-geo/src/noop.js");




var lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;

var lengthStream = {
  point: _noop_js__WEBPACK_IMPORTED_MODULE_1__.default,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop_js__WEBPACK_IMPORTED_MODULE_1__.default;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum;
    lengthSum = new d3_array__WEBPACK_IMPORTED_MODULE_0__.Adder();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_2__.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lengthStream);


/***/ }),

/***/ "./node_modules/d3-geo/src/path/string.js":
/*!************************************************!*\
  !*** ./node_modules/d3-geo/src/path/string.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PathString)
/* harmony export */ });
function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}


/***/ }),

/***/ "./node_modules/d3-geo/src/pointEqual.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-geo/src/pointEqual.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[0] - b[0]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a[1] - b[1]) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/polygonContains.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo/src/polygonContains.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/fsum.js");
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");




function longitude(point) {
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) <= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi)
    return point[0];
  else
    return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(point[0]) * (((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(point[0]) + _math_js__WEBPACK_IMPORTED_MODULE_0__.pi) % _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(polygon, point) {
  var lambda = longitude(point),
      phi = point[1],
      sinPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
      normal = [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), -(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), 0],
      angle = 0,
      winding = 0;

  var sum = new d3_array__WEBPACK_IMPORTED_MODULE_1__.Adder();

  if (sinPhi === 1) phi = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;
  else if (sinPhi === -1) phi = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = longitude(point0),
        phi0 = point0[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
        sinPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi0),
        cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = longitude(point1),
          phi1 = point1[1] / 2 + _math_js__WEBPACK_IMPORTED_MODULE_0__.quarterPi,
          sinPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi1),
          cosPhi1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi,
          k = sinPhi0 * sinPhi1;

      sum.add((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(k * sign * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point0), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)(point1));
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(arc);
        var intersection = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianCross)(normal, arc);
        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || angle < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && sum < -_math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) ^ (winding & 1);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albers.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albers.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conicEqualArea.js */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_0__.default)()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/albersUsa.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/albersUsa.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _albers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./albers.js */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var _conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conicEqualArea.js */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");





// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var cache,
      cacheStream,
      lower48 = (0,_albers_js__WEBPACK_IMPORTED_MODULE_0__.default)(), lower48Point,
      alaska = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = (0,_conicEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null,
        (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.120 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.214 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.166 * k + _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon], [x - 0.115 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon, y + 0.234 * k - _math_js__WEBPACK_IMPORTED_MODULE_2__.epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitSize)(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitWidth)(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_3__.fitHeight)(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthal.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthal.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalRaw": () => (/* binding */ azimuthalRaw),
/* harmony export */   "azimuthalInvert": () => (/* binding */ azimuthalInvert)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x),
        cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y),
        k = scale(cx * cy);
        if (k === Infinity) return [2, 0];
    return [
      k * cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x),
      k * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(c),
        cc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(c);
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x * sc, z * cc),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(z && y * sc / z)
    ];
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEqualArea.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEqualAreaRaw": () => (/* binding */ azimuthalEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




var azimuthalEqualAreaRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(cxcy) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.asin)(z / 2);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/azimuthalEquidistant.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "azimuthalEquidistantRaw": () => (/* binding */ azimuthalEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




var azimuthalEquidistantRaw = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalRaw)(function(c) {
  return (c = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.acos)(c)) && c / (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(c);
});

azimuthalEquidistantRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_0__.azimuthalInvert)(function(z) {
  return z;
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conic.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conic.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicProjection": () => (/* binding */ conicProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");



function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 3,
      m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, phi1 = _[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians) : [phi0 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, phi1 * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees];
  };

  return p;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicConformal.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicConformal.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicConformalRaw": () => (/* binding */ conicConformalRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "./node_modules/d3-geo/src/projection/mercator.js");




function tany(y) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(cy0 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)(tany(y1) / tany(y0)),
      f = cy0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y0), n) / n;

  if (!n) return _mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = -_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    else { if (y > _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) y = _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon; }
    var r = f / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(tany(y), n);
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(n * x), f - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + fy * fy),
      l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(fy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    if (fy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(fy);
    return [l / n, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.pow)(f / r, 1 / n)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEqualArea.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEqualArea.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEqualAreaRaw": () => (/* binding */ conicEqualAreaRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cylindricalEqualArea.js */ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js");




function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0), n = (sy0 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return (0,_cylindricalEqualArea_js__WEBPACK_IMPORTED_MODULE_1__.cylindricalEqualAreaRaw)(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c) / n;

  function project(x, y) {
    var r = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(c - 2 * n * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)) / n;
    return [r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x *= n), r0 - r * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r0y)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    if (r0y * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(r0y);
    return [l / n, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/conicEquidistant.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/conicEquidistant.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "conicEquidistantRaw": () => (/* binding */ conicEquidistantRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _conic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conic.js */ "./node_modules/d3-geo/src/projection/conic.js");
/* harmony import */ var _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./equirectangular.js */ "./node_modules/d3-geo/src/projection/equirectangular.js");




function conicEquidistantRaw(y0, y1) {
  var cy0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y0),
      n = y0 === y1 ? (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y0) : (cy0 - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(n) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return _equirectangular_js__WEBPACK_IMPORTED_MODULE_1__.equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(nx), g - gy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y,
        l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(x, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(gy)) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    if (gy * n < 0)
      l -= _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(x) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(gy);
    return [l / n, g - (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)(n) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x * x + gy * gy)];
  };

  return project;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_conic_js__WEBPACK_IMPORTED_MODULE_2__.conicProjection)(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/cylindricalEqualArea.js":
/*!********************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/cylindricalEqualArea.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cylindricalEqualAreaRaw": () => (/* binding */ cylindricalEqualAreaRaw)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");


function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y * cosPhi0)];
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/equalEarth.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equalEarth.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equalEarthRaw": () => (/* binding */ equalEarthRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



var A1 = 1.340264,
    A2 = -0.081106,
    A3 = 0.000893,
    A4 = 0.003796,
    M = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(3) / 2,
    iterations = 12;

function equalEarthRaw(lambda, phi) {
  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(M * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}

equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon2) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(l),
    (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(l) / M)
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(equalEarthRaw)
      .scale(177.158);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/equirectangular.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/equirectangular.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "equirectangularRaw": () => (/* binding */ equirectangularRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");


function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.default)(equirectangularRaw)
      .scale(152.63);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/fit.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/fit.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fitExtent": () => (/* binding */ fitExtent),
/* harmony export */   "fitSize": () => (/* binding */ fitSize),
/* harmony export */   "fitWidth": () => (/* binding */ fitWidth),
/* harmony export */   "fitHeight": () => (/* binding */ fitHeight)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stream.js */ "./node_modules/d3-geo/src/stream.js");
/* harmony import */ var _path_bounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../path/bounds.js */ "./node_modules/d3-geo/src/path/bounds.js");



function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.default)(object, projection.stream(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default));
  fitBounds(_path_bounds_js__WEBPACK_IMPORTED_MODULE_1__.default.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/gnomonic.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/gnomonic.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gnomonicRaw": () => (/* binding */ gnomonicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




function gnomonicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

gnomonicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.atan);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/identity.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/identity.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
      alpha = 0, ca, sa, // angle
      x0 = null, y0, x1, y1, // clip extent
      kx = 1, ky = 1,
      transform = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
        point: function(x, y) {
          var p = projection([x, y])
          this.stream.point(p[0], p[1]);
        }
      }),
      postclip = _identity_js__WEBPACK_IMPORTED_MODULE_1__.default,
      cache,
      cacheStream;

  function reset() {
    kx = k * sx;
    ky = k * sy;
    cache = cacheStream = null;
    return projection;
  }

  function projection (p) {
    var x = p[0] * kx, y = p[1] * ky;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }    
    return [x + tx, y + ty];
  }
  projection.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx, y / ky];
  };
  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
  };
  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };
  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_1__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_2__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };
  projection.scale = function(_) {
    return arguments.length ? (k = +_, reset()) : k;
  };
  projection.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
  }
  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_3__.radians, sa = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.sin)(alpha), ca = (0,_math_js__WEBPACK_IMPORTED_MODULE_3__.cos)(alpha), reset()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_3__.degrees;
  };
  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
  };
  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
  };
  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitExtent)(projection, extent, object);
  };
  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitSize)(projection, size, object);
  };
  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitWidth)(projection, width, object);
  };
  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_4__.fitHeight)(projection, height, object);
  };

  return projection;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ projection),
/* harmony export */   "projectionMutator": () => (/* binding */ projectionMutator)
/* harmony export */ });
/* harmony import */ var _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../clip/antimeridian.js */ "./node_modules/d3-geo/src/clip/antimeridian.js");
/* harmony import */ var _clip_circle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../clip/circle.js */ "./node_modules/d3-geo/src/clip/circle.js");
/* harmony import */ var _clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../clip/rectangle.js */ "./node_modules/d3-geo/src/clip/rectangle.js");
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../identity.js */ "./node_modules/d3-geo/src/identity.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");
/* harmony import */ var _fit_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./fit.js */ "./node_modules/d3-geo/src/projection/fit.js");
/* harmony import */ var _resample_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resample.js */ "./node_modules/d3-geo/src/projection/resample.js");











var transformRadians = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
  point: function(x, y) {
    this.stream.point(x * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, y * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }
});

function transformRotate(rotate) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.transformer)({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx; y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}

function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.cos)(alpha),
      sinAlpha = (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sin)(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx; y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate angle
      sx = 1, // reflectX
      sy = 1, // reflectX
      theta = null, preclip = _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = _identity_js__WEBPACK_IMPORTED_MODULE_3__.default, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, point[1] * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? (0,_clip_circle_js__WEBPACK_IMPORTED_MODULE_4__.default)(theta = _ * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians) : (theta = null, _clip_antimeridian_js__WEBPACK_IMPORTED_MODULE_2__.default), reset()) : theta * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity_js__WEBPACK_IMPORTED_MODULE_3__.default) : (0,_clip_rectangle_js__WEBPACK_IMPORTED_MODULE_5__.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, phi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : [lambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, phi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaPhi = _[1] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians : 0, recenter()) : [deltaLambda * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaPhi * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees, deltaGamma * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * _math_js__WEBPACK_IMPORTED_MODULE_1__.radians, recenter()) : alpha * _math_js__WEBPACK_IMPORTED_MODULE_1__.degrees;
  };

  projection.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };

  projection.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2 = _ * _), reset()) : (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.sqrt)(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitSize)(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return (0,_fit_js__WEBPACK_IMPORTED_MODULE_7__.fitHeight)(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
        transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate = (0,_rotation_js__WEBPACK_IMPORTED_MODULE_8__.rotateRadians)(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(project, transform);
    projectRotateTransform = (0,_compose_js__WEBPACK_IMPORTED_MODULE_9__.default)(rotate, projectTransform);
    projectResample = (0,_resample_js__WEBPACK_IMPORTED_MODULE_6__.default)(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/mercator.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/mercator.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mercatorRaw": () => (/* binding */ mercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mercatorProjection": () => (/* binding */ mercatorProjection)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _rotation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rotation.js */ "./node_modules/d3-geo/src/rotation.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




function mercatorRaw(lambda, phi) {
  return [lambda, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(y)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
}

function mercatorProjection(project) {
  var m = (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math_js__WEBPACK_IMPORTED_MODULE_0__.pi * scale(),
        t = m((0,_rotation_js__WEBPACK_IMPORTED_MODULE_2__.default)(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/naturalEarth1.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/naturalEarth1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "naturalEarth1Raw": () => (/* binding */ naturalEarth1Raw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");



function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.default)(naturalEarth1Raw)
      .scale(175.295);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/orthographic.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/orthographic.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "orthographicRaw": () => (/* binding */ orthographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




function orthographicRaw(x, y) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y)];
}

orthographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(_math_js__WEBPACK_IMPORTED_MODULE_0__.asin);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/resample.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/resample.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cartesian.js */ "./node_modules/d3-geo/src/cartesian.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transform.js */ "./node_modules/d3-geo/src/transform.js");




var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(30 * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians); // cos(minimum angular distance)

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.transformer)({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(a * a + b * b + c * c),
          phi2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(c /= m),
          lambda2 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(c) - 1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda0 - lambda1) < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon ? (lambda0 + lambda1) / 2 : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_2__.cartesian)([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/stereographic.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/stereographic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stereographicRaw": () => (/* binding */ stereographicRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _azimuthal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./azimuthal.js */ "./node_modules/d3-geo/src/projection/azimuthal.js");
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.js */ "./node_modules/d3-geo/src/projection/index.js");




function stereographicRaw(x, y) {
  var cy = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y), k = 1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(x) * cy;
  return [cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(x) / k, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(y) / k];
}

stereographicRaw.invert = (0,_azimuthal_js__WEBPACK_IMPORTED_MODULE_1__.azimuthalInvert)(function(z) {
  return 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)(z);
});

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,_index_js__WEBPACK_IMPORTED_MODULE_2__.default)(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/projection/transverseMercator.js":
/*!******************************************************************!*\
  !*** ./node_modules/d3-geo/src/projection/transverseMercator.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transverseMercatorRaw": () => (/* binding */ transverseMercatorRaw),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-geo/src/math.js");
/* harmony import */ var _mercator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mercator.js */ "./node_modules/d3-geo/src/projection/mercator.js");



function transverseMercatorRaw(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.log)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.tan)((_math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.exp)(x)) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi];
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var m = (0,_mercator_js__WEBPACK_IMPORTED_MODULE_1__.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}


/***/ }),

/***/ "./node_modules/d3-geo/src/rotation.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-geo/src/rotation.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rotateRadians": () => (/* binding */ rotateRadians),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose.js */ "./node_modules/d3-geo/src/compose.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo/src/math.js");



function rotationIdentity(lambda, phi) {
  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(lambda) > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + Math.round(-lambda / _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) * _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math_js__WEBPACK_IMPORTED_MODULE_0__.tau) ? (deltaPhi || deltaGamma ? (0,_compose_js__WEBPACK_IMPORTED_MODULE_1__.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > _math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda - _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda < -_math_js__WEBPACK_IMPORTED_MODULE_0__.pi ? lambda + _math_js__WEBPACK_IMPORTED_MODULE_0__.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaPhi),
      sinDeltaPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaPhi),
      cosDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(deltaGamma),
      sinDeltaGamma = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi),
        x = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda) * cosPhi,
        y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda) * cosPhi,
        z = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(rotate) {
  rotate = rotateRadians(rotate[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, rotate.length > 2 ? rotate[2] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians, coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians);
    return coordinates[0] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates[1] *= _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees, coordinates;
  };

  return forward;
}


/***/ }),

/***/ "./node_modules/d3-geo/src/stream.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-geo/src/stream.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}


/***/ }),

/***/ "./node_modules/d3-geo/src/transform.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-geo/src/transform.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "transformer": () => (/* binding */ transformer)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/accessors.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/accessors.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "optional": () => (/* binding */ optional),
/* harmony export */   "required": () => (/* binding */ required)
/* harmony export */ });
function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/array.js":
/*!************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/array.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "shuffle": () => (/* binding */ shuffle)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/cluster.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/cluster.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/constant.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/constant.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "constantZero": () => (/* binding */ constantZero),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function constantZero() {
  return 0;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/ancestors.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/ancestors.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/count.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/count.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this.eachAfter(count);
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/descendants.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/descendants.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return Array.from(this);
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/each.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/each.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js":
/*!**************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js":
/*!***************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/find.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/find.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hierarchy),
/* harmony export */   "computeHeight": () => (/* binding */ computeHeight),
/* harmony export */   "Node": () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _count_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./count.js */ "./node_modules/d3-hierarchy/src/hierarchy/count.js");
/* harmony import */ var _each_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each.js */ "./node_modules/d3-hierarchy/src/hierarchy/each.js");
/* harmony import */ var _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eachBefore.js */ "./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js");
/* harmony import */ var _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./eachAfter.js */ "./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-hierarchy/src/hierarchy/find.js");
/* harmony import */ var _sum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sum.js */ "./node_modules/d3-hierarchy/src/hierarchy/sum.js");
/* harmony import */ var _sort_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort.js */ "./node_modules/d3-hierarchy/src/hierarchy/sort.js");
/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./path.js */ "./node_modules/d3-hierarchy/src/hierarchy/path.js");
/* harmony import */ var _ancestors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ancestors.js */ "./node_modules/d3-hierarchy/src/hierarchy/ancestors.js");
/* harmony import */ var _descendants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./descendants.js */ "./node_modules/d3-hierarchy/src/hierarchy/descendants.js");
/* harmony import */ var _leaves_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./leaves.js */ "./node_modules/d3-hierarchy/src/hierarchy/leaves.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./links.js */ "./node_modules/d3-hierarchy/src/hierarchy/links.js");
/* harmony import */ var _iterator_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./iterator.js */ "./node_modules/d3-hierarchy/src/hierarchy/iterator.js");














function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }

  var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function objectChildren(d) {
  return d.children;
}

function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}

function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: _count_js__WEBPACK_IMPORTED_MODULE_0__.default,
  each: _each_js__WEBPACK_IMPORTED_MODULE_1__.default,
  eachAfter: _eachAfter_js__WEBPACK_IMPORTED_MODULE_2__.default,
  eachBefore: _eachBefore_js__WEBPACK_IMPORTED_MODULE_3__.default,
  find: _find_js__WEBPACK_IMPORTED_MODULE_4__.default,
  sum: _sum_js__WEBPACK_IMPORTED_MODULE_5__.default,
  sort: _sort_js__WEBPACK_IMPORTED_MODULE_6__.default,
  path: _path_js__WEBPACK_IMPORTED_MODULE_7__.default,
  ancestors: _ancestors_js__WEBPACK_IMPORTED_MODULE_8__.default,
  descendants: _descendants_js__WEBPACK_IMPORTED_MODULE_9__.default,
  leaves: _leaves_js__WEBPACK_IMPORTED_MODULE_10__.default,
  links: _links_js__WEBPACK_IMPORTED_MODULE_11__.default,
  copy: node_copy,
  [Symbol.iterator]: _iterator_js__WEBPACK_IMPORTED_MODULE_12__.default
};


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/iterator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function* __WEBPACK_DEFAULT_EXPORT__() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/leaves.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/leaves.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/links.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/links.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Dont include the roots parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/path.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/path.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/sort.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/sort.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/hierarchy/sum.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/hierarchy/sum.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/pack/enclose.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/pack/enclose.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-hierarchy/src/array.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  var i = 0, n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.shuffle)(Array.from(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/pack/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/pack/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _siblings_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./siblings.js */ "./node_modules/d3-hierarchy/src/pack/siblings.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../accessors.js */ "./node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-hierarchy/src/constant.js");




function defaultRadius(d) {
  return Math.sqrt(d.value);
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(_constant_js__WEBPACK_IMPORTED_MODULE_0__.constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.optional)(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = (0,_siblings_js__WEBPACK_IMPORTED_MODULE_2__.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/pack/siblings.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/pack/siblings.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "packEnclose": () => (/* binding */ packEnclose),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../array.js */ "./node_modules/d3-hierarchy/src/array.js");
/* harmony import */ var _enclose_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enclose.js */ "./node_modules/d3-hierarchy/src/pack/enclose.js");



function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = (circles = (0,_array_js__WEBPACK_IMPORTED_MODULE_0__.default)(circles)).length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = (0,_enclose_js__WEBPACK_IMPORTED_MODULE_1__.default)(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(circles) {
  packEnclose(circles);
  return circles;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/partition.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/partition.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _treemap_round_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./treemap/round.js */ "./node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./treemap/dice.js */ "./node_modules/d3-hierarchy/src/treemap/dice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_treemap_round_js__WEBPACK_IMPORTED_MODULE_0__.default);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        (0,_treemap_dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/stratify.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/stratify.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessors.js */ "./node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "./node_modules/d3-hierarchy/src/hierarchy/index.js");



var preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var nodes = Array.from(data),
        n = nodes.length,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map;

    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_1__.required)(x), stratify) : parentId;
  };

  return stratify;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/tree.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-hierarchy/src/tree.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hierarchy/index.js */ "./node_modules/d3-hierarchy/src/hierarchy/index.js");


function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(_hierarchy_index_js__WEBPACK_IMPORTED_MODULE_0__.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/binary.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/dice.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/dice.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/index.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-hierarchy/src/treemap/round.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./squarify.js */ "./node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var _accessors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../accessors.js */ "./node_modules/d3-hierarchy/src/accessors.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constant.js */ "./node_modules/d3-hierarchy/src/constant.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var tile = _squarify_js__WEBPACK_IMPORTED_MODULE_0__.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingTop = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingRight = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingBottom = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero,
      paddingLeft = _constant_js__WEBPACK_IMPORTED_MODULE_1__.constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round_js__WEBPACK_IMPORTED_MODULE_2__.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = (0,_accessors_js__WEBPACK_IMPORTED_MODULE_3__.required)(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/resquarify.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/resquarify.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "./node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "./node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var _squarify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squarify.js */ "./node_modules/d3-hierarchy/src/treemap/squarify.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
        else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0,_squarify_js__WEBPACK_IMPORTED_MODULE_2__.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
})(_squarify_js__WEBPACK_IMPORTED_MODULE_2__.phi));


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/round.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/round.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/slice.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/slice.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/sliceDice.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/sliceDice.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dice.js */ "./node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./slice.js */ "./node_modules/d3-hierarchy/src/treemap/slice.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice_js__WEBPACK_IMPORTED_MODULE_0__.default : _dice_js__WEBPACK_IMPORTED_MODULE_1__.default)(parent, x0, y0, x1, y1);
}


/***/ }),

/***/ "./node_modules/d3-hierarchy/src/treemap/squarify.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-hierarchy/src/treemap/squarify.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "phi": () => (/* binding */ phi),
/* harmony export */   "squarifyRatio": () => (/* binding */ squarifyRatio),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dice.js */ "./node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var _slice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slice.js */ "./node_modules/d3-hierarchy/src/treemap/slice.js");



var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) (0,_dice_js__WEBPACK_IMPORTED_MODULE_0__.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else (0,_slice_js__WEBPACK_IMPORTED_MODULE_1__.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi));


/***/ }),

/***/ "./node_modules/d3-interpolate/src/array.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/array.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "genericArray": () => (/* binding */ genericArray)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return ((0,_numberArray_js__WEBPACK_IMPORTED_MODULE_0__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_0__.default : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0,_value_js__WEBPACK_IMPORTED_MODULE_1__.default)(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "basis": () => (/* binding */ basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/color.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/color.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hue": () => (/* binding */ hue),
/* harmony export */   "gamma": () => (/* binding */ gamma),
/* harmony export */   "default": () => (/* binding */ nogamma)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");


function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(a) ? b : a);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/constant.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/constant.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (x => () => x);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/cubehelix.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/cubehelix.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "cubehelixLong": () => (/* binding */ cubehelixLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/cubehelix.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function cubehelix(hue) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.default)(end)).h),
          s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
          l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
          opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;

    return cubehelix;
  })(1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var cubehelixLong = cubehelix(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/date.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/date.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var d = new Date;
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/discrete.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/discrete.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hcl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hcl.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hclLong": () => (/* binding */ hclLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hcl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hcl)(end)).h),
        c = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.c, end.c),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hclLong = hcl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hsl.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hsl.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hslLong": () => (/* binding */ hslLong)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function hsl(hue) {
  return function(start, end) {
    var h = hue((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(start)).h, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_0__.hsl)(end)).h),
        s = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.s, end.s),
        l = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.l, end.l),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_1__.default)(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.hue));
var hslLong = hsl(_color_js__WEBPACK_IMPORTED_MODULE_1__.default);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/hue.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/hue.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.hue)(+a, +b);
  return function(t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolate": () => (/* reexport safe */ _value_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "interpolateArray": () => (/* reexport safe */ _array_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "interpolateBasis": () => (/* reexport safe */ _basis_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "interpolateBasisClosed": () => (/* reexport safe */ _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "interpolateDate": () => (/* reexport safe */ _date_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "interpolateDiscrete": () => (/* reexport safe */ _discrete_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "interpolateHue": () => (/* reexport safe */ _hue_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "interpolateNumber": () => (/* reexport safe */ _number_js__WEBPACK_IMPORTED_MODULE_7__.default),
/* harmony export */   "interpolateNumberArray": () => (/* reexport safe */ _numberArray_js__WEBPACK_IMPORTED_MODULE_8__.default),
/* harmony export */   "interpolateObject": () => (/* reexport safe */ _object_js__WEBPACK_IMPORTED_MODULE_9__.default),
/* harmony export */   "interpolateRound": () => (/* reexport safe */ _round_js__WEBPACK_IMPORTED_MODULE_10__.default),
/* harmony export */   "interpolateString": () => (/* reexport safe */ _string_js__WEBPACK_IMPORTED_MODULE_11__.default),
/* harmony export */   "interpolateTransformCss": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* reexport safe */ _transform_index_js__WEBPACK_IMPORTED_MODULE_12__.interpolateTransformSvg),
/* harmony export */   "interpolateZoom": () => (/* reexport safe */ _zoom_js__WEBPACK_IMPORTED_MODULE_13__.default),
/* harmony export */   "interpolateRgb": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.default),
/* harmony export */   "interpolateRgbBasis": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasis),
/* harmony export */   "interpolateRgbBasisClosed": () => (/* reexport safe */ _rgb_js__WEBPACK_IMPORTED_MODULE_14__.rgbBasisClosed),
/* harmony export */   "interpolateHsl": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.default),
/* harmony export */   "interpolateHslLong": () => (/* reexport safe */ _hsl_js__WEBPACK_IMPORTED_MODULE_15__.hslLong),
/* harmony export */   "interpolateLab": () => (/* reexport safe */ _lab_js__WEBPACK_IMPORTED_MODULE_16__.default),
/* harmony export */   "interpolateHcl": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.default),
/* harmony export */   "interpolateHclLong": () => (/* reexport safe */ _hcl_js__WEBPACK_IMPORTED_MODULE_17__.hclLong),
/* harmony export */   "interpolateCubehelix": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.default),
/* harmony export */   "interpolateCubehelixLong": () => (/* reexport safe */ _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__.cubehelixLong),
/* harmony export */   "piecewise": () => (/* reexport safe */ _piecewise_js__WEBPACK_IMPORTED_MODULE_19__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_20__.default)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _discrete_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discrete.js */ "./node_modules/d3-interpolate/src/discrete.js");
/* harmony import */ var _hue_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hue.js */ "./node_modules/d3-interpolate/src/hue.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _round_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./round.js */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _transform_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform/index.js */ "./node_modules/d3-interpolate/src/transform/index.js");
/* harmony import */ var _zoom_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./zoom.js */ "./node_modules/d3-interpolate/src/zoom.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _hsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hsl.js */ "./node_modules/d3-interpolate/src/hsl.js");
/* harmony import */ var _lab_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lab.js */ "./node_modules/d3-interpolate/src/lab.js");
/* harmony import */ var _hcl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./hcl.js */ "./node_modules/d3-interpolate/src/hcl.js");
/* harmony import */ var _cubehelix_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cubehelix.js */ "./node_modules/d3-interpolate/src/cubehelix.js");
/* harmony import */ var _piecewise_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./piecewise.js */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/d3-interpolate/src/quantize.js");























/***/ }),

/***/ "./node_modules/d3-interpolate/src/lab.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/lab.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ lab)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");



function lab(start, end) {
  var l = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(start)).l, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.default)(end)).l),
      a = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.a, end.a),
      b = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.b, end.b),
      opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/number.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/number.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/numberArray.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-interpolate/src/numberArray.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "isNumberArray": () => (/* binding */ isNumberArray)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/object.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/object.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0,_value_js__WEBPACK_IMPORTED_MODULE_0__.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/piecewise.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-interpolate/src/piecewise.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ piecewise)
/* harmony export */ });
/* harmony import */ var _value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./value.js */ "./node_modules/d3-interpolate/src/value.js");


function piecewise(interpolate, values) {
  if (values === undefined) values = interpolate, interpolate = _value_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/quantize.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-interpolate/src/quantize.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/rgb.js":
/*!************************************************!*\
  !*** ./node_modules/d3-interpolate/src/rgb.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "rgbBasis": () => (/* binding */ rgbBasis),
/* harmony export */   "rgbBasisClosed": () => (/* binding */ rgbBasisClosed)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-interpolate/src/basis.js");
/* harmony import */ var _basisClosed_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basisClosed.js */ "./node_modules/d3-interpolate/src/basisClosed.js");
/* harmony import */ var _color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color.js */ "./node_modules/d3-interpolate/src/color.js");





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function rgbGamma(y) {
  var color = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(start)).r, (end = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0,_color_js__WEBPACK_IMPORTED_MODULE_0__.default)(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;

  return rgb;
})(1));

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color;
    for (i = 0; i < n; ++i) {
      color = (0,d3_color__WEBPACK_IMPORTED_MODULE_1__.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function(t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis_js__WEBPACK_IMPORTED_MODULE_2__.default);
var rgbBasisClosed = rgbSpline(_basisClosed_js__WEBPACK_IMPORTED_MODULE_3__.default);


/***/ }),

/***/ "./node_modules/d3-interpolate/src/round.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/round.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/string.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-interpolate/src/string.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");


var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/decompose.js":
/*!****************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/decompose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/index.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interpolateTransformCss": () => (/* binding */ interpolateTransformCss),
/* harmony export */   "interpolateTransformSvg": () => (/* binding */ interpolateTransformSvg)
/* harmony export */ });
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse.js */ "./node_modules/d3-interpolate/src/transform/parse.js");



function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(xa, xb)}, {i: i - 2, x: (0,_number_js__WEBPACK_IMPORTED_MODULE_0__.default)(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(_parse_js__WEBPACK_IMPORTED_MODULE_1__.parseSvg, ", ", ")", ")");


/***/ }),

/***/ "./node_modules/d3-interpolate/src/transform/parse.js":
/*!************************************************************!*\
  !*** ./node_modules/d3-interpolate/src/transform/parse.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseCss": () => (/* binding */ parseCss),
/* harmony export */   "parseSvg": () => (/* binding */ parseSvg)
/* harmony export */ });
/* harmony import */ var _decompose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decompose.js */ "./node_modules/d3-interpolate/src/transform/decompose.js");


var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity : (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose_js__WEBPACK_IMPORTED_MODULE_0__.identity;
  value = value.matrix;
  return (0,_decompose_js__WEBPACK_IMPORTED_MODULE_0__.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/value.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-interpolate/src/value.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var _rgb_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rgb.js */ "./node_modules/d3-interpolate/src/rgb.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-interpolate/src/array.js");
/* harmony import */ var _date_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./date.js */ "./node_modules/d3-interpolate/src/date.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./object.js */ "./node_modules/d3-interpolate/src/object.js");
/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ "./node_modules/d3-interpolate/src/string.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-interpolate/src/constant.js");
/* harmony import */ var _numberArray_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./numberArray.js */ "./node_modules/d3-interpolate/src/numberArray.js");










/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(b)
      : (t === "number" ? _number_js__WEBPACK_IMPORTED_MODULE_1__.default
      : t === "string" ? ((c = (0,d3_color__WEBPACK_IMPORTED_MODULE_2__.default)(b)) ? (b = c, _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default) : _string_js__WEBPACK_IMPORTED_MODULE_4__.default)
      : b instanceof d3_color__WEBPACK_IMPORTED_MODULE_2__.default ? _rgb_js__WEBPACK_IMPORTED_MODULE_3__.default
      : b instanceof Date ? _date_js__WEBPACK_IMPORTED_MODULE_5__.default
      : (0,_numberArray_js__WEBPACK_IMPORTED_MODULE_6__.isNumberArray)(b) ? _numberArray_js__WEBPACK_IMPORTED_MODULE_6__.default
      : Array.isArray(b) ? _array_js__WEBPACK_IMPORTED_MODULE_7__.genericArray
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object_js__WEBPACK_IMPORTED_MODULE_8__.default
      : _number_js__WEBPACK_IMPORTED_MODULE_1__.default)(a, b);
}


/***/ }),

/***/ "./node_modules/d3-interpolate/src/zoom.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-interpolate/src/zoom.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function zoomRho(rho, rho2, rho4) {

  // p0 = [ux0, uy0, w0]
  // p1 = [ux1, uy1, w1]
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
        ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
        dx = ux1 - ux0,
        dy = uy1 - uy0,
        d2 = dx * dx + dy * dy,
        i,
        S;

    // Special case for u0  u1.
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      }
    }

    // General case.
    else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      }
    }

    i.duration = S * 1000 * rho / Math.SQRT2;

    return i;
  }

  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };

  return zoom;
})(Math.SQRT2, 2, 4));


/***/ }),

/***/ "./node_modules/d3-path/src/path.js":
/*!******************************************!*\
  !*** ./node_modules/d3-path/src/path.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (path);


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "addAll": () => (/* binding */ addAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__.default;
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__.default;
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__.default;
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__.default;
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__.default;
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__.default;
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__.default;
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__.default;
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__.default;
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__.default;
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__.default;
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__.default;


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "removeAll": () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__.default(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultX": () => (/* binding */ defaultX),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultY": () => (/* binding */ defaultY),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ constants)
/* harmony export */ });
function constants(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-scale/src/continuous.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/continuous.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "transformer": () => (/* binding */ transformer),
/* harmony export */   "default": () => (/* binding */ continuous)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/number.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-scale/src/constant.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");





var unit = [0, 1];

function identity(x) {
  return x;
}

function normalize(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(isNaN(b) ? NaN : 0.5);
}

function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) { return Math.max(a, Math.min(b, x)); };
}

// normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
function bimap(domain, range, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range, interpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range[i], range[i + 1]);
  }

  return function(x) {
    var i = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function transformer() {
  var domain = unit,
      range = unit,
      interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default,
      transform,
      untransform,
      unknown,
      clamp = identity,
      piecewise,
      output,
      input;

  function rescale() {
    var n = Math.min(domain.length, range.length);
    if (clamp !== identity) clamp = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
  }

  scale.invert = function(y) {
    return clamp(untransform((input || (input = piecewise(range, domain.map(transform), d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default)))(y)));
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_4__.default), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.rangeRound = function(_) {
    return range = Array.from(_), interpolate = d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity, rescale()) : clamp !== identity;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}

function continuous() {
  return transformer()(identity, identity);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/diverging.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/diverging.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ diverging),
/* harmony export */   "divergingLog": () => (/* binding */ divergingLog),
/* harmony export */   "divergingSymlog": () => (/* binding */ divergingSymlog),
/* harmony export */   "divergingPow": () => (/* binding */ divergingPow),
/* harmony export */   "divergingSqrt": () => (/* binding */ divergingSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./log.js */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _sequential_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sequential.js */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./symlog.js */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pow.js */ "./node_modules/d3-scale/src/pow.js");









function transformer() {
  var x0 = 0,
      x1 = 0.5,
      x2 = 1,
      s = 1,
      t0,
      t1,
      t2,
      k10,
      k21,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      transform,
      clamp = false,
      unknown;

  function scale(x) {
    return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default)(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_3__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
    return scale;
  };
}

function diverging() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_4__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, diverging());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_7__.loggish)(transformer()).domain([0.1, 1, 10]);

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_8__.symlogish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_9__.powish)(transformer());

  scale.copy = function() {
    return (0,_sequential_js__WEBPACK_IMPORTED_MODULE_5__.copy)(scale, divergingPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_6__.initInterpolator.apply(scale, arguments);
}

function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/identity.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/identity.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ identity)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./number.js */ "./node_modules/d3-scale/src/number.js");



function identity(domain) {
  var unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = Array.from(_, _number_js__WEBPACK_IMPORTED_MODULE_0__.default), scale) : domain.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return identity(domain).unknown(unknown);
  };

  domain = arguments.length ? Array.from(domain, _number_js__WEBPACK_IMPORTED_MODULE_0__.default) : [0, 1];

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/init.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/init.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initRange": () => (/* binding */ initRange),
/* harmony export */   "initInterpolator": () => (/* binding */ initInterpolator)
/* harmony export */ });
function initRange(domain, range) {
  switch (arguments.length) {
    case 0: break;
    case 1: this.range(domain); break;
    default: this.range(range).domain(domain); break;
  }
  return this;
}

function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0: break;
    case 1: {
      if (typeof domain === "function") this.interpolator(domain);
      else this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function") this.interpolator(interpolator);
      else this.range(interpolator);
      break;
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/linear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/linear.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linearish": () => (/* binding */ linearish),
/* harmony export */   "default": () => (/* binding */ linear)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _tickFormat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tickFormat.js */ "./node_modules/d3-scale/src/tickFormat.js");





function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    var d = domain();
    return (0,_tickFormat_js__WEBPACK_IMPORTED_MODULE_1__.default)(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    
    while (maxIter-- > 0) {
      step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickIncrement)(start, stop, count);
      if (step === prestep) {
        d[i0] = start
        d[i1] = stop
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.default)();

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_2__.copy)(scale, linear());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);

  return linearish(scale);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/log.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/log.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loggish": () => (/* binding */ loggish),
/* harmony export */   "default": () => (/* binding */ log)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nice.js */ "./node_modules/d3-scale/src/nice.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");






function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function loggish(transform) {
  var scale = transform(transformLog, transformExp),
      domain = scale.domain,
      base = 10,
      logs,
      pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(u, v, n);
    } else {
      z = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_2__.default)(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  return scale;
}

function log() {
  var scale = loggish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.transformer)()).domain([1, 10]);

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_3__.copy)(scale, log()).base(scale.base());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_4__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/nice.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/nice.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ nice)
/* harmony export */ });
function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/number.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/number.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ number)
/* harmony export */ });
function number(x) {
  return +x;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/ordinal.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/ordinal.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "implicit": () => (/* binding */ implicit),
/* harmony export */   "default": () => (/* binding */ ordinal)
/* harmony export */ });
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");


const implicit = Symbol("implicit");

function ordinal() {
  var index = new Map(),
      domain = [],
      range = [],
      unknown = implicit;

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range[(i - 1) % range.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = new Map();
    for (const value of _) {
      const key = value + "";
      if (index.has(key)) continue;
      index.set(key, domain.push(value));
    }
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), scale) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal(domain, range).unknown(unknown);
  };

  _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply(scale, arguments);

  return scale;
}


/***/ }),

/***/ "./node_modules/d3-scale/src/pow.js":
/*!******************************************!*\
  !*** ./node_modules/d3-scale/src/pow.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "powish": () => (/* binding */ powish),
/* harmony export */   "default": () => (/* binding */ pow),
/* harmony export */   "sqrt": () => (/* binding */ sqrt)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformPow(exponent) {
  return function(x) {
    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
  };
}

function transformSqrt(x) {
  return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
}

function transformSquare(x) {
  return x < 0 ? -x * x : x * x;
}

function powish(transform) {
  var scale = transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity),
      exponent = 1;

  function rescale() {
    return exponent === 1 ? transform(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity, _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity)
        : exponent === 0.5 ? transform(transformSqrt, transformSquare)
        : transform(transformPow(exponent), transformPow(1 / exponent));
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, rescale()) : exponent;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_1__.linearish)(scale);
}

function pow() {
  var scale = powish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, pow()).exponent(scale.exponent());
  };

  _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);

  return scale;
}

function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantile.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantile.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantile)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function quantile() {
  var domain = [],
      range = [],
      thresholds = [],
      unknown;

  function rescale() {
    var i = 0, n = Math.max(1, range.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.quantileSorted)(domain, i / n);
    return scale;
  }

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : range[(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3_array__WEBPACK_IMPORTED_MODULE_2__.default);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_3__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/quantize.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-scale/src/quantize.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quantize)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1],
      unknown;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };

  scale.thresholds = function() {
    return domain.slice();
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply((0,_linear_js__WEBPACK_IMPORTED_MODULE_2__.linearish)(scale), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/sequential.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/sequential.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "default": () => (/* binding */ sequential),
/* harmony export */   "sequentialLog": () => (/* binding */ sequentialLog),
/* harmony export */   "sequentialSymlog": () => (/* binding */ sequentialSymlog),
/* harmony export */   "sequentialPow": () => (/* binding */ sequentialPow),
/* harmony export */   "sequentialSqrt": () => (/* binding */ sequentialSqrt)
/* harmony export */ });
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./log.js */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var _symlog_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symlog.js */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var _pow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./pow.js */ "./node_modules/d3-scale/src/pow.js");








function transformer() {
  var x0 = 0,
      x1 = 1,
      t0,
      t1,
      k10,
      transform,
      interpolator = _continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity,
      clamp = false,
      unknown;

  function scale(x) {
    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
  }

  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  function range(interpolate) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
    };
  }

  scale.range = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_1__.default);

  scale.rangeRound = range(d3_interpolate__WEBPACK_IMPORTED_MODULE_2__.default);

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  return function(t) {
    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
    return scale;
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .interpolator(source.interpolator())
      .clamp(source.clamp())
      .unknown(source.unknown());
}

function sequential() {
  var scale = (0,_linear_js__WEBPACK_IMPORTED_MODULE_3__.linearish)(transformer()(_continuous_js__WEBPACK_IMPORTED_MODULE_0__.identity));

  scale.copy = function() {
    return copy(scale, sequential());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialLog() {
  var scale = (0,_log_js__WEBPACK_IMPORTED_MODULE_5__.loggish)(transformer()).domain([1, 10]);

  scale.copy = function() {
    return copy(scale, sequentialLog()).base(scale.base());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSymlog() {
  var scale = (0,_symlog_js__WEBPACK_IMPORTED_MODULE_6__.symlogish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialSymlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialPow() {
  var scale = (0,_pow_js__WEBPACK_IMPORTED_MODULE_7__.powish)(transformer());

  scale.copy = function() {
    return copy(scale, sequentialPow()).exponent(scale.exponent());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_4__.initInterpolator.apply(scale, arguments);
}

function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/symlog.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-scale/src/symlog.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symlogish": () => (/* binding */ symlogish),
/* harmony export */   "default": () => (/* binding */ symlog)
/* harmony export */ });
/* harmony import */ var _linear_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./linear.js */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");




function transformSymlog(c) {
  return function(x) {
    return Math.sign(x) * Math.log1p(Math.abs(x / c));
  };
}

function transformSymexp(c) {
  return function(x) {
    return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
  };
}

function symlogish(transform) {
  var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

  scale.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
  };

  return (0,_linear_js__WEBPACK_IMPORTED_MODULE_0__.linearish)(scale);
}

function symlog() {
  var scale = symlogish((0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.transformer)());

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_1__.copy)(scale, symlog()).constant(scale.constant());
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/threshold.js":
/*!************************************************!*\
  !*** ./node_modules/d3-scale/src/threshold.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ threshold)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");



function threshold() {
  var domain = [0.5],
      range = [0, 1],
      unknown,
      n = 1;

  function scale(x) {
    return x != null && x <= x ? range[(0,d3_array__WEBPACK_IMPORTED_MODULE_0__.default)(domain, x, 0, n)] : unknown;
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function(y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range)
        .unknown(unknown);
  };

  return _init_js__WEBPACK_IMPORTED_MODULE_1__.initRange.apply(scale, arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/tickFormat.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-scale/src/tickFormat.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ tickFormat)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");



function tickFormat(start, stop, count, specifier) {
  var step = (0,d3_array__WEBPACK_IMPORTED_MODULE_0__.tickStep)(start, stop, count),
      precision;
  specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_1__.default)(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(step, value))) specifier.precision = precision;
      return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.formatPrefix)(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return (0,d3_format__WEBPACK_IMPORTED_MODULE_3__.format)(specifier);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/time.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-scale/src/time.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "calendar": () => (/* binding */ calendar),
/* harmony export */   "default": () => (/* binding */ time)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _continuous_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./continuous.js */ "./node_modules/d3-scale/src/continuous.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");
/* harmony import */ var _nice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nice.js */ "./node_modules/d3-scale/src/nice.js");






function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.default)(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain((0,_nice_js__WEBPACK_IMPORTED_MODULE_1__.default)(d, interval)) : scale;
  };

  scale.copy = function() {
    return (0,_continuous_js__WEBPACK_IMPORTED_MODULE_0__.copy)(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return _init_js__WEBPACK_IMPORTED_MODULE_2__.initRange.apply(calendar(d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTicks, d3_time__WEBPACK_IMPORTED_MODULE_3__.timeTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.default, d3_time__WEBPACK_IMPORTED_MODULE_6__.sunday, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time__WEBPACK_IMPORTED_MODULE_10__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_11__.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "./node_modules/d3-scale/src/utcTime.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-scale/src/utcTime.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ utcTime)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/ticks.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time.js */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var _init_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init.js */ "./node_modules/d3-scale/src/init.js");





function utcTime() {
  return _init_js__WEBPACK_IMPORTED_MODULE_0__.initRange.apply((0,_time_js__WEBPACK_IMPORTED_MODULE_1__.calendar)(d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTicks, d3_time__WEBPACK_IMPORTED_MODULE_2__.utcTickInterval, d3_time__WEBPACK_IMPORTED_MODULE_3__.default, d3_time__WEBPACK_IMPORTED_MODULE_4__.default, d3_time__WEBPACK_IMPORTED_MODULE_5__.utcSunday, d3_time__WEBPACK_IMPORTED_MODULE_6__.default, d3_time__WEBPACK_IMPORTED_MODULE_7__.default, d3_time__WEBPACK_IMPORTED_MODULE_8__.default, d3_time__WEBPACK_IMPORTED_MODULE_9__.default, d3_time_format__WEBPACK_IMPORTED_MODULE_10__.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/arc.js":
/*!******************************************!*\
  !*** ./node_modules/d3-shape/src/arc.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-shape/src/math.js");




function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        a1 = endAngle.apply(this, arguments) - _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi,
        da = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_2__.default)();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > _math_js__WEBPACK_IMPORTED_MODULE_0__.tau - _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
      context.moveTo(r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a0), r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        context.moveTo(r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a1), r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) && (padRadius ? +padRadius.apply(this, arguments) : (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(r0 * r0 + r1 * r1)),
          rc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var p0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap)),
            p1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(rp / r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(ap));
        if ((da0 -= p0 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a01),
          y01 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a01),
          x10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a10),
          y10 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a10);

      // Apply rounded corners?
      if (rc > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        var x11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a11),
            y11 = r1 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a11),
            x00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a00),
            y00 = r0 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a00),
            oc;

        // Restrict the corner radius according to the sector angle.
        if (da < _math_js__WEBPACK_IMPORTED_MODULE_0__.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.acos)((ax * bx + ay * by) / ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(ax * ax + ay * ay) * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(bx * bx + by * by))) / 2),
              lc = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r0 - lc) / (kc - 1));
          rc1 = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) || !(da0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y01, t0.x01), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y11, t1.x11), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 2;
    return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(a) * r, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_1__.default)(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/area.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/area.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _line_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./line.js */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x0, y0, y1) {
  var x1 = null,
      defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(0) : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0,_line_js__WEBPACK_IMPORTED_MODULE_5__.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/array.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/array.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var slice = Array.prototype.slice;

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}


/***/ }),

/***/ "./node_modules/d3-shape/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-shape/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function constant() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basis.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basis.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Basis": () => (/* binding */ Basis),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Basis(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisClosed.js":
/*!********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisClosed.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");



function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/basisOpen.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/basisOpen.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: (0,_basis_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new BasisOpen(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/bundle.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/bundle.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _basis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./basis.js */ "./node_modules/d3-shape/src/curve/basis.js");


function Bundle(context, beta) {
  this._basis = new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new _basis_js__WEBPACK_IMPORTED_MODULE_0__.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinal.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "Cardinal": () => (/* binding */ Cardinal),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function point(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalClosed.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalClosed.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalClosed": () => (/* binding */ CardinalClosed),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/cardinalOpen.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/cardinalOpen.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CardinalOpen": () => (/* binding */ CardinalOpen),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");


function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_cardinal_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRom.js":
/*!*******************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRom.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");
/* harmony import */ var _cardinal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinal.js */ "./node_modules/d3-shape/src/curve/cardinal.js");



function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal_js__WEBPACK_IMPORTED_MODULE_1__.Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomClosed.js":
/*!*************************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomClosed.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cardinalClosed.js */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");




function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_1__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed_js__WEBPACK_IMPORTED_MODULE_2__.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/catmullRomOpen.js":
/*!***********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/catmullRomOpen.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cardinalOpen.js */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var _catmullRom_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./catmullRom.js */ "./node_modules/d3-shape/src/curve/catmullRom.js");



function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: (0,_catmullRom_js__WEBPACK_IMPORTED_MODULE_0__.point)(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen_js__WEBPACK_IMPORTED_MODULE_1__.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5));


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linear.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linear.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Linear(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/linearClosed.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/linearClosed.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _noop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../noop.js */ "./node_modules/d3-shape/src/noop.js");


function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  areaEnd: _noop_js__WEBPACK_IMPORTED_MODULE_0__.default,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new LinearClosed(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/monotone.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/monotone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "monotoneX": () => (/* binding */ monotoneX),
/* harmony export */   "monotoneY": () => (/* binding */ monotoneY)
/* harmony export */ });
function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
}

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/natural.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/natural.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Natural(context);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/curve/step.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/curve/step.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "stepBefore": () => (/* binding */ stepBefore),
/* harmony export */   "stepAfter": () => (/* binding */ stepAfter)
/* harmony export */ });
function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/line.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/line.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array.js */ "./node_modules/d3-shape/src/array.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");
/* harmony import */ var _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve/linear.js */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var _point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point.js */ "./node_modules/d3-shape/src/point.js");






/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var defined = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(true),
      context = null,
      curve = _curve_linear_js__WEBPACK_IMPORTED_MODULE_1__.default,
      output = null;

  x = typeof x === "function" ? x : (x === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.x : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(x);
  y = typeof y === "function" ? y : (y === undefined) ? _point_js__WEBPACK_IMPORTED_MODULE_2__.y : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(y);

  function line(data) {
    var i,
        n = (data = (0,_array_js__WEBPACK_IMPORTED_MODULE_3__.default)(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_4__.default)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__.default)(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/math.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/math.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "abs": () => (/* binding */ abs),
/* harmony export */   "atan2": () => (/* binding */ atan2),
/* harmony export */   "cos": () => (/* binding */ cos),
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "sin": () => (/* binding */ sin),
/* harmony export */   "sqrt": () => (/* binding */ sqrt),
/* harmony export */   "epsilon": () => (/* binding */ epsilon),
/* harmony export */   "pi": () => (/* binding */ pi),
/* harmony export */   "halfPi": () => (/* binding */ halfPi),
/* harmony export */   "tau": () => (/* binding */ tau),
/* harmony export */   "acos": () => (/* binding */ acos),
/* harmony export */   "asin": () => (/* binding */ asin)
/* harmony export */ });
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}


/***/ }),

/***/ "./node_modules/d3-shape/src/noop.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-shape/src/noop.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {}


/***/ }),

/***/ "./node_modules/d3-shape/src/point.js":
/*!********************************************!*\
  !*** ./node_modules/d3-shape/src/point.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ x),
/* harmony export */   "y": () => (/* binding */ y)
/* harmony export */ });
function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-shape/src/symbol.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "symbols": () => (/* binding */ symbols),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol/circle.js */ "./node_modules/d3-shape/src/symbol/circle.js");
/* harmony import */ var _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbol/cross.js */ "./node_modules/d3-shape/src/symbol/cross.js");
/* harmony import */ var _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/diamond.js */ "./node_modules/d3-shape/src/symbol/diamond.js");
/* harmony import */ var _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./symbol/star.js */ "./node_modules/d3-shape/src/symbol/star.js");
/* harmony import */ var _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./symbol/square.js */ "./node_modules/d3-shape/src/symbol/square.js");
/* harmony import */ var _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./symbol/triangle.js */ "./node_modules/d3-shape/src/symbol/triangle.js");
/* harmony import */ var _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol/wye.js */ "./node_modules/d3-shape/src/symbol/wye.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-shape/src/constant.js");










var symbols = [
  _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default,
  _symbol_cross_js__WEBPACK_IMPORTED_MODULE_1__.default,
  _symbol_diamond_js__WEBPACK_IMPORTED_MODULE_2__.default,
  _symbol_square_js__WEBPACK_IMPORTED_MODULE_3__.default,
  _symbol_star_js__WEBPACK_IMPORTED_MODULE_4__.default,
  _symbol_triangle_js__WEBPACK_IMPORTED_MODULE_5__.default,
  _symbol_wye_js__WEBPACK_IMPORTED_MODULE_6__.default
];

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(type, size) {
  var context = null;
  type = typeof type === "function" ? type : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(type || _symbol_circle_js__WEBPACK_IMPORTED_MODULE_0__.default);
  size = typeof size === "function" ? size : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(size === undefined ? 64 : +size);

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_8__.default)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_7__.default)(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/circle.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/circle.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math_js__WEBPACK_IMPORTED_MODULE_0__.tau);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/cross.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/cross.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/diamond.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/diamond.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/square.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/square.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/star.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/star.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math.js */ "./node_modules/d3-shape/src/math.js");


var ka = 0.89081309152928522810,
    kr = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10) / Math.sin(7 * _math_js__WEBPACK_IMPORTED_MODULE_0__.pi / 10),
    kx = Math.sin(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr,
    ky = -Math.cos(_math_js__WEBPACK_IMPORTED_MODULE_0__.tau / 10) * kr;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = _math_js__WEBPACK_IMPORTED_MODULE_0__.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/triangle.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/triangle.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var sqrt3 = Math.sqrt(3);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-shape/src/symbol/wye.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-shape/src/symbol/wye.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
});


/***/ }),

/***/ "./node_modules/d3-time-format/src/defaultLocale.js":
/*!**********************************************************!*\
  !*** ./node_modules/d3-time-format/src/defaultLocale.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "default": () => (/* binding */ defaultLocale)
/* harmony export */ });
/* harmony import */ var _locale_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./locale.js */ "./node_modules/d3-time-format/src/locale.js");


var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0,_locale_js__WEBPACK_IMPORTED_MODULE_0__.default)(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}


/***/ }),

/***/ "./node_modules/d3-time-format/src/locale.js":
/*!***************************************************!*\
  !*** ./node_modules/d3-time-format/src/locale.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ formatLocale)
/* harmony export */ });
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");


function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_1__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.ceil(week) : (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.monday)(week);
          week = d3_time__WEBPACK_IMPORTED_MODULE_3__.default.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_2__.monday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_4__.default)(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_2__.thursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcSunday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d), d) + ((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3_time__WEBPACK_IMPORTED_MODULE_0__.utcMonday.count((0,d3_time__WEBPACK_IMPORTED_MODULE_5__.default)(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? (0,d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday)(d) : d3_time__WEBPACK_IMPORTED_MODULE_0__.utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}


/***/ }),

/***/ "./node_modules/d3-time/src/day.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-time/src/day.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "days": () => (/* binding */ days)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var day = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay,
  date => date.getDate() - 1
);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (day);
var days = day.range;


/***/ }),

/***/ "./node_modules/d3-time/src/duration.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/duration.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "durationSecond": () => (/* binding */ durationSecond),
/* harmony export */   "durationMinute": () => (/* binding */ durationMinute),
/* harmony export */   "durationHour": () => (/* binding */ durationHour),
/* harmony export */   "durationDay": () => (/* binding */ durationDay),
/* harmony export */   "durationWeek": () => (/* binding */ durationWeek),
/* harmony export */   "durationMonth": () => (/* binding */ durationMonth),
/* harmony export */   "durationYear": () => (/* binding */ durationYear)
/* harmony export */ });
const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;


/***/ }),

/***/ "./node_modules/d3-time/src/hour.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/hour.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "hours": () => (/* binding */ hours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var hour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond - date.getMinutes() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hour);
var hours = hour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/interval.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/interval.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ newInterval)
/* harmony export */ });
var t0 = new Date,
    t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = function(date) {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}


/***/ }),

/***/ "./node_modules/d3-time/src/millisecond.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-time/src/millisecond.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "milliseconds": () => (/* binding */ milliseconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var millisecond = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (millisecond);
var milliseconds = millisecond.range;


/***/ }),

/***/ "./node_modules/d3-time/src/minute.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/minute.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "minutes": () => (/* binding */ minutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var minute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (minute);
var minutes = minute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/month.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-time/src/month.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "months": () => (/* binding */ months)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var month = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (month);
var months = month.range;


/***/ }),

/***/ "./node_modules/d3-time/src/second.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/second.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "seconds": () => (/* binding */ seconds)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var second = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setTime(date - date.getMilliseconds());
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (second);
var seconds = second.range;


/***/ }),

/***/ "./node_modules/d3-time/src/ticks.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-time/src/ticks.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcTicks": () => (/* binding */ utcTicks),
/* harmony export */   "utcTickInterval": () => (/* binding */ utcTickInterval),
/* harmony export */   "timeTicks": () => (/* binding */ timeTicks),
/* harmony export */   "timeTickInterval": () => (/* binding */ timeTickInterval)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");
/* harmony import */ var _millisecond_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./millisecond.js */ "./node_modules/d3-time/src/millisecond.js");
/* harmony import */ var _second_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./second.js */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var _minute_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./minute.js */ "./node_modules/d3-time/src/minute.js");
/* harmony import */ var _hour_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./hour.js */ "./node_modules/d3-time/src/hour.js");
/* harmony import */ var _day_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./day.js */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var _week_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./week.js */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var _month_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./month.js */ "./node_modules/d3-time/src/month.js");
/* harmony import */ var _year_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./year.js */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utcMinute.js */ "./node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var _utcHour_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utcHour.js */ "./node_modules/d3-time/src/utcHour.js");
/* harmony import */ var _utcDay_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utcDay.js */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utcWeek.js */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utcMonth.js */ "./node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var _utcYear_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utcYear.js */ "./node_modules/d3-time/src/utcYear.js");

















function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [_second_js__WEBPACK_IMPORTED_MODULE_0__.default, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationSecond],
    [minute,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute,  5,  5 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 15, 15 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [minute, 30, 30 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute],
    [  hour,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour,  6,  6 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [  hour, 12, 12 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour  ],
    [   day,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [   day,  2,  2 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay   ],
    [  week,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek  ],
    [ month,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [ month,  3,  3 * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMonth ],
    [  year,  1,      _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, stop / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationYear, count));
    if (i === 0) return _millisecond_js__WEBPACK_IMPORTED_MODULE_4__.default.every(Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

const [utcTicks, utcTickInterval] = ticker(_utcYear_js__WEBPACK_IMPORTED_MODULE_5__.default, _utcMonth_js__WEBPACK_IMPORTED_MODULE_6__.default, _utcWeek_js__WEBPACK_IMPORTED_MODULE_7__.utcSunday, _utcDay_js__WEBPACK_IMPORTED_MODULE_8__.default, _utcHour_js__WEBPACK_IMPORTED_MODULE_9__.default, _utcMinute_js__WEBPACK_IMPORTED_MODULE_10__.default);
const [timeTicks, timeTickInterval] = ticker(_year_js__WEBPACK_IMPORTED_MODULE_11__.default, _month_js__WEBPACK_IMPORTED_MODULE_12__.default, _week_js__WEBPACK_IMPORTED_MODULE_13__.sunday, _day_js__WEBPACK_IMPORTED_MODULE_14__.default, _hour_js__WEBPACK_IMPORTED_MODULE_15__.default, _minute_js__WEBPACK_IMPORTED_MODULE_16__.default);




/***/ }),

/***/ "./node_modules/d3-time/src/utcDay.js":
/*!********************************************!*\
  !*** ./node_modules/d3-time/src/utcDay.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcDays": () => (/* binding */ utcDays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcDay = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcDay);
var utcDays = utcDay.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcHour.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcHour.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcHours": () => (/* binding */ utcHours)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcHour = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationHour;
}, function(date) {
  return date.getUTCHours();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcHour);
var utcHours = utcHour.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMinute.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-time/src/utcMinute.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMinutes": () => (/* binding */ utcMinutes)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



var utcMinute = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute);
}, function(start, end) {
  return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMinute);
var utcMinutes = utcMinute.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcMonth.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-time/src/utcMonth.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcMonths": () => (/* binding */ utcMonths)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcMonth = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcMonth);
var utcMonths = utcMonth.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcWeek.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcWeek.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "utcSunday": () => (/* binding */ utcSunday),
/* harmony export */   "utcMonday": () => (/* binding */ utcMonday),
/* harmony export */   "utcTuesday": () => (/* binding */ utcTuesday),
/* harmony export */   "utcWednesday": () => (/* binding */ utcWednesday),
/* harmony export */   "utcThursday": () => (/* binding */ utcThursday),
/* harmony export */   "utcFriday": () => (/* binding */ utcFriday),
/* harmony export */   "utcSaturday": () => (/* binding */ utcSaturday),
/* harmony export */   "utcSundays": () => (/* binding */ utcSundays),
/* harmony export */   "utcMondays": () => (/* binding */ utcMondays),
/* harmony export */   "utcTuesdays": () => (/* binding */ utcTuesdays),
/* harmony export */   "utcWednesdays": () => (/* binding */ utcWednesdays),
/* harmony export */   "utcThursdays": () => (/* binding */ utcThursdays),
/* harmony export */   "utcFridays": () => (/* binding */ utcFridays),
/* harmony export */   "utcSaturdays": () => (/* binding */ utcSaturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function utcWeekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/utcYear.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-time/src/utcYear.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "utcYears": () => (/* binding */ utcYears)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var utcYear = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (utcYear);
var utcYears = utcYear.range;


/***/ }),

/***/ "./node_modules/d3-time/src/week.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/week.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sunday": () => (/* binding */ sunday),
/* harmony export */   "monday": () => (/* binding */ monday),
/* harmony export */   "tuesday": () => (/* binding */ tuesday),
/* harmony export */   "wednesday": () => (/* binding */ wednesday),
/* harmony export */   "thursday": () => (/* binding */ thursday),
/* harmony export */   "friday": () => (/* binding */ friday),
/* harmony export */   "saturday": () => (/* binding */ saturday),
/* harmony export */   "sundays": () => (/* binding */ sundays),
/* harmony export */   "mondays": () => (/* binding */ mondays),
/* harmony export */   "tuesdays": () => (/* binding */ tuesdays),
/* harmony export */   "wednesdays": () => (/* binding */ wednesdays),
/* harmony export */   "thursdays": () => (/* binding */ thursdays),
/* harmony export */   "fridays": () => (/* binding */ fridays),
/* harmony export */   "saturdays": () => (/* binding */ saturdays)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");
/* harmony import */ var _duration_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./duration.js */ "./node_modules/d3-time/src/duration.js");



function weekday(i) {
  return (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationMinute) / _duration_js__WEBPACK_IMPORTED_MODULE_1__.durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;


/***/ }),

/***/ "./node_modules/d3-time/src/year.js":
/*!******************************************!*\
  !*** ./node_modules/d3-time/src/year.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "years": () => (/* binding */ years)
/* harmony export */ });
/* harmony import */ var _interval_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interval.js */ "./node_modules/d3-time/src/interval.js");


var year = (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0,_interval_js__WEBPACK_IMPORTED_MODULE_0__.default)(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (year);
var years = year.range;


/***/ }),

/***/ "./node_modules/d3-timer/src/interval.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-timer/src/interval.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timer.js */ "./node_modules/d3-timer/src/timer.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback, delay, time) {
  var t = new _timer_js__WEBPACK_IMPORTED_MODULE_0__.Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  t._restart = t.restart;
  t.restart = function(callback, delay, time) {
    delay = +delay, time = time == null ? (0,_timer_js__WEBPACK_IMPORTED_MODULE_0__.now)() : +time;
    t._restart(function tick(elapsed) {
      elapsed += total;
      t._restart(tick, total += delay, time);
      callback(elapsed);
    }, delay, time);
  }
  t.restart(callback, delay, time);
  return t;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "now": () => (/* binding */ now),
/* harmony export */   "Timer": () => (/* binding */ Timer),
/* harmony export */   "timer": () => (/* binding */ timer),
/* harmony export */   "timerFlush": () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/delaunator/index.js":
/*!******************************************!*\
  !*** ./node_modules/delaunator/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Delaunator)
/* harmony export */ });

const EPSILON = Math.pow(2, -52);
const EDGE_STACK = new Uint32Array(512);

class Delaunator {

    static from(points, getX = defaultGetX, getY = defaultGetY) {
        const n = points.length;
        const coords = new Float64Array(n * 2);

        for (let i = 0; i < n; i++) {
            const p = points[i];
            coords[2 * i] = getX(p);
            coords[2 * i + 1] = getY(p);
        }

        return new Delaunator(coords);
    }

    constructor(coords) {
        const n = coords.length >> 1;
        if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

        this.coords = coords;

        // arrays that will store the triangulation graph
        const maxTriangles = Math.max(2 * n - 5, 0);
        this._triangles = new Uint32Array(maxTriangles * 3);
        this._halfedges = new Int32Array(maxTriangles * 3);

        // temporary arrays for tracking the edges of the advancing convex hull
        this._hashSize = Math.ceil(Math.sqrt(n));
        this._hullPrev = new Uint32Array(n); // edge to prev edge
        this._hullNext = new Uint32Array(n); // edge to next edge
        this._hullTri = new Uint32Array(n); // edge to adjacent triangle
        this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

        // temporary arrays for sorting points
        this._ids = new Uint32Array(n);
        this._dists = new Float64Array(n);

        this.update();
    }

    update() {
        const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
        const n = coords.length >> 1;

        // populate an array of point indices; calculate input data bbox
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        for (let i = 0; i < n; i++) {
            const x = coords[2 * i];
            const y = coords[2 * i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
            this._ids[i] = i;
        }
        const cx = (minX + maxX) / 2;
        const cy = (minY + maxY) / 2;

        let minDist = Infinity;
        let i0, i1, i2;

        // pick a seed point close to the center
        for (let i = 0; i < n; i++) {
            const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist) {
                i0 = i;
                minDist = d;
            }
        }
        const i0x = coords[2 * i0];
        const i0y = coords[2 * i0 + 1];

        minDist = Infinity;

        // find the point closest to the seed
        for (let i = 0; i < n; i++) {
            if (i === i0) continue;
            const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
            if (d < minDist && d > 0) {
                i1 = i;
                minDist = d;
            }
        }
        let i1x = coords[2 * i1];
        let i1y = coords[2 * i1 + 1];

        let minRadius = Infinity;

        // find the third point which forms the smallest circumcircle with the first two
        for (let i = 0; i < n; i++) {
            if (i === i0 || i === i1) continue;
            const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
            if (r < minRadius) {
                i2 = i;
                minRadius = r;
            }
        }
        let i2x = coords[2 * i2];
        let i2y = coords[2 * i2 + 1];

        if (minRadius === Infinity) {
            // order collinear points by dx (or dy if all x are identical)
            // and return the list as a hull
            for (let i = 0; i < n; i++) {
                this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
            }
            quicksort(this._ids, this._dists, 0, n - 1);
            const hull = new Uint32Array(n);
            let j = 0;
            for (let i = 0, d0 = -Infinity; i < n; i++) {
                const id = this._ids[i];
                if (this._dists[id] > d0) {
                    hull[j++] = id;
                    d0 = this._dists[id];
                }
            }
            this.hull = hull.subarray(0, j);
            this.triangles = new Uint32Array(0);
            this.halfedges = new Uint32Array(0);
            return;
        }

        // swap the order of the seed points for counter-clockwise orientation
        if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
            const i = i1;
            const x = i1x;
            const y = i1y;
            i1 = i2;
            i1x = i2x;
            i1y = i2y;
            i2 = i;
            i2x = x;
            i2y = y;
        }

        const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
        this._cx = center.x;
        this._cy = center.y;

        for (let i = 0; i < n; i++) {
            this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
        }

        // sort the points by distance from the seed triangle circumcenter
        quicksort(this._ids, this._dists, 0, n - 1);

        // set up the seed triangle as the starting hull
        this._hullStart = i0;
        let hullSize = 3;

        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;

        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;

        hullHash.fill(-1);
        hullHash[this._hashKey(i0x, i0y)] = i0;
        hullHash[this._hashKey(i1x, i1y)] = i1;
        hullHash[this._hashKey(i2x, i2y)] = i2;

        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);

        for (let k = 0, xp, yp; k < this._ids.length; k++) {
            const i = this._ids[k];
            const x = coords[2 * i];
            const y = coords[2 * i + 1];

            // skip near-duplicate points
            if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
            xp = x;
            yp = y;

            // skip seed triangle points
            if (i === i0 || i === i1 || i === i2) continue;

            // find a visible edge on the convex hull using edge hash
            let start = 0;
            for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                start = hullHash[(key + j) % this._hashSize];
                if (start !== -1 && start !== hullNext[start]) break;
            }

            start = hullPrev[start];
            let e = start, q;
            while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                e = q;
                if (e === start) {
                    e = -1;
                    break;
                }
            }
            if (e === -1) continue; // likely a near-duplicate point; skip it

            // add the first triangle from the point
            let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

            // recursively flip triangles from the point until they satisfy the Delaunay condition
            hullTri[i] = this._legalize(t + 2);
            hullTri[e] = t; // keep track of boundary triangles on the hull
            hullSize++;

            // walk forward through the hull, adding more triangles and flipping recursively
            let n = hullNext[e];
            while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                hullTri[i] = this._legalize(t + 2);
                hullNext[n] = n; // mark as removed
                hullSize--;
                n = q;
            }

            // walk backward from the other side, adding more triangles and flipping
            if (e === start) {
                while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                    t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                    this._legalize(t + 2);
                    hullTri[q] = t;
                    hullNext[e] = e; // mark as removed
                    hullSize--;
                    e = q;
                }
            }

            // update the hull indices
            this._hullStart = hullPrev[i] = e;
            hullNext[e] = hullPrev[n] = i;
            hullNext[i] = n;

            // save the two new edges in the hash table
            hullHash[this._hashKey(x, y)] = i;
            hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
        }

        this.hull = new Uint32Array(hullSize);
        for (let i = 0, e = this._hullStart; i < hullSize; i++) {
            this.hull[i] = e;
            e = hullNext[e];
        }

        // trim typed triangle mesh arrays
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }

    _hashKey(x, y) {
        return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
    }

    _legalize(a) {
        const {_triangles: triangles, _halfedges: halfedges, coords} = this;

        let i = 0;
        let ar = 0;

        // recursion eliminated with a fixed-size stack
        while (true) {
            const b = halfedges[a];

            /* if the pair of triangles doesn't satisfy the Delaunay condition
             * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
             * then do the same check/flip recursively for the new pair of triangles
             *
             *           pl                    pl
             *          /||\                  /  \
             *       al/ || \bl            al/    \a
             *        /  ||  \              /      \
             *       /  a||b  \    flip    /___ar___\
             *     p0\   ||   /p1   =>   p0\---bl---/p1
             *        \  ||  /              \      /
             *       ar\ || /br             b\    /br
             *          \||/                  \  /
             *           pr                    pr
             */
            const a0 = a - a % 3;
            ar = a0 + (a + 2) % 3;

            if (b === -1) { // convex hull edge
                if (i === 0) break;
                a = EDGE_STACK[--i];
                continue;
            }

            const b0 = b - b % 3;
            const al = a0 + (a + 1) % 3;
            const bl = b0 + (b + 2) % 3;

            const p0 = triangles[ar];
            const pr = triangles[a];
            const pl = triangles[al];
            const p1 = triangles[bl];

            const illegal = inCircle(
                coords[2 * p0], coords[2 * p0 + 1],
                coords[2 * pr], coords[2 * pr + 1],
                coords[2 * pl], coords[2 * pl + 1],
                coords[2 * p1], coords[2 * p1 + 1]);

            if (illegal) {
                triangles[a] = p1;
                triangles[b] = p0;

                const hbl = halfedges[bl];

                // edge swapped on the other side of the hull (rare); fix the halfedge reference
                if (hbl === -1) {
                    let e = this._hullStart;
                    do {
                        if (this._hullTri[e] === bl) {
                            this._hullTri[e] = a;
                            break;
                        }
                        e = this._hullPrev[e];
                    } while (e !== this._hullStart);
                }
                this._link(a, hbl);
                this._link(b, halfedges[ar]);
                this._link(ar, bl);

                const br = b0 + (b + 1) % 3;

                // don't worry about hitting the cap: it can only happen on extremely degenerate input
                if (i < EDGE_STACK.length) {
                    EDGE_STACK[i++] = br;
                }
            } else {
                if (i === 0) break;
                a = EDGE_STACK[--i];
            }
        }

        return ar;
    }

    _link(a, b) {
        this._halfedges[a] = b;
        if (b !== -1) this._halfedges[b] = a;
    }

    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i1, i2, a, b, c) {
        const t = this.trianglesLen;

        this._triangles[t] = i0;
        this._triangles[t + 1] = i1;
        this._triangles[t + 2] = i2;

        this._link(t, a);
        this._link(t + 1, b);
        this._link(t + 2, c);

        this.trianglesLen += 3;

        return t;
    }
}

// monotonically increases with real angle, but doesn't need expensive trigonometry
function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
}

function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
}

// return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
function orientIfSure(px, py, rx, ry, qx, qy) {
    const l = (ry - py) * (qx - px);
    const r = (rx - px) * (qy - py);
    return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
}

// a more robust orientation test that's stable in a given triangle (to fix robustness issues)
function orient(rx, ry, qx, qy, px, py) {
    const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
    orientIfSure(rx, ry, qx, qy, px, py) ||
    orientIfSure(qx, qy, px, py, rx, ry);
    return sign < 0;
}

function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;

    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;

    return dx * (ey * cp - bp * fy) -
           dy * (ex * cp - bp * fx) +
           ap * (ex * fy - ey * fx) < 0;
}

function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = (ey * bl - dy * cl) * d;
    const y = (dx * cl - ex * bl) * d;

    return x * x + y * y;
}

function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;

    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);

    const x = ax + (ey * bl - dy * cl) * d;
    const y = ay + (dx * cl - ex * bl) * d;

    return {x, y};
}

function quicksort(ids, dists, left, right) {
    if (right - left <= 20) {
        for (let i = left + 1; i <= right; i++) {
            const temp = ids[i];
            const tempDist = dists[temp];
            let j = i - 1;
            while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
            ids[j + 1] = temp;
        }
    } else {
        const median = (left + right) >> 1;
        let i = left + 1;
        let j = right;
        swap(ids, median, i);
        if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
        if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
        if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

        const temp = ids[i];
        const tempDist = dists[temp];
        while (true) {
            do i++; while (dists[ids[i]] < tempDist);
            do j--; while (dists[ids[j]] > tempDist);
            if (j < i) break;
            swap(ids, i, j);
        }
        ids[left + 1] = ids[j];
        ids[j] = temp;

        if (right - i + 1 >= j - left) {
            quicksort(ids, dists, i, right);
            quicksort(ids, dists, left, j - 1);
        } else {
            quicksort(ids, dists, left, j - 1);
            quicksort(ids, dists, i, right);
        }
    }
}

function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultGetX(p) {
    return p[0];
}
function defaultGetY(p) {
    return p[1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "object": () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__.default)(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bbox": () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__.default),
/* harmony export */   "feature": () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__.default),
/* harmony export */   "mesh": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.default),
/* harmony export */   "meshArcs": () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   "merge": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.default),
/* harmony export */   "mergeArcs": () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   "neighbors": () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__.default),
/* harmony export */   "quantize": () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__.default),
/* harmony export */   "transform": () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__.default),
/* harmony export */   "untransform": () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__.default)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "mergeArcs": () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "meshArcs": () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__.default)(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__.default)(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be 2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__.default)(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__.default)(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__.default;
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/vega-canvas/index.browser.js":
/*!***************************************************!*\
  !*** ./node_modules/vega-canvas/index.browser.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "canvas": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domCanvas),
/* harmony export */   "image": () => (/* reexport safe */ _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__.domImage)
/* harmony export */ });
/* harmony import */ var _src_domCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/domCanvas */ "./node_modules/vega-canvas/src/domCanvas.js");



/***/ }),

/***/ "./node_modules/vega-canvas/src/domCanvas.js":
/*!***************************************************!*\
  !*** ./node_modules/vega-canvas/src/domCanvas.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "domCanvas": () => (/* binding */ domCanvas),
/* harmony export */   "domImage": () => (/* binding */ domImage)
/* harmony export */ });
function domCanvas(w, h) {
  if (typeof document !== 'undefined' && document.createElement) {
    const c = document.createElement('canvas');
    if (c && c.getContext) {
      c.width = w;
      c.height = h;
      return c;
    }
  }
  return null;
}

const domImage = () =>
  typeof Image !== 'undefined' ? Image : null;


/***/ }),

/***/ "./node_modules/vega-crossfilter/build/vega-crossfilter.module.js":
/*!************************************************************************!*\
  !*** ./node_modules/vega-crossfilter/build/vega-crossfilter.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "crossfilter": () => (/* binding */ CrossFilter),
/* harmony export */   "resolvefilter": () => (/* binding */ ResolveFilter)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/permute.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




const array8 = n => new Uint8Array(n);
const array16 = n => new Uint16Array(n);
const array32 = n => new Uint32Array(n);

/**
 * Maintains CrossFilter state.
 */

function Bitmaps() {
  let width = 8,
      data = [],
      seen = array32(0),
      curr = array(0, width),
      prev = array(0, width);
  return {
    data: () => data,
    seen: () => seen = lengthen(seen, data.length),

    add(array) {
      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {
        t = array[i];
        t._index = j++;
        data.push(t);
      }
    },

    remove(num, map) {
      // map: index -> boolean (true => remove)
      const n = data.length,
            copy = Array(n - num),
            reindex = data; // reuse old data array for index map

      let t, i, j; // seek forward to first removal

      for (i = 0; !map[i] && i < n; ++i) {
        copy[i] = data[i];
        reindex[i] = i;
      } // condense arrays


      for (j = i; i < n; ++i) {
        t = data[i];

        if (!map[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }

        curr[i] = 0; // clear unused bits
      }

      data = copy;
      return reindex;
    },

    size: () => data.length,
    curr: () => curr,
    prev: () => prev,
    reset: k => prev[k] = curr[k],
    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,

    set(k, one) {
      curr[k] |= one;
    },

    clear(k, one) {
      curr[k] &= ~one;
    },

    resize(n, m) {
      const k = curr.length;

      if (n > k || m > width) {
        width = Math.max(m, width);
        curr = array(n, width, curr);
        prev = array(n, width);
      }
    }

  };
}

function lengthen(array, length, copy) {
  if (array.length >= length) return array;
  copy = copy || new array.constructor(length);
  copy.set(array);
  return copy;
}

function array(n, m, array) {
  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);
  if (array) copy.set(array);
  return copy;
}

function Dimension (index, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index.bisect,
    index: index.index,
    size: index.size,

    onAdd(added, curr) {
      const dim = this,
            range = dim.bisect(dim.range, added.value),
            idx = added.index,
            lo = range[0],
            hi = range[1],
            n1 = idx.length;
      let i;

      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;

      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;

      return dim;
    }

  };
}

/**
 * Maintains a list of values, sorted by key.
 */

function SortedIndex() {
  let index = array32(0),
      value = [],
      size = 0;

  function insert(key, data, base) {
    if (!data.length) return [];
    const n0 = size,
          n1 = data.length,
          addi = array32(n1);
    let addv = Array(n1),
        oldv,
        oldi,
        i;

    for (i = 0; i < n1; ++i) {
      addv[i] = key(data[i]);
      addi[i] = i;
    }

    addv = sort(addv, addi);

    if (n0) {
      oldv = value;
      oldi = index;
      value = Array(n0 + n1);
      index = array32(n0 + n1);
      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);
    } else {
      if (base > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base;
      }
      value = addv;
      index = addi;
    }

    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }

  function remove(num, map) {
    // map: index -> remove
    const n = size;
    let idx, i, j; // seek forward to first removal

    for (i = 0; !map[index[i]] && i < n; ++i); // condense index and value arrays


    for (j = i; i < n; ++i) {
      if (!map[idx = index[i]]) {
        index[j] = idx;
        value[j] = value[i];
        ++j;
      }
    }

    size = n - num;
  }

  function reindex(map) {
    for (let i = 0, n = size; i < n; ++i) {
      index[i] = map[index[i]];
    }
  }

  function bisect(range, array) {
    let n;

    if (array) {
      n = array.length;
    } else {
      array = value;
      n = size;
    }

    return [(0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectLeft)(array, range[0], 0, n), (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectRight)(array, range[1], 0, n)];
  }

  return {
    insert: insert,
    remove: remove,
    bisect: bisect,
    reindex: reindex,
    index: () => index,
    size: () => size
  };
}

function sort(values, index) {
  values.sort.call(index, (a, b) => {
    const x = values[a],
          y = values[b];
    return x < y ? -1 : x > y ? 1 : 0;
  });
  return (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values, index);
}

function merge(base, value0, index0, n0, value1, index1, n1, value, index) {
  let i0 = 0,
      i1 = 0,
      i;

  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value[i] = value0[i0];
      index[i] = index0[i0++];
    } else {
      value[i] = value1[i1];
      index[i] = index1[i1++] + base;
    }
  }

  for (; i0 < n0; ++i0, ++i) {
    value[i] = value0[i0];
    index[i] = index0[i0];
  }

  for (; i1 < n1; ++i1, ++i) {
    value[i] = value1[i1];
    index[i] = index1[i1] + base;
  }
}

/**
 * An indexed multi-dimensional filter.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.
 * @param {Array} params.query - An array of per-dimension range queries.
 */

function CrossFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, Bitmaps(), params);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  'type': 'CrossFilter',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'query',
    'type': 'array',
    'array': true,
    'required': true,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(CrossFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!this._dims) {
      return this.init(_, pulse);
    } else {
      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));

      return init ? this.reinit(_, pulse) : this.eval(_, pulse);
    }
  },

  init(_, pulse) {
    const fields = _.fields,
          query = _.query,
          indices = this._indices = {},
          dims = this._dims = [],
          m = query.length;
    let i = 0,
        key,
        index; // instantiate indices and dimensions

    for (; i < m; ++i) {
      key = fields[i].fname;
      index = indices[key] || (indices[key] = SortedIndex());
      dims.push(Dimension(index, i, query[i]));
    }

    return this.eval(_, pulse);
  },

  reinit(_, pulse) {
    const output = pulse.materialize().fork(),
          fields = _.fields,
          query = _.query,
          indices = this._indices,
          dims = this._dims,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          out = output.rem = output.add,
          mod = output.mod,
          m = query.length,
          adds = {};
    let add, index, key, mods, remMap, modMap, i, n, f; // set prev to current state

    prev.set(curr); // if pulse has remove tuples, process them first

    if (pulse.rem.length) {
      remMap = this.remove(_, pulse, output);
    } // if pulse has added tuples, add them to state


    if (pulse.add.length) {
      bits.add(pulse.add);
    } // if pulse has modified tuples, create an index map


    if (pulse.mod.length) {
      modMap = {};

      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    } // re-initialize indices as needed, update curr bitmap


    for (i = 0; i < m; ++i) {
      f = fields[i];

      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {
        key = f.fname;

        if (!(add = adds[key])) {
          indices[key] = index = SortedIndex();
          adds[key] = add = index.insert(f, pulse.source, 0);
        }

        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);
      }
    } // visit each tuple
    // if filter state changed, push index to add/rem
    // else if in mod and passes a filter, push index to mod


    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        // skip if removed tuple
        continue;
      } else if (prev[i] !== curr[i]) {
        // add if state changed
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        // otherwise, pass mods through
        mod.push(i);
      }
    }

    bits.mask = (1 << m) - 1;
    return output;
  },

  eval(_, pulse) {
    const output = pulse.materialize().fork(),
          m = this._dims.length;
    let mask = 0;

    if (pulse.rem.length) {
      this.remove(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (_.modified('query') && !_.modified('fields')) {
      mask |= this.update(_, pulse, output);
    }

    if (pulse.add.length) {
      this.insert(_, pulse, output);
      mask |= (1 << m) - 1;
    }

    if (pulse.mod.length) {
      this.modify(pulse, output);
      mask |= (1 << m) - 1;
    }

    this.value.mask = mask;
    return output;
  },

  insert(_, pulse, output) {
    const tuples = pulse.add,
          bits = this.value,
          dims = this._dims,
          indices = this._indices,
          fields = _.fields,
          adds = {},
          out = output.add,
          n = bits.size() + tuples.length,
          m = dims.length;
    let k = bits.size(),
        j,
        key,
        add; // resize bitmaps and add tuples as needed

    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(); // add to dimensional indices

    for (j = 0; j < m; ++j) {
      key = fields[j].fname;
      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));
      dims[j].onAdd(add, curr);
    } // set previous filters, output if passes at least one filter


    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all) out.push(k);
    }
  },

  modify(pulse, output) {
    const out = output.mod,
          bits = this.value,
          curr = bits.curr(),
          all = bits.all(),
          tuples = pulse.mod;
    let i, n, k;

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all) out.push(k);
    }
  },

  remove(_, pulse, output) {
    const indices = this._indices,
          bits = this.value,
          curr = bits.curr(),
          prev = bits.prev(),
          all = bits.all(),
          map = {},
          out = output.rem,
          tuples = pulse.rem;
    let i, n, k, f; // process tuples, output if passes at least one filter

    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map[k] = 1; // build index map

      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all) out.push(k);
    } // remove from dimensional indices


    for (k in indices) {
      indices[k].remove(n, map);
    }

    this.reindex(pulse, n, map);
    return map;
  },

  // reindex filters and indices after propagation completes
  reindex(pulse, num, map) {
    const indices = this._indices,
          bits = this.value;
    pulse.runAfter(() => {
      const indexMap = bits.remove(num, map);

      for (const key in indices) indices[key].reindex(indexMap);
    });
  },

  update(_, pulse, output) {
    const dims = this._dims,
          query = _.query,
          stamp = pulse.stamp,
          m = dims.length;
    let mask = 0,
        i,
        q; // survey how many queries have changed

    output.filters = 0;

    for (q = 0; q < m; ++q) {
      if (_.modified('query', q)) {
        i = q;
        ++mask;
      }
    }

    if (mask === 1) {
      // only one query changed, use more efficient update
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output.add, output.rem);
    } else {
      // multiple queries changed, perform full record keeping
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified('query', q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output.add);
        output.rem = output.add; // duplicate add/rem for downstream resolve
      }
    }

    return mask;
  },

  incrementAll(dim, query, stamp, out) {
    const bits = this.value,
          seen = bits.seen(),
          curr = bits.curr(),
          prev = bits.prev(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];

        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }

        curr[k] ^= one;
      }
    }

    dim.range = query.slice();
  },

  incrementOne(dim, query, add, rem) {
    const bits = this.value,
          curr = bits.curr(),
          index = dim.index(),
          old = dim.bisect(dim.range),
          range = dim.bisect(query),
          lo1 = range[0],
          hi1 = range[1],
          lo0 = old[0],
          hi0 = old[1],
          one = dim.one;
    let i, j, k; // Fast incremental update based on previous lo index.

    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    } // Fast incremental update based on previous hi index.


    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    }

    dim.range = query.slice();
  }

});

/**
 * Selectively filters tuples by resolving against a filter bitmap.
 * Useful for processing the output of a cross-filter transform.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.ignore - A bit mask indicating which filters to ignore.
 * @param {object} params.filter - The per-tuple filter bitmaps. Typically this
 *   parameter value is a reference to a {@link CrossFilter} transform.
 */

function ResolveFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
ResolveFilter.Definition = {
  'type': 'ResolveFilter',
  'metadata': {},
  'params': [{
    'name': 'ignore',
    'type': 'number',
    'required': true,
    'description': 'A bit mask indicating which filters to ignore.'
  }, {
    'name': 'filter',
    'type': 'object',
    'required': true,
    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(ResolveFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const ignore = ~(_.ignore || 0),
          // bit mask where zeros -> dims to ignore
    bitmap = _.filter,
          mask = bitmap.mask; // exit early if no relevant filter changes

    if ((mask & ignore) === 0) return pulse.StopPropagation;

    const output = pulse.fork(pulse.ALL),
          data = bitmap.data(),
          curr = bitmap.curr(),
          prev = bitmap.prev(),
          pass = k => !(curr[k] & ignore) ? data[k] : null; // propagate all mod tuples that pass the filter


    output.filter(output.MOD, pass); // determine add & rem tuples via filter functions
    // for efficiency, we do *not* populate new arrays,
    // instead we add filter functions applied downstream

    if (!(mask & mask - 1)) {
      // only one filter changed
      output.filter(output.ADD, pass);
      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);
    } else {
      // multiple filters changed
      output.filter(output.ADD, k => {
        const c = curr[k] & ignore,
              f = !c && c ^ prev[k] & ignore;
        return f ? data[k] : null;
      });
      output.filter(output.REM, k => {
        const c = curr[k] & ignore,
              f = c && !(c ^ (c ^ prev[k] & ignore));
        return f ? data[k] : null;
      });
    } // add filter to source data in case of reflow...


    return output.filter(output.SOURCE, t => pass(t._index));
  }

});




/***/ }),

/***/ "./node_modules/vega-dataflow/build/vega-dataflow.module.js":
/*!******************************************************************!*\
  !*** ./node_modules/vega-dataflow/build/vega-dataflow.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Dataflow": () => (/* binding */ Dataflow),
/* harmony export */   "EventStream": () => (/* binding */ EventStream),
/* harmony export */   "MultiPulse": () => (/* binding */ MultiPulse),
/* harmony export */   "Operator": () => (/* binding */ Operator),
/* harmony export */   "Parameters": () => (/* binding */ Parameters),
/* harmony export */   "Pulse": () => (/* binding */ Pulse),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "UniqueList": () => (/* binding */ UniqueList),
/* harmony export */   "asyncCallback": () => (/* binding */ asyncCallback),
/* harmony export */   "changeset": () => (/* binding */ changeset),
/* harmony export */   "definition": () => (/* binding */ definition),
/* harmony export */   "derive": () => (/* binding */ derive),
/* harmony export */   "ingest": () => (/* binding */ ingest$1),
/* harmony export */   "isChangeSet": () => (/* binding */ isChangeSet),
/* harmony export */   "isTuple": () => (/* binding */ isTuple),
/* harmony export */   "rederive": () => (/* binding */ rederive),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "stableCompare": () => (/* binding */ stableCompare),
/* harmony export */   "transform": () => (/* binding */ transform),
/* harmony export */   "transforms": () => (/* binding */ transforms),
/* harmony export */   "tupleid": () => (/* binding */ tupleid)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");




function UniqueList(idFunc) {
  const $ = idFunc || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        list = [],
        ids = {};

  list.add = _ => {
    const id = $(_);

    if (!ids[id]) {
      ids[id] = 1;
      list.push(_);
    }

    return list;
  };

  list.remove = _ => {
    const id = $(_);

    if (ids[id]) {
      ids[id] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }

    return list;
  };

  return list;
}

/**
 * Invoke and await a potentially async callback function. If
 * an error occurs, trap it and route to Dataflow.error.
 * @param {Dataflow} df - The dataflow instance
 * @param {function} callback - A callback function to invoke
 *   and then await. The dataflow will be passed as the single
 *   argument to the function.
 */
async function asyncCallback (df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}

const TUPLE_ID_KEY = Symbol('vega_id');
let TUPLE_ID = 1;
/**
 * Checks if an input value is a registered tuple.
 * @param {*} t - The value to check.
 * @return {boolean} True if the input is a tuple, false otherwise.
 */

function isTuple(t) {
  return !!(t && tupleid(t));
}
/**
 * Returns the id of a tuple.
 * @param {object} t - The input tuple.
 * @return {*} the tuple id.
 */

function tupleid(t) {
  return t[TUPLE_ID_KEY];
}
/**
 * Sets the id of a tuple.
 * @param {object} t - The input tuple.
 * @param {*} id - The id value to set.
 * @return {object} the input tuple.
 */

function setid(t, id) {
  t[TUPLE_ID_KEY] = id;
  return t;
}
/**
 * Ingest an object or value as a data tuple.
 * If the input value is an object, an id field will be added to it. For
 * efficiency, the input object is modified directly. A copy is not made.
 * If the input value is a literal, it will be wrapped in a new object
 * instance, with the value accessible as the 'data' property.
 * @param datum - The value to ingest.
 * @return {object} The ingested data tuple.
 */


function ingest$1(datum) {
  const t = datum === Object(datum) ? datum : {
    data: datum
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}
/**
 * Given a source tuple, return a derived copy.
 * @param {object} t - The source tuple.
 * @return {object} The derived tuple.
 */

function derive(t) {
  return rederive(t, ingest$1({}));
}
/**
 * Rederive a derived tuple by copying values from the source tuple.
 * @param {object} t - The source tuple.
 * @param {object} d - The derived tuple.
 * @return {object} The derived tuple.
 */

function rederive(t, d) {
  for (const k in t) d[k] = t[k];

  return d;
}
/**
 * Replace an existing tuple with a new tuple.
 * @param {object} t - The existing data tuple.
 * @param {object} d - The new tuple that replaces the old.
 * @return {object} The new tuple.
 */

function replace(t, d) {
  return setid(d, tupleid(t));
}
/**
 * Generate an augmented comparator function that provides stable
 * sorting by tuple id when the given comparator produces ties.
 * @param {function} cmp - The comparator to augment.
 * @param {function} [f] - Optional tuple accessor function.
 * @return {function} An augmented comparator function.
 */

function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);
}

function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add = [],
        // insert tuples
  rem = [],
        // remove tuples
  mod = [],
        // modify tuples
  remp = [],
        // remove by predicate
  modp = []; // modify by predicate

  let clean = null,
      reflow = false;
  return {
    constructor: changeset,

    insert(t) {
      const d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) add.push(d[i]);

      return this;
    },

    remove(t) {
      const a = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t) ? remp : rem,
            d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
            n = d.length;

      for (let i = 0; i < n; ++i) a.push(d[i]);

      return this;
    },

    modify(t, field, value) {
      const m = {
        field: field,
        value: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(value)
      };

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) {
        m.filter = t;
        modp.push(m);
      } else {
        m.tuple = t;
        mod.push(m);
      }

      return this;
    },

    encode(t, set) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) modp.push({
        filter: t,
        field: set
      });else mod.push({
        tuple: t,
        field: set
      });
      return this;
    },

    clean(value) {
      clean = value;
      return this;
    },

    reflow() {
      reflow = true;
      return this;
    },

    pulse(pulse, tuples) {
      const cur = {},
            out = {};
      let i, n, m, f, t, id; // build lookup table of current tuples

      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      } // process individual tuples to remove


      for (i = 0, n = rem.length; i < n; ++i) {
        t = rem[i];
        cur[tupleid(t)] = -1;
      } // process predicate-based removals


      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach(t => {
          if (f(t)) cur[tupleid(t)] = -1;
        });
      } // process all add tuples


      for (i = 0, n = add.length; i < n; ++i) {
        t = add[i];
        id = tupleid(t);

        if (cur[id]) {
          // tuple already resides in dataset
          // if flagged for both add and remove, cancel
          cur[id] = 1;
        } else {
          // tuple does not reside in dataset, add
          pulse.add.push(ingest$1(add[i]));
        }
      } // populate pulse rem list


      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0) pulse.rem.push(t);
      } // modify helper method


      function modify(t, f, v) {
        if (v) {
          t[f] = v(t);
        } else {
          pulse.encode = f;
        }

        if (!reflow) out[tupleid(t)] = t;
      } // process individual tuples to modify


      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t = m.tuple;
        f = m.field;
        id = cur[tupleid(t)];

        if (id > 0) {
          modify(t, f, m.value);
          pulse.modifies(f);
        }
      } // process predicate-based modifications


      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach(t => {
          if (f(t) && cur[tupleid(t)] > 0) {
            modify(t, m.field, m.value);
          }
        });
        pulse.modifies(m.field);
      } // upon reflow request, populate mod with all non-removed tuples
      // otherwise, populate mod with modified tuples only


      if (reflow) {
        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();
      } else {
        for (id in out) pulse.mod.push(out[id]);
      } // set pulse garbage collection request


      if (clean || clean == null && (rem.length || remp.length)) {
        pulse.clean(true);
      }

      return pulse;
    }

  };
}

const CACHE = '_:mod:_';
/**
 * Hash that tracks modifications to assigned values.
 * Callers *must* use the set method to update values.
 */

function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index, value, force) {
    const o = this,
          v = o[name],
          mod = o[CACHE];

    if (index != null && index >= 0) {
      if (v[index] !== value || force) {
        v[index] = value;
        mod[index + ':' + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value || force) {
      o[name] = value;
      mod[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? 1 + value.length : -1;
    }

    return o;
  },

  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index) {
    const mod = this[CACHE];

    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k]) return true;
      }

      return false;
    } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(name)) {
      for (let k = 0; k < name.length; ++k) {
        if (mod[name[k]]) return true;
      }

      return false;
    }

    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];
  },

  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }

};

let OP_ID = 0;
const PULSE = 'pulse',
      NO_PARAMS = new Parameters(); // Boolean Flags

const SKIP$1 = 1,
      MODIFIED = 2;
/**
 * An Operator is a processing node in a dataflow graph.
 * Each operator stores a value and an optional value update function.
 * Operators can accept a hash of named parameters. Parameter values can
 * either be direct (JavaScript literals, arrays, objects) or indirect
 * (other operators whose values will be pulled dynamically). Operators
 * included as parameters will have this operator added as a dependency.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {function(object, Pulse)} [update] - An update function. Upon
 *   evaluation of this operator, the update function will be invoked and the
 *   return value will be used as the new value of this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @see parameters
 */

function Operator(init, update, params, react) {
  this.id = ++OP_ID;
  this.value = init;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;

  if (update) {
    this._update = update;
  }

  if (params) this.parameters(params, react);
}

function flag(bit) {
  return function (state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}

Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value) {
    if (this.value !== value) {
      this.value = value;
      return 1;
    } else {
      return 0;
    }
  },

  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),

  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),

  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initiatal evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(),
          argops = this._argops = this._argops || [],
          deps = [];
    let name, value, n, i;

    const add = (name, index, value) => {
      if (value instanceof Operator) {
        if (value !== this) {
          if (react) value.targets().add(this);
          deps.push(value);
        }

        argops.push({
          op: value,
          name: name,
          index: index
        });
      } else {
        argval.set(name, index, value);
      }
    };

    for (name in params) {
      value = params[name];

      if (name === PULSE) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(value).forEach(op => {
          if (!(op instanceof Operator)) {
            (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Pulse parameters must be operator instances.');
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        argval.set(name, -1, Array(n = value.length));

        for (i = 0; i < n; ++i) add(name, i, value[i]);
      } else {
        add(name, -1, value);
      }
    }

    this.marshall().clear(); // initialize values

    if (initonly) argops.initonly = true;
    return deps;
  },

  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS,
          argops = this._argops;
    let item, i, op, mod;

    if (argops) {
      const n = argops.length;

      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }

      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }

        this._argops = null;
        this._update = null;
      }
    }

    return argval;
  },

  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;

    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;

        if (op._targets) {
          op._targets.remove(this);
        }
      }
    } // remove references to the source and pulse object,
    // if present, to prevent memory leaks of old data.


    this.pulse = null;
    this.source = null;
  },

  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse) {
    const update = this._update;

    if (update) {
      const params = this.marshall(pulse.stamp),
            v = update.call(this, params, pulse);
      params.clear();

      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse.StopPropagation;
      }
    }
  },

  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse);
    }

    return this.pulse = rv || pulse;
  }

};

/**
 * Add an operator to the dataflow graph. This function accepts a
 * variety of input argument types. The basic signature supports an
 * initial value, update function and parameters. If the first parameter
 * is an Operator instance, it will be added directly. If it is a
 * constructor for an Operator subclass, a new instance will be instantiated.
 * Otherwise, if the first parameter is a function instance, it will be used
 * as the update function and a null initial value is assumed.
 * @param {*} init - One of: the operator to add, the initial value of
 *   the operator, an operator class to instantiate, or an update function.
 * @param {function} [update] - The operator update function.
 * @param {object} [params] - The operator parameters.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @return {Operator} - The added operator.
 */

function add (init, update, params, react) {
  let shift = 1,
      op;

  if (init instanceof Operator) {
    op = init;
  } else if (init && init.prototype instanceof Operator) {
    op = new init();
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(init)) {
    op = new Operator(null, init);
  } else {
    shift = 0;
    op = new Operator(init, update);
  }

  this.rank(op);

  if (shift) {
    react = params;
    params = update;
  }

  if (params) this.connect(op, op.parameters(params, react));
  this.touch(op);
  return op;
}

/**
 * Connect a target operator as a dependent of source operators.
 * If necessary, this method will rerank the target operator and its
 * dependents to ensure propagation proceeds in a topologically sorted order.
 * @param {Operator} target - The target operator.
 * @param {Array<Operator>} - The source operators that should propagate
 *   to the target operator.
 */
function connect (target, sources) {
  const targetRank = target.rank,
        n = sources.length;

  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target);
      return;
    }
  }
}

let STREAM_ID = 0;
/**
 * Models an event stream.
 * @constructor
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @param {function(Object)} [receive] - Event callback function to invoke
 *   upon receipt of a new event. Use to override standard event processing.
 */

function EventStream(filter, apply, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter) this._filter = filter;
  if (apply) this._apply = apply;
}
/**
 * Creates a new event stream instance with the provided
 * (optional) filter, apply and receive functions.
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @see EventStream
 */

function stream(filter, apply, receive) {
  return new EventStream(filter, apply, receive);
}
EventStream.prototype = {
  _filter: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  _apply: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,

  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },

  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },

  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt),
            trg = this._targets,
            n = trg ? trg.length : 0;

      for (let i = 0; i < n; ++i) trg[i].receive(val);

      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },

  filter(filter) {
    const s = stream(filter);
    this.targets().add(s);
    return s;
  },

  apply(apply) {
    const s = stream(null, apply);
    this.targets().add(s);
    return s;
  },

  merge() {
    const s = stream();
    this.targets().add(s);

    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }

    return s;
  },

  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now = Date.now();

      if (now - t > pause) {
        t = now;
        return 1;
      } else {
        return 0;
      }
    });
  },

  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(delay, e => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run) df.run();
    })));
    return s;
  },

  between(a, b) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },

  detach() {
    // ensures compatibility with operators (#2753)
    // remove references to other streams and filter functions that may
    // be bound to subcontexts that need to be garbage collected.
    this._filter = vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
    this._targets = null;
  }

};

/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor. The input must
 *  support the addEventListener method.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @param {function(object): *} [apply] - Event application function.
 *   If provided, this function will be invoked and the result will be
 *   used as the downstream event value.
 * @return {EventStream}
 */

function events (source, type, filter, apply) {
  const df = this,
        s = stream(filter, apply),
        send = function (e) {
    e.dataflow = df;

    try {
      s.receive(e);
    } catch (error) {
      df.error(error);
    } finally {
      df.run();
    }
  };

  let sources;

  if (typeof source === 'string' && typeof document !== 'undefined') {
    sources = document.querySelectorAll(source);
  } else {
    sources = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(source);
  }

  const n = sources.length;

  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type, send);
  }

  return s;
}

function parse(data, format) {
  const locale = this.locale();
  return (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.read)(data, format, locale.timeParse, locale.utcParse);
}
/**
 * Ingests new data into the dataflow. First parses the data using the
 * vega-loader read method, then pulses a changeset to the target operator.
 * @param {Operator} target - The Operator to target with ingested data,
 *   typically a Collect transform instance.
 * @param {*} data - The input data, prior to parsing. For JSON this may
 *   be a string or an object. For CSV, TSV, etc should be a string.
 * @param {object} format - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @returns {Dataflow}
 */

function ingest(target, data, format) {
  data = this.parse(data, format);
  return this.pulse(target, this.changeset().insert(data));
}
/**
 * Request data from an external source, parse it, and return a Promise.
 * @param {string} url - The URL from which to load the data. This string
 *   is passed to the vega-loader load method.
 * @param {object} [format] - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @return {Promise} A Promise that resolves upon completion of the request.
 *   The resolved object contains the following properties:
 *   - data: an array of parsed data (or null upon error)
 *   - status: a code for success (0), load fail (-1), or parse fail (-2)
 */

async function request(url, format) {
  const df = this;
  let status = 0,
      data;

  try {
    data = await df.loader().load(url, {
      context: 'dataflow',
      response: (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.responseType)(format && format.type)
    });

    try {
      data = df.parse(data, format);
    } catch (err) {
      status = -2;
      df.warn('Data ingestion failed', url, err);
    }
  } catch (err) {
    status = -1;
    df.warn('Loading failed', url, err);
  }

  return {
    data,
    status
  };
}
async function preload(target, url, format) {
  const df = this,
        pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format);
  df.pulse(target, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(res.data || []));
  pending.done();
  return res;
}

function loadPending(df) {
  let accept;
  const pending = new Promise(a => accept = a);
  pending.requests = 0;

  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };

  return df._pending = pending;
}

const SKIP = {
  skip: true
};
/**
 * Perform operator updates in response to events. Applies an
 * update function to compute a new operator value. If the update function
 * returns a {@link ChangeSet}, the operator will be pulsed with those tuple
 * changes. Otherwise, the operator value will be updated to the return value.
 * @param {EventStream|Operator} source - The event source to react to.
 *   This argument can be either an EventStream or an Operator.
 * @param {Operator|function(object):Operator} target - The operator to update.
 *   This argument can either be an Operator instance or (if the source
 *   argument is an EventStream), a function that accepts an event object as
 *   input and returns an Operator to target.
 * @param {function(Parameters,Event): *} [update] - Optional update function
 *   to compute the new operator value, or a literal value to set. Update
 *   functions expect to receive a parameter object and event as arguments.
 *   This function can either return a new operator value or (if the source
 *   argument is an EventStream) a {@link ChangeSet} instance to pulse
 *   the target operator with tuple changes.
 * @param {object} [params] - The update function parameters.
 * @param {object} [options] - Additional options hash. If not overridden,
 *   updated operators will be skipped by default.
 * @param {boolean} [options.skip] - If true, the operator will
 *  be skipped: it will not be evaluated, but its dependents will be.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @return {Dataflow}
 */

function on (source, target, update, params, options) {
  const fn = source instanceof Operator ? onOperator : onStream;
  fn(this, source, target, update, params, options);
  return this;
}

function onStream(df, stream, target, update, params, options) {
  const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, SKIP);
  let func, op;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) target = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(target);

  if (update === undefined) {
    func = e => df.touch(target(e));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update)) {
    op = new Operator(null, update, params, false);

    func = e => {
      op.evaluate(e);
      const t = target(e),
            v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = e => df.update(target(e), update, opt);
  }

  stream.apply(func);
}

function onOperator(df, source, target, update, params, options) {
  if (update === undefined) {
    source.targets().add(target);
  } else {
    const opt = options || {},
          op = new Operator(null, updater(target, update), params, false);
    op.modified(opt.force);
    op.rank = source.rank; // immediately follow source

    source.targets().add(op); // add dependency

    if (target) {
      op.skip(true); // skip first invocation

      op.value = target.value; // initialize value

      op.targets().add(target); // chain dependencies

      df.connect(target, [op]); // rerank as needed, #1672
    }
  }
}

function updater(target, update) {
  update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update) ? update : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(update);
  return target ? function (_, pulse) {
    const value = update(_, pulse);

    if (!target.skip()) {
      target.skip(value !== this.value).value = value;
    }

    return value;
  } : update;
}

/**
 * Assigns a rank to an operator. Ranks are assigned in increasing order
 * by incrementing an internal rank counter.
 * @param {Operator} op - The operator to assign a rank.
 */

function rank(op) {
  op.rank = ++this._rank;
}
/**
 * Re-ranks an operator and all downstream target dependencies. This
 * is necessary when upstream dependencies of higher rank are added to
 * a target operator.
 * @param {Operator} op - The operator to re-rank.
 */

function rerank(op) {
  const queue = [op];
  let cur, list, i;

  while (queue.length) {
    this.rank(cur = queue.pop());

    if (list = cur._targets) {
      for (i = list.length; --i >= 0;) {
        queue.push(cur = list[i]);
        if (cur === op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Cycle detected in dataflow graph.');
      }
    }
  }
}

/**
 * Sentinel value indicating pulse propagation should stop.
 */

const StopPropagation = {}; // Pulse visit type flags

const ADD = 1 << 0,
      REM = 1 << 1,
      MOD = 1 << 2,
      ADD_REM = ADD | REM,
      ADD_MOD = ADD | MOD,
      ALL = ADD | REM | MOD,
      REFLOW = 1 << 3,
      SOURCE = 1 << 4,
      NO_SOURCE = 1 << 5,
      NO_FIELDS = 1 << 6;
/**
 * A Pulse enables inter-operator communication during a run of the
 * dataflow graph. In addition to the current timestamp, a pulse may also
 * contain a change-set of added, removed or modified data tuples, as well as
 * a pointer to a full backing data source. Tuple change sets may not
 * be fully materialized; for example, to prevent needless array creation
 * a change set may include larger arrays and corresponding filter functions.
 * The pulse provides a {@link visit} method to enable proper and efficient
 * iteration over requested data tuples.
 *
 * In addition, each pulse can track modification flags for data tuple fields.
 * Responsible transform operators should call the {@link modifies} method to
 * indicate changes to data fields. The {@link modified} method enables
 * querying of this modification state.
 *
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The current propagation timestamp.
 * @param {string} [encode] - An optional encoding set name, which is then
 *   accessible as Pulse.encode. Operators can respond to (or ignore) this
 *   setting as appropriate. This parameter can be used in conjunction with
 *   the Encode transform in the vega-encode module.
 */

function Pulse(dataflow, stamp, encode) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode || null;
}

function materialize(data, filter) {
  const out = [];
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(data, filter, _ => out.push(_));
  return out;
}

function filter(pulse, flags) {
  const map = {};
  pulse.visit(flags, t => {
    map[tupleid(t)] = 1;
  });
  return t => map[tupleid(t)] ? null : t;
}

function addFilter(a, b) {
  return a ? (t, i) => a(t, i) && b(t, i) : b;
}

Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,

  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,

  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,

  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,

  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,

  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,

  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,

  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,

  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,

  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,

  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,

  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },

  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },

  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)
    || !p.rem.length && p.source.length === p.add.length;

    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = []; // new operators can ignore rem #2769

      return p;
    }
  },

  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;

    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }

    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }

    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }

    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }

    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }

    return p;
  },

  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },

  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },

  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length,
          src = this.source && this.source.length;

    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD, filter(this, ADD));
    }

    return this;
  },

  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value) {
    if (arguments.length) {
      this.cleans = !!value;
      return this;
    } else {
      return this.cleans;
    }
  },

  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash = this.fields || (this.fields = {});

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_)) {
      _.forEach(f => hash[f] = true);
    } else {
      hash[_] = true;
    }

    return this;
  },

  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter);
    if (flags & REM) p.remF = addFilter(p.remF, filter);
    if (flags & MOD) p.modF = addFilter(p.modF, filter);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);
    return p;
  },

  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;

    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }

    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }

    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }

    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }

    return p;
  },

  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this,
          v = visitor;

    if (flags & SOURCE) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.source, p.srcF, v);
      return p;
    }

    if (flags & ADD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.add, p.addF, v);
    if (flags & REM) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.rem, p.remF, v);
    if (flags & MOD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.mod, p.modF, v);
    const src = p.source;

    if (flags & REFLOW && src) {
      const sum = p.add.length + p.mod.length;

      if (sum === src.length) ; else if (sum) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, filter(p, ADD_MOD), v);
      } else {
        // if no add/rem/mod tuples, visit source
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, p.srcF, v);
      }
    }

    return p;
  }

};

/**
 * Represents a set of multiple pulses. Used as input for operators
 * that accept multiple pulses at a time. Contained pulses are
 * accessible via the public "pulses" array property. This pulse doe
 * not carry added, removed or modified tuples directly. However,
 * the visit method can be used to traverse all such tuples contained
 * in sub-pulses with a timestamp matching this parent multi-pulse.
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The timestamp.
 * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.
 */

function MultiPulse(dataflow, stamp, pulses, encode) {
  const p = this,
        n = pulses.length;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode || null;
  this.pulses = pulses;

  for (let i = 0; i < n; ++i) {
    const pulse = pulses[i];
    if (pulse.stamp !== stamp) continue;

    if (pulse.fields) {
      const hash = p.fields || (p.fields = {});

      for (const f in pulse.fields) {
        hash[f] = 1;
      }
    }

    if (pulse.changed(p.ADD)) c |= p.ADD;
    if (pulse.changed(p.REM)) c |= p.REM;
    if (pulse.changed(p.MOD)) c |= p.MOD;
  }

  this.changes = c;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);

    if (flags !== undefined) {
      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));
      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));
      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));
    }

    return p;
  },

  changed(flags) {
    return this.changes & flags;
  },

  modified(_) {
    const p = this,
          fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },

  filter() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support filtering.');
  },

  materialize() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support materialization.');
  },

  visit(flags, visitor) {
    const p = this,
          pulses = p.pulses,
          n = pulses.length;
    let i = 0;

    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }

    return p;
  }

});

/* eslint-disable require-atomic-updates */
/**
 * Evaluates the dataflow and returns a Promise that resolves when pulse
 * propagation completes. This method will increment the current timestamp
 * and process all updated, pulsed and touched operators. When invoked for
 * the first time, all registered operators will be processed. This method
 * should not be invoked by third-party clients, use {@link runAsync} or
 * {@link run} instead.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function evaluate(encode, prerun, postrun) {
  const df = this,
        async = []; // if the pulse value is set, this is a re-entrant call

  if (df._pulse) return reentrant(df); // wait for pending datasets to load

  if (df._pending) await df._pending; // invoke prerun function, if provided

  if (prerun) await asyncCallback(df, prerun); // exit early if there are no updates

  if (!df._touched.length) {
    df.debug('Dataflow invoked, but nothing to do.');
    return df;
  } // increment timestamp clock


  const stamp = ++df._clock; // set the current pulse

  df._pulse = new Pulse(df, stamp, encode); // initialize priority queue, reset touched operators

  df._touched.forEach(op => df._enqueue(op, true));

  df._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  let count = 0,
      op,
      next,
      error;

  try {
    while (df._heap.size() > 0) {
      // dequeue operator with highest priority
      op = df._heap.pop(); // re-queue if rank changed

      if (op.rank !== op.qrank) {
        df._enqueue(op, true);

        continue;
      } // otherwise, evaluate the operator


      next = op.run(df._getPulse(op, encode));

      if (next.then) {
        // await if operator returns a promise directly
        next = await next;
      } else if (next.async) {
        // queue parallel asynchronous execution
        async.push(next.async);
        next = StopPropagation;
      } // propagate evaluation, enqueue dependent operators


      if (next !== StopPropagation) {
        if (op._targets) op._targets.forEach(op => df._enqueue(op));
      } // increment visit counter


      ++count;
    }
  } catch (err) {
    df._heap.clear();

    error = err;
  } // reset pulse map


  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);

  if (error) {
    df._postrun = [];
    df.error(error);
  } // invoke callbacks queued via runAfter


  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b) => b.priority - a.priority);

    df._postrun = [];

    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  } // invoke postrun function, if provided


  if (postrun) await asyncCallback(df, postrun); // handle non-blocking asynchronous callbacks

  if (async.length) {
    Promise.all(async).then(cb => df.runAsync(null, () => {
      cb.forEach(f => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }

  return df;
}
/**
 * Queues dataflow evaluation to run once any other queued evaluations have
 * completed and returns a Promise that resolves when the queued pulse
 * propagation completes. If provided, a callback function will be invoked
 * immediately before evaluation commences. This method will ensure a
 * separate evaluation is invoked for each time it is called.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */

async function runAsync(encode, prerun, postrun) {
  // await previously queued functions
  while (this._running) await this._running; // run dataflow, manage running promise


  const clear = () => this._running = null;

  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);
  return this._running;
}
/**
 * Requests dataflow evaluation and the immediately returns this dataflow
 * instance. If there are pending data loading or other asynchronous
 * operations, the dataflow will evaluate asynchronously after this method
 * has been invoked. To track when dataflow evaluation completes, use the
 * {@link runAsync} method instead. This method will raise an error if
 * invoked while the dataflow is already in the midst of evaluation.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode module.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Dataflow} - This dataflow instance.
 */

function run(encode, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);
}
/**
 * Schedules a callback function to be invoked after the current pulse
 * propagation completes. If no propagation is currently occurring,
 * the function is invoked immediately. Callbacks scheduled via runAfter
 * are invoked immediately upon completion of the current cycle, before
 * any request queued via runAsync. This method is primarily intended for
 * internal use. Third-party callers using runAfter to schedule a callback
 * that invokes {@link run} or {@link runAsync} should not use this method,
 * but instead use {@link runAsync} with prerun or postrun arguments.
 * @param {function(Dataflow)} callback - The callback function to run.
 *   The callback will be invoked with this Dataflow instance as its
 *   sole argument.
 * @param {boolean} enqueue - A boolean flag indicating that the
 *   callback should be queued up to run after the next propagation
 *   cycle, suppressing immediate invocation when propagation is not
 *   currently occurring.
 * @param {number} [priority] - A priority value used to sort registered
 *   callbacks to determine execution order. This argument is intended
 *   for internal Vega use only.
 */

function runAfter(callback, enqueue, priority) {
  if (this._pulse || enqueue) {
    // pulse propagation is currently running, queue to run after
    this._postrun.push({
      priority: priority || 0,
      callback: callback
    });
  } else {
    // pulse propagation already complete, invoke immediately
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}
/**
 * Raise an error for re-entrant dataflow evaluation.
 */

function reentrant(df) {
  df.error('Dataflow already running. Use runAsync() to chain invocations.');
  return df;
}
/**
 * Enqueue an operator into the priority queue for evaluation. The operator
 * will be enqueued if it has no registered pulse for the current cycle, or if
 * the force argument is true. Upon enqueue, this method also sets the
 * operator's qrank to the current rank value.
 * @param {Operator} op - The operator to enqueue.
 * @param {boolean} [force] - A flag indicating if the operator should be
 *   forceably added to the queue, even if it has already been previously
 *   enqueued during the current pulse propagation. This is useful when the
 *   dataflow graph is dynamically modified and the operator rank changes.
 */


function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;

  if (q || force) {
    op.qrank = op.rank;

    this._heap.push(op);
  }
}
/**
 * Provide a correct pulse for evaluating an operator. If the operator has an
 * explicit source operator, we will try to pull the pulse(s) from it.
 * If there is an array of source operators, we build a multi-pulse.
 * Otherwise, we return a current pulse with correct source data.
 * If the pulse is the pulse map has an explicit target set, we use that.
 * Else if the pulse on the upstream source operator is current, we use that.
 * Else we use the pulse from the pulse map, but copy the source tuple array.
 * @param {Operator} op - The operator for which to get an input pulse.
 * @param {string} [encode] - An (optional) encoding set name with which to
 *   annotate the returned pulse. See {@link run} for more information.
 */

function getPulse(op, encode) {
  const s = op.source,
        stamp = this._clock;
  return s && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}

function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }

  p = p.fork();

  if (s && s !== StopPropagation) {
    p.source = s.source;
  }

  return p;
}

const NO_OPT = {
  skip: false,
  force: false
};
/**
 * Touches an operator, scheduling it to be evaluated. If invoked outside of
 * a pulse propagation, the operator will be evaluated the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the operator
 * will be queued for evaluation if and only if the operator has not yet been
 * evaluated on the current propagation timestamp.
 * @param {Operator} op - The operator to touch.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function touch(op, options) {
  const opt = options || NO_OPT;

  if (this._pulse) {
    // if in midst of propagation, add to priority queue
    this._enqueue(op);
  } else {
    // otherwise, queue for next propagation
    this._touched.add(op);
  }

  if (opt.skip) op.skip(true);
  return this;
}
/**
 * Updates the value of the given operator.
 * @param {Operator} op - The operator to update.
 * @param {*} value - The value to set.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function update(op, value, options) {
  const opt = options || NO_OPT;

  if (op.set(value) || opt.force) {
    this.touch(op, opt);
  }

  return this;
}
/**
 * Pulses an operator with a changeset of tuples. If invoked outside of
 * a pulse propagation, the pulse will be applied the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the pulse
 * will be added to the set of active pulses and will be applied if and
 * only if the target operator has not yet been evaluated on the current
 * propagation timestamp.
 * @param {Operator} op - The operator to pulse.
 * @param {ChangeSet} value - The tuple changeset to apply.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */

function pulse(op, changeset, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),
        t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset.pulse(p, t);
  return this;
}

function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: x => {
      nodes.push(x);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;

      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }

      return item;
    }
  };
}

function siftdown(array, start, idx, cmp) {
  let parent, pidx;
  const item = array[idx];

  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array[pidx];

    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }

    break;
  }

  return array[idx] = item;
}

function siftup(array, idx, cmp) {
  const start = idx,
        end = array.length,
        item = array[idx];
  let cidx = (idx << 1) + 1,
      ridx;

  while (cidx < end) {
    ridx = cidx + 1;

    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }

    array[idx] = array[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }

  array[idx] = item;
  return siftdown(array, start, idx, cmp);
}

/**
 * A dataflow graph for reactive processing of data streams.
 * @constructor
 */

function Dataflow() {
  this.logger((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.logger)());
  this.logLevel(vega_util__WEBPACK_IMPORTED_MODULE_0__.Error);
  this._clock = 0;
  this._rank = 0;
  this._locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.defaultLocale)();

  try {
    this._loader = (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.loader)();
  } catch (e) {// do nothing if loader module is unavailable
  }

  this._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b) => a.qrank - b.qrank);
  this._postrun = [];
}

function logMethod(method) {
  return function () {
    return this._log[method].apply(this, arguments);
  };
}

Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },

  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },

  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },

  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger) {
    if (arguments.length) {
      this._log = logger;
      return this;
    } else {
      return this._log;
    }
  },

  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod('error'),

  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod('warn'),

  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod('info'),

  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod('debug'),

  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod('level'),

  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};

/**
 * Abstract class for operators that process data tuples.
 * Subclasses must provide a {@link transform} method for operator processing.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {Operator} [source] - The operator from which to receive pulses.
 */

function Transform(init, params) {
  Operator.call(this, init, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;

    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse);
    }

    rv = rv || pulse;

    if (rv.then) {
      rv = rv.then(_ => this.pulse = _);
    } else if (rv !== pulse.StopPropagation) {
      this.pulse = rv;
    }

    return rv;
  },

  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse) {
    const params = this.marshall(pulse.stamp),
          out = this.transform(params, pulse);
    params.clear();
    return out;
  },

  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {}

});

const transforms = {};
function definition(type) {
  const t = transform(type);
  return t && t.Definition || null;
}
function transform(type) {
  type = type && type.toLowerCase();
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(transforms, type) ? transforms[type] : null;
}




/***/ }),

/***/ "./node_modules/vega-encode/build/vega-encode.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-encode/build/vega-encode.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "axisticks": () => (/* binding */ AxisTicks),
/* harmony export */   "datajoin": () => (/* binding */ DataJoin),
/* harmony export */   "encode": () => (/* binding */ Encode),
/* harmony export */   "legendentries": () => (/* binding */ LegendEntries),
/* harmony export */   "linkpath": () => (/* binding */ LinkPath),
/* harmony export */   "pie": () => (/* binding */ Pie),
/* harmony export */   "scale": () => (/* binding */ Scale),
/* harmony export */   "sortitems": () => (/* binding */ SortItems),
/* harmony export */   "stack": () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");






/**
 * Generates axis ticks for visualizing a spatial scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate ticks for.
 * @param {*} [params.count=10] - The approximate number of ticks, or
 *   desired tick interval, to use.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {function(*):string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid d3 4.0 format specifier.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function AxisTicks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(AxisTicks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        ticks = this.value,
        scale = _.scale,
        tally = _.count == null ? _.values ? _.values.length : 10 : _.count,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, tally, _.minstep),
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickFormat)(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),
        values = _.values ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.validTicks)(scale, _.values, count) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickValues)(scale, count);
    if (ticks) out.rem = ticks;
    ticks = values.map((value, i) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
      index: i / (values.length - 1 || 1),
      value: value,
      label: format(value)
    }));

    if (_.extra && ticks.length) {
      // add an extra tick pegged to the initial domain value
      // this is used to generate axes with 'binned' domains
      ticks.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ''
      }));
    }

    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }

});

/**
 * Joins a set of data elements against a set of visual items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): object} [params.item] - An item generator function.
 * @param {function(object): *} [params.key] - The key field associating data and visual items.
 */

function DataJoin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

function defaultItemCreate() {
  return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({});
}

function newMap(key) {
  const map = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)().test(t => t.exit);

  map.lookup = t => map.get(key(t));

  return map;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(DataJoin, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        item = _.item || defaultItemCreate,
        key = _.key || vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid,
        map = this.value; // prevent transient (e.g., hover) requests from
    // cascading across marks derived from marks

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(out.encode)) {
      out.encode = null;
    }

    if (map && (_.modified('key') || pulse.modified(key))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('DataJoin does not support modified key function or fields.');
    }

    if (!map) {
      pulse = pulse.addAll();
      this.value = map = newMap(key);
    }

    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      let x = map.get(k);

      if (x) {
        if (x.exit) {
          map.empty--;
          out.add.push(x);
        } else {
          out.mod.push(x);
        }
      } else {
        x = item(t);
        map.set(k, x);
        out.add.push(x);
      }

      x.datum = t;
      x.exit = false;
    });
    pulse.visit(pulse.MOD, t => {
      const k = key(t),
            x = map.get(k);

      if (x) {
        x.datum = t;
        out.mod.push(x);
      }
    });
    pulse.visit(pulse.REM, t => {
      const k = key(t),
            x = map.get(k);

      if (t === x.datum && !x.exit) {
        out.rem.push(x);
        x.exit = true;
        ++map.empty;
      }
    });
    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');

    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {
      df.runAfter(map.clean);
    }

    return out;
  }

});

/**
 * Invokes encoding functions for visual items.
 * @constructor
 * @param {object} params - The parameters to the encoding functions. This
 *   parameter object will be passed through to all invoked encoding functions.
 * @param {object} [params.mod=false] - Flag indicating if tuples in the input
 *   mod set that are unmodified by encoders should be included in the output.
 * @param {object} param.encoders - The encoding functions
 * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set
 * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set
 * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set
 */

function Encode(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Encode, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ADD_REM),
        fmod = _.mod || false,
        encoders = _.encoders,
        encode = pulse.encode; // if an array, the encode directive includes additional sets
    // that must be defined in order for the primary set to be invoked
    // e.g., only run the update set if the hover set is defined

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(encode)) {
      if (out.changed() || encode.every(e => encoders[e])) {
        encode = encode[0];
        out.encode = null; // consume targeted encode directive
      } else {
        return pulse.StopPropagation;
      }
    } // marshall encoder functions


    var reenter = encode === 'enter',
        update = encoders.update || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        enter = encoders.enter || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        exit = encoders.exit || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
        set = (encode && !reenter ? encoders[encode] : update) || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy;

    if (pulse.changed(pulse.ADD)) {
      pulse.visit(pulse.ADD, t => {
        enter(t, _);
        update(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update.output);

      if (set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy && set !== update) {
        pulse.visit(pulse.ADD, t => {
          set(t, _);
        });
        out.modifies(set.output);
      }
    }

    if (pulse.changed(pulse.REM) && exit !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      pulse.visit(pulse.REM, t => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }

    if (reenter || set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);

      if (reenter) {
        pulse.visit(flag, t => {
          const mod = enter(t, _) || fmod;
          if (set(t, _) || mod) out.mod.push(t);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse.visit(flag, t => {
          if (set(t, _) || fmod) out.mod.push(t);
        });
      }

      if (out.mod.length) out.modifies(set.output);
    }

    return out.changed() ? out : pulse.StopPropagation;
  }

});

/**
 * Generates legend entries for visualizing a scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate items for.
 * @param {*} [params.count=5] - The approximate number of items, or
 *   desired tick interval, to use.
 * @param {*} [params.limit] - The maximum number of entries to
 *   include in a symbol legend.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid D3 format specifier string.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */

function LegendEntries(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LegendEntries, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value != null && !_.modified()) {
      return pulse.StopPropagation;
    }

    var locale = pulse.dataflow.locale(),
        out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        items = this.value,
        type = _.type || vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        scale = _.scale,
        limit = +_.limit,
        count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.count == null ? 5 : _.count, _.minstep),
        lskip = !!_.values || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
        format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFormat)(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),
        values = _.values || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelValues)(scale, count),
        domain,
        fraction,
        size,
        offset,
        ellipsis;
    if (items) out.rem = items;

    if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend) {
      if (limit && values.length > limit) {
        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');
        items = values.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values;
      }

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(size = _.size)) {
        // if first value maps to size zero, remove from list (vega#717)
        if (!_.values && scale(items[0]) === 0) {
          items = items.slice(1);
        } // compute size offset for legend entries


        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);
      } else {
        size = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(offset = size || 8);
      }

      items = items.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, items),
        value: value,
        offset: offset,
        size: size(value, _)
      }));

      if (ellipsis) {
        ellipsis = values[items.length];
        items.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
          index: items.length,
          label: "\u2026".concat(values.length - items.length, " entries"),
          value: ellipsis,
          offset: offset,
          size: size(ellipsis, _)
        }));
      }
    } else if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.GradientLegend) {
      domain = scale.domain(), fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleFraction)(scale, domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)); // if automatic label generation produces 2 or fewer values,
      // use the domain end points instead (fixes vega/vega#1364)

      if (values.length < 3 && !_.values && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
        values = [domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)];
      }

      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: fraction(value)
      }));
    } else {
      size = values.length - 1;
      fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFraction)(scale);
      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: index ? fraction(value) : 0,
        perc2: index === size ? 1 : fraction(values[index + 1])
      }));
    }

    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }

});

const sourceX = t => t.source.x;

const sourceY = t => t.source.y;

const targetX = t => t.target.x;

const targetY = t => t.target.y;
/**
 * Layout paths linking source and target elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */


function LinkPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, {}, params);
}
LinkPath.Definition = {
  'type': 'LinkPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sourceX',
    'type': 'field',
    'default': 'source.x'
  }, {
    'name': 'sourceY',
    'type': 'field',
    'default': 'source.y'
  }, {
    'name': 'targetX',
    'type': 'field',
    'default': 'target.x'
  }, {
    'name': 'targetY',
    'type': 'field',
    'default': 'target.y'
  }, {
    'name': 'orient',
    'type': 'enum',
    'default': 'vertical',
    'values': ['horizontal', 'vertical', 'radial']
  }, {
    'name': 'shape',
    'type': 'enum',
    'default': 'line',
    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']
  }, {
    'name': 'require',
    'type': 'signal'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LinkPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sx = _.sourceX || sourceX,
        sy = _.sourceY || sourceY,
        tx = _.targetX || targetX,
        ty = _.targetY || targetY,
        as = _.as || 'path',
        orient = _.orient || 'vertical',
        shape = _.shape || 'line',
        path = Paths.get(shape + '-' + orient) || Paths.get(shape);

    if (!path) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));
    }

    pulse.visit(pulse.SOURCE, t => {
      t[as] = path(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;

const lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const arc = (sx, sy, tx, ty) => {
  var dx = tx - sx,
      dy = ty - sy,
      rr = Math.sqrt(dx * dx + dy * dy) / 2,
      ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;
};

const arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const curve = (sx, sy, tx, ty) => {
  const dx = tx - sx,
        dy = ty - sy,
        ix = 0.2 * (dx + dy),
        iy = 0.2 * (dy - dx);
  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;
};

const curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));

const orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;

const orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;

const orthoR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;
  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;
};

const diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;
};

const diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;
};

const diagonalR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
        ss = Math.sin(sa),
        tc = Math.cos(ta),
        ts = Math.sin(ta),
        mr = (sr + tr) / 2;
  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;
};

const Paths = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)({
  'line': line,
  'line-radial': lineR,
  'arc': arc,
  'arc-radial': arcR,
  'curve': curve,
  'curve-radial': curveR,
  'orthogonal-horizontal': orthoX,
  'orthogonal-vertical': orthoY,
  'orthogonal-radial': orthoR,
  'diagonal-horizontal': diagonalX,
  'diagonal-vertical': diagonalY,
  'diagonal-radial': diagonalR
});

/**
 * Pie and donut chart layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size pie segments.
 * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.
 * @param {number} [params.endAngle=2] - The end angle (in radians) of the layout.
 * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.
 */

function Pie(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Pie.Definition = {
  'type': 'Pie',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'startAngle',
    'type': 'number',
    'default': 0
  }, {
    'name': 'endAngle',
    'type': 'number',
    'default': 6.283185307179586
  }, {
    'name': 'sort',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['startAngle', 'endAngle']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Pie, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || ['startAngle', 'endAngle'],
        startAngle = as[0],
        endAngle = as[1],
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        start = _.startAngle || 0,
        stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,
        data = pulse.source,
        values = data.map(field),
        n = values.length,
        a = start,
        k = (stop - start) / (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(values),
        index = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(n),
        i,
        t,
        v;

    if (_.sort) {
      index.sort((a, b) => values[a] - values[b]);
    }

    for (i = 0; i < n; ++i) {
      v = values[index[i]];
      t = data[index[i]];
      t[startAngle] = a;
      t[endAngle] = a += v * k;
    }

    this.value = values;
    return pulse.reflow(_.modified()).modifies(as);
  }

});

const DEFAULT_COUNT = 5;

function includeZero(scale) {
  const type = scale.type;
  return !scale.bins && (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt);
}

function includePad(type) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(type) && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential;
}

const SKIP = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.toSet)(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);
/**
 * Maintains a scale function mapping data values to visual channels.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Scale(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Scale, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
        scale$1 = this.value,
        key = scaleKey(_);

    if (!scale$1 || key !== scale$1.type) {
      this.value = scale$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scale)(key)();
    }

    for (key in _) if (!SKIP[key]) {
      // padding is a scale property for band/point but not others
      if (key === 'padding' && includePad(scale$1.type)) continue; // invoke scale property setter, raise warning if not found

      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);
    }

    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function scaleKey(_) {
  var t = _.type,
      d = '',
      n; // backwards compatibility pre Vega 5.

  if (t === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential) return vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' + vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear;

  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' : n === 3 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Diverging + '-' : '';
  }

  return (d + t || vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear).toLowerCase();
}

function isContinuousColor(_) {
  const t = _.type;
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(t) && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Time && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.UTC && (_.scheme || _.range && _.range.length && _.range.every(vega_util__WEBPACK_IMPORTED_MODULE_2__.isString));
}

function configureDomain(scale, _, df) {
  // check raw domain, if provided use that and exit early
  const raw = rawDomain(scale, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain = _.domain,
      type = scale.type,
      zero = _.zero || _.zero === undefined && includeZero(scale),
      n,
      mid;
  if (!domain) return 0; // adjust continuous domain for minimum pixel padding

  if (includePad(type) && _.padding && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);
  } // adjust domain based on zero, min, max settings


  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain = domain.slice()).length - 1 || 1;

    if (zero) {
      if (domain[0] > 0) domain[0] = 0;
      if (domain[n] < 0) domain[n] = 0;
    }

    if (_.domainMin != null) domain[0] = _.domainMin;
    if (_.domainMax != null) domain[n] = _.domainMax;

    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;
      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);
      domain.splice(i, 0, mid);
    }
  } // set the scale domain


  scale.domain(domainCheck(type, domain, df)); // if ordinal scale domain is defined, prevent implicit
  // domain construction as side-effect of scale lookup

  if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal) {
    scale.unknown(_.domainImplicit ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleImplicit : undefined);
  } // perform 'nice' adjustment as requested


  if (_.nice && scale.nice) {
    scale.nice(_.nice !== true && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.nice) || null);
  } // return the cardinality of the domain


  return domain.length;
}

function rawDomain(scale, raw, df) {
  if (raw) {
    scale.domain(domainCheck(scale.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}

function padDomain(type, domain, range, pad, exponent, constant) {
  var span = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(range) - range[0]),
      frac = span / (span - 2 * pad),
      d = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Log ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLog)(domain, null, frac) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, 0.5) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, exponent || 1) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Symlog ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomSymlog)(domain, null, frac, constant || 1) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLinear)(domain, null, frac);
  domain = domain.slice();
  domain[0] = d[0];
  domain[domain.length - 1] = d[1];
  return domain;
}

function domainCheck(type, domain, df) {
  if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isLogarithmic)(type)) {
    // sum signs of domain values
    // if all pos or all neg, abs(sum) === domain.length
    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));

    if (s !== domain.length) {
      df.warn('Log scale domain includes zero: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.stringValue)(domain));
    }
  }

  return domain;
}

function configureBins(scale, _, count) {
  let bins = _.bins;

  if (bins && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(bins)) {
    // generate bin boundary array
    const domain = scale.domain(),
          lo = domain[0],
          hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain),
          step = bins.step;
    let start = bins.start == null ? lo : bins.start,
        stop = bins.stop == null ? hi : bins.stop;
    if (!step) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Scale bins parameter missing step property.');
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop > hi) stop = step * Math.floor(hi / step);
    bins = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(start, stop + step / 2, step);
  }

  if (bins) {
    // assign bin boundaries to scale instance
    scale.bins = bins;
  } else if (scale.bins) {
    // no current bins, remove bins if previously set
    delete scale.bins;
  } // special handling for bin-ordinal scales


  if (scale.type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal) {
    if (!bins) {
      // the domain specifies the bins
      scale.bins = scale.domain();
    } else if (!_.domain && !_.domainRaw) {
      // the bins specify the domain
      scale.domain(bins);
      count = bins.length;
    }
  } // return domain cardinality


  return count;
}

function configureRange(scale, _, count) {
  var type = scale.type,
      round = _.round || false,
      range = _.range; // if range step specified, calculate full range extent

  if (_.rangeStep != null) {
    range = configureRangeStep(type, _, count);
  } // else if a range scheme is defined, use that
  else if (_.scheme) {
      range = configureScheme(type, _, count);

      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(range)) {
        if (scale.interpolator) {
          return scale.interpolator(range);
        } else {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Scale type ".concat(type, " does not support interpolating color schemes."));
        }
      }
    } // given a range array for an interpolating scale, convert to interpolator


  if (range && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type)) {
    return scale.interpolator((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(flip(range, _.reverse), _.interpolate, _.interpolateGamma));
  } // configure rounding / interpolation


  if (range && _.interpolate && scale.interpolate) {
    scale.interpolate((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolate)(_.interpolate, _.interpolateGamma));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.round)) {
    scale.round(round);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.rangeRound)) {
    scale.interpolate(round ? d3_interpolate__WEBPACK_IMPORTED_MODULE_5__.default : d3_interpolate__WEBPACK_IMPORTED_MODULE_6__.default);
  }

  if (range) scale.range(flip(range, _.reverse));
}

function configureRangeStep(type, _, count) {
  if (type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Band && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Only band and point scales support rangeStep.');
  } // calculate full range based on requested step size and padding


  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,
      inner = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.bandSpace)(count, inner, outer)];
}

function configureScheme(type, _, count) {
  var extent = _.schemeExtent,
      name,
      scheme$1;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(_.scheme)) {
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scheme)(name);
    if (!scheme$1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)("Unrecognized scheme name: ".concat(_.scheme));
  } // determine size for potential discrete range


  count = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Threshold ? count + 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal ? count - 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantile || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantize ? +_.schemeCount || DEFAULT_COUNT : count; // adjust and/or quantize scheme as appropriate

  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type) ? adjustScheme(scheme$1, extent, _.reverse) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme$1) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.quantizeInterpolator)(adjustScheme(scheme$1, extent), count) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal ? scheme$1 : scheme$1.slice(0, count);
}

function adjustScheme(scheme, extent, reverse) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme) && (extent || reverse) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateRange)(scheme, flip(extent || [0, 1], reverse)) : scheme;
}

function flip(array, reverse) {
  return reverse ? array.slice().reverse() : array;
}

/**
 * Sorts scenegraph items in the pulse source array.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting tuples.
 */

function SortItems(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(SortItems, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');
    if (mod) pulse.source.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort));
    this.modified(mod);
    return pulse;
  }

});

const Zero = 'zero',
      Center = 'center',
      Normalize = 'normalize',
      DefOutput = ['y0', 'y1'];
/**
 * Stack layout for visualization elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to stack.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.
 * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.
 */

function Stack(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stack.Definition = {
  'type': 'Stack',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'offset',
    'type': 'enum',
    'default': Zero,
    'values': [Zero, Center, Normalize]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': DefOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Stack, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || DefOutput,
        y0 = as[0],
        y1 = as[1],
        sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort),
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
        stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,
        groups,
        i,
        n,
        max; // partition, sum, and sort the stack groups

    groups = partition(pulse.source, _.groupby, sort, field); // compute stack layouts per group

    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {
      stack(groups[i], max, field, y0, y1);
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

});

function stackCenter(group, max, field, y0, y1) {
  var last = (max - group.sum) / 2,
      m = group.length,
      j = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last += Math.abs(field(t));
  }
}

function stackNormalize(group, max, field, y0, y1) {
  var scale = 1 / group.sum,
      last = 0,
      m = group.length,
      j = 0,
      v = 0,
      t;

  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last = scale * (v += Math.abs(field(t)));
  }
}

function stackZero(group, max, field, y0, y1) {
  var lastPos = 0,
      lastNeg = 0,
      m = group.length,
      j = 0,
      v,
      t;

  for (; j < m; ++j) {
    t = group[j];
    v = +field(t);

    if (v < 0) {
      t[y0] = lastNeg;
      t[y1] = lastNeg += v;
    } else {
      t[y0] = lastPos;
      t[y1] = lastPos += v;
    }
  }
}

function partition(data, groupby, sort, field) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      m,
      t,
      k,
      g,
      s,
      max; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        groups.push(g);
      }

      g.push(t);
    }
  } // compute sums of groups, sort groups as needed


  for (k = 0, max = 0, m = groups.length; k < m; ++k) {
    g = groups[k];

    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field(g[i]));
    }

    g.sum = s;
    if (s > max) max = s;
    if (sort) g.sort(sort);
  }

  groups.max = max;
  return groups;
}




/***/ }),

/***/ "./node_modules/vega-event-selector/build/vega-event-selector.module.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vega-event-selector/build/vega-event-selector.module.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parseSelector": () => (/* binding */ eventSelector)
/* harmony export */ });
const VIEW = 'view',
      LBRACK = '[',
      RBRACK = ']',
      LBRACE = '{',
      RBRACE = '}',
      COLON = ':',
      COMMA = ',',
      NAME = '@',
      GT = '>',
      ILLEGAL = /[[\]{}]/,
      DEFAULT_MARKS = {
  '*': 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let DEFAULT_SOURCE, MARKS;
/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */

function eventSelector (selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}

function isMarkType(type) {
  return MARKS[type];
}

function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0,
      c;

  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }

  return i;
}

function parseMerge(s) {
  const output = [],
        n = s.length;
  let start = 0,
      i = 0;

  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }

  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }

  return output;
}

function parseSelector(s) {
  return s[0] === '[' ? parseBetween(s) : parseStream(s);
}

function parseBetween(s) {
  const n = s.length;
  let i = 1,
      b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);

  if (i === n) {
    throw 'Empty between selector: ' + s;
  }

  b = parseMerge(s.substring(1, i));

  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }

  s = s.slice(i + 1).trim();

  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }

  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());

  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }

  return stream;
}

function parseStream(s) {
  const stream = {
    source: DEFAULT_SOURCE
  },
        source = [];
  let throttle = [0, 0],
      markname = 0,
      start = 0,
      n = s.length,
      i = 0,
      j,
      filter; // extract throttle from end

  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);

    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }

      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;

    i = 0;
  }

  if (!n) throw s; // set name flag based on first char

  if (s[0] === NAME) markname = ++i; // extract first part of multi-part stream selector

  j = find(s, i, COLON);

  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  } // extract remaining part of stream selector


  i = find(s, i, LBRACK);

  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  } // extract filters


  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  } // marshall event stream specification


  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {
    throw 'Invalid event selector: ' + s;
  }

  if (n > 1) {
    stream.type = source[1];

    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }

  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }

  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];
  return stream;
}

function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(_ => {
    const x = +_;
    if (x !== x) throw s;
    return x;
  });
}




/***/ }),

/***/ "./node_modules/vega-expression/build/vega-expression.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-expression/build/vega-expression.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASTNode": () => (/* binding */ ASTNode),
/* harmony export */   "ArrayExpression": () => (/* binding */ ArrayExpression),
/* harmony export */   "BinaryExpression": () => (/* binding */ BinaryExpression),
/* harmony export */   "CallExpression": () => (/* binding */ CallExpression),
/* harmony export */   "ConditionalExpression": () => (/* binding */ ConditionalExpression),
/* harmony export */   "Identifier": () => (/* binding */ Identifier),
/* harmony export */   "Literal": () => (/* binding */ Literal),
/* harmony export */   "LogicalExpression": () => (/* binding */ LogicalExpression),
/* harmony export */   "MemberExpression": () => (/* binding */ MemberExpression),
/* harmony export */   "ObjectExpression": () => (/* binding */ ObjectExpression),
/* harmony export */   "Property": () => (/* binding */ Property),
/* harmony export */   "RawCode": () => (/* binding */ RawCode),
/* harmony export */   "UnaryExpression": () => (/* binding */ UnaryExpression),
/* harmony export */   "codegenExpression": () => (/* binding */ codegen),
/* harmony export */   "constants": () => (/* binding */ Constants),
/* harmony export */   "functions": () => (/* binding */ Functions),
/* harmony export */   "parseExpression": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");


const RawCode = 'RawCode';
const Literal = 'Literal';
const Property = 'Property';
const Identifier = 'Identifier';
const ArrayExpression = 'ArrayExpression';
const BinaryExpression = 'BinaryExpression';
const CallExpression = 'CallExpression';
const ConditionalExpression = 'ConditionalExpression';
const LogicalExpression = 'LogicalExpression';
const MemberExpression = 'MemberExpression';
const ObjectExpression = 'ObjectExpression';
const UnaryExpression = 'UnaryExpression';
function ASTNode(type) {
  this.type = type;
}

ASTNode.prototype.visit = function (visitor) {
  let c, i, n;
  if (visitor(this)) return 1;

  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};

function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;

    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];

    case CallExpression:
      return [node.callee].concat(node.arguments);

    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];

    case MemberExpression:
      return [node.object, node.property];

    case ObjectExpression:
      return node.properties;

    case Property:
      return [node.key, node.value];

    case UnaryExpression:
      return [node.argument];

    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}

/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var TokenName, source, index, length, lookahead;
var TokenBooleanLiteral = 1,
    TokenEOF = 2,
    TokenIdentifier = 3,
    TokenKeyword = 4,
    TokenNullLiteral = 5,
    TokenNumericLiteral = 6,
    TokenPunctuator = 7,
    TokenStringLiteral = 8,
    TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = 'Boolean';
TokenName[TokenEOF] = '<end>';
TokenName[TokenIdentifier] = 'Identifier';
TokenName[TokenKeyword] = 'Keyword';
TokenName[TokenNullLiteral] = 'Null';
TokenName[TokenNumericLiteral] = 'Numeric';
TokenName[TokenPunctuator] = 'Punctuator';
TokenName[TokenStringLiteral] = 'String';
TokenName[TokenRegularExpression] = 'RegularExpression';
var SyntaxArrayExpression = 'ArrayExpression',
    SyntaxBinaryExpression = 'BinaryExpression',
    SyntaxCallExpression = 'CallExpression',
    SyntaxConditionalExpression = 'ConditionalExpression',
    SyntaxIdentifier = 'Identifier',
    SyntaxLiteral = 'Literal',
    SyntaxLogicalExpression = 'LogicalExpression',
    SyntaxMemberExpression = 'MemberExpression',
    SyntaxObjectExpression = 'ObjectExpression',
    SyntaxProperty = 'Property',
    SyntaxUnaryExpression = 'UnaryExpression'; // Error messages should be identical to V8.

var MessageUnexpectedToken = 'Unexpected token %0',
    MessageUnexpectedNumber = 'Unexpected number',
    MessageUnexpectedString = 'Unexpected string',
    MessageUnexpectedIdentifier = 'Unexpected identifier',
    MessageUnexpectedReserved = 'Unexpected reserved word',
    MessageUnexpectedEOS = 'Unexpected end of input',
    MessageInvalidRegExp = 'Invalid regular expression',
    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',
    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',
    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';
var ILLEGAL = 'ILLEGAL',
    DISABLED = 'Disabled.'; // See also tools/generate-unicode-regex.py.

var RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),
    // eslint-disable-next-line no-misleading-character-class
RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'); // Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
  /* istanbul ignore next */
  if (!condition) {
    throw new Error('ASSERT: ' + message);
  }
}

function isDecimalDigit(ch) {
  return ch >= 0x30 && ch <= 0x39; // 0..9
}

function isHexDigit(ch) {
  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
}

function isOctalDigit(ch) {
  return '01234567'.indexOf(ch) >= 0;
} // 7.2 White Space


function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;
} // 7.3 Line Terminators


function isLineTerminator(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
} // 7.6 Identifier Names and Identifiers


function isIdentifierStart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}

function isIdentifierPart(ch) {
  return ch === 0x24 || ch === 0x5F || ch >= 0x41 && ch <= 0x5A || ch >= 0x61 && ch <= 0x7A || ch >= 0x30 && ch <= 0x39 || ch === 0x5C || ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
} // 7.6.1.1 Keywords


const keywords = {
  'if': 1,
  'in': 1,
  'do': 1,
  'var': 1,
  'for': 1,
  'new': 1,
  'try': 1,
  'let': 1,
  'this': 1,
  'else': 1,
  'case': 1,
  'void': 1,
  'with': 1,
  'enum': 1,
  'while': 1,
  'break': 1,
  'catch': 1,
  'throw': 1,
  'const': 1,
  'yield': 1,
  'class': 1,
  'super': 1,
  'return': 1,
  'typeof': 1,
  'delete': 1,
  'switch': 1,
  'export': 1,
  'import': 1,
  'public': 1,
  'static': 1,
  'default': 1,
  'finally': 1,
  'extends': 1,
  'package': 1,
  'private': 1,
  'function': 1,
  'continue': 1,
  'debugger': 1,
  'interface': 1,
  'protected': 1,
  'instanceof': 1,
  'implements': 1
};

function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);

    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}

function scanHexEscape(prefix) {
  var i,
      len,
      ch,
      code = 0;
  len = prefix === 'u' ? 4 : 2;

  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  return String.fromCharCode(code);
}

function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0; // At least, one hex digit is required.

  if (ch === '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  while (index < length) {
    ch = source[index++];

    if (!isHexDigit(ch)) {
      break;
    }

    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
  }

  if (code > 0x10FFFF || ch !== '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // UTF-16 Encoding


  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }

  cu1 = (code - 0x10000 >> 10) + 0xD800;
  cu2 = (code - 0x10000 & 1023) + 0xDC00;
  return String.fromCharCode(cu1, cu2);
}

function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

  if (ch === 0x5C) {
    if (source.charCodeAt(index) !== 0x75) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    ++index;
    ch = scanHexEscape('u');

    if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }

    id = ch;
  }

  while (index < length) {
    ch = source.charCodeAt(index);

    if (!isIdentifierPart(ch)) {
      break;
    }

    ++index;
    id += String.fromCharCode(ch); // '\u' (U+005C, U+0075) denotes an escaped character.

    if (ch === 0x5C) {
      id = id.substr(0, id.length - 1);

      if (source.charCodeAt(index) !== 0x75) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      ++index;
      ch = scanHexEscape('u');

      if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }

      id += ch;
    }
  }

  return id;
}

function getIdentifier() {
  var start, ch;
  start = index++;

  while (index < length) {
    ch = source.charCodeAt(index);

    if (ch === 0x5C) {
      // Blackslash (U+005C) marks Unicode escape sequence.
      index = start;
      return getEscapedIdentifier();
    }

    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }

  return source.slice(start, index);
}

function scanIdentifier() {
  var start, id, type;
  start = index; // Backslash (U+005C) starts an escaped character.

  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier(); // There is no keyword or literal with only one character.
  // Thus, it must be an identifier.

  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    // eslint-disable-line no-prototype-builtins
    type = TokenKeyword;
  } else if (id === 'null') {
    type = TokenNullLiteral;
  } else if (id === 'true' || id === 'false') {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }

  return {
    type: type,
    value: id,
    start: start,
    end: index
  };
} // 7.7 Punctuators


function scanPunctuator() {
  var start = index,
      code = source.charCodeAt(index),
      code2,
      ch1 = source[index],
      ch2,
      ch3,
      ch4;

  switch (code) {
    // Check for most common single-character punctuators.
    case 0x2E: // . dot

    case 0x28: // ( open bracket

    case 0x29: // ) close bracket

    case 0x3B: // ; semicolon

    case 0x2C: // , comma

    case 0x7B: // { open curly brace

    case 0x7D: // } close curly brace

    case 0x5B: // [

    case 0x5D: // ]

    case 0x3A: // :

    case 0x3F: // ?

    case 0x7E:
      // ~
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start: start,
        end: index
      };

    default:
      code2 = source.charCodeAt(index + 1); // '=' (U+003D) marks an assignment or comparison operator.

      if (code2 === 0x3D) {
        switch (code) {
          case 0x2B: // +

          case 0x2D: // -

          case 0x2F: // /

          case 0x3C: // <

          case 0x3E: // >

          case 0x5E: // ^

          case 0x7C: // |

          case 0x25: // %

          case 0x26: // &

          case 0x2A:
            // *
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start: start,
              end: index
            };

          case 0x21: // !

          case 0x3D:
            // =
            index += 2; // !== and ===

            if (source.charCodeAt(index) === 0x3D) {
              ++index;
            }

            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start: start,
              end: index
            };
        }
      }

  } // 4-character punctuator: >>>=


  ch4 = source.substr(index, 4);

  if (ch4 === '>>>=') {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start: start,
      end: index
    };
  } // 3-character punctuators: === !== >>> <<= >>=


  ch3 = ch4.substr(0, 3);

  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start: start,
      end: index
    };
  } // Other 2-character punctuators: ++ -- << >> && ||


  ch2 = ch3.substr(0, 2);

  if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start: start,
      end: index
    };
  }

  if (ch2 === '//') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  } // 1-character punctuators: < > = ! + - * % & | ^ /


  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start: start,
      end: index
    };
  }

  throwError({}, MessageUnexpectedToken, ILLEGAL);
} // 7.8.3 Numeric Literals


function scanHexLiteral(start) {
  let number = '';

  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt('0x' + number, 16),
    start: start,
    end: index
  };
}

function scanOctalLiteral(start) {
  let number = '0' + source[index++];

  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }

    number += source[index++];
  }

  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start: start,
    end: index
  };
}

function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
  start = index;
  number = '';

  if (ch !== '.') {
    number = source[index++];
    ch = source[index]; // Hex number starts with '0x'.
    // Octal number starts with '0'.

    if (number === '0') {
      if (ch === 'x' || ch === 'X') {
        ++index;
        return scanHexLiteral(start);
      }

      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      } // decimal number starts with '0' such as '09' is illegal.


      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === '.') {
    number += source[index++];

    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }

    ch = source[index];
  }

  if (ch === 'e' || ch === 'E') {
    number += source[index++];
    ch = source[index];

    if (ch === '+' || ch === '-') {
      number += source[index++];
    }

    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }

  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start: start,
    end: index
  };
} // 7.8.4 String Literals


function scanStringLiteral() {
  var str = '',
      quote,
      start,
      ch,
      code,
      octal = false;
  quote = source[index];
  assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
  start = index;
  ++index;

  while (index < length) {
    ch = source[index++];

    if (ch === quote) {
      quote = '';
      break;
    } else if (ch === '\\') {
      ch = source[index++];

      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case 'u':
          case 'x':
            if (source[index] === '{') {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }

            break;

          case 'n':
            str += '\n';
            break;

          case 'r':
            str += '\r';
            break;

          case 't':
            str += '\t';
            break;

          case 'b':
            str += '\b';
            break;

          case 'f':
            str += '\f';
            break;

          case 'v':
            str += '\x0B';
            break;

          default:
            if (isOctalDigit(ch)) {
              code = '01234567'.indexOf(ch); // \0 is not octal escape sequence

              if (code !== 0) {
                octal = true;
              }

              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]); // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3

                if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + '01234567'.indexOf(source[index++]);
                }
              }

              str += String.fromCharCode(code);
            } else {
              str += ch;
            }

            break;
        }
      } else {
        if (ch === '\r' && source[index] === '\n') {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }

  if (quote !== '') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  return {
    type: TokenStringLiteral,
    value: str,
    octal: octal,
    start: start,
    end: index
  };
}

function testRegExp(pattern, flags) {
  let tmp = pattern;

  if (flags.indexOf('u') >= 0) {
    // Replace each astral symbol and every Unicode code point
    // escape sequence with a single ASCII symbol to avoid throwing on
    // regular expressions that are only valid in combination with the
    // `/u` flag.
    // Note: replacing with the ASCII symbol `x` might cause false
    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
    // perfectly valid pattern that is equivalent to `[a-b]`, but it
    // would be replaced by `[x-b]` which throws an error.
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 0x10FFFF) {
        return 'x';
      }

      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
  } // First, detect invalid regular expressions.


  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  } // Return a regular expression object for this pattern-flag pair, or
  // `null` in case the current environment doesn't support the flags it
  // uses.


  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}

function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === '/', 'Regular expression literal must start with a slash');
  str = source[index++];
  classMarker = false;
  terminated = false;

  while (index < length) {
    ch = source[index++];
    str += ch;

    if (ch === '\\') {
      ch = source[index++]; // ECMA-262 7.8.5

      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }

      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === ']') {
        classMarker = false;
      }
    } else {
      if (ch === '/') {
        terminated = true;
        break;
      } else if (ch === '[') {
        classMarker = true;
      }
    }
  }

  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  } // Exclude leading and trailing slash.


  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}

function scanRegExpFlags() {
  var ch, str, flags;
  str = '';
  flags = '';

  while (index < length) {
    ch = source[index];

    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }

    ++index;

    if (ch === '\\' && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch;
      str += ch;
    }
  }

  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }

  return {
    value: flags,
    literal: str
  };
}

function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start: start,
    end: index
  };
}

function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}

function advance() {
  skipComment();

  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }

  const ch = source.charCodeAt(index);

  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  } // Very common: ( and ) and ;


  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
    return scanPunctuator();
  } // String literal starts with single quote (U+0027) or double quote (U+0022).


  if (ch === 0x27 || ch === 0x22) {
    return scanStringLiteral();
  } // Dot (.) U+002E can also start a floating-point number, hence the need
  // to check the next character.


  if (ch === 0x2E) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }

    return scanPunctuator();
  }

  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }

  return scanPunctuator();
}

function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}

function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}

function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}

function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}

function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}

function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}

function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}

function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);

  if (token.regex) {
    if (node.raw === '//') {
      node.raw = '/(?:)/';
    }

    node.regex = token.regex;
  }

  return node;
}

function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === '[';
  node.object = object;
  node.property = property;
  if (!node.computed) property.member = true;
  return node;
}

function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}

function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}

function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
} // Throw an exception


function throwError(token, messageFormat) {
  var error,
      args = Array.prototype.slice.call(arguments, 2),
      msg = messageFormat.replace(/%(\d)/g, (whole, index) => {
    assert(index < args.length, 'Message reference must be in range');
    return args[index];
  });
  error = new Error(msg);
  error.index = index;
  error.description = msg;
  throw error;
} // Throw an exception because of the token.


function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }

  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }

  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }

  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }

  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  } // BooleanLiteral, NullLiteral, or Punctuator.


  throwError(token, MessageUnexpectedToken, token.value);
} // Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.


function expect(value) {
  const token = lex();

  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
} // Return true if the next token matches the specified punctuator.


function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
} // Return true if the next token matches the specified keyword


function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
} // 11.1.4 Array Initialiser


function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect('[');

  while (!match(']')) {
    if (match(',')) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());

      if (!match(']')) {
        expect(',');
      }
    }
  }

  lex();
  return finishArrayExpression(elements);
} // 11.1.5 Object Initialiser


function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex(); // Note: This function is called only from parseObjectProperty(), where
  // EOF and Punctuator tokens are already filtered out.

  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }

    return finishLiteral(token);
  }

  return finishIdentifier(token.value);
}

function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;

  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', id, value);
  }

  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', key, value);
  }
}

function parseObjectInitialiser() {
  var properties = [],
      property,
      name,
      key,
      map = {},
      toString = String;
  index = lookahead.start;
  expect('{');

  while (!match('}')) {
    property = parseObjectProperty();

    if (property.key.type === SyntaxIdentifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }

    key = '$' + name;

    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }

    properties.push(property);

    if (!match('}')) {
      expect(',');
    }
  }

  expect('}');
  return finishObjectExpression(properties);
} // 11.1.6 The Grouping Operator


function parseGroupExpression() {
  expect('(');
  const expr = parseExpression();
  expect(')');
  return expr;
} // 11.1 Primary Expressions


const legalKeywords = {
  'if': 1
};

function parsePrimaryExpression() {
  var type, token, expr;

  if (match('(')) {
    return parseGroupExpression();
  }

  if (match('[')) {
    return parseArrayInitialiser();
  }

  if (match('{')) {
    return parseObjectInitialiser();
  }

  type = lookahead.type;
  index = lookahead.start;

  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }

    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === 'true';
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match('/') || match('/=')) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }

  return expr;
} // 11.2 Left-Hand-Side Expressions


function parseArguments() {
  const args = [];
  expect('(');

  if (!match(')')) {
    while (index < length) {
      args.push(parseConditionalExpression());

      if (match(')')) {
        break;
      }

      expect(',');
    }
  }

  expect(')');
  return args;
}

function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();

  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }

  return finishIdentifier(token.value);
}

function parseNonComputedMember() {
  expect('.');
  return parseNonComputedProperty();
}

function parseComputedMember() {
  expect('[');
  const expr = parseExpression();
  expect(']');
  return expr;
}

function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();

  for (;;) {
    if (match('.')) {
      property = parseNonComputedMember();
      expr = finishMemberExpression('.', expr, property);
    } else if (match('(')) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match('[')) {
      property = parseComputedMember();
      expr = finishMemberExpression('[', expr, property);
    } else {
      break;
    }
  }

  return expr;
} // 11.3 Postfix Expressions


function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();

  if (lookahead.type === TokenPunctuator) {
    if (match('++') || match('--')) {
      throw new Error(DISABLED);
    }
  }

  return expr;
} // 11.4 Unary Operators


function parseUnaryExpression() {
  var token, expr;

  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match('++') || match('--')) {
    throw new Error(DISABLED);
  } else if (match('+') || match('-') || match('~') || match('!')) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }

  return expr;
}

function binaryPrecedence(token) {
  let prec = 0;

  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }

  switch (token.value) {
    case '||':
      prec = 1;
      break;

    case '&&':
      prec = 2;
      break;

    case '|':
      prec = 3;
      break;

    case '^':
      prec = 4;
      break;

    case '&':
      prec = 5;
      break;

    case '==':
    case '!=':
    case '===':
    case '!==':
      prec = 6;
      break;

    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      prec = 7;
      break;

    case '<<':
    case '>>':
    case '>>>':
      prec = 8;
      break;

    case '+':
    case '-':
      prec = 9;
      break;

    case '*':
    case '/':
    case '%':
      prec = 11;
      break;
  }

  return prec;
} // 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators


function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);

  if (prec === 0) {
    return left;
  }

  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];

  while ((prec = binaryPrecedence(lookahead)) > 0) {
    // Reduce: make a binary expression from the three topmost entries.
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack.push(expr);
    } // Shift.


    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  } // Final reduce to clean-up the stack.


  i = stack.length - 1;
  expr = stack[i];
  markers.pop();

  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
  }

  return expr;
} // 11.12 Conditional Operator


function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();

  if (match('?')) {
    lex();
    consequent = parseConditionalExpression();
    expect(':');
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }

  return expr;
} // 11.14 Comma Operator


function parseExpression() {
  const expr = parseConditionalExpression();

  if (match(',')) {
    throw new Error(DISABLED); // no sequence expressions
  }

  return expr;
}

function parser (code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();

  if (lookahead.type !== TokenEOF) {
    throw new Error('Unexpect token after expression.');
  }

  return expr;
}

var Constants = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE'
};

function Functions (codegen) {
  function fncall(name, args, cast, type) {
    let obj = codegen(args[0]);

    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }

    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');
  }

  function fn(name, cast, type) {
    return args => fncall(name, args, cast, type);
  }

  const DATE = 'new Date',
        STRING = 'String',
        REGEXP = 'RegExp';
  return {
    // MATH functions
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to clamp function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to clamp function.');
      const a = args.map(codegen);
      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';
    },
    // DATE functions
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: DATE,
    date: fn('getDate', DATE, 0),
    day: fn('getDay', DATE, 0),
    year: fn('getFullYear', DATE, 0),
    month: fn('getMonth', DATE, 0),
    hours: fn('getHours', DATE, 0),
    minutes: fn('getMinutes', DATE, 0),
    seconds: fn('getSeconds', DATE, 0),
    milliseconds: fn('getMilliseconds', DATE, 0),
    time: fn('getTime', DATE, 0),
    timezoneoffset: fn('getTimezoneOffset', DATE, 0),
    utcdate: fn('getUTCDate', DATE, 0),
    utcday: fn('getUTCDay', DATE, 0),
    utcyear: fn('getUTCFullYear', DATE, 0),
    utcmonth: fn('getUTCMonth', DATE, 0),
    utchours: fn('getUTCHours', DATE, 0),
    utcminutes: fn('getUTCMinutes', DATE, 0),
    utcseconds: fn('getUTCSeconds', DATE, 0),
    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),
    // sequence functions
    length: fn('length', null, -1),
    // STRING functions
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: fn('toUpperCase', STRING, 0),
    lower: fn('toLowerCase', STRING, 0),
    substring: fn('substring', STRING),
    split: fn('split', STRING),
    trim: fn('trim', STRING, 0),
    // REGEXP functions
    regexp: REGEXP,
    test: fn('test', REGEXP),
    // Control Flow functions
    if: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to if function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to if function.');
      const a = args.map(codegen);
      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';
    }
  };
}

function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === '\'' && s[n] === '\'') ? s.slice(1, -1) : s;
}

function codegen (opt) {
  opt = opt || {};
  const allowed = opt.allowed ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.allowed) : {},
        forbidden = opt.forbidden ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.forbidden) : {},
        constants = opt.constants || Constants,
        functions = (opt.functions || Functions)(visit),
        globalvar = opt.globalvar,
        fieldvar = opt.fieldvar,
        outputGlobal = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(globalvar) ? globalvar : id => `${globalvar}["${id}"]`;
  let globals = {},
      fields = {},
      memberDepth = 0;

  function visit(ast) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported type: ' + ast.type);
    return generator(ast);
  }

  const Generators = {
    Literal: n => n.raw,
    Identifier: n => {
      const id = n.name;

      if (memberDepth > 0) {
        return id;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(forbidden, id)) {
        return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal identifier: ' + id);
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(constants, id)) {
        return constants[id];
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(allowed, id)) {
        return id;
      } else {
        globals[id] = 1;
        return outputGlobal(id);
      }
    },
    MemberExpression: n => {
      const d = !n.computed,
            o = visit(n.object);
      if (d) memberDepth += 1;
      const p = visit(n.property);

      if (o === fieldvar) {
        // strip quotes to sanitize field name (#1653)
        fields[stripQuotes(p)] = 1;
      }

      if (d) memberDepth -= 1;
      return o + (d ? '.' + p : '[' + p + ']');
    },
    CallExpression: n => {
      if (n.callee.type !== 'Identifier') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal callee type: ' + n.callee.type);
      }

      const callee = n.callee.name,
            args = n.arguments,
            fn = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(functions, callee) && functions[callee];
      if (!fn) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized function: ' + callee);
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';
    },
    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',
    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',
    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',
    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',
    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',
    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',
    Property: n => {
      memberDepth += 1;
      const k = visit(n.key);
      memberDepth -= 1;
      return k + ':' + visit(n.value);
    }
  };

  function codegen(ast) {
    const result = {
      code: visit(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }

  codegen.functions = functions;
  codegen.constants = constants;
  return codegen;
}




/***/ }),

/***/ "./node_modules/vega-force/build/vega-force.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-force/build/vega-force.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "force": () => (/* binding */ Force)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");




const ForceMap = {
  center: d3_force__WEBPACK_IMPORTED_MODULE_2__.default,
  collide: d3_force__WEBPACK_IMPORTED_MODULE_3__.default,
  nbody: d3_force__WEBPACK_IMPORTED_MODULE_4__.default,
  link: d3_force__WEBPACK_IMPORTED_MODULE_5__.default,
  x: d3_force__WEBPACK_IMPORTED_MODULE_6__.default,
  y: d3_force__WEBPACK_IMPORTED_MODULE_7__.default
};
const Forces = 'forces',
      ForceParams = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],
      ForceConfig = ['static', 'iterations'],
      ForceOutput = ['x', 'y', 'vx', 'vy'];
/**
 * Force simulation layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<object>} params.forces - The forces to apply.
 */

function Force(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Force.Definition = {
  'type': 'Force',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'static',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'restart',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'iterations',
    'type': 'number',
    'default': 300
  }, {
    'name': 'alpha',
    'type': 'number',
    'default': 1
  }, {
    'name': 'alphaMin',
    'type': 'number',
    'default': 0.001
  }, {
    'name': 'alphaTarget',
    'type': 'number',
    'default': 0
  }, {
    'name': 'velocityDecay',
    'type': 'number',
    'default': 0.4
  }, {
    'name': 'forces',
    'type': 'param',
    'array': true,
    'params': [{
      'key': {
        'force': 'center'
      },
      'params': [{
        'name': 'x',
        'type': 'number',
        'default': 0
      }, {
        'name': 'y',
        'type': 'number',
        'default': 0
      }]
    }, {
      'key': {
        'force': 'collide'
      },
      'params': [{
        'name': 'radius',
        'type': 'number',
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'default': 0.7
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'nbody'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': -30
      }, {
        'name': 'theta',
        'type': 'number',
        'default': 0.9
      }, {
        'name': 'distanceMin',
        'type': 'number',
        'default': 1
      }, {
        'name': 'distanceMax',
        'type': 'number'
      }]
    }, {
      'key': {
        'force': 'link'
      },
      'params': [{
        'name': 'links',
        'type': 'data'
      }, {
        'name': 'id',
        'type': 'field'
      }, {
        'name': 'distance',
        'type': 'number',
        'default': 30,
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'expr': true
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'x'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'x',
        'type': 'field'
      }]
    }, {
      'key': {
        'force': 'y'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'y',
        'type': 'field'
      }]
    }]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'modify': false,
    'default': ForceOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Force, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sim = this.value,
        change = pulse.changed(pulse.ADD_REM),
        params = _.modified(ForceParams),
        iters = _.iterations || 300; // configure simulation


    if (!sim) {
      this.value = sim = simulation(pulse.source, _);
      sim.on('tick', rerun(pulse.dataflow, this));

      if (!_.static) {
        change = true;
        sim.tick(); // ensure we run on init
      }

      pulse.modifies('index');
    } else {
      if (change) {
        pulse.modifies('index');
        sim.nodes(pulse.source);
      }

      if (params || pulse.changed(pulse.MOD)) {
        setup(sim, _, 0, pulse);
      }
    } // run simulation


    if (params || change || _.modified(ForceConfig) || pulse.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));

      if (_.static) {
        for (sim.stop(); --iters >= 0;) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change) return pulse.StopPropagation; // defer to sim ticks
      }
    }

    return this.finish(_, pulse);
  },

  finish(_, pulse) {
    const dataflow = pulse.dataflow; // inspect dependencies, touch link source data

    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];

      if (arg.name !== Forces || arg.op._argval.force !== 'link') {
        continue;
      }

      for (var ops = arg.op._argops, i = 0, n = ops.length, op; i < n; ++i) {
        if (ops[i].name === 'links' && (op = ops[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    } // reflow all nodes


    return pulse.reflow(_.modified()).modifies(ForceOutput);
  }

});

function rerun(df, op) {
  return () => df.touch(op).run();
}

function simulation(nodes, _) {
  const sim = (0,d3_force__WEBPACK_IMPORTED_MODULE_8__.default)(nodes),
        stop = sim.stop,
        restart = sim.restart;
  let stopped = false;

  sim.stopped = () => stopped;

  sim.restart = () => (stopped = false, restart());

  sim.stop = () => (stopped = true, stop());

  return setup(sim, _, true).on('end', () => stopped = true);
}

function setup(sim, _, init, pulse) {
  var f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.forces),
      i,
      n,
      p,
      name;

  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }

  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init || _.modified(Forces, i) ? getForce(f[i]) : pulse && modified(f[i], pulse) ? sim.force(name) : null;
    if (p) sim.force(name, p);
  }

  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null); // remove
  }

  sim.numForces = f.length;
  return sim;
}

function modified(f, pulse) {
  var k, v;

  for (k in f) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v = f[k]) && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(v))) return 1;
  }

  return 0;
}

function getForce(_) {
  var f, p;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(ForceMap, _.force)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized force: ' + _.force);
  }

  f = ForceMap[_.force]();

  for (p in _) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f[p])) setForceParam(f[p], _[p], _);
  }

  return f;
}

function setForceParam(f, v, _) {
  f((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v) ? d => v(d, _) : v);
}




/***/ }),

/***/ "./node_modules/vega-format/build/vega-format.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-format/build/vega-format.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultLocale": () => (/* binding */ defaultLocale),
/* harmony export */   "locale": () => (/* binding */ locale),
/* harmony export */   "numberFormatDefaultLocale": () => (/* binding */ numberFormatDefaultLocale),
/* harmony export */   "numberFormatLocale": () => (/* binding */ numberFormatLocale),
/* harmony export */   "resetDefaultLocale": () => (/* binding */ resetDefaultLocale),
/* harmony export */   "resetNumberFormatDefaultLocale": () => (/* binding */ resetNumberFormatDefaultLocale),
/* harmony export */   "resetTimeFormatDefaultLocale": () => (/* binding */ resetTimeFormatDefaultLocale),
/* harmony export */   "timeFormatDefaultLocale": () => (/* binding */ timeFormatDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* binding */ timeFormatLocale)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/locale.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/locale.js");






function memoize (method) {
  const cache = {};
  return spec => cache[spec] || (cache[spec] = method(spec));
}

function trimZeroes(numberFormat, decimalChar) {
  return x => {
    const str = numberFormat(x),
          dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : '';

    while (--idx > dec) if (str[idx] !== '0') {
      ++idx;
      break;
    }

    return str.slice(0, idx) + end;
  };
}

function rightmostDigit(str, dec) {
  let i = str.lastIndexOf('e'),
      c;
  if (i > 0) return i;

  for (i = str.length; --i > dec;) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57) return i + 1; // is digit
  }
}

function numberLocale(locale) {
  const format = memoize(locale.format),
        formatPrefix = locale.formatPrefix;
  return {
    format,
    formatPrefix,

    formatFloat(spec) {
      const s = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(spec || ',');

      if (s.precision == null) {
        s.precision = 12;

        switch (s.type) {
          case '%':
            s.precision -= 2;
            break;

          case 'e':
            s.precision -= 1;
            break;
        }

        return trimZeroes(format(s), // number format
        format('.1f')(1)[1] // decimal point character
        );
      } else {
        return format(s);
      }
    },

    formatSpan(start, stop, count, specifier) {
      specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__.default)(specifier == null ? ',f' : specifier);
      const step = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count),
            value = Math.max(Math.abs(start), Math.abs(stop));
      let precision;

      if (specifier.precision == null) {
        switch (specifier.type) {
          case 's':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__.default)(step, value))) {
                specifier.precision = precision;
              }

              return formatPrefix(specifier, value);
            }

          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__.default)(step, value))) {
                specifier.precision = precision - (specifier.type === 'e');
              }

              break;
            }

          case 'f':
          case '%':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_6__.default)(step))) {
                specifier.precision = precision - (specifier.type === '%') * 2;
              }

              break;
            }
        }
      }

      return format(specifier);
    }

  };
}

let defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: d3_format__WEBPACK_IMPORTED_MODULE_7__.format,
    formatPrefix: d3_format__WEBPACK_IMPORTED_MODULE_7__.formatPrefix
  });
}
function numberFormatLocale(definition) {
  return numberLocale((0,d3_format__WEBPACK_IMPORTED_MODULE_8__.default)(definition));
}
function numberFormatDefaultLocale(definition) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition) : defaultNumberLocale;
}

function timeMultiFormat(format, interval, spec) {
  spec = spec || {};

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)("Invalid time multi-format specifier: ".concat(spec));
  }

  const second = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS),
        minute = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES),
        hour = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS),
        day = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE),
        week = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK),
        month = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH),
        quarter = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER),
        year = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR),
        L = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS] || '.%L'),
        S = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS] || ':%S'),
        M = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES] || '%I:%M'),
        H = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS] || '%I %p'),
        d = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE] || spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DAY] || '%a %d'),
        w = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK] || '%b %d'),
        m = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH] || '%B'),
        q = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER] || '%B'),
        y = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR] || '%Y');
  return date => (second(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week(date) < date ? d : w : year(date) < date ? quarter(date) < date ? m : q : y)(date);
}

function timeLocale(locale) {
  const timeFormat = memoize(locale.format),
        utcFormat = memoize(locale.utcFormat);
  return {
    timeFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? timeFormat(spec) : timeMultiFormat(timeFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.timeInterval, spec),
    utcFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? utcFormat(spec) : timeMultiFormat(utcFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.utcInterval, spec),
    timeParse: memoize(locale.parse),
    utcParse: memoize(locale.utcParse)
  };
}

let defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeFormat,
    parse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeParse,
    utcFormat: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcFormat,
    utcParse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcParse
  });
}
function timeFormatLocale(definition) {
  return timeLocale((0,d3_time_format__WEBPACK_IMPORTED_MODULE_10__.default)(definition));
}
function timeFormatDefaultLocale(definition) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition) : defaultTimeLocale;
}

const createLocale = (number, time) => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, number, time);

function locale(numberSpec, timeSpec) {
  const number = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number, time);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;

  if (args && args !== 2) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('defaultLocale expects either zero or two arguments.');
  }

  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}




/***/ }),

/***/ "./node_modules/vega-functions/build/vega-functions.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-functions/build/vega-functions.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataPrefix": () => (/* binding */ DataPrefix),
/* harmony export */   "IndexPrefix": () => (/* binding */ IndexPrefix),
/* harmony export */   "ScalePrefix": () => (/* binding */ ScalePrefix),
/* harmony export */   "SignalPrefix": () => (/* binding */ SignalPrefix),
/* harmony export */   "bandspace": () => (/* binding */ bandspace),
/* harmony export */   "bandwidth": () => (/* binding */ bandwidth),
/* harmony export */   "codeGenerator": () => (/* binding */ codeGenerator),
/* harmony export */   "codegenParams": () => (/* binding */ codegenParams),
/* harmony export */   "containerSize": () => (/* binding */ containerSize),
/* harmony export */   "contrast": () => (/* binding */ contrast),
/* harmony export */   "copy": () => (/* binding */ copy),
/* harmony export */   "data": () => (/* binding */ data),
/* harmony export */   "dataVisitor": () => (/* binding */ dataVisitor),
/* harmony export */   "dayAbbrevFormat": () => (/* binding */ dayAbbrevFormat),
/* harmony export */   "dayFormat": () => (/* binding */ dayFormat),
/* harmony export */   "debug": () => (/* binding */ debug),
/* harmony export */   "domain": () => (/* binding */ domain),
/* harmony export */   "encode": () => (/* binding */ encode),
/* harmony export */   "expressionFunction": () => (/* binding */ expressionFunction),
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "functionContext": () => (/* binding */ functionContext),
/* harmony export */   "geoArea": () => (/* binding */ geoArea),
/* harmony export */   "geoBounds": () => (/* binding */ geoBounds),
/* harmony export */   "geoCentroid": () => (/* binding */ geoCentroid),
/* harmony export */   "geoShape": () => (/* binding */ geoShape),
/* harmony export */   "inScope": () => (/* binding */ inScope),
/* harmony export */   "indata": () => (/* binding */ indata),
/* harmony export */   "indataVisitor": () => (/* binding */ indataVisitor),
/* harmony export */   "indexof": () => (/* binding */ indexof),
/* harmony export */   "info": () => (/* binding */ info),
/* harmony export */   "invert": () => (/* binding */ invert),
/* harmony export */   "join": () => (/* binding */ join),
/* harmony export */   "lastindexof": () => (/* binding */ lastindexof),
/* harmony export */   "luminance": () => (/* binding */ luminance),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "modify": () => (/* binding */ modify),
/* harmony export */   "monthAbbrevFormat": () => (/* binding */ monthAbbrevFormat),
/* harmony export */   "monthFormat": () => (/* binding */ monthFormat),
/* harmony export */   "parseExpression": () => (/* binding */ parser),
/* harmony export */   "pathShape": () => (/* binding */ pathShape),
/* harmony export */   "pinchAngle": () => (/* binding */ pinchAngle),
/* harmony export */   "pinchDistance": () => (/* binding */ pinchDistance),
/* harmony export */   "pluck": () => (/* binding */ pluck),
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "replace": () => (/* binding */ replace),
/* harmony export */   "reverse": () => (/* binding */ reverse),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleGradient": () => (/* binding */ scaleGradient),
/* harmony export */   "scaleVisitor": () => (/* binding */ scaleVisitor),
/* harmony export */   "screen": () => (/* binding */ screen),
/* harmony export */   "setdata": () => (/* binding */ setdata),
/* harmony export */   "slice": () => (/* binding */ slice),
/* harmony export */   "timeFormat": () => (/* binding */ timeFormat),
/* harmony export */   "timeParse": () => (/* binding */ timeParse),
/* harmony export */   "treeAncestors": () => (/* binding */ treeAncestors),
/* harmony export */   "treePath": () => (/* binding */ treePath),
/* harmony export */   "utcFormat": () => (/* binding */ utcFormat),
/* harmony export */   "utcParse": () => (/* binding */ utcParse),
/* harmony export */   "warn": () => (/* binding */ warn),
/* harmony export */   "windowSize": () => (/* binding */ windowSize)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/bounds.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_selections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-selections */ "./node_modules/vega-selections/build/vega-selection.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");












function data(name) {
  const data = this.context.data[name];
  return data ? data.values.value : [];
}
function indata(name, field, value) {
  const index = this.context.data[name]['index:' + field],
        entry = index ? index.value.get(value) : undefined;
  return entry ? entry.count : entry;
}
function setdata(name, tuples) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input;
  df.pulse(input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(tuples));
  return 1;
}

function encode (item, name, retval) {
  if (item) {
    const df = this.context.dataflow,
          target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name));
  }

  return retval !== undefined ? retval : item;
}

const wrap = method => function (value, spec) {
  const locale = this.context.dataflow.locale();
  return locale[method](spec)(value);
};

const format = wrap('format');
const timeFormat = wrap('timeFormat');
const utcFormat = wrap('utcFormat');
const timeParse = wrap('timeParse');
const utcParse = wrap('utcParse');
const dateObj = new Date(2000, 0, 1);

function time(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';
  dateObj.setYear(2000);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat.call(this, dateObj, specifier);
}

function monthFormat(month) {
  return time.call(this, month, 1, '%B');
}
function monthAbbrevFormat(month) {
  return time.call(this, month, 1, '%b');
}
function dayFormat(day) {
  return time.call(this, 0, 2 + day, '%A');
}
function dayAbbrevFormat(day) {
  return time.call(this, 0, 2 + day, '%a');
}

const DataPrefix = ':';
const IndexPrefix = '@';
const ScalePrefix = '%';
const SignalPrefix = '$';

function dataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to data functions must be a string literal.');
  }

  const data = args[0].value,
        dataName = DataPrefix + data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(dataName, params)) {
    try {
      params[dataName] = scope.getData(data).tuplesRef();
    } catch (err) {// if data set does not exist, there's nothing to track
    }
  }
}
function indataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to indata must be a string literal.');
  if (args[1].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to indata must be a string literal.');
  const data = args[0].value,
        field = args[1].value,
        indexName = IndexPrefix + field;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(indexName, params)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  }
}
function scaleVisitor(name, args, scope, params) {
  if (args[0].type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    // add scale dependency
    addScaleDependency(scope, params, args[0].value);
  } else {
    // indirect scale lookup; add all scales as parameters
    for (name in scope.scales) {
      addScaleDependency(scope, params, name);
    }
  }
}

function addScaleDependency(scope, params, name) {
  const scaleName = ScalePrefix + name;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, scaleName)) {
    try {
      params[scaleName] = scope.scaleRef(name);
    } catch (err) {// TODO: error handling? warning?
    }
  }
}

function getScale(name, ctx) {
  let s;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(name) ? name : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(name) ? (s = ctx.scales[name]) && s.value : undefined;
}
function internalScaleFunctions(codegen, fnctx, visitors) {
  // add helper method to the 'this' expression function context
  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0; // register AST visitors for internal scale functions


  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor; // resolve scale reference directly to the signal hash argument

  const ref = arg => '_[' + (arg.type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix + arg.value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix) + '+' + codegen(arg)) + ']'; // define and return internal scale function code generators
  // these internal functions are called by mark encoders


  return {
    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,
    _range: args => `${ref(args[0])}.range()`,
    _scale: args => `${ref(args[0])}(${codegen(args[1])})`
  };
}

function geoMethod(methodName, globalMethod) {
  return function (projection, geojson, group) {
    if (projection) {
      // projection defined, use it
      const p = getScale(projection, (group || this).context);
      return p && p.path[methodName](geojson);
    } else {
      // projection undefined, use global method
      return globalMethod(geojson);
    }
  };
}

const geoArea = geoMethod('area', d3_geo__WEBPACK_IMPORTED_MODULE_8__.default);
const geoBounds = geoMethod('bounds', d3_geo__WEBPACK_IMPORTED_MODULE_9__.default);
const geoCentroid = geoMethod('centroid', d3_geo__WEBPACK_IMPORTED_MODULE_10__.default);

function inScope (item) {
  const group = this.context.group;
  let value = false;
  if (group) while (item) {
    if (item === group) {
      value = true;
      break;
    }

    item = item.mark.group;
  }
  return value;
}

function log(df, method, args) {
  try {
    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }

  return args[args.length - 1];
}

function warn() {
  return log(this.context.dataflow, 'warn', arguments);
}
function info() {
  return log(this.context.dataflow, 'info', arguments);
}
function debug() {
  return log(this.context.dataflow, 'debug', arguments);
}

function channel_luminance_value(channelValue) {
  const val = channelValue / 255;

  if (val <= 0.03928) {
    return val / 12.92;
  }

  return Math.pow((val + 0.055) / 1.055, 2.4);
}

function luminance(color) {
  const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb)(color),
        r = channel_luminance_value(c.r),
        g = channel_luminance_value(c.g),
        b = channel_luminance_value(c.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
} // https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef

function contrast(color1, color2) {
  const lum1 = luminance(color1),
        lum2 = luminance(color2),
        lumL = Math.max(lum1, lum2),
        lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}

function merge () {
  const args = [].slice.call(arguments);
  args.unshift({});
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(...args);
}

function equal(a, b) {
  return a === b || a !== a && b !== b ? true : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(a) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(b) && a.length === b.length ? equalArray(a, b) : false : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? equalObject(a, b) : false;
}

function equalArray(a, b) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b[i])) return false;
  }

  return true;
}

function equalObject(a, b) {
  for (const key in a) {
    if (!equal(a[key], b[key])) return false;
  }

  return true;
}

function removePredicate(props) {
  return _ => equalObject(props, _);
}

function modify (name, insert, remove, toggle, modify, values) {
  const df = this.context.dataflow,
        data = this.context.data[name],
        input = data.input,
        stamp = df.stamp();
  let changes = data.changes,
      predicate,
      key;

  if (df._trigger === false || !(input.value.length || insert || toggle)) {
    // nothing to do!
    return 0;
  }

  if (!changes || changes.stamp < stamp) {
    data.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }

  if (remove) {
    predicate = remove === true ? vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(remove) || (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple)(remove) ? remove : removePredicate(remove);
    changes.remove(predicate);
  }

  if (insert) {
    changes.insert(insert);
  }

  if (toggle) {
    predicate = removePredicate(toggle);

    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }

  if (modify) {
    for (key in values) {
      changes.modify(modify, key, values[key]);
    }
  }

  return 1;
}

function pinchDistance(event) {
  const t = event.touches,
        dx = t[0].clientX - t[1].clientX,
        dy = t[0].clientY - t[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function pinchAngle(event) {
  const t = event.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}

const accessors = {};
function pluck (data, name) {
  const accessor = accessors[name] || (accessors[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(name));
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) ? data.map(accessor) : accessor(data);
}

function array(seq) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(seq) || ArrayBuffer.isView(seq) ? seq : null;
}

function sequence(seq) {
  return array(seq) || ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(seq) ? seq : null);
}

function join(seq, ...args) {
  return array(seq).join(...args);
}
function indexof(seq, ...args) {
  return sequence(seq).indexOf(...args);
}
function lastindexof(seq, ...args) {
  return sequence(seq).lastIndexOf(...args);
}
function slice(seq, ...args) {
  return sequence(seq).slice(...args);
}
function replace(str, pattern, repl) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(repl)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Function argument passed to replace.');
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array(seq).slice().reverse();
}

function bandspace(count, paddingInner, paddingOuter) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.bandSpace)(count || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.copy() : undefined;
}
function domain(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.domain() : [];
}
function invert(name, range, group) {
  const s = getScale(name, (group || this).context);
  return !s ? undefined : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);
}
function range(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.range ? s.range() : [];
}
function scale(name, value, group) {
  const s = getScale(name, (group || this).context);
  return s ? s(value) : undefined;
}

function scaleGradient (scale, p0, p1, count, group) {
  scale = getScale(scale, (group || this).context);
  const gradient = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Gradient)(p0, p1);
  let stops = scale.domain(),
      min = stops[0],
      max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops),
      fraction = vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;

  if (!(max - min)) {
    // expand scale if domain has zero span, fix #1479
    scale = (scale.interpolator ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sequential')().interpolator(scale.interpolator()) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);
  } else {
    fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scaleFraction)(scale, min, max);
  }

  if (scale.ticks) {
    stops = scale.ticks(+count || 15);
    if (min !== stops[0]) stops.unshift(min);
    if (max !== (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops)) stops.push(max);
  }

  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));
  return gradient;
}

function geoShape(projection, geojson, group) {
  const p = getScale(projection, (group || this).context);
  return function (context) {
    return p ? p.path.context(context)(geojson) : '';
  };
}
function pathShape(path) {
  let p = null;
  return function (context) {
    return context ? (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathRender)(context, p = p || (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathParse)(path)) : path;
  };
}

const datum = d => d.data;

function treeNodes(name, context) {
  const tree = data.call(context, name);
  return tree.root && tree.root.lookup || {};
}

function treePath(name, source, target) {
  const nodes = treeNodes(name, this),
        s = nodes[source],
        t = nodes[target];
  return s && t ? s.path(t).map(datum) : undefined;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : undefined;
}

const _window = () => typeof window !== 'undefined' && window || null;

function screen() {
  const w = _window();

  return w ? w.screen : {};
}
function windowSize() {
  const w = _window();

  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];
}
function containerSize() {
  const view = this.context.dataflow,
        el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];
}

function intersect (b, opt, group) {
  if (!b) return [];
  const [u, v] = b,
        box = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Bounds().set(u[0], u[1], v[0], v[1]),
        scene = group || this.context.dataflow.scenegraph().root;
  return (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.intersect)(scene, box, filter(opt));
}

function filter(opt) {
  let p = null;

  if (opt) {
    const types = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.marktype),
          names = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.markname);

    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));
  }

  return p;
}

const functionContext = {
  random() {
    return (0,vega_statistics__WEBPACK_IMPORTED_MODULE_6__.random)();
  },

  // override default
  cumulativeNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeNormal,
  cumulativeLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeLogNormal,
  cumulativeUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeUniform,
  densityNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityNormal,
  densityLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityLogNormal,
  densityUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityUniform,
  quantileNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileNormal,
  quantileLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileLogNormal,
  quantileUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileUniform,
  sampleNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleNormal,
  sampleLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleLogNormal,
  sampleUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleUniform,
  isArray: vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray,
  isBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean,
  isDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate,

  isDefined(_) {
    return _ !== undefined;
  },

  isNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber,
  isObject: vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject,
  isRegExp: vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp,
  isString: vega_util__WEBPACK_IMPORTED_MODULE_0__.isString,
  isTuple: vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.isTuple,

  isValid(_) {
    return _ != null && _ === _;
  },

  toBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  toDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  toNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  toString: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  indexof,
  join,
  lastindexof,
  replace,
  reverse,
  slice,
  flush: vega_util__WEBPACK_IMPORTED_MODULE_0__.flush,
  lerp: vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp,
  merge,
  pad: vega_util__WEBPACK_IMPORTED_MODULE_0__.pad,
  peek: vega_util__WEBPACK_IMPORTED_MODULE_0__.peek,
  pluck,
  span: vega_util__WEBPACK_IMPORTED_MODULE_0__.span,
  inrange: vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange,
  truncate: vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate,
  rgb: d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb,
  lab: d3_color__WEBPACK_IMPORTED_MODULE_12__.default,
  hcl: d3_color__WEBPACK_IMPORTED_MODULE_12__.hcl,
  hsl: d3_color__WEBPACK_IMPORTED_MODULE_11__.hsl,
  luminance,
  contrast,
  sequence: d3_array__WEBPACK_IMPORTED_MODULE_13__.default,
  format,
  utcFormat,
  utcParse,
  utcOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcOffset,
  utcSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcSequence,
  timeFormat,
  timeParse,
  timeOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeOffset,
  timeSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeSequence,
  timeUnitSpecifier: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter,
  utcquarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter,
  week: vega_time__WEBPACK_IMPORTED_MODULE_7__.week,
  utcweek: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcweek,
  dayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.dayofyear,
  utcdayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcdayofyear,
  warn,
  info,
  debug,
  extent: vega_util__WEBPACK_IMPORTED_MODULE_0__.extent,
  inScope,
  intersect,
  clampRange: vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear,
  panLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog,
  panPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow,
  panSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog,
  zoomLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear,
  zoomLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog,
  zoomPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow,
  zoomSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog,
  encode,
  modify
};
const eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],
      // event functions
eventPrefix = 'event.vega.',
      // event function prefix
thisPrefix = 'this.',
      // function context prefix
astVisitors = {}; // AST visitors for dependency analysis
// export code generator parameters

const codegenParams = {
  forbidden: ['_'],
  allowed: ['datum', 'event', 'item'],
  fieldvar: 'datum',
  globalvar: id => `_[${(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(SignalPrefix + id)}]`,
  functions: buildFunctions,
  constants: vega_expression__WEBPACK_IMPORTED_MODULE_1__.constants,
  visitors: astVisitors
}; // export code generator

const codeGenerator = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.codegenExpression)(codegenParams); // Build expression function registry

function buildFunctions(codegen) {
  const fn = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.functions)(codegen);
  eventFunctions.forEach(name => fn[name] = eventPrefix + name);

  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(fn, internalScaleFunctions(codegen, functionContext, astVisitors));
  return fn;
} // Register an expression function


function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  } // register with the functionContext


  functionContext[name] = fn; // if there is an astVisitor register that, too

  if (visitor) astVisitors[name] = visitor; // if the code generator has already been initialized,
  // we need to also register the function with it

  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;
  return this;
} // register expression functions with ast visitors

expressionFunction('bandwidth', bandwidth, scaleVisitor);
expressionFunction('copy', copy, scaleVisitor);
expressionFunction('domain', domain, scaleVisitor);
expressionFunction('range', range, scaleVisitor);
expressionFunction('invert', invert, scaleVisitor);
expressionFunction('scale', scale, scaleVisitor);
expressionFunction('gradient', scaleGradient, scaleVisitor);
expressionFunction('geoArea', geoArea, scaleVisitor);
expressionFunction('geoBounds', geoBounds, scaleVisitor);
expressionFunction('geoCentroid', geoCentroid, scaleVisitor);
expressionFunction('geoShape', geoShape, scaleVisitor);
expressionFunction('indata', indata, indataVisitor);
expressionFunction('data', data, dataVisitor);
expressionFunction('treePath', treePath, dataVisitor);
expressionFunction('treeAncestors', treeAncestors, dataVisitor); // register Vega-Lite selection functions

expressionFunction('vlSelectionTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionIdTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionIdTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionResolve', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionResolve, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionTuples', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTuples);

function parser (expr, scope) {
  const params = {}; // parse the expression to an abstract syntax tree (ast)

  let ast;

  try {
    expr = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) ? expr : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(expr) + '';
    ast = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr);
  } catch (err) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression parse error: ' + expr);
  } // analyze ast function calls for dependencies


  ast.visit(node => {
    if (node.type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.CallExpression) return;
    const name = node.callee.name,
          visit = codegenParams.visitors[name];
    if (visit) visit(name, node.arguments, scope, params);
  }); // perform code generation

  const gen = codeGenerator(ast); // collect signal dependencies

  gen.globals.forEach(name => {
    const signalName = SignalPrefix + name;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, signalName) && scope.getSignal(name)) {
      params[signalName] = scope.signalRef(name);
    }
  }); // return generated expression code and dependencies

  return {
    $expr: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params
  };
}




/***/ }),

/***/ "./node_modules/vega-geo/build/vega-geo.module.js":
/*!********************************************************!*\
  !*** ./node_modules/vega-geo/build/vega-geo.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "contour": () => (/* binding */ Contour),
/* harmony export */   "geojson": () => (/* binding */ GeoJSON),
/* harmony export */   "geopath": () => (/* binding */ GeoPath),
/* harmony export */   "geopoint": () => (/* binding */ GeoPoint),
/* harmony export */   "geoshape": () => (/* binding */ GeoShape),
/* harmony export */   "graticule": () => (/* binding */ Graticule),
/* harmony export */   "heatmap": () => (/* binding */ Heatmap),
/* harmony export */   "isocontour": () => (/* binding */ Isocontour),
/* harmony export */   "kde2d": () => (/* binding */ KDE2D),
/* harmony export */   "projection": () => (/* binding */ Projection)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-projection */ "./node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/index.browser.js");









function noop() {}

const cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []]; // Implementation adapted from d3/d3-contour. Thanks!

function contours () {
  var dx = 1,
      dy = 1,
      smooth = smoothLinear;

  function contours(values, tz) {
    return tz.map(value => contour(values, value));
  } // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js


  function contour(values, value) {
    var polygons = [],
        holes = [];
    isorings(values, value, ring => {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(hole => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: 'MultiPolygon',
      value: value,
      coordinates: polygons
    };
  } // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js


  function isorings(values, value, callback) {
    var fragmentByStart = new Array(),
        fragmentByEnd = new Array(),
        x,
        y,
        t0,
        t1,
        t2,
        t3; // Special case for the first row (y = -1, t2 = t3 = 0).

    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);

    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }

    cases[t1 << 0].forEach(stitch); // General case for the intermediate rows.

    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);

      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }

      cases[t1 | t2 << 3].forEach(stitch);
    } // Special case for the last row (y = dy - 1, t0 = t1 = 0).


    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);

    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }

    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f,
          g;

      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];

          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(point => {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];

      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }

      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = Math.floor(_[0]),
        _1 = Math.floor(_[1]);

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, contours;
  };

  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
}

function area(ring) {
  var i = 0,
      n = ring.length,
      area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];

  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];

  return area;
}

function contains(ring, hole) {
  var i = -1,
      n = hole.length,
      c;

  while (++i < n) if (c = ringContains(ring, hole[i])) return c;

  return 0;
}

function ringContains(ring, point) {
  var x = point[0],
      y = point[1],
      contains = -1;

  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
        xi = pi[0],
        yi = pi[1],
        pj = ring[j],
        xj = pj[0],
        yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }

  return contains;
}

function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function quantize (k, nice, zero) {
  return function (values) {
    var ex = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extent)(values),
        start = zero ? Math.min(ex[0], 0) : ex[0],
        stop = ex[1],
        span = stop - start,
        step = nice ? (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.tickStep)(start, stop, k) : span / (k + 1);
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.default)(start + step, stop, step);
  };
}

/**
 * Generate isocontours (level sets) based on input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   specified, the levels, nice, resolve, and zero parameters are ignored.
 * @param {number} [params.levels] - The desired number of contour levels.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified levels.
 * @param {string} [params.resolve] - The method for resolving thresholds
 *   across multiple input grids. If 'independent' (the default), threshold
 *   calculation will be performed separately for each grid. If 'shared', a
 *   single set of threshold values will be used for all input grids.
 * @param {boolean} [params.zero] - Boolean flag indicating if the contour
 *   threshold values should include zero.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 * @param {boolean} [params.scale] - Optional numerical value by which to
 *   scale the output isocontour coordinates. This parameter can be useful
 *   to scale the contours to match a desired output resolution.
 * @param {string} [params.as='contour'] - The output field in which to store
 *   the generated isocontour data (default 'contour').
 */

function Isocontour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Isocontour.Definition = {
  'type': 'Isocontour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'levels',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'zero',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'scale',
    'type': 'number',
    'expr': true
  }, {
    'name': 'translate',
    'type': 'number',
    'array': true,
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'default': 'contour'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Isocontour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        contour = contours().smooth(_.smooth !== false),
        tz = _.thresholds || levels(source, field, _),
        as = _.as === null ? null : _.as || 'contour',
        values = [];
    source.forEach(t => {
      const grid = field(t); // generate contour paths in GeoJSON format

      const paths = contour.size([grid.width, grid.height])(grid.values, (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(tz) ? tz : tz(grid.values)); // adjust contour path coordinates as needed

      transformPaths(paths, grid, t, _); // ingest; copy source data properties to output

      paths.forEach(p => {
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.rederive)(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});

function levels(values, f, _) {
  const q = quantize(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== 'shared' ? q : q(values.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(f(t).values)));
}

function transformPaths(paths, grid, datum, _) {
  let s = _.scale || grid.scale,
      t = _.translate || grid.translate;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) s = s(datum, _);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(t)) t = t(datum, _);
  if ((s === 1 || s == null) && !t) return;
  const sx = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[0]) || 1,
        sy = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[1]) || 1,
        tx = t && t[0] || 0,
        ty = t && t[1] || 0;
  paths.forEach(transform(grid, sx, sy, tx, ty));
}

function transform(grid, sx, sy, tx, ty) {
  const x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        flip = sx * sy < 0;

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    if (flip) coordinates.reverse(); // maintain winding order

    coordinates.forEach(transformPoint);
  }

  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x1) * sx + tx;
    coordinates[1] = (coordinates[1] - y1) * sy + ty;
  }

  return function (geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}

function radius(bw, data, f) {
  const v = bw >= 0 ? bw : (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bandwidthNRD)(data, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}

function number(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_) ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(+_);
} // Implementation adapted from d3/d3-contour. Thanks!


function density2D () {
  var x = d => d[0],
      y = d => d[1],
      weight = vega_util__WEBPACK_IMPORTED_MODULE_1__.one,
      bandwidth = [-1, -1],
      dx = 960,
      dy = 500,
      k = 2; // log2(cellSize)


  function density(data, counts) {
    const rx = radius(bandwidth[0], data, x) >> k,
          // blur x-radius
    ry = radius(bandwidth[1], data, y) >> k,
          // blur y-radius
    ox = rx ? rx + 2 : 0,
          // x-offset padding for blur
    oy = ry ? ry + 2 : 0,
          // y-offset padding for blur
    n = 2 * ox + (dx >> k),
          // grid width
    m = 2 * oy + (dy >> k),
          // grid height
    values0 = new Float32Array(n * m),
          values1 = new Float32Array(n * m);
    let values = values0;
    data.forEach(d => {
      const xi = ox + (+x(d) >> k),
            yi = oy + (+y(d) >> k);

      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });

    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values = values1;
    } // scale density estimates
    // density in points per square pixel or probability density


    const s = counts ? Math.pow(2, -2 * k) : 1 / (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(values);

    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;

    return {
      values: values,
      scale: 1 << k,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }

  density.x = function (_) {
    return arguments.length ? (x = number(_), density) : x;
  };

  density.y = function (_) {
    return arguments.length ? (y = number(_), density) : y;
  };

  density.weight = function (_) {
    return arguments.length ? (weight = number(_), density) : weight;
  };

  density.size = function (_) {
    if (!arguments.length) return [dx, dy];

    var _0 = +_[0],
        _1 = +_[1];

    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, density;
  };

  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid cell size');
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };

  density.bandwidth = function (_) {
    if (!arguments.length) return bandwidth;
    _ = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid bandwidth');
    return bandwidth = _, density;
  };

  return density;
}

function blurX(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source[i + j * n];
      }

      if (i >= r) {
        if (i >= w) {
          sr -= source[i - w + j * n];
        }

        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

function blurY(n, m, source, target, r) {
  const w = (r << 1) + 1;

  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source[i + j * n];
      }

      if (j >= r) {
        if (j >= w) {
          sr -= source[i + (j - w) * n];
        }

        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

/**
 * Perform 2D kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The [width, height] extent (in
 *   units of input pixels) over which to perform density estimation.
 * @param {function(object): number} params.x - The x-coordinate accessor.
 * @param {function(object): number} params.y - The y-coordinate accessor.
 * @param {function(object): number} [params.weight] - The weight accessor.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 *   This parameter determines the level of spatial approximation. For example,
 *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.
 *   A value of 1 will result in an output raster grid whose dimensions exactly
 *   matches the size parameter.
 * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,
 *   in pixels. The input can be a two-element array specifying separate
 *   x and y bandwidths, or a single-element array specifying both. If the
 *   bandwidth is unspecified or less than zero, the bandwidth will be
 *   automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.as='grid'] - The output field in which to store
 *   the generated raster grid (default 'grid').
 */

function KDE2D(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
KDE2D.Definition = {
  'type': 'KDE2D',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'grid'
  }]
};
const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];
function params(obj, _) {
  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);
  return obj;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(KDE2D, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        source = pulse.materialize(pulse.SOURCE).source,
        groups = partition(source, _.groupby),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorName),
        kde = params(density2D(), _),
        as = _.as || 'grid',
        values = [];

    function set(t, vals) {
      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];

      return t;
    } // generate density raster grids


    values = groups.map(g => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(set({
      [as]: kde(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }

});
function partition(data, groupby) {
  var groups = [],
      get = f => f(t),
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Generate contours based on kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.
 *  If the values parameter is provided, this must be the dimensions of the input data.
 *  If density estimation is performed, this is the output view dimensions in pixels.
 * @param {Array<number>} [params.values] - An array of numeric values representing an
 *  width x height grid of values over which to compute contours. If unspecified, this
 *  transform will instead attempt to compute contours for the kernel density estimate
 *  using values drawn from data tuples in the input pulse.
 * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.
 * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.
 * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   this parameter is set, the count and nice parameters will be ignored.
 * @param {number} [params.count] - The desired number of contours.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified count.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 */

function Contour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Contour.Definition = {
  'type': 'Contour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'values',
    'type': 'number',
    'array': true
  }, {
    'name': 'x',
    'type': 'field'
  }, {
    'name': 'y',
    'type': 'field'
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number'
  }, {
    'name': 'count',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Contour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
        contour = contours().smooth(_.smooth !== false),
        values = _.values,
        thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),
        size = _.size,
        grid,
        post;

    if (!values) {
      values = pulse.materialize(pulse.SOURCE).source;
      grid = params(density2D(), _)(values, true);
      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values = grid.values;
    }

    thresh = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(thresh) ? thresh : thresh(values);
    values = contour.size(size)(values, thresh);
    if (post) values.forEach(post);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values || []).map(vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest);
    return out;
  }

});

const Feature = 'Feature';
const FeatureCollection = 'FeatureCollection';
const MultiPoint = 'MultiPoint';

/**
 * Consolidate an array of [longitude, latitude] points or GeoJSON features
 * into a combined GeoJSON object. This transform is particularly useful for
 * combining geo data for a Projection's fit argument. The resulting GeoJSON
 * data is available as this transform's value. Input pulses are unchanged.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.fields] - A two-element array
 *   of field accessors for the longitude and latitude values.
 * @param {function(object): *} params.geojson - A field accessor for
 *   retrieving GeoJSON feature data.
 */

function GeoJSON(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoJSON.Definition = {
  'type': 'GeoJSON',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'length': 2
  }, {
    'name': 'geojson',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoJSON, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var features = this._features,
        points = this._points,
        fields = _.fields,
        lon = fields && fields[0],
        lat = fields && fields[1],
        geojson = _.geojson || !fields && vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        flag = pulse.ADD,
        mod;
    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(geojson)) || lon && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lon)) || lat && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lat));

    if (!this.value || mod) {
      flag = pulse.SOURCE;
      this._features = features = [];
      this._points = points = [];
    }

    if (geojson) {
      pulse.visit(flag, t => features.push(geojson(t)));
    }

    if (lon && lat) {
      pulse.visit(flag, t => {
        var x = lon(t),
            y = lat(t);

        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {
          points.push([x, y]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points
        }
      });
    }

    this.value = {
      type: FeatureCollection,
      features: features
    };
  }

});

/**
 * Map GeoJSON data to an SVG path string.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='path'] - The output field in which to store
 *   the generated path data (default 'path').
 */

function GeoPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPath.Definition = {
  'type': 'GeoPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        path = this.value,
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        as = _.as || 'path',
        flag = out.SOURCE;

    if (!path || _.modified()) {
      // parameters updated, reset and reflow
      this.value = path = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection);
      out.materialize().reflow();
    } else {
      flag = field === vega_util__WEBPACK_IMPORTED_MODULE_1__.identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;
    }

    const prev = initPath(path, _.pointRadius);
    out.visit(flag, t => t[as] = path(field(t)));
    path.pointRadius(prev);
    return out.modifies(as);
  }

});

function initPath(path, pointRadius) {
  const prev = path.pointRadius();
  path.context(null);

  if (pointRadius != null) {
    path.pointRadius(pointRadius);
  }

  return prev;
}

/**
 * Geo-code a longitude/latitude point to an x/y coordinate.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {Array<function(object): *>} params.fields - A two-element array of
 *   field accessors for the longitude and latitude values.
 * @param {Array<string>} [params.as] - A two-element array of field names
 *   under which to store the result. Defaults to ['x','y'].
 */

function GeoPoint(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPoint.Definition = {
  'type': 'GeoPoint',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection',
    'required': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['x', 'y']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPoint, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var proj = _.projection,
        lon = _.fields[0],
        lat = _.fields[1],
        as = _.as || ['x', 'y'],
        x = as[0],
        y = as[1],
        mod;

    function set(t) {
      const xy = proj([lon(t), lat(t)]);

      if (xy) {
        t[x] = xy[0];
        t[y] = xy[1];
      } else {
        t[x] = undefined;
        t[y] = undefined;
      }
    }

    if (_.modified()) {
      // parameters updated, reflow
      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);
    } else {
      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);
      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);
    }

    return pulse.modifies(as);
  }

});

/**
 * Annotate items with a geopath shape generator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='shape'] - The output field in which to store
 *   the generated path data (default 'shape').
 */

function GeoShape(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoShape.Definition = {
  'type': 'GeoShape',
  'metadata': {
    'modifies': true,
    'nomod': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field',
    'default': 'datum'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'shape'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoShape, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        shape = this.value,
        as = _.as || 'shape',
        flag = out.ADD;

    if (!shape || _.modified()) {
      // parameters updated, reset and reflow
      this.value = shape = shapeGenerator((0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection), _.field || (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.field)('datum'), _.pointRadius);
      out.materialize().reflow();
      flag = out.SOURCE;
    }

    out.visit(flag, t => t[as] = shape);
    return out.modifies(as);
  }

});

function shapeGenerator(path, field, pointRadius) {
  const shape = pointRadius == null ? _ => path(field(_)) : _ => {
    var prev = path.pointRadius(),
        value = path.pointRadius(pointRadius)(field(_));
    path.pointRadius(prev);
    return value;
  };

  shape.context = _ => {
    path.context(_);
    return shape;
  };

  return shape;
}

/**
 * GeoJSON feature generator for creating graticules.
 * @constructor
 */

function Graticule(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
  this.generator = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__.default)();
}
Graticule.Definition = {
  'type': 'Graticule',
  'metadata': {
    'changes': true,
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMajor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMinor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'step',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'stepMajor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [90, 360]
  }, {
    'name': 'stepMinor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [10, 10]
  }, {
    'name': 'precision',
    'type': 'number',
    'default': 2.5
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Graticule, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var src = this.value,
        gen = this.generator,
        t;

    if (!src.length || _.modified()) {
      for (const prop in _) {
        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }

    t = gen();

    if (src.length) {
      pulse.mod.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.replace)(src[0], t));
    } else {
      pulse.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(t));
    }

    src[0] = t;
    return pulse;
  }

});

/**
 * Render a heatmap image for input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {string} [params.color] - A constant color value or function for
 *   individual pixel color. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {number} [params.opacity] - A constant opacity value or function for
 *   individual pixel opacity. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {string} [params.resolve] - The method for resolving maximum values
 *   across multiple input grids. If 'independent' (the default), maximum
 *   calculation will be performed separately for each grid. If 'shared',
 *   a single global maximum will be used for all input grids.
 * @param {string} [params.as='image'] - The output field in which to store
 *   the generated bitmap canvas images (default 'image').
 */

function Heatmap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Heatmap.Definition = {
  'type': 'heatmap',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'color',
    'type': 'string',
    'expr': true
  }, {
    'name': 'opacity',
    'type': 'number',
    'expr': true
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'image'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Heatmap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }

    var source = pulse.materialize(pulse.SOURCE).source,
        shared = _.resolve === 'shared',
        field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
        opacity = opacity_(_.opacity, _),
        color = color_(_.color, _),
        as = _.as || 'image',
        obj = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: shared ? (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(source.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(field(t).values))) : 0
    };
    source.forEach(t => {
      const v = field(t); // build proxy data object

      const o = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, t, obj); // set maximum value if not globally shared

      if (!shared) o.$max = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__.default)(v.values || []); // generate canvas image
      // optimize color/opacity if not pixel-dependent

      t[as] = toCanvas(v, o, color.dep ? color : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(color(o)), opacity.dep ? opacity : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity(o)));
    });
    return pulse.reflow(true).modifies(as);
  }

}); // get image color function

function color_(color, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(color)) {
    f = obj => (0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color(obj, _));

    f.dep = dependency(color);
  } else {
    // default to mid-grey
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)((0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color || '#888'));
  }

  return f;
} // get image opacity function


function opacity_(opacity, _) {
  let f;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opacity)) {
    f = obj => opacity(obj, _);

    f.dep = dependency(opacity);
  } else if (opacity) {
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity);
  } else {
    // default to [0, max] opacity gradient
    f = obj => obj.$value / obj.$max || 0;

    f.dep = true;
  }

  return f;
} // check if function depends on individual pixel data


function dependency(f) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f)) return false;
  const set = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(f));
  return set.$x || set.$y || set.$value || set.$max;
} // render raster grid to canvas


function toCanvas(grid, obj, color, opacity) {
  const n = grid.width,
        m = grid.height,
        x1 = grid.x1 || 0,
        y1 = grid.y1 || 0,
        x2 = grid.x2 || n,
        y2 = grid.y2 || m,
        val = grid.values,
        value = val ? i => val[i] : vega_util__WEBPACK_IMPORTED_MODULE_1__.zero,
        can = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_4__.canvas)(x2 - x1, y2 - y1),
        ctx = can.getContext('2d'),
        img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),
        pix = img.data;

  for (let j = y1, k = 0; j < y2; ++j) {
    obj.$y = j - y1;

    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {
      obj.$x = i - x1;
      obj.$value = value(i + r);
      const v = color(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity(obj));
    }
  }

  ctx.putImageData(img, 0, 0);
  return can;
}

/**
 * Maintains a cartographic projection.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Projection(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Projection, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let proj = this.value;

    if (!proj || _.modified('type')) {
      this.value = proj = create(_.type);
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_[prop] != null) set(proj, prop, _[prop]);
      });
    } else {
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_.modified(prop)) set(proj, prop, _[prop]);
      });
    }

    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }

});

function fit(proj, _) {
  const data = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;
}

function create(type) {
  const constructor = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.projection)((type || 'mercator').toLowerCase());
  if (!constructor) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized projection type: ' + type);
  return constructor();
}

function set(proj, key, value) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(proj[key])) proj[key](value);
}

function collectGeoJSON(data) {
  data = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(data);
  return data.length === 1 ? data[0] : {
    type: FeatureCollection,
    features: data.reduce((a, f) => a.concat(featurize(f)), [])
  };
}

function featurize(f) {
  return f.type === FeatureCollection ? f.features : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(f).filter(d => d != null).map(d => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}




/***/ }),

/***/ "./node_modules/vega-hierarchy/build/vega-hierarchy.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-hierarchy/build/vega-hierarchy.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "nest": () => (/* binding */ Nest),
/* harmony export */   "pack": () => (/* binding */ Pack),
/* harmony export */   "partition": () => (/* binding */ Partition),
/* harmony export */   "stratify": () => (/* binding */ Stratify),
/* harmony export */   "tree": () => (/* binding */ Tree),
/* harmony export */   "treelinks": () => (/* binding */ TreeLinks),
/* harmony export */   "treemap": () => (/* binding */ Treemap)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/hierarchy/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/pack/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/partition.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/stratify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/tree.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/cluster.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/binary.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/sliceDice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/resquarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/index.js");




// Build lookup table mapping tuple keys to tree node instances
function lookup (tree, key, filter) {
  const map = {};
  tree.each(node => {
    const t = node.data;
    if (filter(t)) map[key(t)] = node;
  });
  tree.lookup = map;
  return tree;
}

/**
 * Nest tuples into a tree structure, grouped by key values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.
 * @param {boolean} [params.generate=false] - A boolean flag indicating if
 *   non-leaf nodes generated by this transform should be included in the
 *   output. The default (false) includes only the input data (leaf nodes)
 *   in the data stream.
 */

function Nest(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Nest.Definition = {
  'type': 'Nest',
  'metadata': {
    'treesource': true,
    'changes': true
  },
  'params': [{
    'name': 'keys',
    'type': 'field',
    'array': true
  }, {
    'name': 'generate',
    'type': 'boolean'
  }]
};

const children = n => n.values;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Nest, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Nest transform requires an upstream data source.');
    }

    var gen = _.generate,
        mod = _.modified(),
        out = pulse.clone(),
        tree = this.value;

    if (!tree || mod || pulse.changed()) {
      // collect nodes to remove
      if (tree) {
        tree.each(node => {
          if (node.children && (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.isTuple)(node.data)) {
            out.rem.push(node.data);
          }
        });
      } // generate new tree structure


      this.value = tree = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__.default)({
        values: (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children); // collect nodes to add

      if (gen) {
        tree.each(node => {
          if (node.children) {
            node = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      } // build lookup table


      lookup(tree, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid);
    }

    out.source.root = tree;
    return out;
  }

});

function nest() {
  const keys = [],
        nest = {
    entries: array => entries(apply(array, 0), 0),
    key: d => (keys.push(d), nest)
  };

  function apply(array, depth) {
    if (depth >= keys.length) {
      return array;
    }

    const n = array.length,
          key = keys[depth++],
          valuesByKey = {},
          result = {};
    let i = -1,
        keyValue,
        value,
        values;

    while (++i < n) {
      keyValue = key(value = array[i]) + '';

      if (values = valuesByKey[keyValue]) {
        values.push(value);
      } else {
        valuesByKey[keyValue] = [value];
      }
    }

    for (keyValue in valuesByKey) {
      result[keyValue] = apply(valuesByKey[keyValue], depth);
    }

    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    const array = [];

    for (const key in map) {
      array.push({
        key,
        values: entries(map[key], depth)
      });
    }

    return array;
  }

  return nest;
}

/**
 * Abstract class for tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function HierarchyLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}

const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;

(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(HierarchyLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source || !pulse.source.root) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(this.constructor.name + ' transform requires a backing tree data source.');
    }

    const layout = this.layout(_.method),
          fields = this.fields,
          root = pulse.source.root,
          as = _.as || fields;
    if (_.field) root.sum(_.field);else root.count();
    if (_.sort) root.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort, d => d.data));
    setParams(layout, this.params, _);

    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : vega_util__WEBPACK_IMPORTED_MODULE_1__.one);
    }

    try {
      this.value = layout(root);
    } catch (err) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(err);
    }

    root.each(node => setFields(node, fields, as));
    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');
  }

});

function setParams(layout, params, _) {
  for (let p, i = 0, n = params.length; i < n; ++i) {
    p = params[i];
    if (p in _) layout[p](_[p]);
  }
}

function setFields(node, fields, as) {
  const t = node.data,
        n = fields.length - 1;

  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }

  t[as[n]] = node.children ? node.children.length : 0;
}

const Output = ['x', 'y', 'r', 'depth', 'children'];
/**
 * Packed circle tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Pack(params) {
  HierarchyLayout.call(this, params);
}
Pack.Definition = {
  'type': 'Pack',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'radius',
    'type': 'field',
    'default': null
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output.length,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Pack, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__.default,
  params: ['radius', 'size', 'padding'],
  fields: Output
});

const Output$1 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Partition tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Partition(params) {
  HierarchyLayout.call(this, params);
}
Partition.Definition = {
  'type': 'Partition',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$1.length,
    'default': Output$1
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Partition, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__.default,
  params: ['size', 'round', 'padding'],
  fields: Output$1
});

/**
 * Stratify a collection of tuples into a tree structure based on
 * id and parent id fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.key - Unique key field for each tuple.
 * @param {function(object): *} params.parentKey - Field with key for parent tuple.
 */

function Stratify(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stratify.Definition = {
  'type': 'Stratify',
  'metadata': {
    'treesource': true
  },
  'params': [{
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'parentKey',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Stratify, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Stratify transform requires an upstream data source.');
    }

    let tree = this.value;

    const mod = _.modified(),
          out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),
          run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields); // prevent upstream source pollution


    out.source = out.source.slice();

    if (run) {
      tree = out.source.length ? lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)().id(_.key).parentId(_.parentKey)(out.source), _.key, vega_util__WEBPACK_IMPORTED_MODULE_1__.truthy) : lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__.default)()([{}]), _.key, _.key);
    }

    out.source.root = this.value = tree;
    return out;
  }

});

const Layouts = {
  tidy: d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__.default,
  cluster: d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__.default
};
const Output$2 = ['x', 'y', 'depth', 'children'];
/**
 * Tree layout. Depending on the method parameter, performs either
 * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Tree(params) {
  HierarchyLayout.call(this, params);
}
Tree.Definition = {
  'type': 'Tree',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'tidy',
    'values': ['tidy', 'cluster']
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'nodeSize',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'separation',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$2.length,
    'default': Output$2
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method) {
    const m = method || 'tidy';
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Layouts, m)) return Layouts[m]();else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Tree layout method: ' + m);
  },

  params: ['size', 'nodeSize'],
  fields: Output$2
});

/**
 * Generate tuples representing links between tree nodes.
 * The resulting tuples will contain 'source' and 'target' fields,
 * which point to parent and child node tuples, respectively.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function TreeLinks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
TreeLinks.Definition = {
  'type': 'TreeLinks',
  'metadata': {
    'tree': true,
    'generates': true,
    'changes': true
  },
  'params': []
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(TreeLinks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const links = this.value,
          tree = pulse.source && pulse.source.root,
          out = pulse.fork(pulse.NO_SOURCE),
          lut = {};
    if (!tree) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('TreeLinks transform requires a tree data source.');

    if (pulse.changed(pulse.ADD_REM)) {
      // remove previous links
      out.rem = links; // build lookup table of valid tuples

      pulse.visit(pulse.SOURCE, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // generate links for all edges incident on valid tuples

      tree.each(node => {
        const t = node.data,
              p = node.parent && node.parent.data;

        if (p && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(p)]) {
          out.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse.changed(pulse.MOD)) {
      // build lookup table of modified tuples
      pulse.visit(pulse.MOD, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1); // gather links incident on modified tuples

      links.forEach(link => {
        if (lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.source)] || lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.target)]) {
          out.mod.push(link);
        }
      });
    }

    return out;
  }

});

const Tiles = {
  binary: d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__.default,
  dice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__.default,
  slice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__.default,
  slicedice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__.default,
  squarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__.default,
  resquarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__.default
};
const Output$3 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];
/**
 * Treemap layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */

function Treemap(params) {
  HierarchyLayout.call(this, params);
}
Treemap.Definition = {
  'type': 'Treemap',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'squarify',
    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingInner',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingOuter',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingTop',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingRight',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingBottom',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingLeft',
    'type': 'number',
    'default': 0
  }, {
    'name': 'ratio',
    'type': 'number',
    'default': 1.618033988749895
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$3.length,
    'default': Output$3
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__.default)();

    x.ratio = _ => {
      const t = x.tile();
      if (t.ratio) x.tile(t.ratio(_));
    };

    x.method = _ => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Tiles, _)) x.tile(Tiles[_]);else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Treemap layout method: ' + _);
    };

    return x;
  },

  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
  fields: Output$3
});




/***/ }),

/***/ "./node_modules/vega-label/build/vega-label.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-label/build/vega-label.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "label": () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");





const ALPHA_MASK = 0xff000000; // alpha value equivalent to opacity 0.0625

const INSIDE_OPACITY_IN_ALPHA = 0x10000000;
const INSIDE_OPACITY = 0.0625;
function baseBitmaps($, data) {
  const bitmap = $.bitmap(); // when there is no base mark but data points are to be avoided

  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));
  return [bitmap, undefined];
}
function markBitmaps($, avoidMarks, labelInside, isGroupArea) {
  // create canvas
  const width = $.width,
        height = $.height,
        border = labelInside || isGroupArea,
        context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)(width, height).getContext('2d'); // render all marks to be avoided into canvas

  avoidMarks.forEach(items => draw(context, items, border)); // get canvas buffer, create bitmaps

  const buffer = new Uint32Array(context.getImageData(0, 0, width, height).data.buffer),
        layer1 = $.bitmap(),
        layer2 = border && $.bitmap(); // populate bitmap layers

  let x, y, u, v, alpha;

  for (y = 0; y < height; ++y) {
    for (x = 0; x < width; ++x) {
      alpha = buffer[y * width + x] & ALPHA_MASK;

      if (alpha) {
        u = $(x);
        v = $(y);
        if (!isGroupArea) layer1.set(u, v); // update interior bitmap

        if (border && alpha ^ INSIDE_OPACITY_IN_ALPHA) layer2.set(u, v); // update border bitmap
      }
    }
  }

  return [layer1, layer2];
}

function draw(context, items, interior) {
  if (!items.length) return;
  const type = items[0].mark.marktype;

  if (type === 'group') {
    items.forEach(group => {
      group.items.forEach(mark => draw(context, mark.items, interior));
    });
  } else {
    vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Marks[type].draw(context, {
      items: interior ? items.map(prepare) : items
    });
  }
}
/**
 * Prepare item before drawing into canvas (setting stroke and opacity)
 * @param {object} source item to be prepared
 * @returns prepared item
 */


function prepare(source) {
  const item = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive)(source, {});

  if (item.stroke) {
    item.strokeOpacity = 1;
  }

  if (item.fill) {
    item.fillOpacity = INSIDE_OPACITY;
    item.stroke = '#000';
    item.strokeOpacity = 1;
    item.strokeWidth = 2;
  }

  return item;
}

const DIV = 5,
      // bit shift from x, y index to bit vector array index
MOD = 31,
      // bit mask for index lookup within a bit vector
SIZE = 32,
      // individual bit vector size
RIGHT0 = new Uint32Array(SIZE + 1),
      // left-anchored bit vectors, full -> 0
RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full

RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];

for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}

function Bitmap (w, h) {
  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));

  function _set(index, mask) {
    array[index] |= mask;
  }

  function _clear(index, mask) {
    array[index] &= mask;
  }

  return {
    array: array,
    get: (x, y) => {
      const index = y * w + x;
      return array[index >>> DIV] & 1 << (index & MOD);
    },
    set: (x, y) => {
      const index = y * w + x;

      _set(index >>> DIV, 1 << (index & MOD));
    },
    clear: (x, y) => {
      const index = y * w + x;

      _clear(index >>> DIV, ~(1 << (index & MOD)));
    },
    getRange: (x, y, x2, y2) => {
      let r = y2,
          start,
          end,
          indexStart,
          indexEnd;

      for (; r >= y; --r) {
        start = r * w + x;
        end = r * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
            return true;
          }
        } else {
          if (array[indexStart] & RIGHT0[start & MOD]) return true;
          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;

          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array[i]) return true;
          }
        }
      }

      return false;
    },
    setRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD]);

          _set(indexEnd, RIGHT1[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);
        }
      }
    },
    clearRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;

      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;

        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD]);

          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);

          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w
  };
}

function scaler (width, height, padding) {
  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),
        w = ~~((width + 2 * padding + ratio) / ratio),
        h = ~~((height + 2 * padding + ratio) / ratio),
        scale = _ => ~~((_ + padding) / ratio);

  scale.invert = _ => _ * ratio - padding;

  scale.bitmap = () => Bitmap(w, h);

  scale.ratio = ratio;
  scale.padding = padding;
  scale.width = width;
  scale.height = height;
  return scale;
}

function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
        height = $.height; // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        areaWidth; // for each area sample point

    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;
      x = (x1 + x2) / 2;
      y = (y1 + y2) / 2;
      areaWidth = Math.abs(x2 - x1 + y2 - y1);

      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x;
        d.y = y;
      }
    }

    x = textWidth / 2;
    y = textHeight / 2;
    x1 = d.x - x;
    x2 = d.x + x;
    y1 = d.y - y;
    y2 = d.y + y;
    d.align = 'center';

    if (x1 < 0 && x2 <= width) {
      d.align = 'left';
    } else if (0 <= x1 && width < x2) {
      d.align = 'right';
    }

    d.baseline = 'middle';

    if (y1 < 0 && y2 <= height) {
      d.baseline = 'top';
    } else if (0 <= y1 && height < y2) {
      d.baseline = 'bottom';
    }

    return true;
  };
}

function outOfBounds(x, y, textWidth, textHeight, width, height) {
  let r = textWidth / 2;
  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;
}

function _outOfBounds() {
  return false;
}

function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2),
        x1 = $(x - w),
        x2 = $(x + w),
        y1 = $(y - (h = h / 2)),
        y2 = $(y + h);
  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function _collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2);
  let x1 = $(x - w),
      x2 = $(x + w),
      y1 = $(y - (h = h / 2)),
      y2 = $(y + h);
  x1 = x1 > 0 ? x1 : 0;
  y1 = y1 > 0 ? y1 : 0;
  x2 = x2 < $.width ? x2 : $.width - 1;
  y2 = y2 < $.height ? y2 : $.height - 1;
  return bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function getTests(infPadding) {
  return infPadding ? [_collision, _outOfBounds] : [collision, outOfBounds];
}

function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1]; // area outlines

  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x = $.invert(_x),
          y = $.invert(_y);
    let lo = maxSize,
        hi = height,
        mid;

    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
      // if the label fits at the current sample point,
      // perform binary search to find the largest font size that fits
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;

        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      } // place label if current lower bound exceeds prior max font size


      if (lo > maxSize) {
        return [x, y, lo, true];
      }
    }
  } // try to place a label within an input area mark


  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        _x1,
        _xMid,
        _x2,
        _y1,
        _yMid,
        _y2,
        areaWidth,
        result,
        swapTmp; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;

      if (x1 > x2) {
        swapTmp = x1;
        x1 = x2;
        x2 = swapTmp;
      }

      if (y1 > y2) {
        swapTmp = y1;
        y1 = y2;
        y2 = swapTmp;
      }

      _x1 = $(x1);
      _x2 = $(x2);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $(y1);
      _y2 = $(y2);
      _yMid = ~~((_y1 + _y2) / 2); // search along the line from mid point between the 2 border to lower border

      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // search along the line from mid point between the 2 border to upper border


      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);

          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const X_DIR = [-1, -1, 1, 1];
const Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex, infPadding) {
  const width = $.width,
        height = $.height,
        [collision, outOfBounds] = getTests(infPadding),
        bm0 = bitmaps[0],
        // where labels have been placed
  bm1 = bitmaps[1],
        // area outlines
  bm2 = $.bitmap(); // flood-fill visitations
  // try to place a label within an input area mark

  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
          // area points
    n = items.length,
          // number of points
    textHeight = d.datum.fontSize,
          // label width
    textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text),
          // label height
    stack = []; // flood fill stack

    let maxSize = avoidBaseMark ? textHeight : 0,
        labelPlaced = false,
        labelPlaced2 = false,
        maxAreaWidth = 0,
        x1,
        x2,
        y1,
        y2,
        x,
        y,
        _x,
        _y,
        lo,
        hi,
        mid,
        areaWidth; // for each area sample point


    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2; // add scaled center point to stack

      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]); // perform flood fill, visit points

      while (stack.length) {
        [_x, _y] = stack.pop(); // exit if point already marked

        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue; // mark point in flood fill bitmap
        // add search points for all (in bound) directions

        bm2.set(_x, _y);

        for (let j = 0; j < 4; ++j) {
          x = _x + X_DIR[j];
          y = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);
        } // unscale point back to x, y space


        x = $.invert(_x);
        y = $.invert(_y);
        lo = maxSize;
        hi = height; // TODO: make this bound smaller

        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          // if the label fits at the current sample point,
          // perform binary search to find the largest font size that fits
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;

            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          } // place label if current lower bound exceeds prior max font size


          if (lo > maxSize) {
            d.x = x;
            d.y = y;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      } // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas


      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2; // place label if it fits and improves the max area width

        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    } // record current label placement information, update label bitmap


    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const Aligns = ['right', 'center', 'left'],
      Baselines = ['bottom', 'middle', 'top'];
function placeMarkLabel ($, bitmaps, anchors, offsets, infPadding) {
  const width = $.width,
        height = $.height,
        bm0 = bitmaps[0],
        bm1 = bitmaps[1],
        n = offsets.length;
  return function (d) {
    const boundary = d.boundary,
          textHeight = d.datum.fontSize; // can not be placed if the mark is not visible in the graph bound

    if (!infPadding && (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height)) {
      return false;
    }

    let textWidth = 0,
        dx,
        dy,
        isInside,
        sizeFactor,
        insideFactor,
        x1,
        x2,
        y1,
        y2,
        xc,
        yc,
        _x1,
        _x2,
        _y1,
        _y2; // for each anchor and offset


    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 0x3) - 1;
      dy = (anchors[i] >>> 0x2 & 0x3) - 1;
      isInside = dx === 0 && dy === 0 || offsets[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets[i] < 0 ? -1 : 1;
      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;
      y1 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $(x1);
      _y1 = $(y1);
      _y2 = $(y2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _y1 = _y1 < 0 ? 0 : _y1;
        _y2 = _y2 >= $.height ? $.height - 1 : _y2;
      }

      if (!textWidth) {
        // to avoid finding width of text label,
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {
          // skip this anchor/offset option if we fail to place a label with 1px width
          continue;
        } else {
          // Otherwise, find the label width
          textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.textMetrics.width(d.datum, d.datum.text);
        }
      }

      xc = x1 + insideFactor * textWidth * dx / 2;
      x1 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $(x1);
      _x2 = $(x2);

      if (infPadding) {
        _x1 = _x1 < 0 ? 0 : _x1;
        _x2 = _x2 >= $.width ? $.width - 1 : _x2;
      }

      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {
        // place label if the position is placeable
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }

    return false;
  };
} // Test if a label with the given dimensions can be added without overlap

function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 ? bm1.getRange(_x1, _y1, _x2, _y2) || !isInMarkBound(x1, y1, x2, y2, boundary) : bm0.getRange(_x1, _y1, _x2, _y2)));
}

function isInMarkBound(x1, y1, x2, y2, boundary) {
  return boundary[0] <= x1 && x2 <= boundary[2] && boundary[3] <= y1 && y2 <= boundary[5];
}

const TOP = 0x0,
      MIDDLE = 0x4,
      BOTTOM = 0x8,
      LEFT = 0x0,
      CENTER = 0x1,
      RIGHT = 0x2; // Mapping from text anchor to number representation

const anchorCode = {
  'top-left': TOP + LEFT,
  'top': TOP + CENTER,
  'top-right': TOP + RIGHT,
  'left': MIDDLE + LEFT,
  'middle': MIDDLE + CENTER,
  'right': MIDDLE + RIGHT,
  'bottom-left': BOTTOM + LEFT,
  'bottom': BOTTOM + CENTER,
  'bottom-right': BOTTOM + RIGHT
};
const placeAreaLabel = {
  'naive': placeAreaLabelNaive,
  'reduced-search': placeAreaLabelReducedSearch,
  'floodfill': placeAreaLabelFloodFill
};
function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {
  // early exit for empty data
  if (!texts.length) return texts;
  const positions = Math.max(offset.length, anchor.length),
        offsets = getOffsets(offset, positions),
        anchors = getAnchors(anchor, positions),
        marktype = markType(texts[0].datum),
        grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,
        isGroupArea = grouptype === 'area',
        boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),
        infPadding = padding === null || padding === Infinity,
        $ = scaler(size[0], size[1], infPadding ? 0 : padding),
        isNaiveGroupArea = isGroupArea && method === 'naive'; // prepare text mark data for placing

  const data = texts.map(d => ({
    datum: d,
    opacity: 0,
    x: undefined,
    y: undefined,
    align: undefined,
    baseline: undefined,
    boundary: boundary(d)
  }));
  let bitmaps;

  if (!isNaiveGroupArea) {
    // sort labels in priority order, if comparator is provided
    if (compare) {
      data.sort((a, b) => compare(a.datum, b.datum));
    } // flag indicating if label can be placed inside its base mark


    let labelInside = false;

    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      // label inside if anchor is at center
      // label inside if offset to be inside the mark bound
      labelInside = anchors[i] === 0x5 || offsets[i] < 0;
    } // extract data information from base mark when base mark is to be avoided
    // base mark is implicitly avoided if it is a group area


    if (marktype && (avoidBaseMark || isGroupArea)) {
      avoidMarks = [texts.map(d => d.datum)].concat(avoidMarks);
    } // generate bitmaps for layout calculation


    bitmaps = avoidMarks.length ? markBitmaps($, avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);
  } // generate label placement function


  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex, infPadding) : placeMarkLabel($, bitmaps, anchors, offsets, infPadding); // place all labels

  data.forEach(d => d.opacity = +place(d));
  return data;
}

function getOffsets(_, count) {
  const offsets = new Float64Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;

  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];

  return offsets;
}

function getAnchors(_, count) {
  const anchors = new Int8Array(count),
        n = _.length;

  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];

  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];

  return anchors;
}

function markType(item) {
  return item && item.mark && item.mark.marktype;
}
/**
 * Factory function for function for getting base mark boundary, depending
 * on mark and group type. When mark type is undefined, line or area: boundary
 * is the coordinate of each data point. When base mark is grouped line,
 * boundary is either at the beginning or end of the line depending on the
 * value of lineAnchor. Otherwise, use bounds of base mark.
 */


function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];

  if (!marktype) {
    return xy; // no reactive geometry
  } else if (marktype === 'line' || marktype === 'area') {
    return d => xy(d.datum);
  } else if (grouptype === 'line') {
    return d => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return d => {
      const b = d.datum.bounds;
      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];
    };
  }
}

const Output = ['x', 'y', 'opacity', 'align', 'baseline'];
const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];
/**
 * Compute text label layout to annotate marks.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting label data in priority order.
 * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.
 *   The available options are 'top-left', 'left', 'bottom-left', 'top',
 *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.
 * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.
 *   This parameter is parallel to the list of anchor points.
 * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.
 *   If this parameter is null, a label may exceed the layout size without any boundary.
 * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor
 *   position for labels. One of 'start' or 'end'.
 * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating
 *   which mark within the group should be labeled.
 * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label
 *   layout should avoid overlap.
 * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid
 *   overlap with the underlying base mark being labeled.
 * @param {string} [params.method='naive'] - For area make labels only, a method for
 *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.
 * @param {Array<string>} [params.as] - The output fields written by the transform.
 *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].
 */

function Label(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Label.Definition = {
  type: 'Label',
  metadata: {
    modifies: true
  },
  params: [{
    name: 'size',
    type: 'number',
    array: true,
    length: 2,
    required: true
  }, {
    name: 'sort',
    type: 'compare'
  }, {
    name: 'anchor',
    type: 'string',
    array: true,
    default: Anchors
  }, {
    name: 'offset',
    type: 'number',
    array: true,
    default: [1]
  }, {
    name: 'padding',
    type: 'number',
    default: 0,
    null: true
  }, {
    name: 'lineAnchor',
    type: 'string',
    values: ['start', 'end'],
    default: 'end'
  }, {
    name: 'markIndex',
    type: 'number',
    default: 0
  }, {
    name: 'avoidBaseMark',
    type: 'boolean',
    default: true
  }, {
    name: 'avoidMarks',
    type: 'data',
    array: true
  }, {
    name: 'method',
    type: 'string',
    default: 'naive'
  }, {
    name: 'as',
    type: 'string',
    array: true,
    length: Output.length,
    default: Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_3__.inherits)(Label, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;

    if (!_.size || _.size.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.error)('Size parameter should be specified as a [width, height] array.');
    }

    const as = _.as || Output; // run label layout

    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.offset == null ? 1 : _.offset), (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {
      // write layout results to data stream
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "./node_modules/vega-loader/build/vega-loader.browser.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-loader/build/vega-loader.browser.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "format": () => (/* binding */ format),
/* harmony export */   "formats": () => (/* binding */ formats),
/* harmony export */   "inferType": () => (/* binding */ inferType),
/* harmony export */   "inferTypes": () => (/* binding */ inferTypes),
/* harmony export */   "loader": () => (/* binding */ loader),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "responseType": () => (/* binding */ responseType),
/* harmony export */   "typeParsers": () => (/* binding */ typeParsers)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");





//   https://...    file://...    //...

const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/; // Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://

const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape

const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex
// Special treatment in node.js for the file: protocol

const fileProtocol = 'file://';
/**
 * Factory for a loader constructor that provides methods for requesting
 * files from either the network or disk, and for sanitizing request URIs.
 * @param {function} fetch - The Fetch API for HTTP network requests.
 *   If null or undefined, HTTP loading will be disabled.
 * @param {object} fs - The file system interface for file loading.
 *   If null or undefined, local file loading will be disabled.
 * @return {function} A loader constructor with the following signature:
 *   param {object} [options] - Optional default loading options to use.
 *   return {object} - A new loader instance.
 */

function loaderFactory (fetch, fs) {
  return options => ({
    options: options || {},
    sanitize: sanitize,
    load: load,
    fileAccess: !!fs,
    file: fileLoader(fs),
    http: httpLoader(fetch)
  });
}
/**
 * Load an external resource, typically either from the web or from the local
 * filesystem. This function uses {@link sanitize} to first sanitize the uri,
 * then calls either {@link http} (for web requests) or {@link file} (for
 * filesystem loading).
 * @param {string} uri - The resource indicator (e.g., URL or filename).
 * @param {object} [options] - Optional loading options. These options will
 *   override any existing default options.
 * @return {Promise} - A promise that resolves to the loaded content.
 */

async function load(uri, options) {
  const opt = await this.sanitize(uri, options),
        url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}
/**
 * URI sanitizer function.
 * @param {string} uri - The uri (url or filename) to check.
 * @param {object} options - An options hash.
 * @return {Promise} - A promise that resolves to an object containing
 *  sanitized uri data, or rejects it the input uri is deemed invalid.
 *  The properties of the resolved object are assumed to be
 *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be
 *  provided by the 'href' property of the returned object.
 */


async function sanitize(uri, options) {
  options = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options, options);
  const fileAccess = this.fileAccess,
        result = {
    href: null
  };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));

  if (uri == null || typeof uri !== 'string' || !isAllowed) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Sanitize failure, invalid URI: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(uri));
  }

  const hasProtocol = protocol_re.test(uri); // if relative url (no protocol/host), prepend baseURL

  if ((base = options.baseURL) && !hasProtocol) {
    // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    if (!uri.startsWith('/') && !base.endsWith('/')) {
      uri = '/' + uri;
    }

    uri = base + uri;
  } // should we load from file system?


  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;

  if (isFile) {
    // strip file protocol
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith('//')) {
    if (options.defaultProtocol === 'file') {
      // if is file, strip protocol and set loadFile flag
      uri = uri.slice(2);
      loadFile = true;
    } else {
      // if relative protocol (starts with '//'), prepend default protocol
      uri = (options.defaultProtocol || 'http') + ':' + uri;
    }
  } // set non-enumerable mode flag to indicate local file load


  Object.defineProperty(result, 'localFile', {
    value: !!loadFile
  }); // set uri

  result.href = uri; // set default result target, if specified

  if (options.target) {
    result.target = options.target + '';
  } // set default result rel, if specified (#1542)


  if (options.rel) {
    result.rel = options.rel + '';
  } // provide control over cross-origin image handling (#2238)
  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image


  if (options.context === 'image' && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + '';
  } // return


  return result;
}
/**
 * File system loader factory.
 * @param {object} fs - The file system interface.
 * @return {function} - A file loader with the following signature:
 *   param {string} filename - The file system path to load.
 *   param {string} filename - The file system path to load.
 *   return {Promise} A promise that resolves to the file contents.
 */


function fileLoader(fs) {
  return fs ? filename => new Promise((accept, reject) => {
    fs.readFile(filename, (error, data) => {
      if (error) reject(error);else accept(data);
    });
  }) : fileReject;
}
/**
 * Default file system loader that simply rejects.
 */


async function fileReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No file system access.');
}
/**
 * HTTP request handler factory.
 * @param {function} fetch - The Fetch API method.
 * @return {function} - An http loader with the following signature:
 *   param {string} url - The url to request.
 *   param {object} options - An options hash.
 *   return {Promise} - A promise that resolves to the file contents.
 */


function httpLoader(fetch) {
  return fetch ? async function (url, options) {
    const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options.http, options),
          type = options && options.response,
          response = await fetch(url, opt);
    return !response.ok ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(response.status + '' + response.statusText) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(response[type]) ? response[type]() : response.text();
  } : httpReject;
}
/**
 * Default http request handler that simply rejects.
 */


async function httpReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No HTTP fetch method available.');
}

const isValid = _ => _ != null && _ === _;

const isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;

const isDate = _ => !Number.isNaN(Date.parse(_));

const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);

const isInteger = _ => isNumber(_) && Number.isInteger(+_);

const typeParsers = {
  boolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  integer: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  number: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  date: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  string: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  unknown: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity
};
const typeTests = [isBoolean, isInteger, isNumber, isDate];
const typeList = ['boolean', 'integer', 'number', 'date'];
function inferType(values, field) {
  if (!values || !values.length) return 'unknown';
  const n = values.length,
        m = typeTests.length,
        a = typeTests.map((_, i) => i + 1);

  for (let i = 0, t = 0, j, value; i < n; ++i) {
    value = field ? values[i][field] : values[i];

    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value) && !typeTests[j](value)) {
        a[j] = 0;
        ++t;
        if (t === typeTests.length) return 'string';
      }
    }
  }

  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data, fields) {
  return fields.reduce((types, field) => {
    types[field] = inferType(data, field);
    return types;
  }, {});
}

function delimitedFormat(delimiter) {
  const parse = function (data, format) {
    const delim = {
      delimiter: delimiter
    };
    return dsv(data, format ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(format, delim) : delim);
  };

  parse.responseType = 'text';
  return parse;
}
function dsv(data, format) {
  if (format.header) {
    data = format.header.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(format.delimiter) + '\n' + data;
  }

  return (0,d3_dsv__WEBPACK_IMPORTED_MODULE_3__.default)(format.delimiter).parse(data + '');
}
dsv.responseType = 'text';

function isBuffer(_) {
  return typeof Buffer === 'function' && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}

function json(data, format) {
  const prop = format && format.property ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(format.property) : vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));
}
json.responseType = 'json';

function parseJSON(data, format) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    data = [...data];
  }

  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;
}

const filters = {
  interior: (a, b) => a !== b,
  exterior: (a, b) => a === b
};
function topojson(data, format) {
  let method, object, property, filter;
  data = json(data, format);

  if (format && format.feature) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.feature;
    property = format.feature;
  } else if (format && format.mesh) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.mesh;
    property = format.mesh;
    filter = filters[format.filter];
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing TopoJSON feature or mesh parameter.');
  }

  object = (object = data.objects[property]) ? method(data, object, filter) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid TopoJSON object: ' + property);
  return object && object.features || [object];
}
topojson.responseType = 'json';

const format = {
  dsv: dsv,
  csv: delimitedFormat(','),
  tsv: delimitedFormat('\t'),
  json: json,
  topojson: topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format[name] = reader;
    return this;
  } else {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(format, name) ? format[name] : null;
  }
}
function responseType(type) {
  const f = formats(type);
  return f && f.responseType || 'text';
}

function read (data, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || 'json');
  if (!reader) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown data format type: ' + schema.type);
  data = reader(data, schema);
  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, 'columns')) delete data.columns;
  return data;
}

function parse(data, types, timeParser, utcParser) {
  if (!data.length) return; // early exit for empty data

  const locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.timeFormatDefaultLocale)();
  timeParser = timeParser || locale.timeParse;
  utcParser = utcParser || locale.utcParse;
  let fields = data.columns || Object.keys(data[0]),
      datum,
      field,
      i,
      j,
      n,
      m;
  if (types === 'auto') types = inferTypes(data, fields);
  fields = Object.keys(types);
  const parsers = fields.map(field => {
    const type = types[field];
    let parts, pattern;

    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {
      parts = type.split(/:(.+)?/, 2); // split on first :

      pattern = parts[1];

      if (pattern[0] === '\'' && pattern[pattern.length - 1] === '\'' || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }

      const parse = parts[0] === 'utc' ? utcParser : timeParser;
      return parse(pattern);
    }

    if (!typeParsers[type]) {
      throw Error('Illegal format pattern: ' + field + ':' + type);
    }

    return typeParsers[type];
  });

  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {
    datum = data[i];

    for (j = 0; j < m; ++j) {
      field = fields[j];
      datum[field] = parsers[j](datum[field]);
    }
  }
}

const loader = loaderFactory(typeof fetch !== 'undefined' && fetch, // use built-in fetch API
null // no file system access
);




/***/ }),

/***/ "./node_modules/vega-parser/build/vega-parser.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-parser/build/vega-parser.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AxisDomainRole": () => (/* binding */ AxisDomainRole),
/* harmony export */   "AxisGridRole": () => (/* binding */ AxisGridRole),
/* harmony export */   "AxisLabelRole": () => (/* binding */ AxisLabelRole),
/* harmony export */   "AxisRole": () => (/* binding */ AxisRole),
/* harmony export */   "AxisTickRole": () => (/* binding */ AxisTickRole),
/* harmony export */   "AxisTitleRole": () => (/* binding */ AxisTitleRole),
/* harmony export */   "DataScope": () => (/* binding */ DataScope),
/* harmony export */   "FrameRole": () => (/* binding */ FrameRole),
/* harmony export */   "LegendEntryRole": () => (/* binding */ LegendEntryRole),
/* harmony export */   "LegendLabelRole": () => (/* binding */ LegendLabelRole),
/* harmony export */   "LegendRole": () => (/* binding */ LegendRole),
/* harmony export */   "LegendSymbolRole": () => (/* binding */ LegendSymbolRole),
/* harmony export */   "LegendTitleRole": () => (/* binding */ LegendTitleRole),
/* harmony export */   "MarkRole": () => (/* binding */ MarkRole),
/* harmony export */   "Scope": () => (/* binding */ Scope),
/* harmony export */   "ScopeRole": () => (/* binding */ ScopeRole),
/* harmony export */   "config": () => (/* binding */ defaults),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "signal": () => (/* binding */ parseSignal),
/* harmony export */   "signalUpdates": () => (/* binding */ parseSignalUpdates),
/* harmony export */   "stream": () => (/* binding */ parseStream)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-event-selector */ "./node_modules/vega-event-selector/build/vega-event-selector.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");






function parseAutosize (spec) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : {
    type: spec || 'pad'
  };
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function parsePadding (spec) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {
    top: number(spec.top),
    bottom: number(spec.bottom),
    left: number(spec.left),
    right: number(spec.right)
  };
}

const encoder = _ => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _) : {
  value: _
};
function addEncode(object, name, value, set) {
  if (value != null) {
    const isEncoder = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) && value.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[0]); // Always assign signal to update, even if the signal is from the enter block

    if (isEncoder) {
      object.update[name] = value;
    } else {
      object[set || 'enter'][name] = {
        value: value
      };
    }

    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object, enter, update) {
  for (const name in enter) {
    addEncode(object, name, enter[name]);
  }

  for (const name in update) {
    addEncode(object, name, update[name], 'update');
  }
}
function extendEncode(encode, extra, skip) {
  for (const name in extra) {
    if (skip && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(skip, name)) continue;
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(encode[name] || {}, extra[name]);
  }

  return encode;
}
function has(key, encode) {
  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);
}

const MarkRole = 'mark';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const AxisRole = 'axis';
const AxisDomainRole = 'axis-domain';
const AxisGridRole = 'axis-grid';
const AxisLabelRole = 'axis-label';
const AxisTickRole = 'axis-tick';
const AxisTitleRole = 'axis-title';
const LegendRole = 'legend';
const LegendBandRole = 'legend-band';
const LegendEntryRole = 'legend-entry';
const LegendGradientRole = 'legend-gradient';
const LegendLabelRole = 'legend-label';
const LegendSymbolRole = 'legend-symbol';
const LegendTitleRole = 'legend-title';
const TitleRole = 'title';
const TitleTextRole = 'title-text';
const TitleSubtitleRole = 'title-subtitle';

function applyDefaults (encode, type, role, style, config) {
  const defaults = {},
        enter = {};
  let update, key, skip, props; // if text mark, apply global lineBreak settings (#2370)

  key = 'lineBreak';

  if (type === 'text' && config[key] != null && !has(key, encode)) {
    applyDefault(defaults, key, config[key]);
  } // ignore legend and axis roles


  if (role == 'legend' || String(role).startsWith('axis')) {
    role = null;
  } // resolve mark config


  props = role === FrameRole ? config.group : role === MarkRole ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, config.mark, config[type]) : null;

  for (key in props) {
    // do not apply defaults if relevant fields are defined
    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));
    if (!skip) applyDefault(defaults, key, props[key]);
  } // resolve styles, apply with increasing precedence


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(style).forEach(name => {
    const props = config.style && config.style[name];

    for (const key in props) {
      if (!has(key, encode)) {
        applyDefault(defaults, key, props[key]);
      }
    }
  });
  encode = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, encode); // defensive copy

  for (key in defaults) {
    props = defaults[key];

    if (props.signal) {
      (update = update || {})[key] = props;
    } else {
      enter[key] = props;
    }
  }

  encode.enter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(enter, encode.enter);
  if (update) encode.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(update, encode.update);
  return encode;
}

function applyDefault(defaults, key, value) {
  defaults[key] = value && value.signal ? {
    signal: value.signal
  } : {
    value: value
  };
}

const scaleRef = scale => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(scale) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(scale) : scale.signal ? `(${scale.signal})` : field(scale);

function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient(enc);
  }

  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(enc.value) : undefined;

  if (enc.scale != null) {
    value = scale(enc, value);
  }

  if (value === undefined) {
    value = null;
  }

  if (enc.exponent != null) {
    value = `pow(${value},${property(enc.exponent)})`;
  }

  if (enc.mult != null) {
    value += `*${property(enc.mult)}`;
  }

  if (enc.offset != null) {
    value += `+${property(enc.offset)}`;
  }

  if (enc.round) {
    value = `round(${value})`;
  }

  return value;
}

const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;

function color(enc) {
  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;
}

function gradient(enc) {
  // map undefined to null; expression lang does not allow undefined
  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_)); // trim null inputs from the end

  while (args.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args) == null) args.pop();

  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(',')})`;
}

function property(property) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) ? '(' + entry$1(property) + ')' : property;
}

function field(ref) {
  return resolveField((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(ref) ? ref : {
    datum: ref
  });
}

function resolveField(ref) {
  let object, level, field;

  if (ref.signal) {
    object = 'datum';
    field = ref.signal;
  } else if (ref.group || ref.parent) {
    level = Math.max(1, ref.level || 1);
    object = 'item';

    while (level-- > 0) {
      object += '.mark.group';
    }

    if (ref.parent) {
      field = ref.parent;
      object += '.datum';
    } else {
      field = ref.group;
    }
  } else if (ref.datum) {
    object = 'datum';
    field = ref.datum;
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ref));
  }

  if (!ref.signal) {
    field = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath)(field).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join('][') : resolveField(field);
  }

  return object + '[' + field + ']';
}

function scale(enc, value) {
  const scale = scaleRef(enc.scale);

  if (enc.range != null) {
    // pull value from scale range
    value = `lerp(_range(${scale}), ${+enc.range})`;
  } else {
    // run value through scale and/or pull scale bandwidth
    if (value !== undefined) value = `_scale(${scale}, ${value})`;

    if (enc.band) {
      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));

      if (enc.extra) {
        // include logic to handle extraneous elements
        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;
      }
    }

    if (value == null) value = '0';
  }

  return value;
}

function rule (enc) {
  let code = '';
  enc.forEach(rule => {
    const value = entry$1(rule);
    code += rule.test ? `(${rule.test})?${value}:` : value;
  }); // if no else clause, terminate with null (#1366)

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(code) === ':') {
    code += 'null';
  }

  return code;
}

function parseEncode (encode, type, role, style, scope, params) {
  const enc = {};
  params = params || {};
  params.encoders = {
    $encode: enc
  };
  encode = applyDefaults(encode, type, role, style, scope.config);

  for (const key in encode) {
    enc[key] = parseBlock(encode[key], type, params, scope);
  }

  return params;
}

function parseBlock(block, marktype, params, scope) {
  const channels = {},
        fields = {};

  for (const name in block) {
    if (block[name] != null) {
      // skip any null entries
      channels[name] = parse$1(expr(block[name]), scope, params, fields);
    }
  }

  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}

function expr(enc) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(enc) ? rule(enc) : entry$1(enc);
}

function parse$1(code, scope, params, fields) {
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, scope);
  expr.$fields.forEach(name => fields[name] = 1);
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(params, expr.$params);
  return expr.$expr;
}

const OUTER = 'outer',
      OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];

function outerError(prefix, name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(prefix + ' for "outer" push: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function parseSignal (signal, scope) {
  const name = signal.name;

  if (signal.push === OUTER) {
    // signal must already be defined, raise error if not
    if (!scope.signals[name]) outerError('No prior signal definition', name); // signal push must not use properties reserved for standard definition

    OUTER_INVALID.forEach(prop => {
      if (signal[prop] !== undefined) outerError('Invalid property ', prop);
    });
  } else {
    // define a new signal in the current scope
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name, signal.bind);
  }
}

function Entry(type, value, params, parent) {
  this.id = -1;
  this.type = type;
  this.value = value;
  this.params = params;
  if (parent) this.parent = parent;
}
function entry(type, value, params, parent) {
  return new Entry(type, value, params, parent);
}
function operator(value, params) {
  return entry('operator', value, params);
} // -----

function ref(op) {
  const ref = {
    $ref: op.id
  }; // if operator not yet registered, cache ref to resolve later

  if (op.id < 0) (op.refs = op.refs || []).push(ref);
  return ref;
}
function fieldRef$1(field, name) {
  return name ? {
    $field: field,
    $name: name
  } : {
    $field: field
  };
}
const keyFieldRef = fieldRef$1('key');
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref = {
    $key: fields
  };
  if (flat) ref.$flat = true;
  return ref;
} // -----

const Ascending = 'ascending';
const Descending = 'descending';
function sortKey(sort) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);
}
function aggrField(op, field) {
  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');
} // -----

const Scope$1 = 'scope';
const View = 'view';
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_)) for (const key in _) {
    if (hasSignal(_[key])) return true;
  }
  return false;
}
function value(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}

const Timer = 'timer';
function parseStream(stream, scope) {
  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream specification: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
  return method(stream, scope);
}

function eventSource(source) {
  return source === Scope$1 ? View : source || View;
}

function mergeStream(stream, scope) {
  const list = stream.merge.map(s => parseStream(s, scope)),
        entry = streamParameters({
    merge: list
  }, stream, scope);
  return scope.addStream(entry).id;
}

function nestedStream(stream, scope) {
  const id = parseStream(stream.stream, scope),
        entry = streamParameters({
    stream: id
  }, stream, scope);
  return scope.addStream(entry).id;
}

function eventStream(stream, scope) {
  let id;

  if (stream.type === Timer) {
    id = scope.event(Timer, stream.throttle);
    stream = {
      between: stream.between,
      filter: stream.filter
    };
  } else {
    id = scope.event(eventSource(stream.source), stream.type);
  }

  const entry = streamParameters({
    stream: id
  }, stream, scope);
  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;
}

function streamParameters(entry, stream, scope) {
  let param = stream.between;

  if (param) {
    if (param.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Stream "between" parameter must have 2 entries: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
    }

    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];
  }

  param = stream.filter ? [].concat(stream.filter) : [];

  if (stream.marktype || stream.markname || stream.markrole) {
    // add filter for mark type, name and/or role
    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));
  }

  if (stream.source === Scope$1) {
    // add filter to limit events from sub-scope only
    param.push('inScope(event.item)');
  }

  if (param.length) {
    entry.filter = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)('(' + param.join(')&&(') + ')', scope).$expr;
  }

  if ((param = stream.throttle) != null) {
    entry.throttle = +param;
  }

  if ((param = stream.debounce) != null) {
    entry.debounce = +param;
  }

  if (stream.consume) {
    entry.consume = true;
  }

  return entry;
}

function filterMark(type, name, role) {
  const item = 'event.item';
  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\'' + type + '\'' : '') + (role ? '&&' + item + '.mark.role===\'' + role + '\'' : '') + (name ? '&&' + item + '.mark.name===\'' + name + '\'' : '');
}

const OP_VALUE_EXPR = {
  code: '_.$value',
  ast: {
    type: 'Identifier',
    value: 'value'
  }
};
function parseUpdate (spec, scope, target) {
  const encode = spec.encode,
        entry = {
    target: target
  };
  let events = spec.events,
      update = spec.update,
      sources = [];

  if (!events) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal update missing events specification.');
  } // interpret as an event selector string


  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(events)) {
    events = (0,vega_event_selector__WEBPACK_IMPORTED_MODULE_2__.parseSelector)(events, scope.isSubscope() ? Scope$1 : View);
  } // separate event streams from signal updates


  events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1); // merge internal operator listeners

  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  } // merge event streams, include as source


  if (events.length) {
    sources.push(events.length > 1 ? {
      merge: events
    } : events[0]);
  }

  if (encode != null) {
    if (update) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal encode and update are mutually exclusive.');
    update = 'encode(item(),' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(encode) + ')';
  } // resolve update value


  entry.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(update) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope) : update.expr != null ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update.signal)
    }
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid signal update specification.');

  if (spec.force) {
    entry.options = {
      force: true
    };
  }

  sources.forEach(source => scope.addUpdate((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(streamSource(source, scope), entry)));
}

function streamSource(stream, scope) {
  return {
    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)
  };
}

function mergeSources(sources) {
  return {
    signal: '[' + sources.map(s => s.scale ? 'scale("' + s.scale + '")' : s.signal) + ']'
  };
}

function parseSignalUpdates (signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr = signal.update;

  if (signal.init) {
    if (expr) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signals can not include both init and update expressions.');
    } else {
      expr = signal.init;
      op.initonly = true;
    }
  }

  if (expr) {
    expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr, scope);
    op.update = expr.$expr;
    op.params = expr.$params;
  }

  if (signal.on) {
    signal.on.forEach(_ => parseUpdate(_, scope, op.id));
  }
}

const transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);

const Aggregate = transform('aggregate');
const AxisTicks = transform('axisticks');
const Bound = transform('bound');
const Collect = transform('collect');
const Compare = transform('compare');
const DataJoin = transform('datajoin');
const Encode = transform('encode');
const Expression = transform('expression');
const Facet = transform('facet');
const Field = transform('field');
const Key = transform('key');
const LegendEntries = transform('legendentries');
const Load = transform('load');
const Mark = transform('mark');
const MultiExtent = transform('multiextent');
const MultiValues = transform('multivalues');
const Overlap = transform('overlap');
const Params = transform('params');
const PreFacet = transform('prefacet');
const Projection = transform('projection');
const Proxy = transform('proxy');
const Relay = transform('relay');
const Render = transform('render');
const Scale = transform('scale');
const Sieve = transform('sieve');
const SortItems = transform('sortitems');
const ViewLayout = transform('viewlayout');
const Values = transform('values');

let FIELD_REF_ID = 0;
const MULTIDOMAIN_SORT_OPS = {
  min: 'min',
  max: 'max',
  count: 'sum'
};
function initScale(spec, scope) {
  const type = spec.type || 'linear';

  if (!(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isValidScaleType)(type)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(type));
  }

  scope.addScale(spec.name, {
    type,
    domain: undefined
  });
}
function parseScale(spec, scope) {
  const params = scope.getScale(spec.name).params;
  let key;
  params.domain = parseScaleDomain(spec.domain, spec, scope);

  if (spec.range != null) {
    params.range = parseScaleRange(spec, scope, params);
  }

  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params);
  }

  if (spec.nice != null) {
    params.nice = parseScaleNice(spec.nice);
  }

  if (spec.bins != null) {
    params.bins = parseScaleBins(spec.bins, scope);
  }

  for (key in spec) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, key) || key === 'name') continue;
    params[key] = parseLiteral(spec[key], scope);
  }
}

function parseLiteral(v, scope) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(v) ? v : v.signal ? scope.signalRef(v.signal) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v));
}

function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));
}

function dataLookupError(name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Can not find data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
} // -- SCALE DOMAIN ----


function parseScaleDomain(domain, spec, scope) {
  if (!domain) {
    if (spec.domainMin != null || spec.domainMax != null) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No scale domain defined for domainMin/domainMax to override.');
    }

    return; // default domain
  }

  return domain.signal ? scope.signalRef(domain.signal) : ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);
}

function explicitDomain(domain, spec, scope) {
  return domain.map(v => parseLiteral(v, scope));
}

function singularDomain(domain, spec, scope) {
  const data = scope.getData(domain.data);
  if (!data) dataLookupError(domain.data);
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);
}

function multipleDomain(domain, spec, scope) {
  const data = domain.data,
        fields = domain.fields.reduce((dom, d) => {
    d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(d) ? {
      data: data,
      field: d
    } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(d) || d.signal ? fieldRef(d, scope) : d;
    dom.push(d);
    return dom;
  }, []);
  return ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? ordinalMultipleDomain : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);
}

function fieldRef(data, scope) {
  const name = '_:vega:_' + FIELD_REF_ID++,
        coll = Collect({});

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data)) {
    coll.value = {
      $ingest: data
    };
  } else if (data.signal) {
    const code = 'setdata(' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ',' + data.signal + ')';
    coll.params.input = scope.signalRef(code);
  }

  scope.addDataPipeline(name, [coll, Sieve({})]);
  return {
    data: name,
    field: 'data'
  };
}

function ordinalMultipleDomain(domain, scope, fields) {
  const sort = parseSort(domain.sort, true);
  let a, v; // get value counts for each domain field

  const counts = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.countsRef(scope, f.field, sort);
  }); // aggregate the results from each domain field

  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };

  if (sort) {
    a = sort.op || 'count';
    v = sort.field ? aggrField(a, sort.field) : 'count';
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }

  a = scope.add(Aggregate(p)); // collect aggregate output

  const c = scope.add(Collect({
    pulse: ref(a)
  })); // extract values for combined domain

  v = scope.add(Values({
    field: keyFieldRef,
    sort: scope.sortRef(sort),
    pulse: ref(c)
  }));
  return ref(v);
}

function parseSort(sort, multidomain) {
  if (sort) {
    if (!sort.field && !sort.op) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort)) sort.field = 'key';else sort = {
        field: 'key'
      };
    } else if (!sort.field && sort.op !== 'count') {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No field provided for sort aggregate op: ' + sort.op);
    } else if (multidomain && sort.field) {
      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multiple domain scales can not be sorted using ' + sort.op);
      }
    }
  }

  return sort;
}

function quantileMultipleDomain(domain, scope, fields) {
  // get value arrays for each domain field
  const values = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.domainRef(scope, f.field);
  }); // combine value arrays

  return ref(scope.add(MultiValues({
    values: values
  })));
}

function numericMultipleDomain(domain, scope, fields) {
  // get extents for each domain field
  const extents = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.extentRef(scope, f.field);
  }); // combine extents

  return ref(scope.add(MultiExtent({
    extents: extents
  })));
} // -- SCALE BINS -----


function parseScaleBins(v, scope) {
  return v.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray(v, scope) : scope.objectProperty(v);
} // -- SCALE NICE -----


function parseScaleNice(nice) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(nice) ? {
    interval: parseLiteral(nice.interval),
    step: parseLiteral(nice.step)
  } : parseLiteral(nice);
} // -- SCALE INTERPOLATION -----


function parseScaleInterpolate(interpolate, params) {
  params.interpolate = parseLiteral(interpolate.type || interpolate);

  if (interpolate.gamma != null) {
    params.interpolateGamma = parseLiteral(interpolate.gamma);
  }
} // -- SCALE RANGE -----


function parseScaleRange(spec, scope, params) {
  const config = scope.config.range;
  let range = spec.range;

  if (range.signal) {
    return scope.signalRef(range.signal);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(range)) {
    if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, range)) {
      spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec, {
        range: config[range]
      });
      return parseScaleRange(spec, scope, params);
    } else if (range === 'width') {
      range = [0, {
        signal: 'width'
      }];
    } else if (range === 'height') {
      range = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? [0, {
        signal: 'height'
      }] : [{
        signal: 'height'
      }, 0];
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale range value: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
    }
  } else if (range.scheme) {
    params.scheme = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);
    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);
    if (range.count) params.schemeCount = parseLiteral(range.count, scope);
    return;
  } else if (range.step) {
    params.rangeStep = parseLiteral(range.step, scope);
    return;
  } else if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    return parseScaleDomain(range, spec, scope);
  } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported range type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
  }

  return range.map(v => ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray : parseLiteral)(v, scope));
}

function parseProjection (proj, scope) {
  const config = scope.config.projection || {},
        params = {};

  for (const name in proj) {
    if (name === 'name') continue;
    params[name] = parseParameter$1(proj[name], name, scope);
  } // apply projection defaults from config


  for (const name in config) {
    if (params[name] == null) {
      params[name] = parseParameter$1(config[name], name, scope);
    }
  }

  scope.addProjection(proj.name, params);
}

function parseParameter$1(_, name, scope) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_));
}

const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const Center = 'center';
const Vertical = 'vertical';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const Index = 'index';
const Label = 'label';
const Offset = 'offset';
const Perc = 'perc';
const Perc2 = 'perc2';
const Value = 'value';
const GuideLabelStyle = 'guide-label';
const GuideTitleStyle = 'guide-title';
const GroupTitleStyle = 'group-title';
const GroupSubtitleStyle = 'group-subtitle';
const Symbols = 'symbol';
const Gradient = 'gradient';
const Discrete = 'discrete';
const Size = 'size';
const Shape = 'shape';
const Fill = 'fill';
const Stroke = 'stroke';
const StrokeWidth = 'strokeWidth';
const StrokeDash = 'strokeDash';
const Opacity = 'opacity'; // Encoding channels supported by legends
// In priority order of 'canonical' scale

const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
const Skip = {
  name: 1,
  style: 1,
  interactive: 1
};
const zero = {
  value: 0
};
const one = {
  value: 1
};

const GroupMark = 'group';
const RectMark = 'rect';
const RuleMark = 'rule';
const SymbolMark = 'symbol';
const TextMark = 'text';

function guideGroup (mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}

function lookup(spec, config) {
  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));

  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));

  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);

  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);

  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));

  return _;
}
function getEncoding(name, encode) {
  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style) {
  const s = scope.config.style[style];
  return s && s[name];
}
function anchorExpr(s, e, m) {
  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;
}
const alignExpr$1 = anchorExpr((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Left), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Right), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Center));
function tickBand(_) {
  const v = _('tickBand');

  let offset = _('tickOffset'),
      band,
      extra;

  if (!v) {
    // if no tick band entry, fall back on other properties
    band = _('bandPosition');
    extra = _('tickExtra');
  } else if (v.signal) {
    // if signal, augment code to interpret values
    band = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
      offset = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`
      };
    }
  } else if (v === 'extent') {
    // if constant, simply set values
    band = 1;
    extra = true;
    offset = 0;
  } else {
    band = 0.5;
    extra = false;
  }

  return {
    extra,
    band,
    offset
  };
}
function extendOffset(value, offset) {
  return !offset ? value : !value ? offset : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? {
    value,
    offset
  } : Object.assign({}, value, {
    offset: extendOffset(value.offset, offset)
  });
}

function guideMark (mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip);
  } else {
    mark.interactive = false;
  }

  return mark;
}

function legendGradient (spec, scale, config, userEncode) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let enter, start, stop, width, height;

  if (vertical) {
    start = [0, 1];
    stop = [0, 0];
    width = thickness;
    height = length;
  } else {
    start = [0, 0];
    stop = [1, 0];
    width = length;
    height = thickness;
  }

  const encode = {
    enter: enter = {
      opacity: zero,
      x: zero,
      y: zero,
      width: encoder(width),
      height: encoder(height)
    },
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      fill: {
        gradient: scale,
        start: start,
        stop: stop
      }
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode
  }, userEncode);
}

function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = _.gradientThickness(),
        length = _.gradientLength();

  let u,
      v,
      uu,
      vv,
      adjust = '';
  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');
  const enter = {
    opacity: zero,
    fill: {
      scale: scale,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = zero;
  enter[uu] = {
    signal: adjust + 'datum.' + Perc2,
    mult: length
  };
  enter[vv] = encoder(thickness);
  const encode = {
    enter: enter,
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`,
      baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        vertical = _.isVertical(),
        thickness = encoder(_.gradientThickness()),
        length = _.gradientLength();

  let overlap = _('labelOverlap'),
      enter,
      update,
      u,
      v,
      adjust = '';

  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: value(spec.labelLimit, config.gradientLabelLimit)
  });

  if (vertical) {
    enter.align = {
      value: 'left'
    };
    enter.baseline = update.baseline = {
      signal: baselineExpr
    };
    u = 'y';
    v = 'x';
    adjust = '1-';
  } else {
    enter.align = update.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: 'top'
    };
    u = 'x';
    v = 'y';
  }

  enter[u] = update[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = update[v] = thickness;
  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.' + Index
  } : undefined; // type, role, style, key, dataRef, encode, extras

  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {
  const _ = lookup(spec, config),
        entries = userEncode.entries,
        interactive = !!(entries && entries.interactive),
        name = entries ? entries.name : undefined,
        height = _('clipHeight'),
        symbolOffset = _('symbolOffset'),
        valueRef = {
    data: 'value'
  },
        xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,
        yEncode = height ? encoder(height) : {
    field: Size
  },
        index = `datum.${Index}`,
        ncols = `max(1, ${columns})`;

  let encode, enter, update, nrows, sort;
  yEncode.mult = 0.5; // -- LEGEND SYMBOLS --

  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  let baseFill = null,
      baseStroke = null;

  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }

  addEncoders(encode, {
    fill: _('symbolFillColor', baseFill),
    shape: _('symbolType'),
    size: _('symbolSize'),
    stroke: _('symbolStrokeColor', baseStroke),
    strokeDash: _('symbolDash'),
    strokeDashOffset: _('symbolDashOffset'),
    strokeWidth: _('symbolStrokeWidth')
  }, {
    // update
    opacity: _('symbolOpacity')
  });
  LegendScales.forEach(scale => {
    if (spec[scale]) {
      update[scale] = enter[scale] = {
        scale: spec[scale],
        field: Value
      };
    }
  });
  const symbols = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height ? true : undefined,
    encode
  }, userEncode.symbols); // -- LEGEND LABELS --

  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _('labelOffset');
  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    align: _('labelAlign'),
    baseline: _('labelBaseline'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: _('labelLimit')
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode
  }, userEncode.labels); // -- LEGEND ENTRY GROUPS --

  encode = {
    enter: {
      noBound: {
        value: !height
      },
      // ignore width/height in bounds calc
      width: zero,
      height: height ? encoder(height) : zero,
      opacity: zero
    },
    exit: {
      opacity: zero
    },
    update: update = {
      opacity: one,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }; // annotate and sort groups to ensure correct ordering

  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update.row.signal = `${index}%${nrows}`;
    update.column.signal = `floor(${index} / ${nrows})`;
    sort = {
      field: ['row', index]
    };
  } else {
    update.row.signal = `floor(${index} / ${ncols})`;
    update.column.signal = `${index} % ${ncols}`;
    sort = {
      field: index
    };
  } // handle zero column case (implies infinite columns)


  update.column.signal = `(${columns})?${update.column.signal}:${index}`; // facet legend entries into sub-groups

  dataRef = {
    facet: {
      data: dataRef,
      name: 'value',
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole,
    from: dataRef,
    encode: extendEncode(encode, entries, Skip),
    marks: [symbols, labels],
    name,
    interactive,
    sort
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup(spec, config); // layout parameters for legend entries


  return {
    align: _('gridAlign'),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _('rowPadding'),
      column: _('columnPadding')
    }
  };
}

const isL = 'item.orient === "left"',
      isR = 'item.orient === "right"',
      isLR = `(${isL} || ${isR})`,
      isVG = `datum.vgrad && ${isLR}`,
      baseline = anchorExpr('"top"', '"bottom"', '"middle"'),
      alignFlip = anchorExpr('"right"', '"left"', '"center"'),
      exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`,
      exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`,
      exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,
      exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config);

  const encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: one,
      x: {
        field: {
          group: 'padding'
        }
      },
      y: {
        field: {
          group: 'padding'
        }
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    orient: _('titleOrient'),
    _anchor: _('titleAnchor'),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    baseline: _('titleBaseline')
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function clip (clip, scope) {
  let expr;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(clip)) {
    if (clip.signal) {
      expr = clip.signal;
    } else if (clip.path) {
      expr = 'pathShape(' + param(clip.path) + ')';
    } else if (clip.sphere) {
      expr = 'geoShape(' + param(clip.sphere) + ', {type: "Sphere"})';
    }
  }

  return expr ? scope.signalRef(expr) : !!clip;
}

function param(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && value.signal ? value.signal : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value);
}

function getRole (spec) {
  const role = spec.role || '';
  return !role.indexOf('axis') || !role.indexOf('legend') || !role.indexOf('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
}

function definition (spec) {
  return {
    marktype: spec.type,
    name: spec.name || undefined,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || undefined,
    aria: spec.aria,
    description: spec.description
  };
}

function interactive (spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}

/**
 * Parse a data transform specification.
 */

function parseTransform (spec, scope) {
  const def = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_4__.definition)(spec.type);
  if (!def) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized transform type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type));
  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def.metadata || {};
  return t;
}
/**
 * Parse all parameters of a data transform.
 */

function parseParameters(def, spec, scope) {
  const params = {},
        n = def.params.length;

  for (let i = 0; i < n; ++i) {
    const pdef = def.params[i];
    params[pdef.name] = parseParameter(pdef, spec, scope);
  }

  return params;
}
/**
 * Parse a data transform parameter.
 */


function parseParameter(def, spec, scope) {
  const type = def.type,
        value = spec[def.name];

  if (type === 'index') {
    return parseIndexParameter(def, spec, scope);
  } else if (value === undefined) {
    if (def.required) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing required ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type) + ' parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(def.name));
    }

    return;
  } else if (type === 'param') {
    return parseSubParameters(def, spec, scope);
  } else if (type === 'projection') {
    return scope.projectionRef(spec[def.name]);
  }

  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);
}
/**
 * Parse a single parameter value.
 */


function parameterValue(def, value, scope) {
  const type = def.type;

  if (isSignal(value)) {
    return isExpr(type) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);
  } else {
    const expr = def.expr || isField(type);
    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;
  }
}
/**
 * Parse parameter for accessing an index of another data set.
 */


function parseIndexParameter(def, spec, scope) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec.from)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Lookup "from" parameter must be a string literal.');
  }

  return scope.getData(spec.from).lookupRef(scope, spec.key);
}
/**
 * Parse a parameter that contains one or more sub-parameter objects.
 */


function parseSubParameters(def, spec, scope) {
  const value = spec[def.name];

  if (def.array) {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
      // signals not allowed!
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expected an array of sub-parameters. Instead: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
    }

    return value.map(v => parseSubParameter(def, v, scope));
  } else {
    return parseSubParameter(def, value, scope);
  }
}
/**
 * Parse a sub-parameter object.
 */


function parseSubParameter(def, value, scope) {
  const n = def.params.length;
  let pdef; // loop over defs to find matching key

  for (let i = 0; i < n; ++i) {
    pdef = def.params[i];

    for (const k in pdef.key) {
      if (pdef.key[k] !== value[k]) {
        pdef = null;
        break;
      }
    }

    if (pdef) break;
  } // raise error if matching key not found


  if (!pdef) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value)); // parse params, create Params transform, return ref

  const params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(parseParameters(pdef, value, scope), pdef.key);
  return ref(scope.add(Params(params)));
} // -- Utilities -----


const outerExpr = _ => _ && _.expr;
const outerField = _ => _ && _.field;
const isData = _ => _ === 'data';
const isExpr = _ => _ === 'expr';
const isField = _ => _ === 'field';
const isCompare = _ => _ === 'compare';

function parseData$1 (from, group, scope) {
  let facet, key, op, dataRef, parent; // if no source data, generate singleton datum

  if (!from) {
    dataRef = ref(scope.add(Collect(null, [{}])));
  } // if faceted, process facet specification
  else if (facet = from.facet) {
    if (!group) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only group marks can be faceted.'); // use pre-faceted source data, if available

    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      // generate facet aggregates if no direct data specification
      if (!from.data) {
        op = parseTransform((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
          type: 'aggregate',
          groupby: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }

      key = scope.keyRef(facet.groupby, true);
    }
  } // if not yet defined, get source data reference


  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }

  return {
    key: key,
    pulse: dataRef,
    parent: parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}

function DataScope(scope, input, output, values, aggr) {
  this.scope = scope; // parent scope object

  this.input = input; // first operator in pipeline (tuple input)

  this.output = output; // last operator in pipeline (tuple output)

  this.values = values; // operator for accessing tuples (but not tuple flow)
  // last aggregate in transform pipeline

  this.aggregate = aggr; // lookup table of field indices

  this.index = {};
}

DataScope.fromEntries = function (scope, entries) {
  const n = entries.length,
        values = entries[n - 1],
        output = entries[n - 2];
  let input = entries[0],
      aggr = null,
      i = 1;

  if (input && input.type === 'load') {
    input = entries[1];
  } // add operator entries to this scope, wire up pulse chain


  scope.add(entries[0]);

  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === 'aggregate') aggr = entries[i];
  }

  return new DataScope(scope, input, output, values, aggr);
};

function fieldKey(field) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? field : null;
}

function addSortField(scope, p, sort) {
  const as = aggrField(sort.op, sort.field);
  let s;

  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ['count'];
    p.fields = [null];
    p.as = ['count'];
  }

  if (sort.op) {
    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);
    p.fields.push(scope.fieldRef(sort.field));
    p.as.push(as);
  }
}

function cache(scope, ds, name, optype, field, counts, index) {
  const cache = ds[name] || (ds[name] = {}),
        sort = sortKey(counts);
  let k = fieldKey(field),
      v,
      op;

  if (k != null) {
    scope = ds.scope;
    k = k + (sort ? '|' + sort : '');
    v = cache[k];
  }

  if (!v) {
    const params = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field, counts)
    } : {
      field: scope.fieldRef(field),
      pulse: ref(ds.output)
    };
    if (sort) params.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, undefined, params));
    if (index) ds.index[field] = op;
    v = ref(op);
    if (k != null) cache[k] = v;
  }

  return v;
}

DataScope.prototype = {
  countsRef(scope, field, sort) {
    const ds = this,
          cache = ds.counts || (ds.counts = {}),
          k = fieldKey(field);
    let v, a, p;

    if (k != null) {
      scope = ds.scope;
      v = cache[k];
    }

    if (!v) {
      p = {
        groupby: scope.fieldRef(field, 'key'),
        pulse: ref(ds.output)
      };
      if (sort && sort.field) addSortField(scope, p, sort);
      a = scope.add(Aggregate(p));
      v = scope.add(Collect({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k != null) cache[k] = v;
    } else if (sort && sort.field) {
      addSortField(scope, v.agg.params, sort);
    }

    return v.ref;
  },

  tuplesRef() {
    return ref(this.values);
  },

  extentRef(scope, field) {
    return cache(scope, this, 'extent', 'extent', field, false);
  },

  domainRef(scope, field) {
    return cache(scope, this, 'domain', 'values', field, false);
  },

  valuesRef(scope, field, sort) {
    return cache(scope, this, 'vals', 'values', field, sort || true);
  },

  lookupRef(scope, field) {
    return cache(scope, this, 'lookup', 'tupleindex', field, false);
  },

  indataRef(scope, field) {
    return cache(scope, this, 'indata', 'tupleindex', field, true, true);
  }

};

function parseFacet (spec, scope, group) {
  const facet = spec.from.facet,
        name = facet.name,
        data = getDataRef(facet, scope);
  let op;

  if (!facet.name) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must have a name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (!facet.data) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must reference a data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  if (facet.field) {
    op = scope.add(PreFacet({
      field: scope.fieldRef(facet.field),
      pulse: data
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group.parent)),
      pulse: data
    }));
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must specify groupby or field: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  } // initialize facet subscope


  const subscope = scope.fork(),
        source = subscope.add(Collect()),
        values = subscope.add(Sieve({
    pulse: ref(source)
  }));
  subscope.addData(name, new DataScope(subscope, source, source, values));
  subscope.addSignal('parent', null); // parse faceted subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseSubflow (spec, scope, input) {
  const op = scope.add(PreFacet({
    pulse: input.pulse
  })),
        subscope = scope.fork();
  subscope.add(Sieve());
  subscope.addSignal('parent', null); // parse group mark subflow

  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseTrigger (spec, scope, name) {
  const remove = spec.remove,
        insert = spec.insert,
        toggle = spec.toggle,
        modify = spec.modify,
        values = spec.values,
        op = scope.add(operator());
  const update = 'if(' + spec.trigger + ',modify("' + name + '",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope);
  op.update = expr.$expr;
  op.params = expr.$params;
}

function parseMark (spec, scope) {
  const role = getRole(spec),
        group = spec.type === GroupMark,
        facet = spec.from && spec.from.facet,
        overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole || role === FrameRole,
      ops,
      op,
      store,
      enc,
      name,
      layoutRef,
      boundRef;
  const nested = role === MarkRole || layout || facet; // resolve input data

  const input = parseData$1(spec.from, group, scope); // data join to map tuples to visual items

  op = scope.add(DataJoin({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),
    pulse: input.pulse,
    clean: !group
  }));
  const joinRef = ref(op); // collect visual items

  op = store = scope.add(Collect({
    pulse: joinRef
  })); // connect visual items to scenegraph

  op = scope.add(Mark({
    markdef: definition(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef('parent') : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op); // add visual encoders

  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  }))); // monitor parent marks to propagate changes

  op.params.parent = scope.encode(); // add post-encoding transforms, if defined

  if (spec.transform) {
    spec.transform.forEach(_ => {
      const tx = parseTransform(_, scope),
            md = tx.metadata;

      if (md.generates || md.changes) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Mark transforms should not generate new data.');
      }

      if (!md.nomod) enc.params.mod = true; // update encode mod handling

      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  } // if item sort specified, perform post-encoding


  if (spec.sort) {
    op = scope.add(SortItems({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }

  const encodeRef = ref(op); // add view layout operator if needed

  if (facet || layout) {
    layout = scope.add(ViewLayout({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  } // compute bounding boxes


  const bound = scope.add(Bound({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound); // if group mark, recurse to parse nested content

  if (group) {
    // juggle layout & bounds to ensure they run *after* any faceting transforms
    if (nested) {
      ops = scope.operators;
      ops.pop();
      if (layout) ops.pop();
    }

    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) // explicit facet
    : nested ? parseSubflow(spec, scope, input) // standard mark group
    : scope.parse(spec); // guide group, we can avoid nested scopes

    scope.popState();

    if (nested) {
      if (layout) ops.push(layout);
      ops.push(bound);
    }
  } // if requested, add overlap removal transform


  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  } // render / sieve items


  const render = scope.add(Render({
    pulse: boundRef
  })),
        sieve = scope.add(Sieve({
    pulse: ref(render)
  }, undefined, scope.parent())); // if mark is named, make accessible as reactive geometry
  // add trigger updates if defined

  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach(on => {
      if (on.insert || on.remove || on.toggle) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Marks only support modify triggers.');
      }

      parseTrigger(on, scope, name);
    });
  }
}

function parseOverlap(overlap, source, scope) {
  const method = overlap.method,
        bound = overlap.bound,
        sep = overlap.separation;
  const params = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method) ? scope.signalRef(method.signal) : method,
    pulse: source
  };

  if (overlap.order) {
    params.sort = scope.compareRef({
      field: overlap.order
    });
  }

  if (bound) {
    const tol = bound.tolerance;
    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params.boundScale = scope.scaleRef(bound.scale);
    params.boundOrient = bound.orient;
  }

  return ref(scope.add(Overlap(params)));
}

function parseLegend (spec, scope) {
  const config = scope.config.legend,
        encode = spec.encode || {},
        _ = lookup(spec, config),
        legendEncode = encode.legend || {},
        name = legendEncode.name || undefined,
        interactive = legendEncode.interactive,
        style = legendEncode.style,
        scales = {};

  let scale = 0,
      entryLayout,
      params,
      children; // resolve scales and 'canonical' scale name

  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);
  if (!scale) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing valid scale for legend.'); // resolve legend type (symbol, gradient, or discrete gradient)

  const type = legendType(spec, scope.scaleType(scale)); // single-element data source for legend group

  const datum = {
    title: spec.title != null,
    scales: scales,
    type: type,
    vgrad: type !== 'symbol' && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect(null, [datum]))); // encoding properties for legend entry sub-group

  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }; // data source for legend values

  const entryRef = ref(scope.add(LegendEntries(params = {
    type: type,
    scale: scope.scaleRef(scale),
    count: scope.objectProperty(_('tickCount')),
    limit: scope.property(_('symbolLimit')),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // continuous gradient legend

  if (type === Gradient) {
    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)]; // adjust default tick count based on the gradient length

    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  } // discrete gradient legend
  else if (type === Discrete) {
    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];
  } // symbol legend
  else {
    // determine legend symbol group layout
    entryLayout = legendSymbolLayout(spec, config);
    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))]; // pass symbol size information to legend entry generator

    params.size = sizeExpression(spec, scope, children[0].marks);
  } // generate legend marks


  children = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children,
    layout: entryLayout,
    interactive
  })]; // include legend title if defined

  if (datum.title) {
    children.push(legendTitle(spec, config, encode.title, dataRef));
  } // parse legend specification


  return parseMark(guideGroup({
    role: LegendRole,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function legendType(spec, scaleType) {
  let type = spec.type || Symbols;

  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isContinuous)(scaleType) ? Gradient : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Symbols;
  }

  return type !== Gradient ? type : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Gradient;
}

function scaleCount(spec) {
  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);
}

function buildLegendEncode(_, spec, config) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset'),
    padding: _('padding'),
    titlePadding: _('titlePadding'),
    cornerRadius: _('cornerRadius'),
    fill: _('fillColor'),
    stroke: _('strokeColor'),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _('legendX'),
    y: _('legendY'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel('size', spec, marks)),
        strokeWidth = deref(getChannel('strokeWidth', spec, marks)),
        fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);
}

function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}

function getFontSize(encode, scope, style) {
  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);
}

const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle (spec, scope) {
  spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec) ? {
    text: spec
  } : spec;

  const _ = lookup(spec, scope.config.title),
        encode = spec.encode || {},
        userEncode = encode.group || {},
        name = userEncode.name || undefined,
        interactive = userEncode.interactive,
        style = userEncode.style,
        children = []; // single-element data source for group title


  const datum = {},
        dataRef = ref(scope.add(Collect(null, [datum]))); // include title text

  children.push(buildTitle(spec, _, titleEncode(spec), dataRef)); // include subtitle text

  if (spec.subtitle) {
    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));
  } // parse title specification


  return parseMark(guideGroup({
    role: TitleRole,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
} // provide backwards-compatibility for title custom encode;
// the top-level encode block has been *deprecated*.

function titleEncode(spec) {
  const encode = spec.encode;
  return encode && encode.title || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode);
}

function groupEncode(_, userEncode) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    anchor: _('anchor'),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _('limit'),
    frame: _('frame'),
    offset: _('offset') || 0,
    padding: _('subtitlePadding')
  });
  return extendEncode(encode, userEncode, Skip);
}

function buildTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.text,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('color'),
    font: _('font'),
    fontSize: _('fontSize'),
    fontStyle: _('fontStyle'),
    fontWeight: _('fontWeight'),
    lineHeight: _('lineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero = {
    value: 0
  },
        text = spec.subtitle,
        encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('subtitleColor'),
    font: _('subtitleFont'),
    fontSize: _('subtitleFontSize'),
    fontStyle: _('subtitleFontStyle'),
    fontWeight: _('subtitleFontWeight'),
    lineHeight: _('subtitleLineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function parseData(data, scope) {
  const transforms = [];

  if (data.transform) {
    data.transform.forEach(tx => {
      transforms.push(parseTransform(tx, scope));
    });
  }

  if (data.on) {
    data.on.forEach(on => {
      parseTrigger(on, scope, data.name);
    });
  }

  scope.addDataPipeline(data.name, analyze(data, scope, transforms));
}
/**
 * Analyze a data pipeline, add needed operators.
 */

function analyze(data, scope, ops) {
  const output = [];
  let source = null,
      modify = false,
      generate = false,
      upstream,
      i,
      n,
      t,
      m;

  if (data.values) {
    // hard-wired input data set
    if (isSignal(data.values) || hasSignal(data.format)) {
      // if either values is signal or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, ingest upon dataflow init
      output.push(source = collect({
        $ingest: data.values,
        $format: data.format
      }));
    }
  } else if (data.url) {
    // load data from external source
    if (hasSignal(data.url) || hasSignal(data.format)) {
      // if either url or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, request load upon dataflow init
      output.push(source = collect({
        $request: data.url,
        $format: data.format
      }));
    }
  } else if (data.source) {
    // derives from one or more other data sets
    source = upstream = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(data.source).map(d => ref(scope.getData(d).output));
    output.push(null); // populate later
  } // scan data transforms, add collectors as needed


  for (i = 0, n = ops.length; i < n; ++i) {
    t = ops[i];
    m = t.metadata;

    if (!source && !m.source) {
      output.push(source = collect());
    }

    output.push(t);
    if (m.generates) generate = true;
    if (m.modifies && !generate) modify = true;
    if (m.source) source = t;else if (m.changes) source = null;
  }

  if (upstream) {
    n = upstream.length - 1;
    output[0] = Relay({
      derive: modify,
      pulse: n ? upstream : upstream[0]
    });

    if (modify || n) {
      // collect derived and multi-pulse tuples
      output.splice(1, 0, collect());
    }
  }

  if (!source) output.push(collect());
  output.push(Sieve({}));
  return output;
}

function collect(values) {
  const s = Collect({}, values);
  s.metadata = {
    source: true
  };
  return s;
}

function load(scope, data) {
  return Load({
    url: data.url ? scope.property(data.url) : undefined,
    async: data.async ? scope.property(data.async) : undefined,
    values: data.values ? scope.property(data.values) : undefined,
    format: scope.objectProperty(data.format)
  });
}

const isX = orient => orient === Bottom || orient === Top; // get sign coefficient based on axis orient


const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b; // condition on axis x-direction

const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b; // condition on axis y-direction

const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;
const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {
  value: a
} : {
  value: b
};
const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {
  value: a
} : {
  value: b
};

const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);

const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);

const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);

const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);

const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);

const ifEnc = (test, a, b) => {
  // ensure inputs are encoder objects (or null)
  a = a != null ? encoder(a) : a;
  b = b != null ? encoder(b) : b;

  if (isSimple(a) && isSimple(b)) {
    // if possible generate simple signal expression
    a = a ? a.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(a.value) : null;
    b = b ? b.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(b.value) : null;
    return {
      signal: `${test} ? (${a}) : (${b})`
    };
  } else {
    // otherwise generate rule set
    return [(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      test
    }, a)].concat(b || []);
  }
};

const isSimple = enc => enc == null || Object.keys(enc).length === 1;

const ifExpr = (test, a, b) => ({
  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`
});

const ifOrient = ($orient, t, b, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'
});

const toExpr = v => isSignal(v) ? v.signal : v == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v);

const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {
  signal: `(${sign.signal}) * ${value}`
} : {
  value: sign * value
};
const patch = (value, base) => {
  const s = value.signal;
  return s && s.endsWith('(null)') ? {
    signal: s.slice(0, -6) + base.signal
  } : value;
};

function fallback(prop, config, axisConfig, style) {
  let styleProp;

  if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, prop)) {
    return config[prop];
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(axisConfig, prop)) {
    return axisConfig[prop];
  } else if (prop.startsWith('title')) {
    switch (prop) {
      case 'titleColor':
        styleProp = 'fill';
        break;

      case 'titleFont':
      case 'titleFontSize':
      case 'titleFontWeight':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideTitleStyle][styleProp];
  } else if (prop.startsWith('label')) {
    switch (prop) {
      case 'labelColor':
        styleProp = 'fill';
        break;

      case 'labelFont':
      case 'labelFontSize':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }

    return style[GuideLabelStyle][styleProp];
  }

  return null;
}

function keys(objects) {
  const map = {};

  for (const obj of objects) {
    if (!obj) continue;

    for (const key in obj) map[key] = 1;
  }

  return Object.keys(map);
}

function axisConfig (spec, scope) {
  var config = scope.config,
      style = config.style,
      axis = config.axis,
      band = scope.scaleType(spec.scale) === 'band' && config.axisBand,
      orient = spec.orient,
      xy,
      or,
      key;

  if (isSignal(orient)) {
    const xyKeys = keys([config.axisX, config.axisY]),
          orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};

    for (key of xyKeys) {
      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));
    }

    or = {};

    for (key of orientKeys) {
      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));
    }
  } else {
    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;
    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];
  }

  const result = xy || or || band ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, axis, xy, or, band) : axis;
  return result;
}

function axisDomain (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient;

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('domainColor'),
    strokeCap: _('domainCap'),
    strokeDash: _('domainDash'),
    strokeDashOffset: _('domainDashOffset'),
    strokeWidth: _('domainWidth'),
    strokeOpacity: _('domainOpacity')
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update.x = ifX(orient, pos0, zero);
  enter.x2 = update.x2 = ifX(orient, pos1);
  enter.y = update.y = ifY(orient, pos0, zero);
  enter.y2 = update.y2 = ifY(orient, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode
  }, userEncode);
}

function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}

function axisGrid (spec, config, userEncode, dataRef, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        vscale = spec.gridScale,
        sign = getSign(orient, 1, -1),
        offset = offsetValue(spec.offset, sign);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gridColor'),
    strokeCap: _('gridCap'),
    strokeDash: _('gridDash'),
    strokeDashOffset: _('gridDashOffset'),
    strokeOpacity: _('gridOpacity'),
    strokeWidth: _('gridWidth')
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  const sz = ifX(orient, {
    signal: 'height'
  }, {
    signal: 'width'
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign,
    offset: offset
  } : {
    value: 0,
    offset: offset
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign,
    offset: offset
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(sz, {
    mult: sign,
    offset: offset
  });
  enter.x = update.x = ifX(orient, tickPos, gridStart);
  enter.y = update.y = ifY(orient, tickPos, gridStart);
  enter.x2 = update.x2 = ifY(orient, gridEnd);
  enter.y2 = update.y2 = ifX(orient, gridEnd);
  exit.x = ifX(orient, tickPos);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function offsetValue(offset, sign) {
  if (sign === 1) ; else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
    offset = isSignal(sign) ? {
      signal: `(${sign.signal}) * (${offset || 0})`
    } : sign * (offset || 0);
  } else {
    let entry = offset = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, offset);

    while (entry.mult != null) {
      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(entry.mult)) {
        entry.mult = isSignal(sign) // no offset if sign === 1
        ? {
          signal: `(${entry.mult}) * (${sign.signal})`
        } : entry.mult * sign;
        return offset;
      } else {
        entry = entry.mult = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, entry.mult);
      }
    }

    entry.mult = sign;
  }

  return offset;
}

function axisTicks (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('tickColor'),
    strokeCap: _('tickCap'),
    strokeDash: _('tickDash'),
    strokeDashOffset: _('tickDashOffset'),
    strokeOpacity: _('tickOpacity'),
    strokeWidth: _('tickWidth')
  });
  const tickSize = encoder(size);
  tickSize.mult = sign;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  update.y = enter.y = ifX(orient, zero, tickPos);
  update.y2 = enter.y2 = ifX(orient, tickSize);
  exit.x = ifX(orient, tickPos);
  update.x = enter.x = ifY(orient, zero, tickPos);
  update.x2 = enter.x2 = ifY(orient, tickSize);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function flushExpr(scale, threshold, a, b, c) {
  return {
    signal: 'flush(range("' + scale + '"), ' + 'scale("' + scale + '", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'
  };
}

function axisLabels (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        scale = spec.scale,
        sign = getSign(orient, -1, 1),
        flush = deref(_('labelFlush')),
        flushOffset = deref(_('labelFlushOffset')),
        labelAlign = _('labelAlign'),
        labelBaseline = _('labelBaseline');

  let flushOn = flush === 0 || !!flush,
      update;
  const tickSize = encoder(size);
  tickSize.mult = sign;
  tickSize.offset = encoder(_('labelPadding') || 0);
  tickSize.offset.mult = sign;
  const tickPos = {
    scale: scale,
    field: Value,
    band: 0.5,
    offset: extendOffset(band.offset, _('labelOffset'))
  };
  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '"left"', '"right"', '"center"') : {
    value: 'center'
  }, ifRight(orient, 'left', 'right'));
  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '"top"', '"bottom"', '"middle"') : {
    value: 'middle'
  });
  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero,
    x: ifX(orient, tickPos, tickSize),
    y: ifY(orient, tickPos, tickSize)
  };
  const encode = {
    enter: enter,
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline
    },
    exit: {
      opacity: zero,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode, {
    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null
  });
  addEncoders(encode, {
    angle: _('labelAngle'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontWeight: _('labelFontWeight'),
    fontStyle: _('labelFontStyle'),
    limit: _('labelLimit'),
    lineHeight: _('labelLineHeight')
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });

  const bound = _('labelBound');

  let overlap = _('labelOverlap'); // if overlap method or bound defined, request label overlap removal


  overlap = overlap || bound ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.index',
    bound: bound ? {
      scale,
      orient,
      tolerance: bound
    } : null
  } : undefined;

  if (update.align !== align) {
    update.align = patch(update.align, align);
  }

  if (update.baseline !== baseline) {
    update.baseline = patch(update.baseline, baseline);
  }

  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function axisTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
        orient = spec.orient,
        sign = getSign(orient, -1, 1);

  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero,
      anchor: encoder(_('titleAnchor', null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update.x = ifX(orient, titlePos);
  update.y = ifY(orient, titlePos);
  enter.angle = ifX(orient, zero, mult(sign, 90));
  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {
    value: Bottom
  });
  update.angle = enter.angle;
  update.baseline = enter.baseline;
  addEncoders(encode, {
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    angle: _('titleAngle'),
    baseline: _('titleBaseline')
  });
  autoLayout(_, orient, encode, userEncode);
  encode.update.align = patch(encode.update.align, enter.align);
  encode.update.angle = patch(encode.update.angle, enter.angle);
  encode.update.baseline = patch(encode.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function autoLayout(_, orient, encode, userEncode) {
  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;

  const autoY = auto(_('titleX'), 'x'),
        autoX = auto(_('titleY'), 'y');
  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));
}

function parseAxis (spec, scope) {
  const config = axisConfig(spec, scope),
        encode = spec.encode || {},
        axisEncode = encode.axis || {},
        name = axisEncode.name || undefined,
        interactive = axisEncode.interactive,
        style = axisEncode.style,
        _ = lookup(spec, config),
        band = tickBand(_); // single-element data source for axis group


  const datum = {
    scale: spec.scale,
    ticks: !!_('ticks'),
    labels: !!_('labels'),
    grid: !!_('grid'),
    domain: !!_('domain'),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect({}, [datum]))); // data source for axis ticks

  const ticksRef = ref(scope.add(AxisTicks({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  }))); // generate axis marks

  const children = [];
  let size; // include axis gridlines if requested

  if (datum.grid) {
    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));
  } // include axis ticks if requested


  if (datum.ticks) {
    size = _('tickSize');
    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));
  } // include axis labels if requested


  if (datum.labels) {
    size = datum.ticks ? size : 0;
    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));
  } // include axis domain path if requested


  if (datum.domain) {
    children.push(axisDomain(spec, config, encode.domain, dataRef));
  } // include axis title if defined


  if (datum.title) {
    children.push(axisTitle(spec, config, encode.title, dataRef));
  } // parse axis specification


  return parseMark(guideGroup({
    role: AxisRole,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

function buildAxisEncode(_, spec) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset') || 0,
    position: value(spec.position, 0),
    titlePadding: _('titlePadding'),
    minExtent: _('minExtent'),
    maxExtent: _('maxExtent'),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _('translate'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function parseScope (spec, scope, preprocessed) {
  const signals = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals),
        scales = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.scales); // parse signal definitions, if not already preprocessed

  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope)); // parse cartographic projection definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.projections).forEach(_ => parseProjection(_, scope)); // initialize scale references

  scales.forEach(_ => initScale(_, scope)); // parse data sources

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.data).forEach(_ => parseData(_, scope)); // parse scale definitions

  scales.forEach(_ => parseScale(_, scope)); // parse signal updates

  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope)); // parse axis definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.axes).forEach(_ => parseAxis(_, scope)); // parse mark definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.marks).forEach(_ => parseMark(_, scope)); // parse legend definitions

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.legends).forEach(_ => parseLegend(_, scope)); // parse title, if defined

  if (spec.title) parseTitle(spec.title, scope); // parse collected lambda (anonymous) expressions

  scope.parseLambdas();
  return scope;
}

const rootEncode = spec => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: 'width'
    },
    height: {
      signal: 'height'
    }
  }
}, spec);

function parseView(spec, scope) {
  const config = scope.config; // add scenegraph root

  const root = ref(scope.root = scope.add(operator())); // parse top-level signal definitions

  const signals = collectSignals(spec, config);
  signals.forEach(_ => parseSignal(_, scope)); // assign description, event, legend, and locale configuration

  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale; // store root group item

  const input = scope.add(Collect()); // encode root group item

  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
    pulse: ref(input)
  }))); // perform view layout

  const parent = scope.add(ViewLayout({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef('autosize'),
    mark: root,
    pulse: ref(encode)
  }));
  scope.operators.pop(); // parse remainder of specification

  scope.pushState(ref(encode), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent); // bound / render / sieve root item

  let op = scope.add(Bound({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render({
    pulse: ref(op)
  }));
  op = scope.add(Sieve({
    pulse: ref(op)
  })); // track metadata for root item

  scope.addData('root', new DataScope(scope, input, input, op));
  return scope;
}

function signalObject(name, value) {
  return value && value.signal ? {
    name,
    update: value.signal
  } : {
    name,
    value
  };
}
/**
 * Collect top-level signals, merging values as needed. Signals
 * defined in the config signals arrays are added only if that
 * signal is not explicitly defined in the specification.
 * Built-in signals (autosize, background, padding, width, height)
 * receive special treatment. They are initialized using the
 * top-level spec property, or, if undefined in the spec, using
 * the corresponding top-level config property. If this property
 * is a signal reference object, the signal expression maps to the
 * signal 'update' property. If the spec's top-level signal array
 * contains an entry that matches a built-in signal, that entry
 * will be merged with the built-in specification, potentially
 * overwriting existing 'value' or 'update' properties.
 */


function collectSignals(spec, config) {
  const _ = name => value(spec[name], config[name]),
        signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],
        pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),
        map = {}; // add spec signal array


  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals).forEach(s => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // merge if built-in signal
      s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(pre[s.name], s);
    } else {
      // otherwise add to signal list
      signals.push(s);
    }

    map[s.name] = s;
  }); // add config signal array

  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(config.signals).forEach(s => {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s.name) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // add to signal list if not already defined
      signals.push(s);
    }
  });
  return signals;
}

function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}

function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}

Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },

  fork() {
    return new Subscope(this);
  },

  isSubscope() {
    return this._subid > 0;
  },

  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },

  id() {
    return (this._subid ? this._subid + ':' : 0) + this._id++;
  },

  add(op) {
    this.operators.push(op);
    op.id = this.id(); // if pre-registration references exist, resolve them now

    if (op.refs) {
      op.refs.forEach(ref => {
        ref.$ref = op.id;
      });
      op.refs = null;
    }

    return op;
  },

  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy({
      value: vref
    }));
  },

  addStream(stream) {
    this.streams.push(stream);
    stream.id = this.id();
    return stream;
  },

  addUpdate(update) {
    this.updates.push(update);
    return update;
  },

  // Apply metadata
  finish() {
    let name, ds; // annotate root

    if (this.root) this.root.root = true; // annotate signals

    for (name in this.signals) {
      this.signals[name].signal = name;
    } // annotate scales


    for (name in this.scales) {
      this.scales[name].scale = name;
    } // annotate data sets


    function annotate(op, name, type) {
      let data, list;

      if (op) {
        data = op.data || (op.data = {});
        list = data[name] || (data[name] = []);
        list.push(type);
      }
    }

    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, 'input');
      annotate(ds.output, name, 'output');
      annotate(ds.values, name, 'values');

      for (const field in ds.index) {
        annotate(ds.index[field], name, 'index:' + field);
      }
    }

    return this;
  },

  // ----
  pushState(encode, parent, lookup) {
    this._encode.push(ref(this.add(Sieve({
      pulse: encode
    }))));

    this._parent.push(parent);

    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);

    this._markpath.push(-1);
  },

  popState() {
    this._encode.pop();

    this._parent.pop();

    this._lookup.pop();

    this._markpath.pop();
  },

  parent() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._parent);
  },

  encode() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._encode);
  },

  lookup() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._lookup);
  },

  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },

  // ----
  fieldRef(field, name) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field)) return fieldRef$1(field, name);

    if (!field.signal) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(field));
    }

    const s = field.signal;
    let f = this.field[s];

    if (!f) {
      const params = {
        name: this.signalRef(s)
      };
      if (name) params.as = name;
      this.field[s] = f = ref(this.add(Field(params)));
    }

    return f;
  },

  compareRef(cmp) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;

    const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.field).map(check),
          orders = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.order).map(check);
    return signal ? ref(this.add(Compare({
      fields: fields,
      orders: orders
    }))) : compareRef(fields, orders);
  },

  keyRef(fields, flat) {
    let signal = false;

    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;

    const sig = this.signals;
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(fields).map(check);
    return signal ? ref(this.add(Key({
      fields: fields,
      flat: flat
    }))) : keyRef(fields, flat);
  },

  sortRef(sort) {
    if (!sort) return sort; // including id ensures stable sorting

    const a = aggrField(sort.op, sort.field),
          o = sort.order || Ascending;
    return o.signal ? ref(this.add(Compare({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },

  // ----
  event(source, type) {
    const key = source + ':' + type;

    if (!this.events[key]) {
      const id = this.id();
      this.streams.push({
        id: id,
        source: source,
        type: type
      });
      this.events[key] = id;
    }

    return this.events[key];
  },

  // ----
  hasOwnSignal(name) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.signals, name);
  },

  addSignal(name, value) {
    if (this.hasOwnSignal(name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    const op = value instanceof Entry ? value : this.add(operator(value));
    return this.signals[name] = op;
  },

  getSignal(name) {
    if (!this.signals[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.signals[name];
  },

  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }

    return ref(this.lambdas[s]);
  },

  parseLambdas() {
    const code = Object.keys(this.lambdas);

    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i],
            e = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(s, this),
            op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },

  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },

  objectProperty(spec) {
    return !spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },

  exprRef(code, name) {
    const params = {
      expr: (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, this)
    };
    if (name) params.expr.$name = name;
    return ref(this.add(Expression(params)));
  },

  addBinding(name, bind) {
    if (!this.bindings) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Nested signals do not support binding: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.bindings.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      signal: name
    }, bind));
  },

  // ----
  addScaleProj(name, transform) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.scales, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate scale or projection name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    this.scales[name] = this.add(transform);
  },

  addScale(name, params) {
    this.addScaleProj(name, Scale(params));
  },

  addProjection(name, params) {
    this.addScaleProj(name, Projection(params));
  },

  getScale(name) {
    if (!this.scales[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.scales[name];
  },

  scaleRef(name) {
    return ref(this.getScale(name));
  },

  scaleType(name) {
    return this.getScale(name).params.type;
  },

  projectionRef(name) {
    return this.scaleRef(name);
  },

  projectionType(name) {
    return this.scaleType(name);
  },

  // ----
  addData(name, dataScope) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name] = dataScope;
  },

  getData(name) {
    if (!this.data[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Undefined data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.data[name];
  },

  addDataPipeline(name, entries) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }

    return this.addData(name, DataScope.fromEntries(this, entries));
  }

};

function propertyLambda(spec) {
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(spec) ? arrayLambda : objectLambda)(spec);
}

function arrayLambda(array) {
  const n = array.length;
  let code = '[';

  for (let i = 0; i < n; ++i) {
    const value = array[i];
    code += (i > 0 ? ',' : '') + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + ']';
}

function objectLambda(obj) {
  let code = '{',
      i = 0,
      key,
      value;

  for (key in obj) {
    value = obj[key];
    code += (++i > 1 ? ',' : '') + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(key) + ':' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }

  return code + '}';
}

/**
 * Standard configuration defaults for Vega specification parsing.
 * Users can provide their own (sub-)set of these default values
 * by passing in a config object to the top-level parse method.
 */
function defaults () {
  const defaultFont = 'sans-serif',
        defaultSymbolSize = 30,
        defaultStrokeWidth = 2,
        defaultColor = '#4c78a8',
        black = '#000',
        gray = '#888',
        lightGray = '#ddd';
  return {
    // default visualization description
    description: 'Vega visualization',
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: 'pad',
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ['wheel']
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      'guide-label': {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      // axis & legend titles
      'guide-title': {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: 'bold'
      },
      // headers, including chart title
      'group-title': {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: 'bold'
      },
      // chart subtitle
      'group-subtitle': {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'circle'
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'square'
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: 'transparent',
        stroke: lightGray
      }
    },
    // defaults for title
    title: {
      orient: 'top',
      anchor: 'middle',
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: 'mercator'
    },
    // defaults for legends
    legend: {
      orient: 'right',
      padding: 0,
      gridAlign: 'each',
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: 'vertical',
      gradientDirection: 'vertical',
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: 'left',
      labelBaseline: 'middle',
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: 'circle',
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: 'transparent',
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: 'top',
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: 'horizontal',
        left: {
          direction: 'vertical'
        },
        right: {
          direction: 'vertical'
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: 'tableau10'
      },
      ordinal: {
        scheme: 'blues'
      },
      heatmap: {
        scheme: 'yellowgreenblue'
      },
      ramp: {
        scheme: 'blues'
      },
      diverging: {
        scheme: 'blueorange',
        extent: [1, 0]
      },
      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']
    }
  };
}

function parse (spec, config, options) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Input Vega specification must be an object.');
  }

  config = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig)(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}




/***/ }),

/***/ "./node_modules/vega-projection/build/vega-projection.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-projection/build/vega-projection.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getProjectionPath": () => (/* binding */ getProjectionPath),
/* harmony export */   "projection": () => (/* binding */ projection),
/* harmony export */   "projectionProperties": () => (/* binding */ projectionProperties)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/equalEarth.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/mercator.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/stereographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/mollweide.js");



const defaultPath = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)();
const projectionProperties = [// standard properties in d3-geo
'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY', // extended properties in d3-geo-projections
'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];
/**
 * Augment projections with their type and a copy method.
 */

function create(type, constructor) {
  return function projection() {
    const p = constructor();
    p.type = type;
    p.path = (0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.default)().projection(p);

    p.copy = p.copy || function () {
      const c = projection();
      projectionProperties.forEach(prop => {
        if (p[prop]) c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };

    return p;
  };
}

function projection(type, proj) {
  if (!type || typeof type !== 'string') {
    throw new Error('Projection type must be a name string.');
  }

  type = type.toLowerCase();

  if (arguments.length > 1) {
    projections[type] = create(type, proj);
    return this;
  } else {
    return projections[type] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
const projections = {
  // base d3-geo projection types
  albers: d3_geo__WEBPACK_IMPORTED_MODULE_1__.default,
  albersusa: d3_geo__WEBPACK_IMPORTED_MODULE_2__.default,
  azimuthalequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_3__.default,
  azimuthalequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_4__.default,
  conicconformal: d3_geo__WEBPACK_IMPORTED_MODULE_5__.default,
  conicequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_6__.default,
  conicequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_7__.default,
  equalEarth: d3_geo__WEBPACK_IMPORTED_MODULE_8__.default,
  equirectangular: d3_geo__WEBPACK_IMPORTED_MODULE_9__.default,
  gnomonic: d3_geo__WEBPACK_IMPORTED_MODULE_10__.default,
  identity: d3_geo__WEBPACK_IMPORTED_MODULE_11__.default,
  mercator: d3_geo__WEBPACK_IMPORTED_MODULE_12__.default,
  mollweide: d3_geo_projection__WEBPACK_IMPORTED_MODULE_13__.default,
  naturalEarth1: d3_geo__WEBPACK_IMPORTED_MODULE_14__.default,
  orthographic: d3_geo__WEBPACK_IMPORTED_MODULE_15__.default,
  stereographic: d3_geo__WEBPACK_IMPORTED_MODULE_16__.default,
  transversemercator: d3_geo__WEBPACK_IMPORTED_MODULE_17__.default
};

for (const key in projections) {
  projection(key, projections[key]);
}




/***/ }),

/***/ "./node_modules/vega-regression/build/vega-regression.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-regression/build/vega-regression.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loess": () => (/* binding */ Loess),
/* harmony export */   "regression": () => (/* binding */ Regression)
/* harmony export */ });
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




function partition (data, groupby) {
  var groups = [],
      get = function (f) {
    return f(t);
  },
      map,
      i,
      n,
      t,
      k,
      g; // partition data points into stack groups


  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(t);
    }
  }

  return groups;
}

/**
 * Compute locally-weighted regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.bandwidth=0.3] - The loess bandwidth.
 */

function Loess(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Loess.Definition = {
  'type': 'Loess',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0.3
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Loess, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            m = names.length,
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            values = [];
      groups.forEach(g => {
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLoess)(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {
          const t = {};

          for (let i = 0; i < m; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

const Methods = {
  linear: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLinear,
  log: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLog,
  exp: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionExp,
  pow: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPow,
  quad: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionQuad,
  poly: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPoly
};

const degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;
/**
 * Compute regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {string} [params.method='linear'] - The regression method to apply.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.
 * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.
 */


function Regression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Regression.Definition = {
  'type': 'Regression',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'linear',
    'values': Object.keys(Methods)
  }, {
    'name': 'order',
    'type': 'number',
    'default': 3
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'params',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Regression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition(source, _.groupby),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
            method = _.method || 'linear',
            order = _.order || 3,
            dof = degreesOfFreedom(method, order),
            as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
            fit = Methods[method],
            values = [];
      let domain = _.extent;

      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.hasOwnProperty)(Methods, method)) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Invalid regression method: ' + method);
      }

      if (domain != null) {
        if (method === 'log' && domain[0] <= 0) {
          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');
          domain = null;
        }
      }

      groups.forEach(g => {
        const n = g.length;

        if (n <= dof) {
          pulse.dataflow.warn('Skipping regression with more parameters than data points.');
          return;
        }

        const model = fit(g, _.x, _.y, order);

        if (_.params) {
          // if parameter vectors requested return those
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }

        const dom = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(g, _.x),
              add = p => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        };

        if (method === 'linear') {
          // for linear regression we only need the end points
          dom.forEach(x => add([x, model.predict(x)]));
        } else {
          // otherwise return trend line sample points
          (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.sampleCurve)(model.predict, dom, 25, 200).forEach(add);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});




/***/ }),

/***/ "./node_modules/vega-runtime/build/vega-runtime.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-runtime/build/vega-runtime.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "context": () => (/* binding */ context)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");



/**
 * Parse a serialized dataflow specification.
 */
function parse (spec) {
  const ctx = this,
        operators = spec.operators || []; // parse background

  if (spec.background) {
    ctx.background = spec.background;
  } // parse event configuration


  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  } // parse locale configuration


  if (spec.locale) {
    ctx.locale = spec.locale;
  } // parse operators


  operators.forEach(entry => ctx.parseOperator(entry)); // parse operator parameters

  operators.forEach(entry => ctx.parseOperatorParameters(entry)); // parse streams

  (spec.streams || []).forEach(entry => ctx.parseStream(entry)); // parse updates

  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));
  return ctx.resolve();
}

const Skip = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['rule']),
      Swap = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['group', 'image', 'rect']);
function adjustSpatial(encode, marktype) {
  let code = '';
  if (Skip[marktype]) return code;

  if (encode.x2) {
    if (encode.x) {
      if (Swap[marktype]) {
        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';
      }

      code += 'o.width=o.x2-o.x;';
    } else {
      code += 'o.x=o.x2-(o.width||0);';
    }
  }

  if (encode.xc) {
    code += 'o.x=o.xc-(o.width||0)/2;';
  }

  if (encode.y2) {
    if (encode.y) {
      if (Swap[marktype]) {
        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';
      }

      code += 'o.height=o.y2-o.y;';
    } else {
      code += 'o.y=o.y2-(o.height||0);';
    }
  }

  if (encode.yc) {
    code += 'o.y=o.yc-(o.height||0)/2;';
  }

  return code;
}
function canonicalType(type) {
  return (type + '').toLowerCase();
}
function isOperator(type) {
  return canonicalType(type) === 'operator';
}
function isCollect(type) {
  return canonicalType(type) === 'collect';
}

function expression(ctx, args, code) {
  // wrap code in return statement if expression does not terminate
  if (code[code.length - 1] !== ';') {
    code = 'return(' + code + ');';
  }

  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
} // generate code for comparing a single field


function _compare(u, v, lt, gt) {
  return "((u = ".concat(u, ") < (v = ").concat(v, ") || u == null) && v != null ? ").concat(lt, "\n  : (u > v || v == null) && u != null ? ").concat(gt, "\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ").concat(lt, "\n  : v !== v && u === u ? ").concat(gt, " : ");
}

var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),

  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),

  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr) => expression(ctx, ['event'], expr.code),

  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr) => {
    const code = "var datum=event.item&&event.item.datum;return ".concat(expr.code, ";");
    return expression(ctx, ['_', 'event'], code);
  },

  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode) => {
    const {
      marktype,
      channels
    } = encode;
    let code = 'var o=item,datum=o.datum,m=0,$;';

    for (const name in channels) {
      const o = 'o[' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ']';
      code += "$=".concat(channels[name].code, ";if(").concat(o, "!==$)").concat(o, "=$,m=1;");
    }

    code += adjustSpatial(channels, marktype);
    code += 'return m;';
    return expression(ctx, ['item', '_'], code);
  },

  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path) {
      const ref = "[".concat(path.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(']['), "]");
      const get = Function('_', "return _".concat(ref, ";"));
      get.path = ref;
      return get;
    },

    comparator(fields, orders) {
      let t;

      const map = (f, i) => {
        const o = orders[i];
        let u, v;

        if (f.path) {
          u = "a".concat(f.path);
          v = "b".concat(f.path);
        } else {
          (t = t || {})['f' + i] = f;
          u = "this.f".concat(i, "(a)");
          v = "this.f".concat(i, "(b)");
        }

        return _compare(u, v, -o, o);
      };

      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');
      return t ? fn.bind(t) : fn;
    }

  }
};

/**
 * Parse a dataflow operator.
 */

function parseOperator(spec) {
  const ctx = this;

  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}
/**
 * Parse and assign operator parameters.
 */

function parseOperatorParameters(spec) {
  const ctx = this;

  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid operator id: ' + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}

/**
 * Parse a set of operator parameters.
 */

function parseParameters(spec, params) {
  params = params || {};
  const ctx = this;

  for (const key in spec) {
    const value = spec[key];
    params[key] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);
  }

  return params;
}
/**
 * Parse a single parameter.
 */

function parseParameter(spec, ctx, params) {
  if (!spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) return spec;

  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(spec, p.key)) {
      return p.parse(spec, ctx, params);
    }
  }

  return spec;
}
/** Reference parsers. */


var PARSERS = [{
  key: '$ref',
  parse: getOperator
}, {
  key: '$key',
  parse: getKey
}, {
  key: '$expr',
  parse: getExpression
}, {
  key: '$field',
  parse: getField
}, {
  key: '$encode',
  parse: getEncode
}, {
  key: '$compare',
  parse: getCompare
}, {
  key: '$context',
  parse: getContext
}, {
  key: '$subflow',
  parse: getSubflow
}, {
  key: '$tupleid',
  parse: getTupleId
}];
/**
 * Resolve an operator reference.
 */

function getOperator(_, ctx) {
  return ctx.get(_.$ref) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Operator not defined: ' + _.$ref);
}
/**
 * Resolve an expression reference.
 */


function getExpression(_, ctx, params) {
  if (_.$params) {
    // parse expression parameters
    ctx.parseParameters(_.$params, params);
  }

  const k = 'e:' + _.$expr.code + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.parameterExpression(_.$expr), _.$fields, _.$name));
}
/**
 * Resolve a key accessor reference.
 */


function getKey(_, ctx) {
  const k = 'k:' + _.$key + '_' + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.$key, _.$flat, ctx.expr.codegen));
}
/**
 * Resolve a field accessor reference.
 */


function getField(_, ctx) {
  if (!_.$field) return null;
  const k = 'f:' + _.$field + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.$field, _.$name, ctx.expr.codegen));
}
/**
 * Resolve a comparator function reference.
 */


function getCompare(_, ctx) {
  // As of Vega 5.5.3, $tupleid sort is no longer used.
  // Keep here for now for backwards compatibility.
  const k = 'c:' + _.$compare + '_' + _.$order,
        c = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.$compare).map(_ => _ && _.$tupleid ? vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid : _);
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(c, _.$order, ctx.expr.codegen));
}
/**
 * Resolve an encode operator reference.
 */


function getEncode(_, ctx) {
  const spec = _.$encode,
        encode = {};

  for (const name in spec) {
    const enc = spec[name];
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode[name].output = enc.$output;
  }

  return encode;
}
/**
 * Resolve a context reference.
 */


function getContext(_, ctx) {
  return ctx;
}
/**
 * Resolve a recursive subflow specification.
 */


function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function (dataflow, key, parent) {
    const subctx = ctx.fork().parse(spec),
          op = subctx.get(spec.operators[0].id),
          p = subctx.signals.parent;
    if (p) p.set(parent);

    op.detachSubflow = () => ctx.detach(subctx);

    return op;
  };
}
/**
 * Resolve a tuple id reference.
 */


function getTupleId() {
  return vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
}

/**
 * Parse an event stream specification.
 */

function parseStream (spec) {
  var ctx = this,
      filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,
      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,
      args;

  if (spec.source) {
    stream = ctx.events(spec.source, spec.type, filter);
  } else if (spec.merge) {
    args = spec.merge.map(_ => ctx.get(_));
    stream = args[0].merge.apply(args[0], args.slice(1));
  }

  if (spec.between) {
    args = spec.between.map(_ => ctx.get(_));
    stream = stream.between(args[0], args[1]);
  }

  if (spec.filter) {
    stream = stream.filter(filter);
  }

  if (spec.throttle != null) {
    stream = stream.throttle(+spec.throttle);
  }

  if (spec.debounce != null) {
    stream = stream.debounce(+spec.debounce);
  }

  if (stream == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream definition: ' + JSON.stringify(spec));
  }

  if (spec.consume) stream.consume(true);
  ctx.stream(spec, stream);
}

/**
 * Parse an event-driven operator update.
 */

function parseUpdate (spec) {
  var ctx = this,
      srcid = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(srcid = spec.source) ? srcid.$ref : srcid,
      source = ctx.get(srcid),
      target = null,
      update = spec.update,
      params = undefined;
  if (!source) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Source not defined: ' + spec.source);
  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);

  if (update && update.$expr) {
    if (update.$params) {
      params = ctx.parseParameters(update.$params);
    }

    update = ctx.handlerExpression(update.$expr);
  }

  ctx.update(spec, source, target, update, params);
}

const SKIP = {
  skip: true
};
function getState(options) {
  var ctx = this,
      state = {};

  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach(key => {
      const op = ctx.signals[key];

      if (options.signals(key, op)) {
        signals[key] = op.value;
      }
    });
  }

  if (options.data) {
    var data = state.data = {};
    Object.keys(ctx.data).forEach(key => {
      const dataset = ctx.data[key];

      if (options.data(key, dataset)) {
        data[key] = dataset.input.value;
      }
    });
  }

  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));
  }

  return state;
}
function setState(state) {
  var ctx = this,
      df = ctx.dataflow,
      data = state.data,
      signals = state.signals;
  Object.keys(signals || {}).forEach(key => {
    df.update(ctx.signals[key], signals[key], SKIP);
  });
  Object.keys(data || {}).forEach(key => {
    df.pulse(ctx.data[key].input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(data[key]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}

/**
 * Context objects store the current parse state.
 * Enables lookup of parsed operators, event streams, accessors, etc.
 * Provides a 'fork' method for creating child contexts for subflows.
 */

function context (df, transforms, functions, expr) {
  return new Context(df, transforms, functions, expr);
}

function Context(df, transforms, functions, expr) {
  this.dataflow = df;
  this.transforms = transforms;
  this.events = df.events.bind(df);
  this.expr = expr || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};

  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}

function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);

  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}

Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },

  detach(ctx) {
    this.subcontext = this.subcontext.filter(c => c !== ctx); // disconnect all nodes in the subcontext
    // wipe out targets first for better efficiency

    const keys = Object.keys(ctx.nodes);

    for (const key of keys) ctx.nodes[key]._targets = null;

    for (const key of keys) ctx.nodes[key].detach();

    ctx.nodes = null;
  },

  get(id) {
    return this.nodes[id];
  },

  set(id, node) {
    return this.nodes[id] = node;
  },

  add(spec, op) {
    const ctx = this,
          df = ctx.dataflow,
          data = spec.value;
    ctx.set(spec.id, op);

    if (isCollect(spec.type) && data) {
      if (data.$ingest) {
        df.ingest(op, data.$ingest, data.$format);
      } else if (data.$request) {
        df.preload(op, data.$request, data.$format);
      } else {
        df.pulse(op, df.changeset().insert(data));
      }
    }

    if (spec.root) {
      ctx.root = op;
    }

    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);

      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }

    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }

    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }

    if (spec.data) {
      for (const name in spec.data) {
        const data = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach(role => data[role] = op);
      }
    }
  },

  resolve() {
    (this.unresolved || []).forEach(fn => fn());
    delete this.unresolved;
    return this;
  },

  operator(spec, update) {
    this.add(spec, this.dataflow.add(spec.value, update));
  },

  transform(spec, type) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));
  },

  stream(spec, stream) {
    this.set(spec.id, stream);
  },

  update(spec, stream, target, update, params) {
    this.dataflow.on(stream, target, update, params, spec.options);
  },

  // expression parsing
  operatorExpression(expr) {
    return this.expr.operator(this, expr);
  },

  parameterExpression(expr) {
    return this.expr.parameter(this, expr);
  },

  eventExpression(expr) {
    return this.expr.event(this, expr);
  },

  handlerExpression(expr) {
    return this.expr.handler(this, expr);
  },

  encodeExpression(encode) {
    return this.expr.encode(this, encode);
  },

  // parse methods
  parse,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};




/***/ }),

/***/ "./node_modules/vega-scale/build/vega-scale.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-scale/build/vega-scale.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scaleImplicit": () => (/* reexport safe */ d3_scale__WEBPACK_IMPORTED_MODULE_1__.implicit),
/* harmony export */   "Band": () => (/* binding */ Band),
/* harmony export */   "BinOrdinal": () => (/* binding */ BinOrdinal),
/* harmony export */   "DiscreteLegend": () => (/* binding */ DiscreteLegend),
/* harmony export */   "Diverging": () => (/* binding */ Diverging),
/* harmony export */   "GradientLegend": () => (/* binding */ GradientLegend),
/* harmony export */   "Identity": () => (/* binding */ Identity),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Log": () => (/* binding */ Log),
/* harmony export */   "Ordinal": () => (/* binding */ Ordinal),
/* harmony export */   "Point": () => (/* binding */ Point),
/* harmony export */   "Pow": () => (/* binding */ Pow),
/* harmony export */   "Quantile": () => (/* binding */ Quantile),
/* harmony export */   "Quantize": () => (/* binding */ Quantize),
/* harmony export */   "Sequential": () => (/* binding */ Sequential),
/* harmony export */   "Sqrt": () => (/* binding */ Sqrt),
/* harmony export */   "SymbolLegend": () => (/* binding */ SymbolLegend),
/* harmony export */   "Symlog": () => (/* binding */ Symlog),
/* harmony export */   "Threshold": () => (/* binding */ Threshold),
/* harmony export */   "Time": () => (/* binding */ Time),
/* harmony export */   "UTC": () => (/* binding */ UTC),
/* harmony export */   "bandSpace": () => (/* binding */ bandSpace),
/* harmony export */   "domainCaption": () => (/* binding */ domainCaption),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "interpolateColors": () => (/* binding */ interpolateColors),
/* harmony export */   "interpolateRange": () => (/* binding */ interpolateRange),
/* harmony export */   "isContinuous": () => (/* binding */ isContinuous),
/* harmony export */   "isDiscrete": () => (/* binding */ isDiscrete),
/* harmony export */   "isDiscretizing": () => (/* binding */ isDiscretizing),
/* harmony export */   "isInterpolating": () => (/* binding */ isInterpolating),
/* harmony export */   "isLogarithmic": () => (/* binding */ isLogarithmic),
/* harmony export */   "isQuantile": () => (/* binding */ isQuantile),
/* harmony export */   "isTemporal": () => (/* binding */ isTemporal),
/* harmony export */   "isValidScaleType": () => (/* binding */ isValidScaleType),
/* harmony export */   "labelFormat": () => (/* binding */ labelFormat),
/* harmony export */   "labelFraction": () => (/* binding */ labelFraction),
/* harmony export */   "labelValues": () => (/* binding */ labelValues),
/* harmony export */   "quantizeInterpolator": () => (/* binding */ quantizeInterpolator),
/* harmony export */   "scale": () => (/* binding */ scale),
/* harmony export */   "scaleCopy": () => (/* binding */ scaleCopy),
/* harmony export */   "scaleFraction": () => (/* binding */ scaleFraction),
/* harmony export */   "scheme": () => (/* binding */ scheme),
/* harmony export */   "tickCount": () => (/* binding */ tickCount),
/* harmony export */   "tickFormat": () => (/* binding */ tickFormat),
/* harmony export */   "tickValues": () => (/* binding */ tickValues),
/* harmony export */   "validTicks": () => (/* binding */ validTicks)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/tickFormat.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/identity.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/utcTime.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/diverging.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");








function bandSpace (count, paddingInner, paddingOuter) {
  const space = count - paddingInner + paddingOuter * 2;
  return count ? space > 0 ? space : 1 : 0;
}

const Identity = 'identity';
const Linear = 'linear';
const Log = 'log';
const Pow = 'pow';
const Sqrt = 'sqrt';
const Symlog = 'symlog';
const Time = 'time';
const UTC = 'utc';
const Sequential = 'sequential';
const Diverging = 'diverging';
const Quantile = 'quantile';
const Quantize = 'quantize';
const Threshold = 'threshold';
const Ordinal = 'ordinal';
const Point = 'point';
const Band = 'band';
const BinOrdinal = 'bin-ordinal'; // categories

const Continuous = 'continuous';
const Discrete = 'discrete';
const Discretizing = 'discretizing';
const Interpolating = 'interpolating';
const Temporal = 'temporal';

function invertRange (scale) {
  return function (_) {
    let lo = _[0],
        hi = _[1],
        t;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    return [scale.invert(lo), scale.invert(hi)];
  };
}

function invertRangeExtent (scale) {
  return function (_) {
    const range = scale.range();
    let lo = _[0],
        hi = _[1],
        min = -1,
        max,
        t,
        i,
        n;

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    for (i = 0, n = range.length; i < n; ++i) {
      if (range[i] >= lo && range[i] <= hi) {
        if (min < 0) min = i;
        max = i;
      }
    }

    if (min < 0) return undefined;
    lo = scale.invertExtent(range[min]);
    hi = scale.invertExtent(range[max]);
    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];
  };
}

function band() {
  const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__.default)().unknown(undefined),
        domain = scale.domain,
        ordinalRange = scale.range;
  let range$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    const n = domain().length,
          reverse = range$1[1] < range$1[0],
          stop = range$1[1 - reverse],
          space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse - 0];
    step = (stop - start) / (space || 1);

    if (round) {
      step = Math.floor(step);
    }

    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);

    if (round) {
      start = Math.round(start);
      bandwidth = Math.round(bandwidth);
    }

    const values = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(n).map(i => start + step * i);
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain(_);
      return rescale();
    } else {
      return domain();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };

  scale.rangeRound = function (_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };

  scale.padding = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingInner = function (_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };

  scale.paddingOuter = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };

  scale.align = function (_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };

  scale.invertRange = function (_) {
    // bail if range has null or undefined values
    if (_[0] == null || _[1] == null) return;
    const reverse = range$1[1] < range$1[0],
          values = reverse ? ordinalRange().reverse() : ordinalRange(),
          n = values.length - 1;
    let lo = +_[0],
        hi = +_[1],
        a,
        b,
        t; // bail if either range endpoint is invalid

    if (lo !== lo || hi !== hi) return; // order range inputs, bail if outside of scale range

    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }

    if (hi < values[0] || lo > range$1[1 - reverse]) return; // binary search to index into scale range

    a = Math.max(0, (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, lo) - 1);
    b = lo === hi ? a : (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, hi) - 1; // increment index a if lo is within padding gap

    if (lo - values[a] > bandwidth + 1e-10) ++a;

    if (reverse) {
      // map + swap
      t = a;
      a = n - b;
      b = n - t;
    }

    return a > b ? undefined : domain().slice(a, b + 1);
  };

  scale.invert = function (_) {
    const value = scale.invertRange([_, _]);
    return value ? value[0] : value;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  const copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var map = Array.prototype.map;
function numbers(_) {
  return map.call(_, vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);
}

const slice = Array.prototype.slice;

function scaleBinOrdinal() {
  let domain = [],
      range = [];

  function scale(x) {
    return x == null || x !== x ? undefined : range[((0,d3_array__WEBPACK_IMPORTED_MODULE_4__.default)(domain, x) - 1) % range.length];
  }

  scale.domain = function (_) {
    if (arguments.length) {
      domain = numbers(_);
      return scale;
    } else {
      return domain.slice();
    }
  };

  scale.range = function (_) {
    if (arguments.length) {
      range = slice.call(_);
      return scale;
    } else {
      return range.slice();
    }
  };

  scale.tickFormat = function (count, specifier) {
    return (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__.default)(domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain), count == null ? 10 : count, specifier);
  };

  scale.copy = function () {
    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());
  };

  return scale;
}

const scales = {};
/**
 * Augment scales with their type and needed inverse methods.
 */

function create(type, constructor, metadata) {
  const ctr = function scale() {
    const s = constructor();

    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;
    }

    s.type = type;
    return s;
  };

  ctr.metadata = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(metadata));
  return ctr;
}

function scale(type, scale, metadata) {
  if (arguments.length > 1) {
    scales[type] = create(type, scale, metadata);
    return this;
  } else {
    return isValidScaleType(type) ? scales[type] : undefined;
  }
} // identity scale

scale(Identity, d3_scale__WEBPACK_IMPORTED_MODULE_6__.default); // continuous scales

scale(Linear, d3_scale__WEBPACK_IMPORTED_MODULE_7__.default, Continuous);
scale(Log, d3_scale__WEBPACK_IMPORTED_MODULE_8__.default, [Continuous, Log]);
scale(Pow, d3_scale__WEBPACK_IMPORTED_MODULE_9__.default, Continuous);
scale(Sqrt, d3_scale__WEBPACK_IMPORTED_MODULE_9__.sqrt, Continuous);
scale(Symlog, d3_scale__WEBPACK_IMPORTED_MODULE_10__.default, Continuous);
scale(Time, d3_scale__WEBPACK_IMPORTED_MODULE_11__.default, [Continuous, Temporal]);
scale(UTC, d3_scale__WEBPACK_IMPORTED_MODULE_12__.default, [Continuous, Temporal]); // sequential scales

scale(Sequential, d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]); // backwards compat

scale("".concat(Sequential, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_13__.default, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialLog, [Continuous, Interpolating, Log]);
scale("".concat(Sequential, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialPow, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSqrt, [Continuous, Interpolating]);
scale("".concat(Sequential, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSymlog, [Continuous, Interpolating]); // diverging scales

scale("".concat(Diverging, "-").concat(Linear), d3_scale__WEBPACK_IMPORTED_MODULE_14__.default, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Log), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingLog, [Continuous, Interpolating, Log]);
scale("".concat(Diverging, "-").concat(Pow), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingPow, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Sqrt), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSqrt, [Continuous, Interpolating]);
scale("".concat(Diverging, "-").concat(Symlog), d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSymlog, [Continuous, Interpolating]); // discretizing scales

scale(Quantile, d3_scale__WEBPACK_IMPORTED_MODULE_15__.default, [Discretizing, Quantile]);
scale(Quantize, d3_scale__WEBPACK_IMPORTED_MODULE_16__.default, Discretizing);
scale(Threshold, d3_scale__WEBPACK_IMPORTED_MODULE_17__.default, Discretizing); // discrete scales

scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, d3_scale__WEBPACK_IMPORTED_MODULE_1__.default, Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, type);
}

function hasType(key, type) {
  const s = scales[key];
  return s && s.metadata[type];
}

function isContinuous(key) {
  return hasType(key, Continuous);
}
function isDiscrete(key) {
  return hasType(key, Discrete);
}
function isDiscretizing(key) {
  return hasType(key, Discretizing);
}
function isLogarithmic(key) {
  return hasType(key, Log);
}
function isTemporal(key) {
  return hasType(key, Temporal);
}
function isInterpolating(key) {
  return hasType(key, Interpolating);
}
function isQuantile(key) {
  return hasType(key, Quantile);
}

const scaleProps = ['clamp', 'base', 'constant', 'exponent'];
function interpolateRange(interpolator, range) {
  const start = range[0],
        span = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range) - start;
  return function (i) {
    return interpolator(start + i * span);
  };
}
function interpolateColors(colors, type, gamma) {
  return (0,d3_interpolate__WEBPACK_IMPORTED_MODULE_18__.default)(interpolate(type || 'rgb', gamma), colors);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count),
        n = count + 1;

  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);

  return samples;
}
function scaleCopy(scale) {
  const t = scale.type,
        s = scale.copy();
  s.type = t;
  return s;
}
function scaleFraction(scale$1, min, max) {
  const delta = max - min;
  let i, t, s;

  if (!delta || !Number.isFinite(delta)) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(0.5);
  } else {
    i = (t = scale$1.type).indexOf('-');
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min, max]).range([0, 1]);
    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);
    return s;
  }
}
function interpolate(type, gamma) {
  const interp = d3_interpolate__WEBPACK_IMPORTED_MODULE_19__[method(type)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}

function method(type) {
  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
}

const continuous = {
  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',
  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',
  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',
  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',
  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',
  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',
  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',
  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',
  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',
  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',
  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',
  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',
  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',
  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',
  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',
  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',
  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',
  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',
  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',
  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',
  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',
  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',
  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',
  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',
  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',
  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',
  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',
  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',
  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',
  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',
  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',
  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',
  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',
  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',
  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',
  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',
  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',
  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',
  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',
  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',
  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',
  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',
  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',
  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',
  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',
  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',
  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',
  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',
  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',
  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',
  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',
  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',
  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'
};
const discrete = {
  category10: '1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf',
  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',
  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',
  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',
  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',
  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5',
  accent: '7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666',
  dark2: '1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666',
  paired: 'a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928',
  pastel1: 'fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2',
  pastel2: 'b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc',
  set1: 'e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999',
  set2: '66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3',
  set3: '8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f'
};

function colors(palette) {
  const n = palette.length / 6 | 0,
        c = new Array(n);

  for (let i = 0; i < n;) {
    c[i] = '#' + palette.slice(i * 6, ++i * 6);
  }

  return c;
}

function apply(_, f) {
  for (const k in _) scheme(k, f(_[k]));
}

const schemes = {};
apply(discrete, colors);
apply(continuous, _ => interpolateColors(colors(_)));
function scheme(name, scheme) {
  name = name && name.toLowerCase();

  if (arguments.length > 1) {
    schemes[name] = scheme;
    return this;
  } else {
    return schemes[name];
  }
}

const SymbolLegend = 'symbol';
const DiscreteLegend = 'discrete';
const GradientLegend = 'gradient';

const defaultFormatter = value => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => String(v)) : String(value);

const ascending = (a, b) => a[1] - b[1];

const descending = (a, b) => b[1] - a[1];
/**
 * Determine the tick count or interval function.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} count - The desired tick count or interval specifier.
 * @param {number} minStep - The desired minimum step between tick values.
 * @return {*} - The tick count or interval function.
 */


function tickCount(scale, count, minStep) {
  let step;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(count)) {
    if (scale.bins) {
      count = Math.max(count, scale.bins.length);
    }

    if (minStep != null) {
      count = Math.min(count, Math.floor((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(scale.domain()) / minStep || 1));
    }
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(count)) {
    step = count.step;
    count = count.interval;
  }

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(count)) {
    count = scale.type === Time ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.timeInterval)(count) : scale.type == UTC ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.utcInterval)(count) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only time and utc scales accept interval strings.');
    if (step) count = count.every(step);
  }

  return count;
}
/**
 * Filter a set of candidate tick values, ensuring that only tick values
 * that lie within the scale range are included.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {Array<*>} ticks - The candidate tick values.
 * @param {*} count - The tick count or interval function.
 * @return {Array<*>} - The filtered tick values.
 */

function validTicks(scale, ticks, count) {
  let range = scale.range(),
      lo = range[0],
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range),
      cmp = ascending;

  if (lo > hi) {
    range = hi;
    hi = lo;
    lo = range;
    cmp = descending;
  }

  lo = Math.floor(lo);
  hi = Math.ceil(hi); // filter ticks to valid values within the range
  // additionally sort ticks in range order (#2579)

  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);

  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(ticks)];

    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }

    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }

  return ticks;
}
/**
 * Generate tick values for the given scale and approximate tick count or
 * interval value. If the scale has a 'ticks' method, it will be used to
 * generate the ticks, with the count argument passed as a parameter. If the
 * scale lacks a 'ticks' method, the full scale domain will be returned.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} [count] - The approximate number of desired ticks.
 * @return {Array<*>} - The generated tick values.
 */

function tickValues(scale, count) {
  return scale.bins ? validTicks(scale, scale.bins) : scale.ticks ? scale.ticks(count) : scale.domain();
}
/**
 * Generate a label format function for a scale. If the scale has a
 * 'tickFormat' method, it will be used to generate the formatter, with the
 * count and specifier arguments passed as parameters. If the scale lacks a
 * 'tickFormat' method, the returned formatter performs simple string coercion.
 * If the input scale is a logarithmic scale and the format specifier does not
 * indicate a desired decimal precision, a special variable precision formatter
 * that automatically trims trailing zeroes will be generated.
 * @param {Scale} scale - The scale for which to generate the label formatter.
 * @param {*} [count] - The approximate number of desired ticks.
 * @param {string} [specifier] - The format specifier. Must be a legal d3
 *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or
 *   time multi-format specifier object.
 * @return {function(*):string} - The generated label formatter.
 */

function tickFormat(locale, scale, count, specifier, formatType, noSkip) {
  const type = scale.type;
  let format = defaultFormatter;

  if (type === Time || formatType === Time) {
    format = locale.timeFormat(specifier);
  } else if (type === UTC || formatType === UTC) {
    format = locale.utcFormat(specifier);
  } else if (isLogarithmic(type)) {
    const varfmt = locale.formatFloat(specifier);

    if (noSkip || scale.bins) {
      format = varfmt;
    } else {
      const test = tickLog(scale, count, false);

      format = _ => test(_) ? varfmt(_) : '';
    }
  } else if (scale.tickFormat) {
    // if d3 scale has tickFormat, it must be continuous
    const d = scale.domain();
    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format = locale.format(specifier);
  }

  return format;
}
function tickLog(scale, count, values) {
  const ticks = tickValues(scale, count),
        base = scale.base(),
        logb = Math.log(base),
        k = Math.max(1, base * count / ticks.length); // apply d3-scale's log format filter criteria

  const test = d => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5) i *= base;
    return i <= k;
  };

  return values ? ticks.filter(test) : test;
}

const symbols = {
  [Quantile]: 'quantiles',
  [Quantize]: 'thresholds',
  [Threshold]: 'domain'
};
const formats = {
  [Quantile]: 'quantiles',
  [Quantize]: 'domain'
};
function labelValues(scale, count) {
  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);
}
function thresholdFormat(locale, scale, specifier) {
  const _ = scale[formats[scale.type]](),
        n = _.length;

  let d = n > 1 ? _[1] - _[0] : _[0],
      i;

  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  } // tickCount = 3 ticks times 10 for increased resolution


  return locale.formatSpan(0, d, 3 * 10, specifier);
}

function thresholdValues(thresholds) {
  const values = [-Infinity].concat(thresholds);
  values.max = +Infinity;
  return values;
}

function binValues(bins) {
  const values = bins.slice(0, -1);
  values.max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(bins);
  return values;
}

const isDiscreteRange = scale => symbols[scale.type] || scale.bins;

function labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {
  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);
  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);
}

const formatRange = format => (value, index, array) => {
  const limit = get(array[index + 1], get(array.max, +Infinity)),
        lo = formatValue(value, format),
        hi = formatValue(limit, format);
  return lo && hi ? lo + ' \u2013 ' + hi : hi ? '< ' + hi : '\u2265 ' + lo;
};

const get = (value, dflt) => value != null ? value : dflt;

const formatDiscrete = format => (value, index) => index ? format(value) : null;

const formatPoint = format => value => format(value);

const formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;

function labelFraction(scale) {
  const domain = scale.domain(),
        count = domain.length - 1;
  let lo = +domain[0],
      hi = +(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain),
      span = hi - lo;

  if (scale.type === Threshold) {
    const adjust = count ? span / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span = hi - lo;
  }

  return value => (value - lo) / span;
}

function format(locale, scale, specifier, formatType) {
  const type = formatType || scale.type; // replace abbreviated time specifiers to improve screen reader experience

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(specifier) && isTemporal(type)) {
    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');
  }

  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);
}

function domainCaption(locale, scale, opt) {
  opt = opt || {};
  const max = Math.max(3, opt.maxlen || 7),
        fmt = format(locale, scale, opt.format, opt.formatType); // if scale breaks domain into bins, describe boundaries

  if (isDiscretizing(scale.type)) {
    const v = labelValues(scale).slice(1).map(fmt),
          n = v.length;
    return "".concat(n, " boundar").concat(n === 1 ? 'y' : 'ies', ": ").concat(v.join(', '));
  } // if scale domain is discrete, list values
  else if (isDiscrete(scale.type)) {
      const d = scale.domain(),
            n = d.length,
            v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');
      return "".concat(n, " value").concat(n === 1 ? '' : 's', ": ").concat(v);
    } // if scale domain is continuous, describe value range
    else {
        const d = scale.domain();
        return "values from ".concat(fmt(d[0]), " to ").concat(fmt((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(d)));
      }
}




/***/ }),

/***/ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-scenegraph/build/vega-scenegraph.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bounds": () => (/* binding */ Bounds),
/* harmony export */   "CanvasHandler": () => (/* binding */ CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* binding */ CanvasRenderer),
/* harmony export */   "Gradient": () => (/* binding */ Gradient),
/* harmony export */   "GroupItem": () => (/* binding */ GroupItem),
/* harmony export */   "Handler": () => (/* binding */ Handler),
/* harmony export */   "Item": () => (/* binding */ Item),
/* harmony export */   "Marks": () => (/* binding */ Marks),
/* harmony export */   "RenderType": () => (/* binding */ RenderType),
/* harmony export */   "Renderer": () => (/* binding */ Renderer),
/* harmony export */   "ResourceLoader": () => (/* binding */ ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* binding */ SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* binding */ SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* binding */ SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* binding */ Scenegraph),
/* harmony export */   "boundClip": () => (/* binding */ boundClip),
/* harmony export */   "boundContext": () => (/* binding */ boundContext),
/* harmony export */   "boundItem": () => (/* binding */ boundItem),
/* harmony export */   "boundMark": () => (/* binding */ boundMark),
/* harmony export */   "boundStroke": () => (/* binding */ boundStroke),
/* harmony export */   "domChild": () => (/* binding */ domChild),
/* harmony export */   "domClear": () => (/* binding */ domClear),
/* harmony export */   "domCreate": () => (/* binding */ domCreate),
/* harmony export */   "domFind": () => (/* binding */ domFind),
/* harmony export */   "font": () => (/* binding */ font),
/* harmony export */   "fontFamily": () => (/* binding */ fontFamily),
/* harmony export */   "fontSize": () => (/* binding */ fontSize),
/* harmony export */   "intersect": () => (/* binding */ intersect),
/* harmony export */   "intersectBoxLine": () => (/* binding */ intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* binding */ intersectPath),
/* harmony export */   "intersectPoint": () => (/* binding */ intersectPoint),
/* harmony export */   "intersectRule": () => (/* binding */ intersectRule),
/* harmony export */   "lineHeight": () => (/* binding */ lineHeight),
/* harmony export */   "markup": () => (/* binding */ markup),
/* harmony export */   "multiLineOffset": () => (/* binding */ multiLineOffset),
/* harmony export */   "pathCurves": () => (/* binding */ curves),
/* harmony export */   "pathEqual": () => (/* binding */ pathEqual),
/* harmony export */   "pathParse": () => (/* binding */ pathParse),
/* harmony export */   "pathRectangle": () => (/* binding */ vg_rect),
/* harmony export */   "pathRender": () => (/* binding */ pathRender),
/* harmony export */   "pathSymbols": () => (/* binding */ symbols),
/* harmony export */   "pathTrail": () => (/* binding */ vg_trail),
/* harmony export */   "point": () => (/* binding */ point),
/* harmony export */   "renderModule": () => (/* binding */ renderModule),
/* harmony export */   "resetSVGClipId": () => (/* binding */ resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* binding */ resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* binding */ sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* binding */ sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* binding */ pickVisit),
/* harmony export */   "sceneToJSON": () => (/* binding */ sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* binding */ visit),
/* harmony export */   "sceneZOrder": () => (/* binding */ zorder),
/* harmony export */   "serializeXML": () => (/* binding */ serializeXML),
/* harmony export */   "textMetrics": () => (/* binding */ textMetrics)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");







let gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
const patternPrefix = 'p_';
function isGradient(value) {
  return value && value.gradient;
}
function gradientRef(g, defs, base) {
  const type = g.gradient;
  let id = g.id,
      prefix = type === 'radial' ? patternPrefix : ''; // check id, assign default values as needed

  if (!id) {
    id = g.id = 'gradient_' + gradient_id++;

    if (type === 'radial') {
      g.x1 = get(g.x1, 0.5);
      g.y1 = get(g.y1, 0.5);
      g.r1 = get(g.r1, 0);
      g.x2 = get(g.x2, 0.5);
      g.y2 = get(g.y2, 0.5);
      g.r2 = get(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get(g.x1, 0);
      g.y1 = get(g.y1, 0);
      g.x2 = get(g.x2, 1);
      g.y2 = get(g.y2, 0);
    }
  } // register definition


  defs[id] = g; // return url reference

  return 'url(' + (base || '') + '#' + prefix + id + ')';
}

function get(val, def) {
  return val != null ? val : def;
}

function Gradient (p0, p1) {
  var stops = [],
      gradient;
  return gradient = {
    gradient: 'linear',
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops: stops,
    stop: function (offset, color) {
      stops.push({
        offset: offset,
        color: color
      });
      return gradient;
    }
  };
}

const lookup = {
  'basis': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_4__.default
  },
  'basis-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_5__.default
  },
  'basis-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_6__.default
  },
  'bundle': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_7__.default,
    tension: 'beta',
    value: 0.85
  },
  'cardinal': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_8__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_9__.default,
    tension: 'tension',
    value: 0
  },
  'cardinal-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_10__.default,
    tension: 'tension',
    value: 0
  },
  'catmull-rom': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_11__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_12__.default,
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_13__.default,
    tension: 'alpha',
    value: 0.5
  },
  'linear': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_14__.default
  },
  'linear-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_15__.default
  },
  'monotone': {
    horizontal: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneY,
    vertical: d3_shape__WEBPACK_IMPORTED_MODULE_16__.monotoneX
  },
  'natural': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_17__.default
  },
  'step': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.default
  },
  'step-after': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepAfter
  },
  'step-before': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__.stepBefore
  }
};
function curves(type, orientation, tension) {
  var entry = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(lookup, type) && lookup[type],
      curve = null;

  if (entry) {
    curve = entry.curve || entry[orientation || 'vertical'];

    if (entry.tension && tension != null) {
      curve = curve[entry.tension](tension);
    }
  }

  return curve;
}

// Path parsing and rendering code adapted from fabric.js -- Thanks!
const cmdlen = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
},
      regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
function pathParse (pathstr) {
  const result = [];
  let curr, chunks, parsed, param, cmd, len, i, j, n, m; // First, break path into command sequence

  const path = pathstr.slice().replace(regexp[0], '###$1').split(regexp[1]).slice(1); // Next, parse each command in turn

  for (i = 0, n = path.length; i < n; ++i) {
    curr = path[i];
    chunks = curr.slice(1).trim().replace(regexp[2], '$1###$2').replace(regexp[3], '$1###$2').split(regexp[4]);
    cmd = curr.charAt(0);
    parsed = [cmd];

    for (j = 0, m = chunks.length; j < m; ++j) {
      if ((param = +chunks[j]) === param) {
        // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];

    if (parsed.length - 1 > len) {
      const m = parsed.length;
      j = 1;
      result.push([cmd].concat(parsed.slice(j, j += len))); // handle implicit lineTo (#2803)

      cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;

      for (; j < m; j += len) {
        result.push([cmd].concat(parsed.slice(j, j + len)));
      }
    } else {
      result.push(parsed);
    }
  }

  return result;
}

const DegToRad = Math.PI / 180;
const Epsilon = 1e-14;
const HalfPi = Math.PI / 2;
const Tau = Math.PI * 2;
const HalfSqrt3 = Math.sqrt(3) / 2;

var segmentCache = {};
var bezierCache = {};
var join = [].join; // Copied from Inkscape svgtopdf, thanks!

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const key = join.call(arguments);

  if (segmentCache[key]) {
    return segmentCache[key];
  }

  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);

  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y;
  const y1 = a10 * x + a11 * y;
  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;

  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }

  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
  const result = [];

  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return segmentCache[key] = result;
}
function bezier(params) {
  const key = join.call(params);

  if (bezierCache[key]) {
    return bezierCache[key];
  }

  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x1 = cx + cos_th0 - t * sin_th0;
  const y1 = cy + sin_th0 + t * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t * sin_th1;
  const y2 = y3 - t * cos_th1;
  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}

const temp = ['l', 0, 0, 0, 0, 0, 0, 0];

function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];

  if (c === 'a' || c === 'A') {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c === 'h' || c === 'H') {
    temp[1] = sX * current[1];
  } else if (c === 'v' || c === 'V') {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }

  return temp;
}

function pathRender (context, path, l, t, sX, sY) {
  var current,
      // current instruction
  previous = null,
      x = 0,
      // current x
  y = 0,
      // current y
  controlX = 0,
      // current control point x
  controlY = 0,
      // current control point y
  tempX,
      tempY,
      tempControlX,
      tempControlY;
  if (l == null) l = 0;
  if (t == null) t = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context.beginPath) context.beginPath();

  for (var i = 0, len = path.length; i < len; ++i) {
    current = path[i];

    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }

    switch (current[0]) {
      // first letter
      case 'l':
        // lineto, relative
        x += current[1];
        y += current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'L':
        // lineto, absolute
        x = current[1];
        y = current[2];
        context.lineTo(x + l, y + t);
        break;

      case 'h':
        // horizontal lineto, relative
        x += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'H':
        // horizontal lineto, absolute
        x = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'v':
        // vertical lineto, relative
        y += current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'V':
        // verical lineto, absolute
        y = current[1];
        context.lineTo(x + l, y + t);
        break;

      case 'm':
        // moveTo, relative
        x += current[1];
        y += current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'M':
        // moveTo, absolute
        x = current[1];
        y = current[2];
        context.moveTo(x + l, y + t);
        break;

      case 'c':
        // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        context.bezierCurveTo(x + current[1] + l, // x1
        y + current[2] + t, // y1
        controlX + l, // x2
        controlY + t, // y2
        tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'C':
        // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
        break;

      case 's':
        // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t); // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = x + current[1];
        controlY = y + current[2];
        x = tempX;
        y = tempY;
        break;

      case 'S':
        // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY; // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.

        controlX = current[1];
        controlY = current[2];
        break;

      case 'q':
        // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        controlX = x + current[1];
        controlY = y + current[2];
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'Q':
        // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't':
        // shorthand quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        } else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        } else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2]; // calculate reflection of previous control points

        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        context.closePath();
        break;
    }

    previous = current;
  }
}

function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], // end x
  coords[6], // end y
  coords[0], // radius x
  coords[1], // radius y
  coords[3], // large flag
  coords[4], // sweep flag
  coords[2], // rotation
  x, y);

  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}

const Tan30 = 0.5773502691896257;
const builtins = {
  'circle': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, Tau);
    }
  },
  'cross': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 2.5;
      context.moveTo(-r, -s);
      context.lineTo(-r, s);
      context.lineTo(-s, s);
      context.lineTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, s);
      context.lineTo(r, s);
      context.lineTo(r, -s);
      context.lineTo(s, -s);
      context.lineTo(s, -r);
      context.lineTo(-s, -r);
      context.lineTo(-s, -s);
      context.closePath();
    }
  },
  'diamond': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.closePath();
    }
  },
  'square': {
    draw: function (context, size) {
      var w = Math.sqrt(size),
          x = -w / 2;
      context.rect(x, x, w, w);
    }
  },
  'arrow': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          s = r / 7,
          t = r / 2.5,
          v = r / 8;
      context.moveTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, -v);
      context.lineTo(t, -v);
      context.lineTo(0, -r);
      context.lineTo(-t, -v);
      context.lineTo(-s, -v);
      context.closePath();
    }
  },
  'wedge': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30,
          b = r / 4;
      context.moveTo(0, -h - o);
      context.lineTo(-b, h - o);
      context.lineTo(b, h - o);
      context.closePath();
    }
  },
  'triangle': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r,
          o = h - r * Tan30;
      context.moveTo(0, -h - o);
      context.lineTo(-r, h - o);
      context.lineTo(r, h - o);
      context.closePath();
    }
  },
  'triangle-up': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, -h);
      context.lineTo(-r, h);
      context.lineTo(r, h);
      context.closePath();
    }
  },
  'triangle-down': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(0, h);
      context.lineTo(-r, -h);
      context.lineTo(r, -h);
      context.closePath();
    }
  },
  'triangle-right': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(h, 0);
      context.lineTo(-h, -r);
      context.lineTo(-h, r);
      context.closePath();
    }
  },
  'triangle-left': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
          h = HalfSqrt3 * r;
      context.moveTo(-h, 0);
      context.lineTo(h, -r);
      context.lineTo(h, r);
      context.closePath();
    }
  },
  'stroke': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
    }
  }
};
function symbols(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};

function customSymbol(path) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(custom, path)) {
    const parsed = pathParse(path);
    custom[path] = {
      draw: function (context, size) {
        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }

  return custom[path];
}

const C = 0.448084975506; // C = 1 - c

function rectangleX(d) {
  return d.x;
}

function rectangleY(d) {
  return d.y;
}

function rectangleWidth(d) {
  return d.width;
}

function rectangleHeight(d) {
  return d.height;
}

function number(_) {
  return typeof _ === 'function' ? _ : () => +_;
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}

function vg_rect () {
  var x = rectangleX,
      y = rectangleY,
      width = rectangleWidth,
      height = rectangleHeight,
      crTL = number(0),
      crTR = crTL,
      crBL = crTL,
      crBR = crTL,
      context = null;

  function rectangle(_, x0, y0) {
    var buffer,
        x1 = x0 != null ? x0 : +x.call(this, _),
        y1 = y0 != null ? y0 : +y.call(this, _),
        w = +width.call(this, _),
        h = +height.call(this, _),
        s = Math.min(w, h) / 2,
        tl = clamp(+crTL.call(this, _), 0, s),
        tr = clamp(+crTR.call(this, _), 0, s),
        bl = clamp(+crBL.call(this, _), 0, s),
        br = clamp(+crBR.call(this, _), 0, s);
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
      context.rect(x1, y1, w, h);
    } else {
      var x2 = x1 + w,
          y2 = y1 + h;
      context.moveTo(x1 + tl, y1);
      context.lineTo(x2 - tr, y1);
      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
      context.lineTo(x2, y2 - br);
      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
      context.lineTo(x1 + bl, y2);
      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
      context.lineTo(x1, y1 + tl);
      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
      context.closePath();
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  rectangle.x = function (_) {
    if (arguments.length) {
      x = number(_);
      return rectangle;
    } else {
      return x;
    }
  };

  rectangle.y = function (_) {
    if (arguments.length) {
      y = number(_);
      return rectangle;
    } else {
      return y;
    }
  };

  rectangle.width = function (_) {
    if (arguments.length) {
      width = number(_);
      return rectangle;
    } else {
      return width;
    }
  };

  rectangle.height = function (_) {
    if (arguments.length) {
      height = number(_);
      return rectangle;
    } else {
      return height;
    }
  };

  rectangle.cornerRadius = function (tl, tr, br, bl) {
    if (arguments.length) {
      crTL = number(tl);
      crTR = tr != null ? number(tr) : crTL;
      crBR = br != null ? number(br) : crTL;
      crBL = bl != null ? number(bl) : crTR;
      return rectangle;
    } else {
      return crTL;
    }
  };

  rectangle.context = function (_) {
    if (arguments.length) {
      context = _ == null ? null : _;
      return rectangle;
    } else {
      return context;
    }
  };

  return rectangle;
}

function vg_trail () {
  var x,
      y,
      size,
      defined,
      context = null,
      ready,
      x1,
      y1,
      r1;

  function point(x2, y2, w2) {
    const r2 = w2 / 2;

    if (ready) {
      var ux = y1 - y2,
          uy = x2 - x1;

      if (ux || uy) {
        // get normal vector
        var ud = Math.sqrt(ux * ux + uy * uy),
            rx = (ux /= ud) * r1,
            ry = (uy /= ud) * r1,
            t = Math.atan2(uy, ux); // draw segment

        context.moveTo(x1 - rx, y1 - ry);
        context.lineTo(x2 - ux * r2, y2 - uy * r2);
        context.arc(x2, y2, r2, t - Math.PI, t);
        context.lineTo(x1 + rx, y1 + ry);
        context.arc(x1, y1, r1, t, t + Math.PI);
      } else {
        context.arc(x2, y2, r2, 0, Tau);
      }

      context.closePath();
    } else {
      ready = 1;
    }

    x1 = x2;
    y1 = y2;
    r1 = r2;
  }

  function trail(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_19__.default)();

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }

      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
    }

    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }

  trail.x = function (_) {
    if (arguments.length) {
      x = _;
      return trail;
    } else {
      return x;
    }
  };

  trail.y = function (_) {
    if (arguments.length) {
      y = _;
      return trail;
    } else {
      return y;
    }
  };

  trail.size = function (_) {
    if (arguments.length) {
      size = _;
      return trail;
    } else {
      return size;
    }
  };

  trail.defined = function (_) {
    if (arguments.length) {
      defined = _;
      return trail;
    } else {
      return defined;
    }
  };

  trail.context = function (_) {
    if (arguments.length) {
      if (_ == null) {
        context = null;
      } else {
        context = _;
      }

      return trail;
    } else {
      return context;
    }
  };

  return trail;
}

function value$1(a, b) {
  return a != null ? a : b;
}

const x = item => item.x || 0,
      y = item => item.y || 0,
      w = item => item.width || 0,
      h = item => item.height || 0,
      xw = item => (item.x || 0) + (item.width || 0),
      yh = item => (item.y || 0) + (item.height || 0),
      sa = item => item.startAngle || 0,
      ea = item => item.endAngle || 0,
      pa = item => item.padAngle || 0,
      ir = item => item.innerRadius || 0,
      or = item => item.outerRadius || 0,
      cr = item => item.cornerRadius || 0,
      tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
      tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
      br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
      bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
      sz = item => value$1(item.size, 64),
      ts = item => item.size || 1,
      def = item => !(item.defined === false),
      type = item => symbols(item.shape || 'circle');

const arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_20__.default)().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
      areavShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().x(x).y1(y).y0(yh).defined(def),
      areahShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__.default)().y(y).x1(x).x0(xw).defined(def),
      lineShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_22__.default)().x(x).y(y).defined(def),
      rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
      symbolShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_23__.default)().type(type).size(sz),
      trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context, item) {
  return arcShape.context(context)(item);
}
function area$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function line$1(context, items) {
  const item = items[0],
        interp = item.interpolate || 'linear';
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function rectangle(context, item, x, y) {
  return rectShape.context(context)(item, x, y);
}
function shape$1(context, item) {
  return (item.mark.shape || item.shape).context(context)(item);
}
function symbol$1(context, item) {
  return symbolShape.context(context)(item);
}
function trail$1(context, items) {
  return trailShape.context(context)(items);
}

var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1 (renderer, item, size) {
  var clip = item.clip,
      defs = renderer._defs,
      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
      c = defs.clipping[id] || (defs.clipping[id] = {
    id: id
  });

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    c.path = clip(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }

  return 'url(#' + id + ')';
}

function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },

  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },

  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },

  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  },

  set(x1, y1, x2, y2) {
    if (x2 < x1) {
      this.x2 = x1;
      this.x1 = x2;
    } else {
      this.x1 = x1;
      this.x2 = x2;
    }

    if (y2 < y1) {
      this.y2 = y1;
      this.y1 = y2;
    } else {
      this.y1 = y1;
      this.y2 = y2;
    }

    return this;
  },

  add(x, y) {
    if (x < this.x1) this.x1 = x;
    if (y < this.y1) this.y1 = y;
    if (x > this.x2) this.x2 = x;
    if (y > this.y2) this.y2 = y;
    return this;
  },

  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },

  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },

  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },

  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },

  rotate(angle, x, y) {
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },

  rotatedPoints(angle, x, y) {
    var {
      x1,
      y1,
      x2,
      y2
    } = this,
        cos = Math.cos(angle),
        sin = Math.sin(angle),
        cx = x - x * cos + y * sin,
        cy = y - x * sin - y * cos;
    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
  },

  union(b) {
    if (b.x1 < this.x1) this.x1 = b.x1;
    if (b.y1 < this.y1) this.y1 = b.y1;
    if (b.x2 > this.x2) this.x2 = b.x2;
    if (b.y2 > this.y2) this.y2 = b.y2;
    return this;
  },

  intersect(b) {
    if (b.x1 > this.x1) this.x1 = b.x1;
    if (b.y1 > this.y1) this.y1 = b.y1;
    if (b.x2 < this.x2) this.x2 = b.x2;
    if (b.y2 < this.y2) this.y2 = b.y2;
    return this;
  },

  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  },

  alignsWith(b) {
    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
  },

  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  },

  contains(x, y) {
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  },

  width() {
    return this.x2 - this.x1;
  },

  height() {
    return this.y2 - this.y1;
  }

};

function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}

function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(GroupItem, Item);

function ResourceLoader(customLoader) {
  this._pending = 0;
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
}

function increment(loader) {
  loader._pending += 1;
}

function decrement(loader) {
  loader._pending -= 1;
}

ResourceLoader.prototype = {
  pending() {
    return this._pending;
  },

  sanitizeURL(uri) {
    const loader = this;
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'href'
    }).then(opt => {
      decrement(loader);
      return opt;
    }).catch(() => {
      decrement(loader);
      return null;
    });
  },

  loadImage(uri) {
    const loader = this,
          Image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.image)();
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'image'
    }).then(opt => {
      const url = opt.href;
      if (!url || !Image) throw {
        url: url
      };
      const img = new Image(); // set crossOrigin only if cors is defined; empty string sets anonymous mode
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin

      const cors = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
      if (cors != null) img.crossOrigin = cors; // attempt to load image resource

      img.onload = () => decrement(loader);

      img.onerror = () => decrement(loader);

      img.src = url;
      return img;
    }).catch(e => {
      decrement(loader);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ''
      };
    });
  },

  ready() {
    const loader = this;
    return new Promise(accept => {
      function poll(value) {
        if (!loader.pending()) accept(value);else setTimeout(() => {
          poll(true);
        }, 10);
      }

      poll(false);
    });
  }

};

function boundStroke (bounds, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }

  return bounds;
}

function miterAdjustment(item, strokeWidth) {
  // TODO: more sophisticated adjustment? Or miter support in boundContext?
  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
}

const circleThreshold = Tau - 1e-8;
let bounds, lx, ly, rot, ma, mb, mc, md;

const add = (x, y) => bounds.add(x, y);

const addL = (x, y) => add(lx = x, ly = y);

const addX = x => add(x, bounds.y1);

const addY = y => add(bounds.x1, y);

const px = (x, y) => ma * x + mc * y;

const py = (x, y) => mb * x + md * y;

const addp = (x, y) => add(px(x, y), py(x, y));

const addpL = (x, y) => addL(px(x, y), py(x, y));

function boundContext (_, deg) {
  bounds = _;

  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }

  return context$1;
}
const context$1 = {
  beginPath() {},

  closePath() {},

  moveTo: addpL,
  lineTo: addpL,

  rect(x, y, w, h) {
    if (rot) {
      addp(x + w, y);
      addp(x + w, y + h);
      addp(x, y + h);
      addpL(x, y);
    } else {
      add(x + w, y + h);
      addL(x, y);
    }
  },

  quadraticCurveTo(x1, y1, x2, y2) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },

  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    const px1 = px(x1, y1),
          py1 = py(x1, y1),
          px2 = px(x2, y2),
          py2 = py(x2, y2),
          px3 = px(x3, y3),
          py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },

  arc(cx, cy, r, sa, ea, ccw) {
    sa += rot;
    ea += rot; // store last point on path

    lx = r * Math.cos(ea) + cx;
    ly = r * Math.sin(ea) + cy;

    if (Math.abs(ea - sa) > circleThreshold) {
      // treat as full circle
      add(cx - r, cy - r);
      add(cx + r, cy + r);
    } else {
      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);

      let s, i; // sample end points

      update(sa);
      update(ea); // sample interior points aligned with 90 degrees

      if (ea !== sa) {
        sa = sa % Tau;
        if (sa < 0) sa += Tau;
        ea = ea % Tau;
        if (ea < 0) ea += Tau;

        if (ea < sa) {
          ccw = !ccw; // flip direction

          s = sa;
          sa = ea;
          ea = s; // swap end-points
        }

        if (ccw) {
          ea -= Tau;
          s = sa - sa % HalfPi;

          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
        } else {
          s = sa - sa % HalfPi + HalfPi;

          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
        }
      }
    }
  }

};

function quadExtrema(x0, x1, x2, cb) {
  const t = (x0 - x1) / (x0 + x2 - 2 * x1);
  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
}

function cubicExtrema(x0, x1, x2, x3, cb) {
  const a = x3 - x0 + 3 * x1 - 3 * x2,
        b = x0 + x2 - 2 * x1,
        c = x0 - x1;
  let t0 = 0,
      t1 = 0,
      r; // solve for parameter t

  if (Math.abs(a) > Epsilon) {
    // quadratic equation
    r = b * b + c * a;

    if (r >= 0) {
      r = Math.sqrt(r);
      t0 = (-b + r) / a;
      t1 = (-b - r) / a;
    }
  } else {
    // linear equation
    t0 = 0.5 * c / b;
  } // calculate position


  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
}

function cubic(t, x0, x1, x2, x3) {
  const s = 1 - t,
        s2 = s * s,
        t2 = t * t;
  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
}

var context = (context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1)) ? context.getContext('2d') : null;

const b = new Bounds();
function intersectPath(draw) {
  return function (item, brush) {
    // rely on (inaccurate) bounds intersection if no context
    if (!context) return true; // add path to offscreen graphics context

    draw(context, item); // get bounds intersection region

    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1,
      y1,
      x2,
      y2
    } = b; // iterate over intersection region
    // perform fine grained inclusion test

    for (let y = y1; y <= y2; ++y) {
      for (let x = x1; x <= x2; ++x) {
        if (context.isPointInPath(x, y)) {
          return true;
        }
      }
    } // false if no hits in intersection region


    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        w = item.width || 0,
        h = item.height || 0;
  return box.intersects(b.set(x, y, x + w, y + h));
}
function intersectRule(item, box) {
  const x = item.x || 0,
        y = item.y || 0,
        x2 = item.x2 != null ? item.x2 : x,
        y2 = item.y2 != null ? item.y2 : y;
  return intersectBoxLine(box, x, y, x2, y2);
}
function intersectBoxLine(box, x, y, u, v) {
  const {
    x1,
    y1,
    x2,
    y2
  } = box,
        dx = u - x,
        dy = v - y;
  let t0 = 0,
      t1 = 1,
      p,
      q,
      r,
      e;

  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x1 - x);
    }

    if (e === 1) {
      p = dx;
      q = x2 - x;
    }

    if (e === 2) {
      p = -dy;
      q = -(y1 - y);
    }

    if (e === 3) {
      p = dy;
      q = y2 - y;
    }

    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r = q / p;

    if (p < 0) {
      if (r > t1) return false;else if (r > t0) t0 = r;
    } else if (p > 0) {
      if (r < t0) return false;else if (r < t1) t1 = r;
    }
  }

  return true;
}

function blend (context, item) {
  context.globalCompositeOperation = item.blend || 'source-over';
}

function value (value, dflt) {
  return value == null ? dflt : value;
}

function addStops(gradient, stops) {
  const n = stops.length;

  for (let i = 0; i < n; ++i) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }

  return gradient;
}

function gradient (context, spec, bounds) {
  const w = bounds.width(),
        h = bounds.height();
  let gradient;

  if (spec.gradient === 'radial') {
    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
  } else {
    // linear gradient
    const x1 = value(spec.x1, 0),
          y1 = value(spec.y1, 0),
          x2 = value(spec.x2, 1),
          y2 = value(spec.y2, 0);

    if (x1 === x2 || y1 === y2 || w === h) {
      // axis aligned: use normal gradient
      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
    } else {
      // not axis aligned: render gradient into a pattern (#2365)
      // this allows us to use normalized bounding box coordinates
      const image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(Math.ceil(w), Math.ceil(h)),
            ictx = image.getContext('2d');
      ictx.scale(w, h);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w, h);
      return context.createPattern(image, 'no-repeat');
    }
  }

  return addStops(gradient, spec.stops);
}

function color (context, item, value) {
  return isGradient(value) ? gradient(context, value, item.bounds) : value;
}

function fill (context, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.fillStyle = color(context, item, item.fill);
    return true;
  } else {
    return false;
  }
}

var Empty = [];
function stroke (context, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;

  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.strokeStyle = color(context, item, item.stroke);
    context.lineWidth = lw;
    context.lineCap = item.strokeCap || 'butt';
    context.lineJoin = item.strokeJoin || 'miter';
    context.miterLimit = item.strokeMiterLimit || 10;

    if (context.setLineDash) {
      context.setLineDash(item.strokeDash || Empty);
      context.lineDashOffset = item.strokeDashOffset || 0;
    }

    return true;
  } else {
    return false;
  }
}

function compare(a, b) {
  return a.zindex - b.zindex || a.index - b.index;
}

function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items,
      output = [],
      item,
      i,
      n;

  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output.push(item);
  }

  scene.zdirty = false;
  return scene.zitems = output.sort(compare);
}
function visit(scene, visitor) {
  var items = scene.items,
      i,
      n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);

  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }

    items = zitems;
  }

  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items,
      hit,
      i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;

  for (i = items.length; --i >= 0;) {
    if (hit = visitor(items[i])) return hit;
  }

  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0;) {
      if (!items[i].zindex) {
        if (hit = visitor(items[i])) return hit;
      }
    }
  }

  return null;
}

function drawAll(path) {
  return function (context, scene, bounds) {
    visit(scene, item => {
      if (!bounds || bounds.intersects(item.bounds)) {
        drawPath(path, context, item, item);
      }
    });
  };
}
function drawOne(path) {
  return function (context, scene, bounds) {
    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
      drawPath(path, context, scene.items[0], scene.items);
    }
  };
}

function drawPath(path, context, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0) return;
  if (path(context, items)) return;
  blend(context, item);

  if (item.fill && fill(context, item, opacity)) {
    context.fill();
  }

  if (item.stroke && stroke(context, item, opacity)) {
    context.stroke();
  }
}

function pick$1(test) {
  test = test || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
  return function (context, scene, x, y, gx, gy) {
    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return pickVisit(scene, item => {
      const b = item.bounds; // first hit test against bounding box

      if (b && !b.contains(gx, gy) || !b) return; // if in bounding box, perform more careful test

      if (test(context, item, x, y, gx, gy)) return item;
    });
  };
}
function hitPath(path, filled) {
  return function (context, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = filled == null ? item.fill : filled,
        stroke = item.stroke && context.isPointInStroke,
        lw,
        lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context.lineWidth = lw != null ? lw : 1;
      context.lineCap = lc != null ? lc : 'butt';
    }

    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
  };
}
function pickPath(path) {
  return pick$1(hitPath(path));
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}
function rotate(a) {
  return 'rotate(' + a + ')';
}
function scale(scaleX, scaleY) {
  return 'scale(' + scaleX + ',' + scaleY + ')';
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
}

function markItemPath (type, shape, isect) {
  function attr(emit, item) {
    emit('transform', rotateItem(item));
    emit('d', shape(null, item));
  }

  function bound(bounds, item) {
    shape(boundContext(bounds, item.angle), item);
    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
  }

  function draw(context, item) {
    var x = item.x || 0,
        y = item.y || 0,
        a = item.angle || 0;
    context.translate(x, y);
    if (a) context.rotate(a *= DegToRad);
    context.beginPath();
    shape(context, item);
    if (a) context.rotate(-a);
    context.translate(-x, -y);
  }

  return {
    type: type,
    tag: 'path',
    nested: false,
    attr: attr,
    bound: bound,
    draw: drawAll(draw),
    pick: pickPath(draw),
    isect: isect || intersectPath(draw)
  };
}

var arc = markItemPath('arc', arc$1);

function pickArea(a, p) {
  var v = a[0].orient === 'horizontal' ? p[1] : p[0],
      z = a[0].orient === 'horizontal' ? 'y' : 'x',
      i = a.length,
      min = +Infinity,
      hit,
      d;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    d = Math.abs(a[i][z] - v);

    if (d < min) {
      min = d;
      hit = a[i];
    }
  }

  return hit;
}
function pickLine(a, p) {
  var t = Math.pow(a[0].strokeWidth || 1, 2),
      i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t) return a[i];
  }

  return null;
}
function pickTrail(a, p) {
  var i = a.length,
      dx,
      dy,
      dd;

  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx) return a[i];
  }

  return null;
}

function markMultiItemPath (type, shape, tip) {
  function attr(emit, item) {
    var items = item.mark.items;
    if (items.length) emit('d', shape(null, items));
  }

  function bound(bounds, mark) {
    var items = mark.items;

    if (items.length === 0) {
      return bounds;
    } else {
      shape(boundContext(bounds), items);
      return boundStroke(bounds, items[0]);
    }
  }

  function draw(context, items) {
    context.beginPath();
    shape(context, items);
  }

  const hit = hitPath(draw);

  function pick(context, scene, x, y, gx, gy) {
    var items = scene.items,
        b = scene.bounds;

    if (!items || !items.length || b && !b.contains(gx, gy)) {
      return null;
    }

    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return hit(context, items, x, y) ? items[0] : null;
  }

  return {
    type: type,
    tag: 'path',
    nested: true,
    attr: attr,
    bound: bound,
    draw: drawOne(draw),
    pick: pick,
    isect: intersectPoint,
    tip: tip
  };
}

var area = markMultiItemPath('area', area$1, pickArea);

function clip (context, scene) {
  var clip = scene.clip;
  context.save();

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    context.beginPath();
    clip(context);
    context.clip();
  } else {
    clipGroup(context, scene.group);
  }
}
function clipGroup(context, group) {
  context.beginPath();
  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
  context.clip();
}

function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}

function attr$5(emit, item) {
  emit('transform', translateItem(item));
}

function emitRectangle(emit, item) {
  const off = offset$1(item);
  emit('d', rectangle(null, item, off, off));
}

function background(emit, item) {
  emit('class', 'background');
  emit('aria-hidden', true);
  emitRectangle(emit, item);
}

function foreground(emit, item) {
  emit('class', 'foreground');
  emit('aria-hidden', true);

  if (item.strokeForeground) {
    emitRectangle(emit, item);
  } else {
    emit('d', '');
  }
}

function content(emit, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit('clip-path', url);
}

function bound$5(bounds, group) {
  if (!group.clip && group.items) {
    const items = group.items,
          m = items.length;

    for (let j = 0; j < m; ++j) {
      bounds.union(items[j].bounds);
    }
  }

  if ((group.clip || group.width || group.height) && !group.noBound) {
    bounds.add(0, 0).add(group.width || 0, group.height || 0);
  }

  boundStroke(bounds, group);
  return bounds.translate(group.x || 0, group.y || 0);
}

function rectanglePath(context, group, x, y) {
  const off = offset$1(group);
  context.beginPath();
  rectangle(context, group, (x || 0) + off, (y || 0) + off);
}

const hitBackground = hitPath(rectanglePath);
const hitForeground = hitPath(rectanglePath, false);
const hitCorner = hitPath(rectanglePath, true);

function draw$4(context, scene, bounds) {
  visit(scene, group => {
    const gx = group.x || 0,
          gy = group.y || 0,
          fore = group.strokeForeground,
          opacity = group.opacity == null ? 1 : group.opacity; // draw group background

    if ((group.stroke || group.fill) && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (group.fill && fill(context, group, opacity)) {
        context.fill();
      }

      if (group.stroke && !fore && stroke(context, group, opacity)) {
        context.stroke();
      }
    } // setup graphics context, set clip and bounds


    context.save();
    context.translate(gx, gy);
    if (group.clip) clipGroup(context, group);
    if (bounds) bounds.translate(-gx, -gy); // draw group contents

    visit(group, item => {
      this.draw(context, item, bounds);
    }); // restore graphics context

    if (bounds) bounds.translate(gx, gy);
    context.restore(); // draw group foreground

    if (fore && group.stroke && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);

      if (stroke(context, group, opacity)) {
        context.stroke();
      }
    }
  });
}

function pick(context, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }

  const cx = x * context.pixelRatio,
        cy = y * context.pixelRatio;
  return pickVisit(scene, group => {
    let hit, dx, dy; // first hit test bounding box

    const b = group.bounds;
    if (b && !b.contains(gx, gy)) return; // passed bounds check, test rectangular clip

    dx = group.x || 0;
    dy = group.y || 0;
    const dw = dx + (group.width || 0),
          dh = dy + (group.height || 0),
          c = group.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return; // adjust coordinate system

    context.save();
    context.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy; // test background for rounded corner clip

    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
      context.restore();
      return null;
    }

    const fore = group.strokeForeground,
          ix = scene.interactive !== false; // hit test against group foreground

    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
      context.restore();
      return group;
    } // hit test against contained marks


    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null); // hit test against group background

    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
      hit = group;
    } // restore state and return


    context.restore();
    return hit || null;
  });
}

function pickMark(mark, x, y) {
  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
}

var group = {
  type: 'group',
  tag: 'g',
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick,
  isect: intersectRect,
  content: content,
  background: background,
  foreground: foreground
};

var metadata = {
  'xmlns': 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  'version': '1.1'
};

function getImage(item, renderer) {
  var image = item.image;

  if (!image || item.url && item.url !== image.url) {
    image = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then(image => {
      item.image = image;
      item.image.url = item.url;
    });
  }

  return image;
}

function imageWidth(item, image) {
  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
}

function imageHeight(item, image) {
  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
}

function imageXOffset(align, w) {
  return align === 'center' ? w / 2 : align === 'right' ? w : 0;
}

function imageYOffset(baseline, h) {
  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
}

function attr$4(emit, item, renderer) {
  const img = getImage(item, renderer),
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
  emit('transform', translate(x, y));
  emit('width', w);
  emit('height', h);
  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
}

function bound$4(bounds, item) {
  const img = item.image,
        w = imageWidth(item, img),
        h = imageHeight(item, img),
        x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h);
  return bounds.set(x, y, x + w, y + h);
}

function draw$3(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    const img = getImage(item, this);
    let w = imageWidth(item, img);
    let h = imageHeight(item, img);
    if (w === 0 || h === 0) return; // early exit

    let x = (item.x || 0) - imageXOffset(item.align, w),
        y = (item.y || 0) - imageYOffset(item.baseline, h),
        opacity,
        ar0,
        ar1,
        t;

    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;

      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w / ar0;
          y += (h - t) / 2;
          h = t;
        } else {
          t = h * ar0;
          x += (w - t) / 2;
          w = t;
        }
      }
    }

    if (img.complete || img.toDataURL) {
      blend(context, item);
      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context.imageSmoothingEnabled = item.smooth !== false;
      context.drawImage(img, x, y, w, h);
    }
  });
}

var image = {
  type: 'image',
  tag: 'image',
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};

var line = markMultiItemPath('line', line$1, pickLine);

function attr$3(emit, item) {
  var sx = item.scaleX || 1,
      sy = item.scaleY || 1;

  if (sx !== 1 || sy !== 1) {
    emit('vector-effect', 'non-scaling-stroke');
  }

  emit('transform', transformItem(item));
  emit('d', item.path);
}

function path$1(context, item) {
  var path = item.path;
  if (path == null) return true;
  var x = item.x || 0,
      y = item.y || 0,
      sx = item.scaleX || 1,
      sy = item.scaleY || 1,
      a = (item.angle || 0) * DegToRad,
      cache = item.pathCache;

  if (!cache || cache.path !== path) {
    (item.pathCache = cache = pathParse(path)).path = path;
  }

  if (a && context.rotate && context.translate) {
    context.translate(x, y);
    context.rotate(a);
    pathRender(context, cache, 0, 0, sx, sy);
    context.rotate(-a);
    context.translate(-x, -y);
  } else {
    pathRender(context, cache, x, y, sx, sy);
  }
}

function bound$3(bounds, item) {
  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
}

var path$2 = {
  type: 'path',
  tag: 'path',
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};

function attr$2(emit, item) {
  emit('d', rectangle(null, item));
}

function bound$2(bounds, item) {
  var x, y;
  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
}

function draw$2(context, item) {
  context.beginPath();
  rectangle(context, item);
}

var rect = {
  type: 'rect',
  tag: 'path',
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};

function attr$1(emit, item) {
  emit('transform', translateItem(item));
  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
}

function bound$1(bounds, item) {
  var x1, y1;
  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
}

function path(context, item, opacity) {
  var x1, y1, x2, y2;

  if (item.stroke && stroke(context, item, opacity)) {
    x1 = item.x || 0;
    y1 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x1;
    y2 = item.y2 != null ? item.y2 : y1;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    return true;
  }

  return false;
}

function draw$1(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    var opacity = item.opacity == null ? 1 : item.opacity;

    if (opacity && path(context, item, opacity)) {
      blend(context, item);
      context.stroke();
    }
  });
}

function hit$1(context, item, x, y) {
  if (!context.isPointInStroke) return false;
  return path(context, item, 1) && context.isPointInStroke(x, y);
}

var rule = {
  type: 'rule',
  tag: 'line',
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};

var shape = markItemPath('shape', shape$1);

var symbol = markItemPath('symbol', symbol$1, intersectPoint);

const widthCache = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache)();
var textMetrics = {
  height: fontSize,
  measureWidth: measureWidth,
  estimateWidth: estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);

function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
} // make simple estimate if no canvas is available


function estimateWidth(item, text) {
  return _estimateWidth(textValue(item, text), fontSize(item));
}

function _estimateWidth(text, currentFontHeight) {
  return ~~(0.8 * text.length * currentFontHeight);
} // measure text width if canvas is available


function measureWidth(item, text) {
  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
}

function _measureWidth(text, currentFont) {
  const key = `(${currentFont}) ${text}`;
  let width = widthCache.get(key);

  if (width === undefined) {
    context.font = currentFont;
    width = context.measureText(text).width;
    widthCache.set(key, width);
  }

  return width;
}

function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}

function lineArray(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.length > 1 ? _ : _[0] : _;
}

function textLines(item) {
  return lineArray(item.lineBreak && item.text && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl = textLines(item);
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl) ? tl.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line) {
  const text = line == null ? '' : (line + '').trim();
  return item.limit > 0 && text.length ? truncate(item, text) : text;
}

function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    // we are using canvas
    const currentFont = font(item);
    return text => _measureWidth(text, currentFont);
  } else {
    // we are relying on estimates
    const currentFontHeight = fontSize(item);
    return text => _estimateWidth(text, currentFontHeight);
  }
}

function truncate(item, text) {
  var limit = +item.limit,
      width = widthGetter(item);
  if (width(text) < limit) return text;
  var ellipsis = item.ellipsis || '\u2026',
      rtl = item.dir === 'rtl',
      lo = 0,
      hi = text.length,
      mid;
  limit -= width(ellipsis);

  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
    }

    return ellipsis + text.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
    }

    return text.slice(0, lo) + ellipsis;
  }
}

function fontFamily(item, quote) {
  var font = item.font;
  return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
}
function font(item, quote) {
  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
}
function offset(item) {
  // perform our own font baseline calculation
  // why? not all browsers support SVG 1.1 'alignment-baseline' :(
  // this also ensures consistent layout across renderers
  var baseline = item.baseline,
      h = fontSize(item);
  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
}

const textAlign = {
  'left': 'start',
  'center': 'middle',
  'right': 'end'
};
const tempBounds = new Bounds();

function anchorPoint(item) {
  var x = item.x || 0,
      y = item.y || 0,
      r = item.radius || 0,
      t;

  if (r) {
    t = (item.theta || 0) - HalfPi;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  tempBounds.x1 = x;
  tempBounds.y1 = y;
  return tempBounds;
}

function attr(emit, item) {
  var dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item),
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      a = item.angle || 0,
      t;
  emit('text-anchor', textAlign[item.align] || 'start');

  if (a) {
    t = translate(x, y) + ' ' + rotate(a);
    if (dx || dy) t += ' ' + translate(dx, dy);
  } else {
    t = translate(x + dx, y + dy);
  }

  emit('transform', t);
}

function bound(bounds, item, mode) {
  var h = textMetrics.height(item),
      a = item.align,
      p = anchorPoint(item),
      x = p.x1,
      y = p.y1,
      dx = item.dx || 0,
      dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
      // use 4/5 offset
  tl = textLines(item),
      w; // get dimensions

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
    // multi-line text
    h += lineHeight(item) * (tl.length - 1);
    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
  } else {
    // single-line text
    w = textMetrics.width(item, tl);
  } // horizontal alignment


  if (a === 'center') {
    dx -= w / 2;
  } else if (a === 'right') {
    dx -= w;
  } else ;

  bounds.set(dx += x, dy += y, dx + w, dy + h);

  if (item.angle && !mode) {
    bounds.rotate(item.angle * DegToRad, x, y);
  } else if (mode === 2) {
    return bounds.rotatedPoints(item.angle * DegToRad, x, y);
  }

  return bounds;
}

function draw(context, scene, bounds) {
  visit(scene, item => {
    var opacity = item.opacity == null ? 1 : item.opacity,
        p,
        x,
        y,
        i,
        lh,
        tl,
        str;
    if (bounds && !bounds.intersects(item.bounds) || // bounds check
    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context.font = font(item);
    context.textAlign = item.align || 'left';
    p = anchorPoint(item);
    x = p.x1, y = p.y1;

    if (item.angle) {
      context.save();
      context.translate(x, y);
      context.rotate(item.angle * DegToRad);
      x = y = 0; // reset x, y
    }

    x += item.dx || 0;
    y += (item.dy || 0) + offset(item);
    tl = textLines(item);
    blend(context, item);

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      lh = lineHeight(item);

      for (i = 0; i < tl.length; ++i) {
        str = textValue(item, tl[i]);

        if (item.fill && fill(context, item, opacity)) {
          context.fillText(str, x, y);
        }

        if (item.stroke && stroke(context, item, opacity)) {
          context.strokeText(str, x, y);
        }

        y += lh;
      }
    } else {
      str = textValue(item, tl);

      if (item.fill && fill(context, item, opacity)) {
        context.fillText(str, x, y);
      }

      if (item.stroke && stroke(context, item, opacity)) {
        context.strokeText(str, x, y);
      }
    }

    if (item.angle) context.restore();
  });
}

function hit(context, item, x, y, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true; // bounds sufficient if no rotation
  // project point into space of unrotated bounds

  var p = anchorPoint(item),
      ax = p.x1,
      ay = p.y1,
      b = bound(tempBounds, item, 1),
      a = -item.angle * DegToRad,
      cos = Math.cos(a),
      sin = Math.sin(a),
      px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
      py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
  return b.contains(px, py);
}

function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}

var text = {
  type: 'text',
  tag: 'text',
  nested: false,
  attr: attr,
  bound: bound,
  draw: draw,
  pick: pick$1(hit),
  isect: intersectText
};

var trail = markMultiItemPath('trail', trail$1, pickTrail);

var Marks = {
  arc: arc,
  area: area,
  group: group,
  image: image,
  line: line,
  path: path$2,
  rect: rect,
  rule: rule,
  shape: shape,
  symbol: symbol,
  text: text,
  trail: trail
};

function boundItem (item, func, opt) {
  var type = Marks[item.mark.marktype],
      bound = func || type.bound;
  if (type.nested) item = item.mark;
  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
}

var DUMMY = {
  mark: null
};
function boundMark (mark, bounds, opt) {
  var type = Marks[mark.marktype],
      bound = type.bound,
      items = mark.items,
      hasItems = items && items.length,
      i,
      n,
      item,
      b;

  if (type.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      // no items, fake it
      DUMMY.mark = mark;
      item = DUMMY;
    }

    b = boundItem(item, bound, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();

  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds.union(boundItem(items[i], bound, opt));
    }
  }

  return mark.bounds = bounds;
}

const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline', // layout
'fill', 'fillOpacity', 'opacity', 'blend', // fill
'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap', // stroke
'strokeDash', 'strokeDashOffset', // stroke dash
'strokeForeground', 'strokeOffset', // group
'startAngle', 'endAngle', 'innerRadius', 'outerRadius', // arc
'cornerRadius', 'padAngle', // arc, rect
'cornerRadiusTopLeft', 'cornerRadiusTopRight', // rect, group
'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined', // area, line
'url', 'aspect', 'smooth', // image
'path', 'scaleX', 'scaleY', // path
'x2', 'y2', // rule
'size', 'shape', // symbol
'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy', // text
'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant', // font
'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json) {
  const scene = typeof json === 'string' ? JSON.parse(json) : json;
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      items = scene.items,
      parent,
      i,
      n;

  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type ? 'mark' : 'group';
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ('group' === (type || parent)) initialize(items[i]);
    }
  }

  if (type) boundMark(scene);
  return scene;
}

function Scenegraph(scene) {
  if (arguments.length) {
    this.root = sceneFromJSON(scene);
  } else {
    this.root = createMark({
      marktype: 'group',
      name: 'root',
      role: 'frame'
    });
    this.root.items = [new GroupItem(this.root)];
  }
}
Scenegraph.prototype = {
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  },

  mark(markdef, group, index) {
    group = group || this.root.items[0];
    const mark = createMark(markdef, group);
    group.items[index] = mark;
    if (mark.zindex) mark.group.zdirty = true;
    return mark;
  }

};

function createMark(def, group) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def.clip,
    group: group,
    interactive: def.interactive === false ? false : true,
    items: [],
    marktype: def.marktype,
    name: def.name || undefined,
    role: def.role || undefined,
    zindex: def.zindex || 0
  }; // add accessibility properties if defined

  if (def.aria != null) {
    mark.aria = def.aria;
  }

  if (def.description) {
    mark.description = def.description;
  }

  return mark;
}

// create a new DOM element
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== 'undefined' && document.createElement) {
    doc = document;
  }

  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
} // find first child element with matching tag

function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes,
      i = 0,
      n = nodes.length;

  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
} // retrieve child element at given index
// create & insert if doesn't exist or if tags do not match

function domChild(el, index, tag, ns) {
  var a = el.childNodes[index],
      b;

  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b);
  }

  return a;
} // remove all child elements at or above the given index

function domClear(el, index) {
  var nodes = el.childNodes,
      curr = nodes.length;

  while (curr > index) el.removeChild(nodes[--curr]);

  return el;
} // generate css class name for mark

function cssClass(mark) {
  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
}

function point (event, el) {
  const rect = el.getBoundingClientRect();
  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
}

function resolveItem (item, event, el, origin) {
  var mark = item && item.mark,
      mdef,
      p;

  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point(event, el);
    p[0] -= origin[0];
    p[1] -= origin[1];

    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }

    item = mdef.tip(mark.items, p);
  }

  return item;
}

/**
 * Create a new Handler instance.
 * @param {object} [customLoader] - Optional loader instance for
 *   href URL sanitization. If not specified, a standard loader
 *   instance will be generated.
 * @param {function} [customTooltip] - Optional tooltip handler
 *   function for custom tooltip display.
 * @constructor
 */

function Handler(customLoader, customTooltip) {
  this._active = null;
  this._handlers = {};
  this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_2__.loader)();
  this._tooltip = customTooltip || defaultTooltip;
} // The default tooltip display handler.
// Sets the HTML title attribute on the visualization container.

function defaultTooltip(handler, event, item, value) {
  handler.element().setAttribute('title', value || '');
}

Handler.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  },

  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  },

  /**
   * Add an event handler. Subclasses should override this method.
   */
  on()
  /*type, handler*/
  {},

  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off()
  /*type, handler*/
  {},

  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h, type, handler) {
    for (let i = h ? h.length : 0; --i >= 0;) {
      if (h[i].type === type && (!handler || h[i].handler === handler)) {
        return i;
      }
    }

    return -1;
  },

  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type) {
    const h = this._handlers,
          a = [];

    if (type) {
      a.push(...h[this.eventName(type)]);
    } else {
      for (const k in h) {
        a.push(...h[k]);
      }
    }

    return a;
  },

  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf('.');
    return i < 0 ? name : name.slice(0, i);
  },

  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event, item, href) {
    this._loader.sanitize(href, {
      context: 'href'
    }).then(opt => {
      const e = new MouseEvent(event.type, event),
            a = domCreate(null, 'a');

      for (const name in opt) a.setAttribute(name, opt[name]);

      a.dispatchEvent(e);
    }).catch(() => {
      /* do nothing */
    });
  },

  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event, this.canvas(), this._origin);
      const value = show && item && item.tooltip || null;

      this._tooltip.call(this._obj, this, event, item, value);
    }
  },

  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect = el.getBoundingClientRect(),
          origin = this._origin,
          bounds = item.bounds,
          width = bounds.width(),
          height = bounds.height();
    let x = bounds.x1 + origin[0] + rect.left,
        y = bounds.y1 + origin[1] + rect.top; // translate coordinate for each parent group

    while (item.mark && (item = item.mark.group)) {
      x += item.x || 0;
      y += item.y || 0;
    } // return DOMRect-compatible bounding box


    return {
      x,
      y,
      width,
      height,
      left: x,
      top: y,
      right: x + width,
      bottom: y + height
    };
  }

};

/**
 * Create a new Renderer instance.
 * @param {object} [loader] - Optional loader instance for
 *   image and href URL sanitization. If not specified, a
 *   standard loader instance will be generated.
 * @constructor
 */

function Renderer(loader) {
  this._el = null;
  this._bgcolor = null;
  this._loader = new ResourceLoader(loader);
}
Renderer.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    this._el = el;
    return this.resize(width, height, origin, scaleFactor);
  },

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    this._width = width;
    this._height = height;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  },

  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty()
  /*item*/
  {},

  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Renderer} - This renderer instance.
   */
  render(scene) {
    const r = this; // bind arguments into a render call, and cache it
    // this function may be subsequently called for async redraw

    r._call = function () {
      r._render(scene);
    }; // invoke the renderer


    r._call(); // clear the cached call for garbage collection
    // async redraws will stash their own copy


    r._call = null;
    return r;
  },

  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render()
  /*scene*/
  {// subclasses to override
  },

  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene) {
    const r = this.render(scene);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  },

  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method, uri) {
    var r = this,
        p = r._loader[method](uri);

    if (!r._ready) {
      // re-render the scene when loading completes
      const call = r._call;
      r._ready = r._loader.ready().then(redraw => {
        if (redraw) call();
        r._ready = null;
      });
    }

    return p;
  },

  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load('sanitizeURL', uri);
  },

  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load('loadImage', uri);
  }

};

const KeyDownEvent = 'keydown';
const KeyPressEvent = 'keypress';
const KeyUpEvent = 'keyup';
const DragEnterEvent = 'dragenter';
const DragLeaveEvent = 'dragleave';
const DragOverEvent = 'dragover';
const MouseDownEvent = 'mousedown';
const MouseUpEvent = 'mouseup';
const MouseMoveEvent = 'mousemove';
const MouseOutEvent = 'mouseout';
const MouseOverEvent = 'mouseover';
const ClickEvent = 'click';
const DoubleClickEvent = 'dblclick';
const WheelEvent = 'wheel';
const MouseWheelEvent = 'mousewheel';
const TouchStartEvent = 'touchstart';
const TouchMoveEvent = 'touchmove';
const TouchEndEvent = 'touchend';
const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
const TooltipShowEvent = MouseMoveEvent;
const TooltipHideEvent = MouseOutEvent;
const HrefEvent = ClickEvent;

function CanvasHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  this._down = null;
  this._touch = null;
  this._first = true;
  this._events = {};
}

const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type]; // lazily add listeners to the canvas as needed


function eventListenerCheck(handler, type) {
  eventBundle(type).forEach(_ => addEventListener(handler, _));
}

function addEventListener(handler, type) {
  const canvas = handler.canvas();

  if (canvas && !handler._events[type]) {
    handler._events[type] = 1;
    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
  }
}

function move(moveEvent, overEvent, outEvent) {
  return function (evt) {
    const a = this._active,
          p = this.pickEvent(evt);

    if (p === a) {
      // active item and picked item are the same
      this.fire(moveEvent, evt); // fire move
    } else {
      // active item and picked item are different
      if (!a || !a.exit) {
        // fire out for prior active item
        // suppress if active item was removed from scene
        this.fire(outEvent, evt);
      }

      this._active = p; // set new active item

      this.fire(overEvent, evt); // fire over for new active item

      this.fire(moveEvent, evt); // fire move for new active item
    }
  };
}

function inactive(type) {
  return function (evt) {
    this.fire(type, evt);
    this._active = null;
  };
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasHandler, Handler, {
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, 'canvas'); // add minimal events required for proper state management

    [ClickEvent, MouseDownEvent, MouseMoveEvent, MouseOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },

  // retrieve the current canvas context
  context() {
    return this._canvas.getContext('2d');
  },

  // supported events
  events: Events,

  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  },

  mousemove: move(MouseMoveEvent, MouseOverEvent, MouseOutEvent),
  dragover: move(DragOverEvent, DragEnterEvent, DragLeaveEvent),
  mouseout: inactive(MouseOutEvent),
  dragleave: inactive(DragLeaveEvent),

  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  },

  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  },

  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);

    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }

    this.fire(TouchStartEvent, evt, true);
  },

  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  },

  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  },

  // fire an event
  fire(type, evt, touch) {
    const a = touch ? this._touch : this._active,
          h = this._handlers[type]; // set event type relative to scenegraph items

    evt.vegaType = type; // handle hyperlinks and tooltips first

    if (type === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
      this.handleTooltip(evt, a, type !== TooltipHideEvent);
    } // invoke all registered handlers


    if (h) {
      for (let i = 0, len = h.length; i < len; ++i) {
        h[i].handler.call(this._obj, evt, a);
      }
    }
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      eventListenerCheck(this, type);
      (h[name] || (h[name] = [])).push({
        type: type,
        handler: handler
      });
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      h.splice(i, 1);
    }

    return this;
  },

  pickEvent(evt) {
    const p = point(evt, this._canvas),
          o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  },

  // find the scenegraph item at the current mouse position
  // x, y -- the absolute x, y mouse coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x, y, gx, gy) {
    const g = this.context(),
          mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x, y, gx, gy);
  }

});

function devicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
}

var pixelRatio = devicePixelRatio();
function resize (canvas, width, height, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
        context = canvas.getContext('2d'),
        ratio = inDOM ? pixelRatio : scaleFactor;
  canvas.width = width * ratio;
  canvas.height = height * ratio;

  for (const key in opt) {
    context[key] = opt[key];
  }

  if (inDOM && ratio !== 1) {
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }

  context.pixelRatio = ratio;
  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}

function CanvasRenderer(loader) {
  Renderer.call(this, loader);
  this._options = {};
  this._redraw = false;
  this._dirty = new Bounds();
  this._tempb = new Bounds();
}
const base$1 = Renderer.prototype;

const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);

function clipToBounds(g, b, origin) {
  // expand bounds by 1 pixel, then round to pixel boundaries
  b.expand(1).round(); // align to base pixel grid in case of non-integer scaling (#2425)

  if (g.pixelRatio % 1) {
    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  } // to avoid artifacts translate if origin has fractional pixels


  b.translate(-(origin[0] % 1), -(origin[1] % 1)); // set clip path

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();
  return b;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CanvasRenderer, Renderer, {
  initialize(el, width, height, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(1, 1, this._options.type); // instantiate a small canvas

    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);

      this._canvas.setAttribute('class', 'marks');
    } // this method will invoke resize to size the canvas appropriately


    return base$1.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  resize(width, height, origin, scaleFactor) {
    base$1.resize.call(this, width, height, origin, scaleFactor);

    if (this._canvas) {
      // configure canvas size and transform
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      // external context needs to be scaled and positioned to origin
      const ctx = this._options.externalContext;
      if (!ctx) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('CanvasRenderer is missing a valid canvas or context');
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }

    this._redraw = true;
    return this;
  },

  canvas() {
    return this._canvas;
  },

  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
  },

  dirty(item) {
    const b = this._tempb.clear().union(item.bounds);

    let g = item.mark.group;

    while (g) {
      b.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }

    this._dirty.union(b);
  },

  _render(scene) {
    const g = this.context(),
          o = this._origin,
          w = this._width,
          h = this._height,
          db = this._dirty,
          vb = viewBounds(o, w, h); // setup

    g.save();
    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w, h); // render

    this.draw(g, scene, b); // takedown

    g.restore();
    db.clear();
    return this;
  },

  draw(ctx, scene, bounds) {
    const mark = Marks[scene.marktype];
    if (scene.clip) clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds);
    if (scene.clip) ctx.restore();
  },

  clear(x, y, w, h) {
    const opt = this._options,
          g = this.context();

    if (opt.type !== 'pdf' && !opt.externalContext) {
      // calling clear rect voids vector output in pdf mode
      // and could remove external context content (#2615)
      g.clearRect(x, y, w, h);
    }

    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x, y, w, h);
    }
  }

});

function SVGHandler(loader, tooltip) {
  Handler.call(this, loader, tooltip);
  const h = this;
  h._hrefHandler = listener(h, (evt, item) => {
    if (item && item.href) h.handleHref(evt, item, item.href);
  });
  h._tooltipHandler = listener(h, (evt, item) => {
    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
  });
} // wrap an event listener for the SVG DOM

const listener = (context, handler) => evt => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context._obj, evt, item);
};

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGHandler, Handler, {
  initialize(el, origin, obj) {
    let svg = this._svg;

    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    this._svg = svg = el && domFind(el, 'svg');

    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }

    return Handler.prototype.initialize.call(this, el, origin, obj);
  },

  canvas() {
    return this._svg;
  },

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
          h = this._handlers,
          i = this._handlerIndex(h[name], type, handler);

    if (i < 0) {
      const x = {
        type,
        handler,
        listener: listener(this, handler)
      };
      (h[name] || (h[name] = [])).push(x);

      if (this._svg) {
        this._svg.addEventListener(name, x.listener);
      }
    }

    return this;
  },

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
          h = this._handlers[name],
          i = this._handlerIndex(h, type, handler);

    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h[i].listener);
      }

      h.splice(i, 1);
    }

    return this;
  }

});

const ARIA_HIDDEN = 'aria-hidden';
const ARIA_LABEL = 'aria-label';
const ARIA_ROLE = 'role';
const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
const GRAPHICS_OBJECT = 'graphics-object';
const GRAPHICS_SYMBOL = 'graphics-symbol';

const bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || undefined
}); // these roles are covered by related roles
// we can ignore them, no need to generate attributes


const AriaIgnore = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']); // aria attribute generators for guide roles

const AriaGuides = {
  'axis': {
    desc: 'axis',
    caption: axisCaption
  },
  'legend': {
    desc: 'legend',
    caption: legendCaption
  },
  'title-text': {
    desc: 'title',
    caption: item => `Title text '${titleCaption(item)}'`
  },
  'title-subtitle': {
    desc: 'subtitle',
    caption: item => `Subtitle text '${titleCaption(item)}'`
  }
}; // aria properties generated for mark item encoding channels

const AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit, item) {
  const hide = item.aria === false;
  emit(ARIA_HIDDEN, hide || undefined);

  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit(AriaEncode[prop], undefined);
    }
  } else {
    const type = item.mark.marktype;
    emit(ARIA_LABEL, item.description);
    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}

function ariaMark(mark) {
  const type = mark.marktype;
  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
}

function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0],
          caption = opt.caption || (() => '');

    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}

function titleCaption(item) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(item.text).join(' ');
}

function axisCaption(item) {
  const datum = item.datum,
        orient = item.orient,
        title = datum.title ? extractTitle(item) : null,
        ctx = item.context,
        scale = ctx.scales[datum.scale].value,
        locale = ctx.dataflow.locale(),
        type = scale.type,
        xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(type) ? 'discrete' : type} scale` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function legendCaption(item) {
  const datum = item.datum,
        title = datum.title ? extractTitle(item) : null,
        type = `${datum.type || ''} legend`.trim(),
        scales = datum.scales,
        props = Object.keys(scales),
        ctx = item.context,
        scale = ctx.scales[scales[props[0]]].value,
        locale = ctx.dataflow.locale();
  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.domainCaption)(locale, scale, item)}`;
}

function extractTitle(item) {
  try {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(item.items).items[0].text).join(' ');
  } catch (err) {
    return null;
  }
}

function channelCaption(props) {
  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(props);
}

function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}

const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');

function markup() {
  let buf = '',
      outer = '',
      inner = '';

  const stack = [],
        clear = () => outer = inner = '',
        push = tag => {
    if (outer) {
      buf += `${outer}>${inner}`;
      clear();
    }

    stack.push(tag);
  },
        attr = (name, value) => {
    if (value != null) outer += ` ${name}="${attrText(value)}"`;
    return m;
  },
        m = {
    open(tag, ...attrs) {
      push(tag);
      outer = '<' + tag;

      for (const set of attrs) {
        for (const key in set) attr(key, set[key]);
      }

      return m;
    },

    close() {
      const tag = stack.pop();

      if (outer) {
        buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
      } else {
        buf += `</${tag}>`;
      }

      clear();
      return m;
    },

    attr,
    text: t => (inner += innerText(t), m),
    toString: () => buf
  };

  return m;
}
const serializeXML = node => _serialize(markup(), node) + '';

function _serialize(m, node) {
  m.open(node.tagName);

  if (node.hasAttributes()) {
    const attrs = node.attributes,
          n = attrs.length;

    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }

  if (node.hasChildNodes()) {
    const children = node.childNodes,
          n = children.length;

    for (let i = 0; i < n; i++) {
      const child = children[i];
      child.nodeType === 3 // text node
      ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }

  return m.close();
}

const styles = {
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  stroke: 'stroke',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  strokeCap: 'stroke-linecap',
  strokeJoin: 'stroke-linejoin',
  strokeDash: 'stroke-dasharray',
  strokeDashOffset: 'stroke-dashoffset',
  strokeMiterLimit: 'stroke-miterlimit',
  opacity: 'opacity',
  blend: 'mix-blend-mode'
}; // ensure miter limit default is consistent with canvas (#2498)

const rootAttributes = {
  'fill': 'none',
  'stroke-miterlimit': 10
};

const RootIndex = 0,
      xmlns = 'http://www.w3.org/2000/xmlns/',
      svgns = metadata.xmlns;
function SVGRenderer(loader) {
  Renderer.call(this, loader);
  this._dirtyID = 0;
  this._dirty = [];
  this._svg = null;
  this._root = null;
  this._defs = null;
}
const base = Renderer.prototype;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGRenderer, Renderer, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    // create the svg definitions cache
    this._defs = {};

    this._clearDefs();

    if (el) {
      this._svg = domChild(el, 0, 'svg', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);

      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);

      this._svg.setAttribute('version', metadata['version']);

      this._svg.setAttribute('class', 'marks');

      domClear(el, 1); // set the svg root group

      this._root = domChild(this._svg, RootIndex, 'g', svgns);
      setAttributes(this._root, rootAttributes); // ensure no additional child elements

      domClear(this._svg, RootIndex + 1);
    } // set background color if defined


    this.background(this._bgcolor);
    return base.initialize.call(this, el, width, height, origin, scaleFactor);
  },

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty('background-color', bgcolor);
    }

    return base.background.apply(this, arguments);
  },

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    base.resize.call(this, width, height, origin, scaleFactor);

    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });

      this._root.setAttribute('transform', `translate(${this._origin})`);
    }

    this._dirty = [];
    return this;
  },

  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },

  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg,
          bg = this._bgcolor;
    if (!svg) return null;
    let node;

    if (bg) {
      svg.removeAttribute('style');
      node = domChild(svg, RootIndex, 'rect', svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }

    const text = serializeXML(svg);

    if (bg) {
      svg.removeChild(node);

      this._svg.style.setProperty('background-color', bg);
    }

    return text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    // perform spot updates and re-render markup
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene);
      domClear(this._root, 1);
    }

    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  },

  // -- Manage rendering of items marked as dirty --

  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;

      this._dirty.push(item);
    }
  },

  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || item.dirty === this._dirtyID;
  },

  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id = ++this._dirtyID;
    let item, mark, type, mdef, i, n, o;

    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;

      if (mark.marktype !== type) {
        // memoize mark instance lookup
        type = mark.marktype;
        mdef = Marks[type];
      }

      if (mark.zdirty && mark.dirty !== id) {
        this._dirtyAll = false;
        dirtyParents(item, id);
        mark.items.forEach(i => {
          i.dirty = id;
        });
      }

      if (mark.zdirty) continue; // handle in standard drawing pass

      if (item.exit) {
        // EXIT
        if (mdef.nested && mark.items.length) {
          // if nested mark with remaining points, update instead
          o = mark.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          // otherwise remove from DOM
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }

        item._svg = null;
        continue;
      }

      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id) continue; // already visited

      if (!item._svg || !item._svg.ownerSVGElement) {
        // ENTER
        this._dirtyAll = false;
        dirtyParents(item, id);
      } else {
        // IN-PLACE UPDATE
        this._update(mdef, item._svg, item);
      }

      item._update = id;
    }

    return !this._dirtyAll;
  },

  // -- Construct & maintain scenegraph to SVG mapping ---

  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   */
  mark(el, scene, prev) {
    if (!this.isDirty(scene)) return scene._svg;
    const svg = this._svg,
          mdef = Marks[scene.marktype],
          events = scene.interactive === false ? 'none' : null,
          isGroup = mdef.tag === 'g';
    let sibling = null,
        i = 0;
    const parent = bind(scene, el, prev, 'g', svg);
    parent.setAttribute('class', cssClass(scene)); // apply aria attributes to parent container element

    const aria = ariaMarkAttributes(scene);

    for (const key in aria) setAttribute(parent, key, aria[key]);

    if (!isGroup) {
      setAttribute(parent, 'pointer-events', events);
    }

    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);

    const process = item => {
      const dirty = this.isDirty(item),
            node = bind(item, parent, sibling, mdef.tag, svg);

      if (dirty) {
        this._update(mdef, node, item);

        if (isGroup) recurse(this, node, item);
      }

      sibling = node;
      ++i;
    };

    if (mdef.nested) {
      if (scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    }

    domClear(parent, i);
    return parent;
  },

  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    // set dom element and values cache
    // provides access to emit method
    element = el;
    values = el.__values__; // apply aria-specific properties

    ariaItemAttributes(emit, item); // apply svg attributes

    mdef.attr(emit, item, this); // some marks need special treatment

    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item); // apply svg style attributes
    // note: element state may have been modified by 'extra' method

    if (element) this.style(element, item);
  },

  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;

    for (const prop in styles) {
      let value = prop === 'font' ? fontFamily(item) : item[prop];
      if (value === values[prop]) continue;
      const name = styles[prop];

      if (value == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value)) {
          value = gradientRef(value, this._defs.gradient, href());
        }

        el.setAttribute(name, value + '');
      }

      values[prop] = value;
    }
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg,
          defs = this._defs;
    let el = defs.el,
        index = 0;

    for (const id in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateGradient(el, defs.gradient[id], index);
    }

    for (const id in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateClipping(el, defs.clipping[id], index);
    } // clean-up


    if (el) {
      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
    }
  },

  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def = this._defs;
    def.gradient = {};
    def.clipping = {};
  }

}); // mark ancestor chain with a dirty id

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item = item.mark.group) {
    item.dirty = id;

    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
} // update gradient definitions


function updateGradient(el, grad, index) {
  let i, n, stop;

  if (grad.gradient === 'radial') {
    // SVG radial gradients automatically transform to normalized bbox
    // coordinates, in a way that is cumbersome to replicate in canvas.
    // We wrap the radial gradient in a pattern element, allowing us to
    // maintain a circular gradient that matches what canvas provides.
    let pt = domChild(el, index++, 'pattern', svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: '0,0,1,1',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid slice'
    });
    pt = domChild(pt, 0, 'rect', svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index++, 'radialGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index++, 'linearGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }

  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop = domChild(el, i, 'stop', svgns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }

  domClear(el, i);
  return index;
} // update clipping path definitions


function updateClipping(el, clip, index) {
  let mask;
  el = domChild(el, index, 'clipPath', svgns);
  el.setAttribute('id', clip.id);

  if (clip.path) {
    mask = domChild(el, 0, 'path', svgns);
    mask.setAttribute('d', clip.path);
  } else {
    mask = domChild(el, 0, 'rect', svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip.width,
      height: clip.height
    });
  }

  domClear(el, 1);
  return index + 1;
} // Recursively process group contents.


function recurse(renderer, el, group) {
  el = el.lastChild.previousSibling;
  let prev,
      idx = 0;
  visit(group, item => {
    prev = renderer.mark(el, item, prev);
    ++idx;
  }); // remove any extraneous DOM elements

  domClear(el, 1 + idx);
} // Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.


function bind(item, el, sibling, tag, svg) {
  let node = item._svg,
      doc; // create a new dom node if needed

  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;

    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: 'default'
      }; // if group, create background, content, and foreground elements

      if (tag === 'g') {
        const bg = domCreate(doc, 'path', svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, 'g', svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, 'path', svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: 'default'
        };
      }
    }
  } // (re-)insert if (a) not contained in SVG or (b) sibling order has changed


  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }

  return node;
} // check if two nodes are ordered siblings


function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
} // -- Set attributes & styles on SVG elements ---


let element = null,
    // temp var for current SVG element
values = null; // temp var for current values hash
// Extra configuration for certain mark types

const mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__; // use parent's values hash

    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value = item.mark.interactive === false ? 'none' : null;

    if (value !== values.events) {
      setAttribute(fg, 'pointer-events', value);
      setAttribute(bg, 'pointer-events', value);
      values.events = value;
    }

    if (item.strokeForeground && item.stroke) {
      const fill = item.fill;
      setAttribute(fg, 'display', null); // set style of background

      this.style(bg, item);
      setAttribute(bg, 'stroke', null); // set style of foreground

      if (fill) item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill) item.fill = fill; // leave element null to prevent downstream styling

      element = null;
    } else {
      // ensure foreground is ignored
      setAttribute(fg, 'display', 'none');
    }
  },

  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, 'image-rendering', 'optimizeSpeed');
      setStyle(el, 'image-rendering', 'pixelated');
    } else {
      setStyle(el, 'image-rendering', null);
    }
  },

  text(mdef, el, item) {
    const tl = textLines(item);
    let key, value, doc, lh;

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      // multi-line text
      value = tl.map(_ => textValue(item, _));
      key = value.join('\n'); // content cache key

      if (key !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value.forEach((t, i) => {
          const ts = domCreate(doc, 'tspan', svgns);
          ts.__data__ = item; // data binding

          ts.textContent = t;

          if (i) {
            ts.setAttribute('x', 0);
            ts.setAttribute('dy', lh);
          }

          el.appendChild(ts);
        });
        values.text = key;
      }
    } else {
      // single-line text
      value = textValue(item, tl);

      if (value !== values.text) {
        el.textContent = value;
        values.text = value;
      }
    }

    setAttribute(el, 'font-family', fontFamily(item));
    setAttribute(el, 'font-size', fontSize(item) + 'px');
    setAttribute(el, 'font-style', item.fontStyle);
    setAttribute(el, 'font-variant', item.fontVariant);
    setAttribute(el, 'font-weight', item.fontWeight);
  }

};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return; // use appropriate method given namespace (ns)

  if (ns) {
    setAttributeNS(element, name, value, ns);
  } else {
    setAttribute(element, name, value);
  } // note current value for future comparison


  values[name] = value;
}

function setStyle(el, name, value) {
  if (value !== values[name]) {
    if (value == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value + '');
    }

    values[name] = value;
  }
}

function setAttributes(el, attrs) {
  for (const key in attrs) {
    setAttribute(el, key, attrs[key]);
  }
}

function setAttribute(el, name, value) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttribute(name, value);
  } else {
    // else remove DOM attribute
    el.removeAttribute(name);
  }
}

function setAttributeNS(el, name, value, ns) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttributeNS(ns, name, value);
  } else {
    // else remove DOM attribute
    el.removeAttributeNS(ns, name);
  }
}

function href() {
  let loc;
  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}

function SVGStringRenderer(loader) {
  Renderer.call(this, loader);
  this._text = null;
  this._defs = {
    gradient: {},
    clipping: {}
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(SVGStringRenderer, Renderer, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup(); // svg tag

    m.open('svg', (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, metadata, {
      class: 'marks',
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    })); // background, if defined

    const bg = this._bgcolor;

    if (bg && bg !== 'transparent' && bg !== 'none') {
      m.open('rect', {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    } // root content group


    m.open('g', rootAttributes, {
      transform: 'translate(' + this._origin + ')'
    });
    this.mark(m, scene);
    m.close(); // </g>
    // defs

    this.defs(m); // get SVG text string

    this._text = m.close() + '';
    return this;
  },

  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype],
          tag = mdef.tag,
          attrList = [ariaItemAttributes, mdef.attr]; // render opening group tag

    m.open('g', {
      'class': cssClass(scene),
      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
    }); // render contained elements

    const process = item => {
      const href = this.href(item);
      if (href) m.open('a', href);
      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));

      if (tag === 'text') {
        const tl = textLines(item);

        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
          // multi-line text
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };

          for (let i = 0; i < tl.length; ++i) {
            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
          }
        } else {
          // single-line text
          m.text(textValue(item, tl));
        }
      } else if (tag === 'g') {
        const fore = item.strokeForeground,
              fill = item.fill,
              stroke = item.stroke;

        if (fore && stroke) {
          item.stroke = null;
        }

        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close(); // recurse for group content

        m.open('g', this.attr(scene, item, mdef.content));
        visit(item, scene => this.mark(m, scene));
        m.close();

        if (fore && stroke) {
          if (fill) item.fill = null;
          item.stroke = stroke;
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
          if (fill) item.fill = fill;
        } else {
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
        }
      }

      m.close(); // </tag>

      if (href) m.close(); // </a>
    };

    if (mdef.nested) {
      if (scene.items && scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    } // render closing group tag


    return m.close(); // </g>
  },

  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href = item.href;
    let attr;

    if (href) {
      if (attr = this._hrefs && this._hrefs[href]) {
        return attr;
      } else {
        this.sanitizeURL(href).then(attr => {
          // rewrite to use xlink namespace
          attr['xlink:href'] = attr.href;
          attr.href = null;
          (this._hrefs || (this._hrefs = {}))[href] = attr;
        });
      }
    }

    return null;
  },

  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object = {},
          emit = (name, value, ns, prefixed) => {
      object[prefixed || name] = value;
    }; // apply mark specific attributes


    if (Array.isArray(attrs)) {
      attrs.forEach(fn => fn(emit, item, this));
    } else {
      attrs(emit, item, this);
    } // apply style attributes


    if (tag) {
      style(object, item, scene, tag, this._defs);
    }

    return object;
  },

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient = this._defs.gradient,
          clipping = this._defs.clipping,
          count = Object.keys(gradient).length + Object.keys(clipping).length;
    if (count === 0) return; // nothing to do

    m.open('defs');

    for (const id in gradient) {
      const def = gradient[id],
            stops = def.stops;

      if (def.gradient === 'radial') {
        // SVG radial gradients automatically transform to normalized bbox
        // coordinates, in a way that is cumbersome to replicate in canvas.
        // We wrap the radial gradient in a pattern element, allowing us to
        // maintain a circular gradient that matches what canvas provides.
        m.open('pattern', {
          id: patternPrefix + id,
          viewBox: '0,0,1,1',
          width: '100%',
          height: '100%',
          preserveAspectRatio: 'xMidYMid slice'
        });
        m.open('rect', {
          width: '1',
          height: '1',
          fill: 'url(#' + id + ')'
        }).close();
        m.close(); // </pattern>

        m.open('radialGradient', {
          id: id,
          fx: def.x1,
          fy: def.y1,
          fr: def.r1,
          cx: def.x2,
          cy: def.y2,
          r: def.r2
        });
      } else {
        m.open('linearGradient', {
          id: id,
          x1: def.x1,
          x2: def.x2,
          y1: def.y1,
          y2: def.y2
        });
      }

      for (let i = 0; i < stops.length; ++i) {
        m.open('stop', {
          offset: stops[i].offset,
          'stop-color': stops[i].color
        }).close();
      }

      m.close();
    }

    for (const id in clipping) {
      const def = clipping[id];
      m.open('clipPath', {
        id: id
      });

      if (def.path) {
        m.open('path', {
          d: def.path
        }).close();
      } else {
        m.open('rect', {
          x: 0,
          y: 0,
          width: def.width,
          height: def.height
        }).close();
      }

      m.close();
    }

    m.close();
  }

}); // Helper function for attr for style presentation attributes

function style(s, item, scene, tag, defs) {
  if (item == null) return s;

  if (tag === 'bgrect' && scene.interactive === false) {
    s['pointer-events'] = 'none';
  }

  if (tag === 'bgfore') {
    if (scene.interactive === false) {
      s['pointer-events'] = 'none';
    }

    s.display = 'none';
    if (item.fill !== null) return s;
  }

  if (tag === 'image' && item.smooth === false) {
    s.style = 'image-rendering: optimizeSpeed; image-rendering: pixelated;';
  }

  if (tag === 'text') {
    s['font-family'] = fontFamily(item);
    s['font-size'] = fontSize(item) + 'px';
    s['font-style'] = item.fontStyle;
    s['font-variant'] = item.fontVariant;
    s['font-weight'] = item.fontWeight;
  }

  for (const prop in styles) {
    let value = item[prop];
    const name = styles[prop];

    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
      if (isGradient(value)) {
        value = gradientRef(value, defs.gradient, '');
      }

      s[name] = value;
    }
  }

  return s;
}

const Canvas = 'canvas';
const PNG = 'png';
const SVG = 'svg';
const None = 'none';
const RenderType = {
  Canvas: Canvas,
  PNG: PNG,
  SVG: SVG,
  None: None
};
const modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[None] = {};
function renderModule(name, _) {
  name = String(name || '').toLowerCase();

  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}

function intersect(scene, bounds, filter) {
  const hits = [],
        // intersection results
  box = new Bounds().union(bounds),
        // defensive copy
  type = scene.marktype;
  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Intersect scene must be mark node or group item.');
}

function intersectMark(mark, box, filter, hits) {
  if (visitMark(mark, box, filter)) {
    const items = mark.items,
          type = mark.marktype,
          n = items.length;
    let i = 0;

    if (type === 'group') {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter, hits);
      }
    } else {
      for (const test = Marks[type].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test)) hits.push(item);
      }
    }
  }

  return hits;
}

function visitMark(mark, box, filter) {
  // process if bounds intersect and if
  // (1) mark is a group mark (so we must recurse), or
  // (2) mark is interactive and passes filter
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
}

function intersectGroup(group, box, filter, hits) {
  // test intersect against group
  // skip groups by default unless filter says otherwise
  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
    hits.push(group);
  } // recursively test children marks
  // translate box to group coordinate space


  const marks = group.items,
        n = marks && marks.length;

  if (n) {
    const x = group.x || 0,
          y = group.y || 0;
    box.translate(-x, -y);

    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter, hits);
    }

    box.translate(x, y);
  }

  return hits;
}

function intersectItem(item, box, test) {
  // test bounds enclosure, bounds intersection, then detailed test
  const bounds = item.bounds;
  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
}

const clipBounds = new Bounds();
function boundClip (mark) {
  const clip = mark.clip;

  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    clip(boundContext(clipBounds.clear()));
  } else if (clip) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else return;

  mark.bounds.intersect(clipBounds);
}

const TOLERANCE = 1e-9;
function sceneEqual(a, b, key) {
  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? a == b : objectEqual(a, b);
}
function pathEqual(a, b) {
  return sceneEqual(pathParse(a), pathParse(b));
}

function objectEqual(a, b) {
  var ka = Object.keys(a),
      kb = Object.keys(b),
      key,
      i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }

  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!sceneEqual(a[key], b[key], key)) return false;
  }

  return typeof a === typeof b;
}

function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}




/***/ }),

/***/ "./node_modules/vega-selections/build/vega-selection.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vega-selections/build/vega-selection.module.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "selectionIdTest": () => (/* binding */ selectionIdTest),
/* harmony export */   "selectionResolve": () => (/* binding */ selectionResolve),
/* harmony export */   "selectionTest": () => (/* binding */ selectionTest),
/* harmony export */   "selectionTuples": () => (/* binding */ selectionTuples),
/* harmony export */   "selectionVisitor": () => (/* binding */ selectionVisitor)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");



function ascending (a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function bisector (f) {
  let delta = f;
  let compare = f;

  if (f.length === 1) {
    delta = (d, x) => f(d) - x;

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left,
    center,
    right
  };
}

function ascendingComparator(f) {
  return (d, x) => ascending(f(d), x);
}

const Intersect = 'intersect';
const Union = 'union';
const VlMulti = 'vlMulti';
const VlPoint = 'vlPoint';
const Or = 'or';
const And = 'and';

const SELECTION_ID = '_vgsid_',
      TYPE_ENUM = 'E',
      TYPE_RANGE_INC = 'R',
      TYPE_RANGE_EXC = 'R-E',
      TYPE_RANGE_LE = 'R-LE',
      TYPE_RANGE_RE = 'R-RE',
      UNIT_INDEX = 'index:unit'; // TODO: revisit date coercion?

function testPoint(datum, entry) {
  var fields = entry.fields,
      values = entry.values,
      n = fields.length,
      i = 0,
      dval,
      f;

  for (; i < n; ++i) {
    f = fields[i];
    f.getter = vega_util__WEBPACK_IMPORTED_MODULE_0__.field.getter || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field);
    dval = f.getter(datum);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(dval)) dval = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(dval);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i])) values[i] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(values[i]);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i][0])) values[i] = values[i].map(vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);

    if (f.type === TYPE_ENUM) {
      // Enumerated fields can either specify individual values (single/multi selections)
      // or an array of values (interval selections).
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        // Discrete selection of bins test within the range [bin_start, bin_end).
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        // 'R-E'/'R-LE' included for completeness.
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, true)) return false;
      }
    }
  }

  return true;
}
/**
 * Tests if a tuple is contained within an interactive selection.
 * @param {string} name - The name of the data set representing the selection.
 *  Tuples in the dataset are of the form
 *  {unit: string, fields: array<fielddef>, values: array<*>}.
 *  Fielddef is of the form
 *  {field: string, channel: string, type: 'E' | 'R'} where
 *  'type' identifies whether tuples in the dataset enumerate
 *  values for the field, or specify a continuous range.
 * @param {object} datum - The tuple to test for inclusion.
 * @param {string} op - The set operation for combining selections.
 *   One of 'intersect' or 'union' (default).
 * @return {boolean} - True if the datum is in the selection, false otherwise.
 */


function selectionTest(name, datum, op) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
      intersect = op === Intersect,
      n = entries.length,
      i = 0,
      entry,
      miss,
      count,
      unit,
      b;

  for (; i < n; ++i) {
    entry = entries[i];

    if (unitIdx && intersect) {
      // multi selections union within the same unit and intersect across units.
      miss = miss || {};
      count = miss[unit = entry.unit] || 0; // if we've already matched this unit, skip.

      if (count === -1) continue;
      b = testPoint(datum, entry);
      miss[unit] = b ? -1 : ++count; // if we match and there are no other units return true
      // if we've missed against all tuples in this unit return false

      if (b && unitIdx.size === 1) return true;
      if (!b && count === unitIdx.get(unit).count) return false;
    } else {
      b = testPoint(datum, entry); // if we find a miss and we do require intersection return false
      // if we find a match and we don't require intersection return true

      if (intersect ^ b) return b;
    }
  } // if intersecting and we made it here, then we saw no misses
  // if not intersecting, then we saw no matches
  // if no active selections, return false


  return n && intersect;
}
const selectionId = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(SELECTION_ID),
      bisect = bisector(selectionId),
      bisectLeft = bisect.left,
      bisectRight = bisect.right;
function selectionIdTest(name, datum, op) {
  const data = this.context.data[name],
        entries = data ? data.values.value : [],
        unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
        intersect = op === Intersect,
        value = selectionId(datum),
        index = bisectLeft(entries, value);
  if (index === entries.length) return false;
  if (selectionId(entries[index]) !== value) return false;

  if (unitIdx && intersect) {
    if (unitIdx.size === 1) return true;
    if (bisectRight(entries, value) - index < unitIdx.size) return false;
  }

  return true;
}

/**
 * Maps an array of scene graph items to an array of selection tuples.
 * @param {string} name  - The name of the dataset representing the selection.
 * @param {string} unit  - The name of the unit view.
 *
 * @returns {array} An array of selection entries for the given unit.
 */

function selectionTuples(array, base) {
  return array.map(x => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    values: base.fields.map(f => (f.getter || (f.getter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field)))(x.datum))
  }, base));
}

/**
 * Resolves selection for use as a scale domain or reads via the API.
 * @param {string} name - The name of the dataset representing the selection
 * @param {string} [op='union'] - The set operation for combining selections.
 *                 One of 'intersect' or 'union' (default).
 * @param {boolean} isMulti - Identifies a "multi" selection to perform more
 *                 expensive resolution computation.
 * @param {boolean} vl5 - With Vega-Lite v5, "multi" selections are now called "point"
 *                 selections, and thus the resolved tuple should reflect this name.
 *                 This parameter allows us to reflect this change without triggering
 *                 a major version bump for Vega.
 * @returns {object} An object of selected fields and values.
 */

function selectionResolve(name, op, isMulti, vl5) {
  var data = this.context.data[name],
      entries = data ? data.values.value : [],
      resolved = {},
      multiRes = {},
      types = {},
      entry,
      fields,
      values,
      unit,
      field,
      res,
      resUnit,
      type,
      union,
      n = entries.length,
      i = 0,
      j,
      m; // First union all entries within the same unit.

  for (; i < n; ++i) {
    entry = entries[i];
    unit = entry.unit;
    fields = entry.fields;
    values = entry.values;

    for (j = 0, m = fields.length; j < m; ++j) {
      field = fields[j];
      res = resolved[field.field] || (resolved[field.field] = {});
      resUnit = res[unit] || (res[unit] = []);
      types[field.field] = type = field.type.charAt(0);
      union = ops[type + '_union'];
      res[unit] = union(resUnit, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values[j]));
    } // If the same multi-selection is repeated over views and projected over
    // an encoding, it may operate over different fields making it especially
    // tricky to reliably resolve it. At best, we can de-dupe identical entries
    // but doing so may be more computationally expensive than it is worth.
    // Instead, for now, we simply transform our store representation into
    // a more human-friendly one.


    if (isMulti) {
      resUnit = multiRes[unit] || (multiRes[unit] = []);
      resUnit.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));
    }
  } // Then resolve fields across units as per the op.


  op = op || Union;
  Object.keys(resolved).forEach(field => {
    resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[types[field] + '_' + op](acc, curr));
  });
  entries = Object.keys(multiRes);

  if (isMulti && entries.length) {
    const key = vl5 ? VlPoint : VlMulti;
    resolved[key] = op === Union ? {
      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries.map(k => ({
        [Or]: multiRes[k]
      }))
    };
  }

  return resolved;
}
var ops = {
  E_union: function (base, value) {
    if (!base.length) return value;
    var i = 0,
        n = value.length;

    for (; i < n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);

    return base;
  },
  E_intersect: function (base, value) {
    return !base.length ? value : base.filter(v => value.indexOf(v) >= 0);
  },
  R_union: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];
    if (base[0] > lo) base[0] = lo;
    if (base[1] < hi) base[1] = hi;
    return base;
  },
  R_intersect: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
        hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);

    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }

    if (!base.length) return [lo, hi];

    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo) base[0] = lo;
      if (base[1] > hi) base[1] = hi;
    }

    return base;
  }
};

const DataPrefix = ':',
      IndexPrefix = '@';
function selectionVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to selection functions must be a string literal.');
  const data = args[0].value,
        op = args.length >= 2 && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args).value,
        field = 'unit',
        indexName = IndexPrefix + field,
        dataName = DataPrefix + data; // eslint-disable-next-line no-prototype-builtins

  if (op === Intersect && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, indexName)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  } // eslint-disable-next-line no-prototype-builtins


  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, dataName)) {
    params[dataName] = scope.getData(data).tuplesRef();
  }
}




/***/ }),

/***/ "./node_modules/vega-statistics/build/vega-statistics.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-statistics/build/vega-statistics.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bandwidthNRD": () => (/* binding */ estimateBandwidth),
/* harmony export */   "bin": () => (/* binding */ bin),
/* harmony export */   "bootstrapCI": () => (/* binding */ bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* binding */ cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* binding */ cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* binding */ cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* binding */ densityLogNormal),
/* harmony export */   "densityNormal": () => (/* binding */ densityNormal),
/* harmony export */   "densityUniform": () => (/* binding */ densityUniform),
/* harmony export */   "dotbin": () => (/* binding */ dotbin),
/* harmony export */   "quantileLogNormal": () => (/* binding */ quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* binding */ quantileNormal),
/* harmony export */   "quantileUniform": () => (/* binding */ quantileUniform),
/* harmony export */   "quantiles": () => (/* binding */ quantiles),
/* harmony export */   "quartiles": () => (/* binding */ quartiles),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "randomInteger": () => (/* binding */ integer),
/* harmony export */   "randomKDE": () => (/* binding */ kde),
/* harmony export */   "randomLCG": () => (/* binding */ lcg),
/* harmony export */   "randomLogNormal": () => (/* binding */ lognormal),
/* harmony export */   "randomMixture": () => (/* binding */ mixture),
/* harmony export */   "randomNormal": () => (/* binding */ gaussian),
/* harmony export */   "randomUniform": () => (/* binding */ uniform),
/* harmony export */   "regressionExp": () => (/* binding */ exp),
/* harmony export */   "regressionLinear": () => (/* binding */ linear),
/* harmony export */   "regressionLoess": () => (/* binding */ loess),
/* harmony export */   "regressionLog": () => (/* binding */ log),
/* harmony export */   "regressionPoly": () => (/* binding */ poly),
/* harmony export */   "regressionPow": () => (/* binding */ pow),
/* harmony export */   "regressionQuad": () => (/* binding */ quad),
/* harmony export */   "sampleCurve": () => (/* binding */ sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* binding */ sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* binding */ sampleNormal),
/* harmony export */   "sampleUniform": () => (/* binding */ sampleUniform),
/* harmony export */   "setRandom": () => (/* binding */ setRandom)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/deviation.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/median.js");


function* numbers (values, valueof) {
  if (valueof == null) {
    for (let value of values) {
      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;

    for (let value of values) {
      value = valueof(value, ++index, values);

      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantiles (array, p, f) {
  const values = Float64Array.from(numbers(array, f)); // don't depend on return value from typed array sort call
  // protects against undefined sort results in Safari (vega/vega-lite#4964)

  values.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return p.map(_ => (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.quantileSorted)(values, _));
}

function quartiles (array, f) {
  return quantiles(array, [0.25, 0.50, 0.75], f);
}

// Theory, Practice, and Visualization. Wiley.

function estimateBandwidth (array, f) {
  const n = array.length,
        d = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.default)(array, f),
        q = quartiles(array, f),
        h = (q[2] - q[0]) / 1.34,
        v = Math.min(d, h) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}

function bin (_) {
  // determine range
  const maxb = _.maxbins || 20,
        base = _.base || 10,
        logb = Math.log(base),
        div = _.divide || [5, 2];
  let min = _.extent[0],
      max = _.extent[1],
      step,
      level,
      minstep,
      v,
      i,
      n;
  const span = _.span || max - min || Math.abs(min) || 1;

  if (_.step) {
    // if step size is explicitly given, use that
    step = _.step;
  } else if (_.steps) {
    // if provided, limit choice to acceptable step sizes
    v = span / maxb;

    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i);

    step = _.steps[Math.max(0, i - 1)];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span) / logb) - level)); // increase step size if too many bins

    while (Math.ceil(span / step) > maxb) {
      step *= base;
    } // decrease step size if allowed


    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  } // update precision, min and max


  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1,
        eps = Math.pow(base, -precision - 1);

  if (_.nice || _.nice === undefined) {
    v = Math.floor(min / step + eps) * step;
    min = min < v ? v - step : v;
    max = Math.ceil(max / step) * step;
  }

  return {
    start: min,
    stop: max === min ? min + step : max,
    step: step
  };
}

var random = Math.random;
function setRandom(r) {
  random = r;
}

function bootstrapCI (array, samples, alpha, f) {
  if (!array.length) return [undefined, undefined];
  const values = Float64Array.from(numbers(array, f)),
        n = values.length,
        m = samples;
  let a, i, j, mu;

  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values[~~(random() * n)];
    }

    mu[j] = a / n;
  }

  mu.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__.default);
  return [(0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, alpha / 2), (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.default)(mu, 1 - alpha / 2)];
}

// Dot density binning for dot plot construction.
// Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
// https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
function dotbin (array, step, smooth, f) {
  f = f || (_ => _);

  const n = array.length,
        v = new Float64Array(n);
  let i = 0,
      j = 1,
      a = f(array[0]),
      b = a,
      w = a + step,
      x;

  for (; j < n; ++j) {
    x = f(array[j]);

    if (x >= w) {
      b = (a + b) / 2;

      for (; i < j; ++i) v[i] = b;

      w = x + step;
      a = x;
    }

    b = x;
  }

  b = (a + b) / 2;

  for (; i < j; ++i) v[i] = b;

  return smooth ? smoothing(v, step + step / 4) : v;
} // perform smoothing to reduce variance
// swap points between "adjacent" stacks
// Wilkinson defines adjacent as within step/4 units

function smoothing(v, thresh) {
  const n = v.length;
  let a = 0,
      b = 1,
      c,
      d; // get left stack

  while (v[a] === v[b]) ++b;

  while (b < n) {
    // get right stack
    c = b + 1;

    while (v[b] === v[c]) ++c; // are stacks adjacent?
    // if so, compare sizes and swap as needed


    if (v[b] - v[b - 1] < thresh) {
      d = b + (a + c - b - b >> 1);

      while (d < b) v[d++] = v[b];

      while (d > b) v[d--] = v[a];
    } // update left stack indices


    a = b;
    b = c;
  }

  return v;
}

function lcg (seed) {
  // Random numbers using a Linear Congruential Generator with seed value
  // Uses glibc values from https://en.wikipedia.org/wiki/Linear_congruential_generator
  return function () {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}

function integer (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }

  let a, b, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b - a;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ || 0;
        d = b - a;
        return dist;
      } else {
        return b;
      }
    },

    sample() {
      return a + Math.floor(d * random());
    },

    pdf(x) {
      return x === Math.floor(x) && x >= a && x < b ? 1 / d : 0;
    },

    cdf(x) {
      const v = Math.floor(x);
      return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
    },

    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }

  };
  return dist.min(min).max(max);
}

const SQRT2PI = Math.sqrt(2 * Math.PI);
const SQRT2 = Math.SQRT2;

let nextSample = NaN;
function sampleNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  let x = 0,
      y = 0,
      rds,
      c;

  if (nextSample === nextSample) {
    x = nextSample;
    nextSample = NaN;
  } else {
    do {
      x = random() * 2 - 1;
      y = random() * 2 - 1;
      rds = x * x + y * y;
    } while (rds === 0 || rds > 1);

    c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform

    x *= c;
    nextSample = y * c;
  }

  return mean + x * stdev;
}
function densityNormal(value, mean, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value - (mean || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
} // Approximation from West (2009)
// Better Approximations to Cumulative Normal Functions

function cumulativeNormal(value, mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value - mean) / stdev,
        Z = Math.abs(z);
  let cd;

  if (Z > 37) {
    cd = 0;
  } else {
    const exp = Math.exp(-Z * Z / 2);
    let sum;

    if (Z < 7.07106781186547) {
      sum = 3.52624965998911e-02 * Z + 0.700383064443688;
      sum = sum * Z + 6.37396220353165;
      sum = sum * Z + 33.912866078383;
      sum = sum * Z + 112.079291497871;
      sum = sum * Z + 221.213596169931;
      sum = sum * Z + 220.206867912376;
      cd = exp * sum;
      sum = 8.83883476483184e-02 * Z + 1.75566716318264;
      sum = sum * Z + 16.064177579207;
      sum = sum * Z + 86.7807322029461;
      sum = sum * Z + 296.564248779674;
      sum = sum * Z + 637.333633378831;
      sum = sum * Z + 793.826512519948;
      sum = sum * Z + 440.413735824752;
      cd = cd / sum;
    } else {
      sum = Z + 0.65;
      sum = Z + 4 / sum;
      sum = Z + 3 / sum;
      sum = Z + 2 / sum;
      sum = Z + 1 / sum;
      cd = exp / sum / 2.506628274631;
    }
  }

  return z > 0 ? 1 - cd : cd;
} // Approximation of Probit function using inverse error function.

function quantileNormal(p, mean, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
} // Approximate inverse error function. Implementation from "Approximating
// the erfinv function" by Mike Giles, GPU Computing Gems, volume 2, 2010.
// Ported from Apache Commons Math, http://www.apache.org/licenses/LICENSE-2.0

function erfinv(x) {
  // beware that the logarithm argument must be
  // commputed as (1.0 - x) * (1.0 + x),
  // it must NOT be simplified as 1.0 - x * x as this
  // would induce rounding errors near the boundaries +/-1
  let w = -Math.log((1 - x) * (1 + x)),
      p;

  if (w < 6.25) {
    w -= 3.125;
    p = -3.6444120640178196996e-21;
    p = -1.685059138182016589e-19 + p * w;
    p = 1.2858480715256400167e-18 + p * w;
    p = 1.115787767802518096e-17 + p * w;
    p = -1.333171662854620906e-16 + p * w;
    p = 2.0972767875968561637e-17 + p * w;
    p = 6.6376381343583238325e-15 + p * w;
    p = -4.0545662729752068639e-14 + p * w;
    p = -8.1519341976054721522e-14 + p * w;
    p = 2.6335093153082322977e-12 + p * w;
    p = -1.2975133253453532498e-11 + p * w;
    p = -5.4154120542946279317e-11 + p * w;
    p = 1.051212273321532285e-09 + p * w;
    p = -4.1126339803469836976e-09 + p * w;
    p = -2.9070369957882005086e-08 + p * w;
    p = 4.2347877827932403518e-07 + p * w;
    p = -1.3654692000834678645e-06 + p * w;
    p = -1.3882523362786468719e-05 + p * w;
    p = 0.0001867342080340571352 + p * w;
    p = -0.00074070253416626697512 + p * w;
    p = -0.0060336708714301490533 + p * w;
    p = 0.24015818242558961693 + p * w;
    p = 1.6536545626831027356 + p * w;
  } else if (w < 16.0) {
    w = Math.sqrt(w) - 3.25;
    p = 2.2137376921775787049e-09;
    p = 9.0756561938885390979e-08 + p * w;
    p = -2.7517406297064545428e-07 + p * w;
    p = 1.8239629214389227755e-08 + p * w;
    p = 1.5027403968909827627e-06 + p * w;
    p = -4.013867526981545969e-06 + p * w;
    p = 2.9234449089955446044e-06 + p * w;
    p = 1.2475304481671778723e-05 + p * w;
    p = -4.7318229009055733981e-05 + p * w;
    p = 6.8284851459573175448e-05 + p * w;
    p = 2.4031110387097893999e-05 + p * w;
    p = -0.0003550375203628474796 + p * w;
    p = 0.00095328937973738049703 + p * w;
    p = -0.0016882755560235047313 + p * w;
    p = 0.0024914420961078508066 + p * w;
    p = -0.0037512085075692412107 + p * w;
    p = 0.005370914553590063617 + p * w;
    p = 1.0052589676941592334 + p * w;
    p = 3.0838856104922207635 + p * w;
  } else if (Number.isFinite(w)) {
    w = Math.sqrt(w) - 5.0;
    p = -2.7109920616438573243e-11;
    p = -2.5556418169965252055e-10 + p * w;
    p = 1.5076572693500548083e-09 + p * w;
    p = -3.7894654401267369937e-09 + p * w;
    p = 7.6157012080783393804e-09 + p * w;
    p = -1.4960026627149240478e-08 + p * w;
    p = 2.9147953450901080826e-08 + p * w;
    p = -6.7711997758452339498e-08 + p * w;
    p = 2.2900482228026654717e-07 + p * w;
    p = -9.9298272942317002539e-07 + p * w;
    p = 4.5260625972231537039e-06 + p * w;
    p = -1.9681778105531670567e-05 + p * w;
    p = 7.5995277030017761139e-05 + p * w;
    p = -0.00021503011930044477347 + p * w;
    p = -0.00013871931833623122026 + p * w;
    p = 1.0103004648645343977 + p * w;
    p = 4.8499064014085844221 + p * w;
  } else {
    p = Infinity;
  }

  return p * x;
}

function gaussian (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleNormal(mu, sigma),
    pdf: value => densityNormal(value, mu, sigma),
    cdf: value => cumulativeNormal(value, mu, sigma),
    icdf: p => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function kde (support, bandwidth) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth);
      } else {
        return support;
      }
    },

    bandwidth(_) {
      if (!arguments.length) return bandwidth;
      bandwidth = _;
      if (!bandwidth && support) bandwidth = estimateBandwidth(support);
      return dist;
    },

    sample() {
      return support[~~(random() * n)] + bandwidth * kernel.sample();
    },

    pdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.pdf((x - support[i]) / bandwidth);
      }

      return y / bandwidth / n;
    },

    cdf(x) {
      let y = 0,
          i = 0;

      for (; i < n; ++i) {
        y += kernel.cdf((x - support[i]) / bandwidth);
      }

      return y / n;
    },

    icdf() {
      throw Error('KDE icdf not supported.');
    }

  };
  return dist.data(support);
}

function sampleLogNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean + sampleNormal() * stdev);
}
function densityLogNormal(value, mean, stdev) {
  if (value <= 0) return 0;
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value) - mean) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value);
}
function cumulativeLogNormal(value, mean, stdev) {
  return cumulativeNormal(Math.log(value), mean, stdev);
}
function quantileLogNormal(p, mean, stdev) {
  return Math.exp(quantileNormal(p, mean, stdev));
}
function lognormal (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },

    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },

    sample: () => sampleLogNormal(mu, sigma),
    pdf: value => densityLogNormal(value, mu, sigma),
    cdf: value => cumulativeLogNormal(value, mu, sigma),
    icdf: p => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function mixture (dists, weights) {
  let m = 0,
      w;

  function normalize(x) {
    const w = [];
    let sum = 0,
        i;

    for (i = 0; i < m; ++i) {
      sum += w[i] = x[i] == null ? 1 : +x[i];
    }

    for (i = 0; i < m; ++i) {
      w[i] /= sum;
    }

    return w;
  }

  const dist = {
    weights(_) {
      if (arguments.length) {
        w = normalize(weights = _ || []);
        return dist;
      }

      return weights;
    },

    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }

        return dist.weights(weights);
      }

      return dists;
    },

    sample() {
      const r = random();
      let d = dists[m - 1],
          v = w[0],
          i = 0; // first select distribution

      for (; i < m - 1; v += w[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      } // then sample from it


      return d.sample();
    },

    pdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].pdf(x);
      }

      return p;
    },

    cdf(x) {
      let p = 0,
          i = 0;

      for (; i < m; ++i) {
        p += w[i] * dists[i].cdf(x);
      }

      return p;
    },

    icdf() {
      throw Error('Mixture icdf not supported.');
    }

  };
  return dist.distributions(dists).weights(weights);
}

function sampleUniform(min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return min + (max - min) * random();
}
function densityUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value >= min && value <= max ? 1 / (max - min) : 0;
}
function cumulativeUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return value < min ? 0 : value > max ? 1 : (value - min) / (max - min);
}
function quantileUniform(p, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return p >= 0 && p <= 1 ? min + p * (max - min) : NaN;
}
function uniform (min, max) {
  let a, b;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },

    max(_) {
      if (arguments.length) {
        b = _ == null ? 1 : _;
        return dist;
      } else {
        return b;
      }
    },

    sample: () => sampleUniform(a, b),
    pdf: value => densityUniform(value, a, b),
    cdf: value => cumulativeUniform(value, a, b),
    icdf: p => quantileUniform(p, a, b)
  };

  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }

  return dist.min(min).max(max);
}

// Ordinary Least Squares
function ols (uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX,
        slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
        intercept = uY - slope * uX;
  return [intercept, slope];
}

function points(data, x, y, sort) {
  data = data.filter(d => {
    let u = x(d),
        v = y(d);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });

  if (sort) {
    data.sort((a, b) => x(a) - x(b));
  }

  const n = data.length,
        X = new Float64Array(n),
        Y = new Float64Array(n); // extract values, calculate means

  let i = 0,
      ux = 0,
      uy = 0,
      xv,
      yv,
      d;

  for (d of data) {
    X[i] = xv = +x(d);
    Y[i] = yv = +y(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  } // mean center the data


  for (i = 0; i < n; ++i) {
    X[i] -= ux;
    Y[i] -= uy;
  }

  return [X, Y, ux, uy];
}
function visitPoints(data, x, y, callback) {
  let i = -1,
      u,
      v;

  for (const d of data) {
    u = x(d);
    v = y(d);

    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function rSquared (data, x, y, uY, predict) {
  let SSE = 0,
      SST = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx),
          sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function linear (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * x;

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function log (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] + coef[1] * Math.log(x);

  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

function exp (data, x, y) {
  // eslint-disable-next-line no-unused-vars
  const [xv, yv, ux, uy] = points(data, x, y);
  let YL = 0,
      XY = 0,
      XYL = 0,
      X2Y = 0,
      n = 0,
      dx,
      ly,
      xy;
  visitPoints(data, x, y, (_, dy) => {
    dx = xv[n++];
    ly = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });

  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy),
        predict = x => Math.exp(c0 + c1 * (x - ux));

  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE

function pow (data, x, y) {
  let X = 0,
      Y = 0,
      XY = 0,
      X2 = 0,
      YS = 0,
      n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const lx = Math.log(dx),
          ly = Math.log(dy);
    ++n;
    X += (lx - X) / n;
    Y += (ly - Y) / n;
    XY += (lx * ly - XY) / n;
    X2 += (lx * lx - X2) / n;
    YS += (dy - YS) / n;
  });

  const coef = ols(X, Y, XY, X2),
        predict = x => coef[0] * Math.pow(x, coef[1]);

  coef[0] = Math.exp(coef[0]);
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, YS, predict)
  };
}

function quad (data, x, y) {
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length;
  let X2 = 0,
      X3 = 0,
      X4 = 0,
      XY = 0,
      X2Y = 0,
      i,
      dx,
      dy,
      x2;

  for (i = 0; i < n;) {
    dx = xv[i];
    dy = yv[i++];
    x2 = dx * dx;
    X2 += (x2 - X2) / i;
    X3 += (x2 * dx - X3) / i;
    X4 += (x2 * x2 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x2 * dy - X2Y) / i;
  }

  const X2X2 = X4 - X2 * X2,
        d = X2 * X2X2 - X3 * X3,
        a = (X2Y * X2 - XY * X3) / d,
        b = (XY * X2X2 - X2Y * X3) / d,
        c = -a * X2,
        predict = x => {
    x = x - ux;
    return a * x * x + b * x + c + uy;
  }; // transform coefficients back from mean-centered space


  return {
    coef: [c - b * ux + a * ux * ux + uy, b - 2 * a * ux, a],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
// ... which was adapted from regression-js by Tom Alexander
// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE

function poly (data, x, y, order) {
  // use more efficient methods for lower orders
  if (order === 1) return linear(data, x, y);
  if (order === 2) return quad(data, x, y);
  const [xv, yv, ux, uy] = points(data, x, y),
        n = xv.length,
        lhs = [],
        rhs = [],
        k = order + 1;
  let i, j, l, v, c;

  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }

    lhs.push(v);
    c = new Float64Array(k);

    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }

      c[j] = v;
    }

    rhs.push(c);
  }

  rhs.push(lhs);

  const coef = gaussianElimination(rhs),
        predict = x => {
    x -= ux;
    let y = uy + coef[0] + coef[1] * x + coef[2] * x * x;

    for (i = 3; i < k; ++i) y += coef[i] * Math.pow(x, i);

    return y;
  };

  return {
    coef: uncenter(k, coef, -ux, uy),
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

function uncenter(k, a, x, y) {
  const z = Array(k);
  let i, j, v, c; // initialize to zero

  for (i = 0; i < k; ++i) z[i] = 0; // polynomial expansion


  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;

    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j; // binomial coefficent

      z[i - j] += v * Math.pow(x, j) * c;
    }
  } // bias term


  z[0] += y;
  return z;
} // Given an array for a two-dimensional matrix and the polynomial order,
// solve A * x = b using Gaussian elimination.


function gaussianElimination(matrix) {
  const n = matrix.length - 1,
        coef = [];
  let i, j, k, r, t;

  for (i = 0; i < n; ++i) {
    r = i; // max row

    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }

    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }

    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; --j) {
    t = 0;

    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }

    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }

  return coef;
}

const maxiters = 2,
      epsilon = 1e-12; // Adapted from science.js by Jason Davies
// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js
// License: https://github.com/jasondavies/science.js/blob/master/LICENSE

function loess (data, x, y, bandwidth) {
  const [xv, yv, ux, uy] = points(data, x, y, true),
        n = xv.length,
        bw = Math.max(2, ~~(bandwidth * n)),
        // # nearest neighbors
  yhat = new Float64Array(n),
        residuals = new Float64Array(n),
        robustWeights = new Float64Array(n).fill(1);

  for (let iter = -1; ++iter <= maxiters;) {
    const interval = [0, bw - 1];

    for (let i = 0; i < n; ++i) {
      const dx = xv[i],
            i0 = interval[0],
            i1 = interval[1],
            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0,
          X = 0,
          Y = 0,
          XY = 0,
          X2 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1); // avoid singularity!

      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k],
              yk = yv[k],
              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
              xkw = xk * w;
        W += w;
        X += xkw;
        Y += yk * w;
        XY += yk * xkw;
        X2 += xk * xkw;
      } // linear regression fit


      const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);
      yhat[i] = a + b * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval);
    }

    if (iter === maxiters) {
      break;
    }

    const medianResidual = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.default)(residuals);
    if (Math.abs(medianResidual) < epsilon) break;

    for (let i = 0, arg, w; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual); // default to epsilon (rather than zero) for large deviations
      // keeping weights tiny but non-zero prevents singularites

      robustWeights[i] = arg >= 1 ? epsilon : (w = 1 - arg * arg) * w;
    }
  }

  return output(xv, yhat, ux, uy);
} // weighting kernel for local regression

function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
} // advance sliding window interval of nearest neighbors


function updateInterval(xv, i, interval) {
  const val = xv[i];
  let left = interval[0],
      right = interval[1] + 1;
  if (right >= xv.length) return; // step right if distance to new right edge is <= distance to old left edge
  // step when distance is equal to ensure movement over duplicate x values

  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
} // generate smoothed output points
// average points with repeated x values


function output(xv, yhat, ux, uy) {
  const n = xv.length,
        out = [];
  let i = 0,
      cnt = 0,
      prev = [],
      v;

  for (; i < n; ++i) {
    v = xv[i] + ux;

    if (prev[0] === v) {
      // average output values via online update
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      // add new output point
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }

  prev[1] += uy;
  return out;
}

// subdivide up to accuracy of 0.5 degrees
const MIN_RADIANS = 0.5 * Math.PI / 180; // Adaptively sample an interpolated function over a domain extent

function sampleCurve (f, extent, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);

  const point = x => [x, f(x)],
        minX = extent[0],
        maxX = extent[1],
        span = maxX - minX,
        stop = span / maxSteps,
        prev = [point(minX)],
        next = [];

  if (minSteps === maxSteps) {
    // no adaptation, sample uniform grid directly and return
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point(minX + i / minSteps * span));
    }

    prev.push(point(maxX));
    return prev;
  } else {
    // sample minimum points on uniform grid
    // then move on to perform adaptive refinement
    next.push(point(maxX));

    for (let i = minSteps; --i > 0;) {
      next.push(point(minX + i / minSteps * span));
    }
  }

  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span;
  const sy = scaleY(p0[1], next);

  while (p1) {
    // midpoint for potential curve subdivision
    const pm = point((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop;

    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      // maximum resolution has not yet been met, and
      // subdivision midpoint is sufficiently different from endpoint
      // save subdivision, push midpoint onto the visitation stack
      next.push(pm);
    } else {
      // subdivision midpoint sufficiently similar to endpoint
      // skip subdivision, store endpoint, move to next point on the stack
      p0 = p1;
      prev.push(p1);
      next.pop();
    }

    p1 = next[next.length - 1];
  }

  return prev;
}

function scaleY(init, points) {
  let ymin = init;
  let ymax = init;
  const n = points.length;

  for (let i = 0; i < n; ++i) {
    const y = points[i][1];
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;
  }

  return 1 / (ymax - ymin);
}

function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])),
        a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}




/***/ }),

/***/ "./node_modules/vega-time/build/vega-time.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/vega-time/build/vega-time.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DATE": () => (/* binding */ DATE),
/* harmony export */   "DAY": () => (/* binding */ DAY),
/* harmony export */   "DAYOFYEAR": () => (/* binding */ DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* binding */ HOURS),
/* harmony export */   "MILLISECONDS": () => (/* binding */ MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* binding */ MINUTES),
/* harmony export */   "MONTH": () => (/* binding */ MONTH),
/* harmony export */   "QUARTER": () => (/* binding */ QUARTER),
/* harmony export */   "SECONDS": () => (/* binding */ SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* binding */ TIME_UNITS),
/* harmony export */   "WEEK": () => (/* binding */ WEEK),
/* harmony export */   "YEAR": () => (/* binding */ YEAR),
/* harmony export */   "dayofyear": () => (/* binding */ dayofyear),
/* harmony export */   "timeBin": () => (/* binding */ bin),
/* harmony export */   "timeFloor": () => (/* binding */ timeFloor),
/* harmony export */   "timeInterval": () => (/* binding */ timeInterval),
/* harmony export */   "timeOffset": () => (/* binding */ timeOffset),
/* harmony export */   "timeSequence": () => (/* binding */ timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* binding */ timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* binding */ timeUnits),
/* harmony export */   "utcFloor": () => (/* binding */ utcFloor),
/* harmony export */   "utcInterval": () => (/* binding */ utcInterval),
/* harmony export */   "utcOffset": () => (/* binding */ utcOffset),
/* harmony export */   "utcSequence": () => (/* binding */ utcSequence),
/* harmony export */   "utcdayofyear": () => (/* binding */ utcdayofyear),
/* harmony export */   "utcweek": () => (/* binding */ utcweek),
/* harmony export */   "week": () => (/* binding */ week)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcDay.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcWeek.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/millisecond.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcYear.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMonth.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcHour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/utcMinute.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");




const YEAR = 'year';
const QUARTER = 'quarter';
const MONTH = 'month';
const WEEK = 'week';
const DATE = 'date';
const DAY = 'day';
const DAYOFYEAR = 'dayofyear';
const HOURS = 'hours';
const MINUTES = 'minutes';
const SECONDS = 'seconds';
const MILLISECONDS = 'milliseconds';
const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
const UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(units).slice(),
        m = {}; // check validity

  if (!u.length) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing time unit.');
  u.forEach(unit => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(UNITS, unit)) {
      m[unit] = 1;
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Invalid time unit: ".concat(unit, "."));
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);

  if (numTypes > 1) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)("Incompatible time units: ".concat(units));
  } // ensure proper sort order


  u.sort((a, b) => UNITS[a] - UNITS[b]);
  return u;
}
const defaultSpecifiers = {
  [YEAR]: '%Y ',
  [QUARTER]: 'Q%q ',
  [MONTH]: '%b ',
  [DATE]: '%d ',
  [WEEK]: 'W%U ',
  [DAY]: '%a ',
  [DAYOFYEAR]: '%j ',
  [HOURS]: '%H:00',
  [MINUTES]: '00:%M',
  [SECONDS]: ':%S',
  [MILLISECONDS]: '.%L',
  ["".concat(YEAR, "-").concat(MONTH)]: '%Y-%m ',
  ["".concat(YEAR, "-").concat(MONTH, "-").concat(DATE)]: '%Y-%m-%d ',
  ["".concat(HOURS, "-").concat(MINUTES)]: '%H:%M'
};
function timeUnitSpecifier(units, specifiers) {
  const s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultSpecifiers, specifiers),
        u = timeUnits(units),
        n = u.length;
  let fmt = '',
      start = 0,
      end,
      key;

  for (start = 0; start < n;) {
    for (end = u.length; end > start; --end) {
      key = u.slice(start, end).join('-');

      if (s[key] != null) {
        fmt += s[key];
        start = end;
        break;
      }
    }
  }

  return fmt.trim();
}

const t0 = new Date();

function localYear(y) {
  t0.setFullYear(y);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}

function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_1__.default.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y) {
  return localYear(y).getDay();
}
function localDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y);
    return date;
  }

  return new Date(y, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_3__.default.count(y - 1, d);
}
function utcWeekNum(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday.count(y - 1, d);
}
function utcFirst(y) {
  t0.setTime(Date.UTC(y, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(y, m, d, H, M, S, L));
}

function floor(units, step, get, inv, newDate) {
  const s = step || 1,
        b = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(units),
        _ = (unit, p, key) => {
    key = key || unit;
    return getUnit(get[key], inv[key], unit === b && s, p);
  };

  const t = new Date(),
        u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(units),
        y = u[YEAR] ? _(YEAR) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(2012),
        m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : vega_util__WEBPACK_IMPORTED_MODULE_0__.one,
        H = u[HOURS] ? _(HOURS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        M = u[MINUTES] ? _(MINUTES) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        S = u[SECONDS] ? _(SECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
        L = u[MILLISECONDS] ? _(MILLISECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero;
  return function (v) {
    t.setTime(+v);
    const year = y(t);
    return newDate(year, m(t), d(t, year), H(t), M(t), S(t), L(t));
  };
}

function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y) => phase + step * Math.floor((f(d, y) - phase) / step) : (d, y) => step * Math.floor(f(d, y) / step);
  return inv ? (d, y) => inv(u(d, y), y) : u;
} // returns the day of the year based on week number, day of week,
// and the day of the week for the first day of the year


function weekday(week, day, firstDay) {
  return day + week * 7 - (firstDay + 6) % 7;
} // -- LOCAL TIME --


const localGet = {
  [YEAR]: d => d.getFullYear(),
  [QUARTER]: d => Math.floor(d.getMonth() / 3),
  [MONTH]: d => d.getMonth(),
  [DATE]: d => d.getDate(),
  [HOURS]: d => d.getHours(),
  [MINUTES]: d => d.getMinutes(),
  [SECONDS]: d => d.getSeconds(),
  [MILLISECONDS]: d => d.getMilliseconds(),
  [DAYOFYEAR]: d => localDayOfYear(d),
  [WEEK]: d => localWeekNum(d),
  [WEEK + DAY]: (d, y) => weekday(localWeekNum(d), d.getDay(), localFirst(y)),
  [DAY]: (d, y) => weekday(1, d.getDay(), localFirst(y))
};
const localInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, localFirst(y))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
} // -- UTC TIME --

const utcGet = {
  [YEAR]: d => d.getUTCFullYear(),
  [QUARTER]: d => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: d => d.getUTCMonth(),
  [DATE]: d => d.getUTCDate(),
  [HOURS]: d => d.getUTCHours(),
  [MINUTES]: d => d.getUTCMinutes(),
  [SECONDS]: d => d.getUTCSeconds(),
  [MILLISECONDS]: d => d.getUTCMilliseconds(),
  [DAYOFYEAR]: d => utcDayOfYear(d),
  [WEEK]: d => utcWeekNum(d),
  [DAY]: (d, y) => weekday(1, d.getUTCDay(), utcFirst(y)),
  [WEEK + DAY]: (d, y) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y))
};
const utcInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, utcFirst(y))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}

const timeIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_5__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_6__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_2__.sunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_1__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_7__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_8__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
const utcIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_11__.default,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_12__.default,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_4__.utcSunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_3__.default,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_13__.default,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_14__.default,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_9__.default,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_10__.default
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}

function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : undefined;
}

function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}

function sequence(ival, start, stop, step) {
  return ival ? ival.range(start, stop, step) : undefined;
}

function timeSequence(unit, start, stop, step) {
  return sequence(timeInterval(unit), start, stop, step);
}
function utcSequence(unit, start, stop, step) {
  return sequence(utcInterval(unit), start, stop, step);
}

const durationSecond = 1000,
      durationMinute = durationSecond * 60,
      durationHour = durationMinute * 60,
      durationDay = durationHour * 24,
      durationWeek = durationDay * 7,
      durationMonth = durationDay * 30,
      durationYear = durationDay * 365;
const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS],
      Seconds = Milli.slice(0, -1),
      Minutes = Seconds.slice(0, -1),
      Hours = Minutes.slice(0, -1),
      Day = Hours.slice(0, -1),
      Week = [YEAR, WEEK],
      Month = [YEAR, MONTH],
      Year = [YEAR];
const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin (opt) {
  const ext = opt.extent,
        max = opt.maxbins || 40,
        target = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(ext)) / max;
  let i = (0,d3_array__WEBPACK_IMPORTED_MODULE_15__.default)(i => i[2]).right(intervals, target),
      units,
      step;

  if (i === intervals.length) {
    units = Year, step = (0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0] / durationYear, ext[1] / durationYear, max);
  } else if (i) {
    i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_16__.tickStep)(ext[0], ext[1], max), 1);
  }

  return {
    units,
    step
  };
}




/***/ }),

/***/ "./node_modules/vega-transforms/build/vega-transforms.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-transforms/build/vega-transforms.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aggregate": () => (/* binding */ Aggregate),
/* harmony export */   "bin": () => (/* binding */ Bin),
/* harmony export */   "collect": () => (/* binding */ Collect),
/* harmony export */   "compare": () => (/* binding */ Compare),
/* harmony export */   "countpattern": () => (/* binding */ CountPattern),
/* harmony export */   "cross": () => (/* binding */ Cross),
/* harmony export */   "density": () => (/* binding */ Density),
/* harmony export */   "dotbin": () => (/* binding */ DotBin),
/* harmony export */   "expression": () => (/* binding */ Expression),
/* harmony export */   "extent": () => (/* binding */ Extent),
/* harmony export */   "facet": () => (/* binding */ Facet),
/* harmony export */   "field": () => (/* binding */ Field),
/* harmony export */   "filter": () => (/* binding */ Filter),
/* harmony export */   "flatten": () => (/* binding */ Flatten),
/* harmony export */   "fold": () => (/* binding */ Fold),
/* harmony export */   "formula": () => (/* binding */ Formula),
/* harmony export */   "generate": () => (/* binding */ Generate),
/* harmony export */   "impute": () => (/* binding */ Impute),
/* harmony export */   "joinaggregate": () => (/* binding */ JoinAggregate),
/* harmony export */   "kde": () => (/* binding */ KDE),
/* harmony export */   "key": () => (/* binding */ Key),
/* harmony export */   "load": () => (/* binding */ Load),
/* harmony export */   "lookup": () => (/* binding */ Lookup),
/* harmony export */   "multiextent": () => (/* binding */ MultiExtent),
/* harmony export */   "multivalues": () => (/* binding */ MultiValues),
/* harmony export */   "params": () => (/* binding */ Params),
/* harmony export */   "pivot": () => (/* binding */ Pivot),
/* harmony export */   "prefacet": () => (/* binding */ PreFacet),
/* harmony export */   "project": () => (/* binding */ Project),
/* harmony export */   "proxy": () => (/* binding */ Proxy),
/* harmony export */   "quantile": () => (/* binding */ Quantile),
/* harmony export */   "relay": () => (/* binding */ Relay),
/* harmony export */   "sample": () => (/* binding */ Sample),
/* harmony export */   "sequence": () => (/* binding */ Sequence),
/* harmony export */   "sieve": () => (/* binding */ Sieve),
/* harmony export */   "subflow": () => (/* binding */ Subflow),
/* harmony export */   "timeunit": () => (/* binding */ TimeUnit),
/* harmony export */   "tupleindex": () => (/* binding */ TupleIndex),
/* harmony export */   "values": () => (/* binding */ Values),
/* harmony export */   "window": () => (/* binding */ Window)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/median.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/mean.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");






function multikey(f) {
  return x => {
    const n = f.length;
    let i = 1,
        k = String(f[0](x));

    for (; i < n; ++i) {
      k += '|' + f[i](x);
    }

    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function () {
    return '';
  } : fields.length === 1 ? fields[0] : multikey(fields);
}

function measureName(op, field, as) {
  return as || op + (!field ? '' : '_' + field);
}

const noop = () => {};

const base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
const AggregateOps = {
  values: {
    init: m => m.cell.store = true,
    value: m => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: m => m.cell.num
  },
  __count__: {
    value: m => m.missing + m.valid
  },
  missing: {
    value: m => m.missing
  },
  valid: {
    value: m => m.valid
  },
  sum: {
    init: m => m.sum = 0,
    value: m => m.sum,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: m => m.product = 1,
    value: m => m.valid ? m.product : undefined,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: m => m.mean = 0,
    value: m => m.valid ? m.mean : undefined,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: m => m.valid ? m.mean : undefined,
    req: ['mean'],
    idx: 1
  },
  variance: {
    init: m => m.dev = 0,
    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ['mean'],
    idx: 1
  },
  variancep: {
    value: m => m.valid > 1 ? m.dev / m.valid : undefined,
    req: ['variance'],
    idx: 2
  },
  stdev: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,
    req: ['variance'],
    idx: 2
  },
  stdevp: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,
    req: ['variance'],
    idx: 2
  },
  stderr: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,
    req: ['variance'],
    idx: 2
  },
  distinct: {
    value: m => m.cell.data.distinct(m.get),
    req: ['values'],
    idx: 3
  },
  ci0: {
    value: m => m.cell.data.ci0(m.get),
    req: ['values'],
    idx: 3
  },
  ci1: {
    value: m => m.cell.data.ci1(m.get),
    req: ['values'],
    idx: 3
  },
  median: {
    value: m => m.cell.data.q2(m.get),
    req: ['values'],
    idx: 3
  },
  q1: {
    value: m => m.cell.data.q1(m.get),
    req: ['values'],
    idx: 3
  },
  q3: {
    value: m => m.cell.data.q3(m.get),
    req: ['values'],
    idx: 3
  },
  min: {
    init: m => m.min = undefined,
    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === undefined) m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min) m.min = NaN;
    },
    req: ['values'],
    idx: 4
  },
  max: {
    init: m => m.max = undefined,
    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === undefined) m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max) m.max = NaN;
    },
    req: ['values'],
    idx: 4
  },
  argmin: {
    init: m => m.argmin = undefined,
    value: m => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t) => {
      if (v < m.min) m.argmin = t;
    },
    rem: (m, v) => {
      if (v <= m.min) m.argmin = undefined;
    },
    req: ['min', 'values'],
    idx: 3
  },
  argmax: {
    init: m => m.argmax = undefined,
    value: m => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t) => {
      if (v > m.max) m.argmax = t;
    },
    rem: (m, v) => {
      if (v >= m.max) m.argmax = undefined;
    },
    req: ['max', 'values'],
    idx: 3
  }
};
const ValidAggregateOps = Object.keys(AggregateOps);

function measure(key, value) {
  return out => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: key,
    out: out || key
  }, base_op, value);
}

ValidAggregateOps.forEach(key => {
  AggregateOps[key] = measure(key, AggregateOps[key]);
});
function createMeasure(op, name) {
  return AggregateOps[op](name);
}

function compareIndex(a, b) {
  return a.idx - b.idx;
}

function resolve(agg) {
  const map = {};
  agg.forEach(a => map[a.name] = a);

  const getreqs = a => {
    if (!a.req) return;
    a.req.forEach(key => {
      if (!map[key]) getreqs(map[key] = AggregateOps[key]());
    });
  };

  agg.forEach(getreqs);
  return Object.values(map).sort(compareIndex);
}

function init() {
  this.valid = 0;
  this.missing = 0;

  this._ops.forEach(op => op.init(this));
}

function add(v, t) {
  if (v == null || v === '') {
    ++this.missing;
    return;
  }

  if (v !== v) return;
  ++this.valid;

  this._ops.forEach(op => op.add(this, v, t));
}

function rem(v, t) {
  if (v == null || v === '') {
    --this.missing;
    return;
  }

  if (v !== v) return;
  --this.valid;

  this._ops.forEach(op => op.rem(this, v, t));
}

function set(t) {
  this._out.forEach(op => t[op.out] = op.value(this));

  return t;
}

function compileMeasures(agg, field) {
  const get = field || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
        ops = resolve(agg),
        out = agg.slice().sort(compareIndex);

  function ctr(cell) {
    this._ops = ops;
    this._out = out;
    this.cell = cell;
    this.init();
  }

  ctr.prototype.init = init;
  ctr.prototype.add = add;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get;
  ctr.fields = agg.map(op => op.out);
  return ctr;
}

function TupleStore(key) {
  this._key = key ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(key) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
  this.reset();
}
const prototype$1 = TupleStore.prototype;

prototype$1.reset = function () {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};

prototype$1.add = function (v) {
  this._add.push(v);
};

prototype$1.rem = function (v) {
  this._rem.push(v);
};

prototype$1.values = function () {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a = this._add,
        r = this._rem,
        k = this._key,
        n = a.length,
        m = r.length,
        x = Array(n - m),
        map = {};
  let i, j, v; // use unique key field to clear removed values

  for (i = 0; i < m; ++i) {
    map[k(r[i])] = 1;
  }

  for (i = 0, j = 0; i < n; ++i) {
    if (map[k(v = a[i])]) {
      map[k(v)] = 0;
    } else {
      x[j++] = v;
    }
  }

  this._rem = [];
  return this._add = x;
}; // memoizing statistics methods


prototype$1.distinct = function (get) {
  const v = this.values(),
        map = {};
  let n = v.length,
      count = 0,
      s;

  while (--n >= 0) {
    s = get(v[n]) + '';

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s)) {
      map[s] = 1;
      ++count;
    }
  }

  return count;
};

prototype$1.extent = function (get) {
  if (this._get !== get || !this._ext) {
    const v = this.values(),
          i = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex)(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;
  }

  return this._ext;
};

prototype$1.argmin = function (get) {
  return this.extent(get)[0] || {};
};

prototype$1.argmax = function (get) {
  return this.extent(get)[1] || {};
};

prototype$1.min = function (get) {
  const m = this.extent(get)[0];
  return m != null ? get(m) : undefined;
};

prototype$1.max = function (get) {
  const m = this.extent(get)[1];
  return m != null ? get(m) : undefined;
};

prototype$1.quartile = function (get) {
  if (this._get !== get || !this._q) {
    this._q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quartiles)(this.values(), get);
    this._get = get;
  }

  return this._q;
};

prototype$1.q1 = function (get) {
  return this.quartile(get)[0];
};

prototype$1.q2 = function (get) {
  return this.quartile(get)[1];
};

prototype$1.q3 = function (get) {
  return this.quartile(get)[2];
};

prototype$1.ci = function (get) {
  if (this._get !== get || !this._ci) {
    this._ci = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bootstrapCI)(this.values(), 1000, 0.05, get);
    this._get = get;
  }

  return this._ci;
};

prototype$1.ci0 = function (get) {
  return this.ci(get)[0];
};

prototype$1.ci1 = function (get) {
  return this.ci(get)[1];
};

/**
 * Group-by aggregation operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.
 * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.
 * @param {Array<string>} [params.as] - An array of output field names for aggregated values.
 * @param {boolean} [params.cross=false] - A flag indicating that the full
 *   cross-product of groupby values should be generated, including empty cells.
 *   If true, the drop parameter is ignored and empty cells are retained.
 * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.
 */

function Aggregate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this._adds = []; // array of added output tuples

  this._mods = []; // array of modified output tuples

  this._alen = 0; // number of active added tuples

  this._mlen = 0; // number of active modified tuples

  this._drop = true; // should empty aggregation cells be removed

  this._cross = false; // produce full cross-product of group-by values

  this._dims = []; // group-by dimension accessors

  this._dnames = []; // group-by dimension names

  this._measures = []; // collection of aggregation monoids

  this._countOnly = false; // flag indicating only count aggregation

  this._counts = null; // collection of count fields

  this._prev = null; // previous aggregation cells

  this._inputs = null; // array of dependent input tuple field names

  this._outputs = null; // array of output tuple field names
}
Aggregate.Definition = {
  'type': 'Aggregate',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'drop',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'cross',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Aggregate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const aggr = this,
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          mod = _.modified();

    aggr.stamp = out.stamp;

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // Indicate output fields and return aggregate tuples.


    out.modifies(aggr._outputs); // Should empty cells be dropped?

    aggr._drop = _.drop !== false; // If domain cross-product requested, generate empty cells as needed
    // and ensure that empty cells are not dropped

    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }

    if (pulse.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }

    return aggr.changes(out);
  },

  cross() {
    const aggr = this,
          curr = aggr.value,
          dims = aggr._dnames,
          vals = dims.map(() => ({})),
          n = dims.length; // collect all group-by domain values

    function collect(cells) {
      let key, i, t, v;

      for (key in cells) {
        t = cells[key].tuple;

        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }

    collect(aggr._prev);
    collect(curr); // iterate over key cross-product, create cells as needed

    function generate(base, tuple, index) {
      const name = dims[index],
            v = vals[index++];

      for (const k in v) {
        const key = base ? base + '|' + k : k;
        tuple[name] = v[k];
        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);
      }
    }

    generate('', {}, 0);
  },

  init(_) {
    // initialize input and output fields
    const inputs = this._inputs = [],
          outputs = this._outputs = [],
          inputMap = {};

    function inputVisit(get) {
      const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(get)),
            n = fields.length;
      let i = 0,
          f;

      for (; i < n; ++i) {
        if (!inputMap[f = fields[i]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    } // initialize group-by dimensions


    this._dims = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.groupby);
    this._dnames = this._dims.map(d => {
      const dname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims); // initialize aggregate measures

    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null],
          ops = _.ops || ['count'],
          as = _.as || [],
          n = fields.length,
          map = {};
    let field, op, m, mname, outname, i;

    if (n !== ops.length) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unmatched number of fields and aggregate ops.');
    }

    for (i = 0; i < n; ++i) {
      field = fields[i];
      op = ops[i];

      if (field == null && op !== 'count') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
      }

      mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);

      if (op === 'count') {
        this._counts.push(outname);

        continue;
      }

      m = map[mname];

      if (!m) {
        inputVisit(field);
        m = map[mname] = [];
        m.field = field;

        this._measures.push(m);
      }

      if (op !== 'count') this._countOnly = false;
      m.push(createMeasure(op, outname));
    }

    this._measures = this._measures.map(m => compileMeasures(m, m.field));
    return {}; // aggregation cells (this.value)
  },

  // -- Cell Management -----
  cellkey: groupkey(),

  cell(key, t) {
    let cell = this.value[key];

    if (!cell) {
      cell = this.value[key] = this.newcell(key, t);
      this._adds[this._alen++] = cell;
    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._adds[this._alen++] = cell;
    } else if (cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._mods[this._mlen++] = cell;
    }

    return cell;
  },

  newcell(key, t) {
    const cell = {
      key: key,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key]),
      stamp: this.stamp,
      store: false
    };

    if (!this._countOnly) {
      const measures = this._measures,
            n = measures.length;
      cell.agg = Array(n);

      for (let i = 0; i < n; ++i) {
        cell.agg[i] = new measures[i](cell);
      }
    }

    if (cell.store) {
      cell.data = new TupleStore();
    }

    return cell;
  },

  newtuple(t, p) {
    const names = this._dnames,
          dims = this._dims,
          n = dims.length,
          x = {};

    for (let i = 0; i < n; ++i) {
      x[names[i]] = dims[i](t);
    }

    return p ? (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.replace)(p.tuple, x) : (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(x);
  },

  clean() {
    const cells = this.value;

    for (const key in cells) {
      if (cells[key].num === 0) {
        delete cells[key];
      }
    }
  },

  // -- Process Tuples -----
  add(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num += 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.add(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },

  rem(t) {
    const key = this.cellkey(t),
          cell = this.cell(key, t);
    cell.num -= 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.rem(t);
    const agg = cell.agg;

    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },

  celltuple(cell) {
    const tuple = cell.tuple,
          counts = this._counts; // consolidate stored values

    if (cell.store) {
      cell.data.values();
    } // update tuple properties


    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell.num;
    }

    if (!this._countOnly) {
      const agg = cell.agg;

      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }

    return tuple;
  },

  changes(out) {
    const adds = this._adds,
          mods = this._mods,
          prev = this._prev,
          drop = this._drop,
          add = out.add,
          rem = out.rem,
          mod = out.mod;
    let cell, key, i, n;
    if (prev) for (key in prev) {
      cell = prev[key];
      if (!drop || cell.num) rem.push(cell.tuple);
    }

    for (i = 0, n = this._alen; i < n; ++i) {
      add.push(this.celltuple(adds[i]));
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      cell = mods[i];
      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells

    this._prev = null;
    return out;
  }

});

const EPSILON$1 = 1e-14;
/**
 * Generates a binning function for discretizing data.
 * @constructor
 * @param {object} params - The parameters for this operator. The
 *   provided values should be valid options for the {@link bin} function.
 * @param {function(object): *} params.field - The data field to bin.
 */

function Bin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Bin.Definition = {
  'type': 'Bin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'anchor',
    'type': 'number'
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 20
  }, {
    'name': 'base',
    'type': 'number',
    'default': 10
  }, {
    'name': 'divide',
    'type': 'number',
    'array': true,
    'default': [5, 2]
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'span',
    'type': 'number'
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'steps',
    'type': 'number',
    'array': true
  }, {
    'name': 'minstep',
    'type': 'number',
    'default': 0
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'name',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['bin0', 'bin1']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Bin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const band = _.interval !== false,
          bins = this._bins(_),
          start = bins.start,
          step = bins.step,
          as = _.as || ['bin0', 'bin1'],
          b0 = as[0],
          b1 = as[1];

    let flag;

    if (_.modified()) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
    } else {
      flag = pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(_.field)) ? pulse.ADD_MOD : pulse.ADD;
    }

    pulse.visit(flag, band ? t => {
      const v = bins(t); // minimum bin value (inclusive)

      t[b0] = v; // maximum bin value (exclusive)
      // use convoluted math for better floating point agreement
      // see https://github.com/vega/vega/issues/830
      // infinite values propagate through this formula! #2227

      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : t => t[b0] = bins(t));
    return pulse.modifies(band ? as : b0);
  },

  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }

    const field = _.field,
          bins = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bin)(_),
          step = bins.step;
    let start = bins.start,
        stop = start + Math.ceil((bins.stop - start) / step) * step,
        a,
        d;

    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop += d;
    }

    const f = function (t) {
      let v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));
      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };

    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(f, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field), _.name || 'bin_' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field));
  }

});

function SortedList (idFunc, source, input) {
  const $ = idFunc;
  let data = source || [],
      add = input || [],
      rem = {},
      cnt = 0;
  return {
    add: t => add.push(t),
    remove: t => rem[$(t)] = ++cnt,
    size: () => data.length,
    data: (compare, resort) => {
      if (cnt) {
        data = data.filter(t => !rem[$(t)]);
        rem = {};
        cnt = 0;
      }

      if (resort && compare) {
        data.sort(compare);
      }

      if (add.length) {
        data = compare ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.merge)(compare, data, add.sort(compare)) : data.concat(add);
        add = [];
      }

      return data;
    }
  };
}

/**
 * Collects all data tuples that pass through this operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for additionally sorting the collected tuples.
 */

function Collect(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Collect.Definition = {
  'type': 'Collect',
  'metadata': {
    'source': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Collect, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          list = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid, this.value, out.materialize(out.ADD).add),
          sort = _.sort,
          mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(sort), mod); // propagate tree root if defined

    if (pulse.source && pulse.source.root) {
      this.value.root = pulse.source.root;
    }

    return out;
  }

});

/**
 * Generates a comparator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string|function>} params.fields - The fields to compare.
 * @param {Array<string>} [params.orders] - The sort orders.
 *   Each entry should be one of "ascending" (default) or "descending".
 */

function Compare(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$5, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Compare, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$5(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(_.fields, _.orders);
}

/**
 * Count regexp-defined pattern occurrences in a text field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the text field.
 * @param {string} [params.pattern] - RegExp string defining the text pattern.
 * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.
 * @param {string} [params.stopwords] - RegExp string of words to ignore.
 */

function CountPattern(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
CountPattern.Definition = {
  'type': 'CountPattern',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'case',
    'type': 'enum',
    'values': ['upper', 'lower', 'mixed'],
    'default': 'mixed'
  }, {
    'name': 'pattern',
    'type': 'string',
    'default': '[\\w"]+'
  }, {
    'name': 'stopwords',
    'type': 'string',
    'default': ''
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['text', 'count']
  }]
};

function tokenize(text, tcase, match) {
  switch (tcase) {
    case 'upper':
      text = text.toUpperCase();
      break;

    case 'lower':
      text = text.toLowerCase();
      break;
  }

  return text.match(match);
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CountPattern, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const process = update => tuple => {
      var tokens = tokenize(get(tuple), _.case, match) || [],
          t;

      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop.test(t = tokens[i])) update(t);
      }
    };

    const init = this._parameterCheck(_, pulse),
          counts = this._counts,
          match = this._match,
          stop = this._stop,
          get = _.field,
          as = _.as || ['text', 'count'],
          add = process(t => counts[t] = 1 + (counts[t] || 0)),
          rem = process(t => counts[t] -= 1);

    if (init) {
      pulse.visit(pulse.SOURCE, add);
    } else {
      pulse.visit(pulse.ADD, add);
      pulse.visit(pulse.REM, rem);
    }

    return this._finish(pulse, as); // generate output tuples
  },

  _parameterCheck(_, pulse) {
    let init = false;

    if (_.modified('stopwords') || !this._stop) {
      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');
      init = true;
    }

    if (_.modified('pattern') || !this._match) {
      this._match = new RegExp(_.pattern || '[\\w\']+', 'g');
      init = true;
    }

    if (_.modified('field') || pulse.modified(_.field.fields)) {
      init = true;
    }

    if (init) this._counts = {};
    return init;
  },

  _finish(pulse, as) {
    const counts = this._counts,
          tuples = this._tuples || (this._tuples = {}),
          text = as[0],
          count = as[1],
          out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    let w, t, c;

    for (w in counts) {
      t = tuples[w];
      c = counts[w] || 0;

      if (!t && c) {
        tuples[w] = t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({});
        t[text] = w;
        t[count] = c;
        out.add.push(t);
      } else if (c === 0) {
        if (t) out.rem.push(t);
        counts[w] = null;
        tuples[w] = null;
      } else if (t[count] !== c) {
        t[count] = c;
        out.mod.push(t);
      }
    }

    return out.modifies(as);
  }

});

/**
 * Perform a cross-product of a tuple stream with itself.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object):boolean} [params.filter] - An optional filter
 *   function for selectively including tuples in the cross product.
 * @param {Array<string>} [params.as] - The names of the output fields.
 */

function Cross(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Cross.Definition = {
  'type': 'Cross',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'filter',
    'type': 'expr'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['a', 'b']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Cross, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          as = _.as || ['a', 'b'],
          a = as[0],
          b = as[1],
          reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');

    let data = this.value;

    if (reset) {
      if (data) out.rem = data;
      data = pulse.materialize(pulse.SOURCE).source;
      out.add = this.value = cross(data, a, b, _.filter || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy);
    } else {
      out.mod = data;
    }

    out.source = this.value;
    return out.modifies(as);
  }

});

function cross(input, a, b, filter) {
  var data = [],
      t = {},
      n = input.length,
      i = 0,
      j,
      left;

  for (; i < n; ++i) {
    t[a] = left = input[i];

    for (j = 0; j < n; ++j) {
      t[b] = input[j];

      if (filter(t)) {
        data.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        t = {};
        t[a] = left;
      }
    }
  }

  return data;
}

const Distributions = {
  kde: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE,
  mixture: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomMixture,
  normal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomNormal,
  lognormal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomLogNormal,
  uniform: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomUniform
};
const DISTRIBUTIONS = 'distributions',
      FUNCTION = 'function',
      FIELD = 'field';
/**
 * Parse a parameter object for a probability distribution.
 * @param {object} def - The distribution parameter object.
 * @param {function():Array<object>} - A method for requesting
 *   source data. Used for distributions (such as KDE) that
 *   require sample data points. This method will only be
 *   invoked if the 'from' parameter for a target data source
 *   is not provided. Typically this method returns backing
 *   source data for a Pulse object.
 * @return {object} - The output distribution object.
 */

function parse(def, data) {
  const func = def[FUNCTION];

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(Distributions, func)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown distribution function: ' + func);
  }

  const d = Distributions[func]();

  for (const name in def) {
    // if data field, extract values
    if (name === FIELD) {
      d.data((def.from || data()).map(def[name]));
    } // if distribution mixture, recurse to parse each definition
    else if (name === DISTRIBUTIONS) {
        d[name](def[name].map(_ => parse(_, data)));
      } // otherwise, simply set the parameter
      else if (typeof d[name] === FUNCTION) {
          d[name](def[name]);
        }
  }

  return d;
}

/**
 * Grid sample points for a probability density. Given a distribution and
 * a sampling extent, will generate points suitable for plotting either
 * PDF (probability density function) or CDF (cumulative distribution
 * function) curves.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.distribution - The probability distribution. This
 *   is an object parameter dependent on the distribution type.
 * @param {string} [params.method='pdf'] - The distribution method to sample.
 *   One of 'pdf' or 'cdf'.
 * @param {Array<number>} [params.extent] - The [min, max] extent over which
 *   to sample the distribution. This argument is required in most cases, but
 *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method
 *   that returns numerical sample points from which the extent can be deduced.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function Density(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const distributions = [{
  'key': {
    'function': 'normal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'lognormal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'uniform'
  },
  'params': [{
    'name': 'min',
    'type': 'number',
    'default': 0
  }, {
    'name': 'max',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'kde'
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'from',
    'type': 'data'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }]
}];
const mixture = {
  'key': {
    'function': 'mixture'
  },
  'params': [{
    'name': 'distributions',
    'type': 'param',
    'array': true,
    'params': distributions
  }, {
    'name': 'weights',
    'type': 'number',
    'array': true
  }]
};
Density.Definition = {
  'type': 'Density',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'pdf',
    'values': ['pdf', 'cdf']
  }, {
    'name': 'distribution',
    'type': 'param',
    'params': distributions.concat(mixture)
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Density, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const dist = parse(_.distribution, source(pulse)),
            minsteps = _.steps || _.minsteps || 25,
            maxsteps = _.steps || _.maxsteps || 200;
      let method = _.method || 'pdf';

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (!_.extent && !dist.data) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing density extent parameter.');
      }

      method = dist[method];
      const as = _.as || ['value', 'density'],
            domain = _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(dist.data()),
            values = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(method, domain, minsteps, maxsteps).map(v => {
        const tuple = {};
        tuple[as[0]] = v[0];
        tuple[as[1]] = v[1];
        return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(tuple);
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

function source(pulse) {
  return () => pulse.materialize(pulse.SOURCE).source;
}

function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(f));
}
function partition$1(data, groupby, field) {
  const groups = [],
        get = f => f(t);

  let map, i, n, t, k, g; // partition data points into groups

  if (groupby == null) {
    groups.push(data.map(field));
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];

      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }

      g.push(field(t));
    }
  }

  return groups;
}

const Output = 'bin';
/**
 * Dot density binning for dot plot construction.
 * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
 * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to bin.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.step] - The step size (bin width) within which dots should be
 *   stacked. Defaults to 1/30 of the extent of the data *field*.
 * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density
 *   stacks should be smoothed to reduce variance.
 */

function DotBin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
DotBin.Definition = {
  'type': 'DotBin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': Output
  }]
};

const autostep = (data, field) => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(data, field)) / 30;

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(DotBin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !(_.modified() || pulse.changed())) {
      return pulse; // early exit
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(pulse.source, _.groupby, vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
          smooth = _.smooth || false,
          field = _.field,
          step = _.step || autostep(source, field),
          sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)((a, b) => field(a) - field(b)),
          as = _.as || Output,
          n = groups.length; // compute dotplot bins per group

    let min = Infinity,
        max = -Infinity,
        i = 0,
        j;

    for (; i < n; ++i) {
      const g = groups[i].sort(sort);
      j = -1;

      for (const v of (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.dotbin)(g, step, smooth, field)) {
        if (v < min) min = v;
        if (v > max) max = v;
        g[++j][as] = v;
      }
    }

    this.value = {
      start: min,
      stop: max,
      step: step
    };
    return pulse.reflow(true).modifies(as);
  }

});

/**
 * Wraps an expression function with access to external parameters.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function} params.expr - The expression function. The
 *  function should accept both a datum and a parameter object.
 *  This operator's value will be a new function that wraps the
 *  expression function with access to this operator's parameters.
 */

function Expression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$4, params);
  this.modified(true);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Expression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$4(_) {
  const expr = _.expr;
  return this.value && !_.modified('expr') ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(datum => expr(datum, _), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(expr), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(expr));
}

/**
 * Computes extents (min/max) for a data field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field over which to compute extends.
 */

function Extent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [undefined, undefined], params);
}
Extent.Definition = {
  'type': 'Extent',
  'metadata': {},
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Extent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const extent = this.value,
          field = _.field,
          mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');

    let min = extent[0],
        max = extent[1];

    if (mod || min == null) {
      min = +Infinity;
      max = -Infinity;
    }

    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {
      const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));

      if (v != null) {
        // NaNs will fail all comparisons!
        if (v < min) min = v;
        if (v > max) max = v;
      }
    });

    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      let name = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      if (name) name = ` for field "${name}"`;
      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);
      min = max = undefined;
    }

    this.value = [min, max];
  }

});

/**
 * Provides a bridge between a parent transform and a target subflow that
 * consumes only a subset of the tuples that pass through the parent.
 * @constructor
 * @param {Pulse} pulse - A pulse to use as the value of this operator.
 * @param {Transform} parent - The parent transform (typically a Facet instance).
 */

function Subflow(pulse, parent) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, pulse);
  this.parent = parent;
  this.count = 0;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Subflow, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target) {
    this.detachSubflow = target.detachSubflow;
    this.targets().add(target);
    return target.source = this;
  },

  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },

  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },

  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },

  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse) {
    this.value.init(pulse, pulse.NO_SOURCE);
  },

  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    // assert: this.value.stamp === pulse.stamp
    return this.value;
  }

});

/**
 * Facets a dataflow into a set of subflows based on a key.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): *} params.key - The key field to facet by.
 */

function Facet(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._keys = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(); // cache previously calculated key values
  // keep track of active subflows, use as targets array for listeners
  // this allows us to limit propagation to only updated subflows

  const a = this._targets = [];
  a.active = 0;

  a.forEach = f => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Facet, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },

  // parent argument provided by PreFacet subclass
  subflow(key, flow, pulse, parent) {
    const flows = this.value;
    let sf = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(flows, key) && flows[key],
        df,
        p;

    if (!sf) {
      p = parent || (p = this._group[key]) && p.tuple;
      df = pulse.dataflow;
      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key, p));
      flows[key] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse.stamp) {
      sf.init(pulse);
      this.activate(sf);
    }

    return sf;
  },

  clean() {
    const flows = this.value;
    let detached = 0;

    for (const key in flows) {
      if (flows[key].count === 0) {
        const detach = flows[key].detachSubflow;
        if (detach) detach();
        delete flows[key];
        ++detached;
      }
    } // remove inactive targets from the active targets array


    if (detached) {
      const active = this._targets.filter(sf => sf && sf.count > 0);

      this.initTargets(active);
    }
  },

  initTargets(act) {
    const a = this._targets,
          n = a.length,
          m = act ? act.length : 0;
    let i = 0;

    for (; i < m; ++i) {
      a[i] = act[i];
    }

    for (; i < n && a[i] != null; ++i) {
      a[i] = null; // ensure old flows can be garbage collected
    }

    a.active = m;
  },

  transform(_, pulse) {
    const df = pulse.dataflow,
          key = _.key,
          flow = _.subflow,
          cache = this._keys,
          rekey = _.modified('key'),
          subflow = key => this.subflow(key, flow, pulse);

    this._group = _.group || {};
    this.initTargets(); // reset list of active subflows

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            k = cache.get(id);

      if (k !== undefined) {
        cache.delete(id);
        subflow(k).rem(t);
      }
    });
    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), k);
      subflow(k).add(t);
    });

    if (rekey || pulse.modified(key.fields)) {
      pulse.visit(pulse.MOD, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse.changed(pulse.MOD)) {
      pulse.visit(pulse.MOD, t => {
        subflow(cache.get((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t))).mod(t);
      });
    }

    if (rekey) {
      pulse.visit(pulse.REFLOW, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
              k0 = cache.get(id),
              k1 = key(t);

        if (k0 !== k1) {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }

    if (pulse.clean()) {
      df.runAfter(() => {
        this.clean();
        cache.clean();
      });
    } else if (cache.empty > df.cleanThreshold) {
      df.runAfter(cache.clean);
    }

    return pulse;
  }

});

/**
 * Generates one or more field accessor functions.
 * If the 'name' parameter is an array, an array of field accessors
 * will be created and the 'as' parameter will be ignored.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.name - The field name(s) to access.
 * @param {string} params.as - The accessor function name.
 */

function Field(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$3, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Field, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$3(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_.name) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.name).map(f => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f)) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.name, _.as);
}

/**
 * Filters data tuples according to a predicate function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The predicate expression function
 *   that determines a tuple's filter status. Truthy values pass the filter.
 */

function Filter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
Filter.Definition = {
  'type': 'Filter',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Filter, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          cache = this.value,
          // cache ids of filtered tuples
    output = pulse.fork(),
          add = output.add,
          rem = output.rem,
          mod = output.mod,
          test = _.expr;
    let isMod = true;
    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      if (!cache.has(id)) rem.push(t);else cache.delete(id);
    });
    pulse.visit(pulse.ADD, t => {
      if (test(t, _)) add.push(t);else cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), 1);
    });

    function revisit(t) {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
            b = test(t, _),
            s = cache.get(id);

      if (b && s) {
        cache.delete(id);
        add.push(t);
      } else if (!b && !s) {
        cache.set(id, 1);
        rem.push(t);
      } else if (isMod && b && !s) {
        mod.push(t);
      }
    }

    pulse.visit(pulse.MOD, revisit);

    if (_.modified()) {
      isMod = false;
      pulse.visit(pulse.REFLOW, revisit);
    }

    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);
    return output;
  }

});

/**
 * Flattens array-typed field values into new data objects.
 * If multiple fields are specified, they are treated as parallel arrays,
 * with output values included for each matching index (or null if missing).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of field
 *   accessors for the tuple fields that should be flattened.
 * @param {string} [params.index] - Optional output field name for index
 *   value. If unspecified, no index field is included in the output.
 * @param {Array<string>} [params.as] - Output field names for flattened
 *   array fields. Any unspecified fields will use the field name provided
 *   by the fields accessors.
 */

function Flatten(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Flatten.Definition = {
  'type': 'Flatten',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'index',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Flatten, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(fields, _.as || []),
          index = _.index || null,
          m = as.length; // remove any previous results

    out.rem = this.value; // generate flattened tuples

    pulse.visit(pulse.SOURCE, t => {
      const arrays = fields.map(f => f(t)),
            maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0,
          j,
          d,
          v;

      for (; i < maxlen; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);

        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }

        if (index) {
          d[index] = i;
        }

        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index) out.modifies(index);
    return out.modifies(as);
  }

});

/**
 * Folds one more tuple fields into multiple tuples in which the field
 * name and values are available under new 'key' and 'value' fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.fields - An array of field accessors
 *   for the tuple fields that should be folded.
 * @param {Array<string>} [params.as] - Output field names for folded key
 *   and value fields, defaults to ['key', 'value'].
 */

function Fold(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Fold.Definition = {
  'type': 'Fold',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['key', 'value']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Fold, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          fnames = fields.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          as = _.as || ['key', 'value'],
          k = as[0],
          v = as[1],
          n = fields.length;
    out.rem = this.value;
    pulse.visit(pulse.SOURCE, t => {
      for (let i = 0, d; i < n; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }

});

/**
 * Invokes a function for each data tuple and saves the results as a new field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The formula function to invoke for each tuple.
 * @param {string} params.as - The field name under which to save the result.
 * @param {boolean} [params.initonly=false] - If true, the formula is applied to
 *   added tuples only, and does not update in response to modifications.
 */

function Formula(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Formula.Definition = {
  'type': 'Formula',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'required': true
  }, {
    'name': 'initonly',
    'type': 'boolean'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Formula, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const func = _.expr,
          as = _.as,
          mod = _.modified(),
          flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;

    if (mod) {
      // parameters updated, need to reflow
      pulse = pulse.materialize().reflow(true);
    }

    if (!_.initonly) {
      pulse.modifies(as);
    }

    return pulse.visit(flag, t => t[as] = func(t, _));
  }

});

/**
 * Generates data tuples using a provided generator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Parameters): object} params.generator - A tuple generator
 *   function. This function is given the operator parameters as input.
 *   Changes to any additional parameters will not trigger re-calculation
 *   of previously generated tuples. Only future tuples are affected.
 * @param {number} params.size - The number of tuples to produce.
 */

function Generate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Generate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
          gen = _.generator;
    let data = this.value,
        num = _.size - data.length,
        add,
        rem,
        t;

    if (num > 0) {
      // need more tuples, generate and add
      for (add = []; --num >= 0;) {
        add.push(t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(gen(_)));
        data.push(t);
      }

      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;
    } else {
      // need fewer tuples, remove
      rem = data.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;
      data = data.slice(-num);
    }

    out.source = this.value = data;
    return out;
  }

});

const Methods = {
  value: 'value',
  median: d3_array__WEBPACK_IMPORTED_MODULE_4__.default,
  mean: d3_array__WEBPACK_IMPORTED_MODULE_5__.default,
  min: d3_array__WEBPACK_IMPORTED_MODULE_6__.default,
  max: d3_array__WEBPACK_IMPORTED_MODULE_7__.default
};
const Empty = [];
/**
 * Impute missing values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to impute.
 * @param {Array<function(object): *>} [params.groupby] - An array of
 *   accessors to determine series within which to perform imputation.
 * @param {function(object): *} params.key - An accessor for a key value.
 *   Each key value should be unique within a group. New tuples will be
 *   imputed for any key values that are not found within a group.
 * @param {Array<*>} [params.keyvals] - Optional array of required key
 *   values. New tuples will be imputed for any key values that are not
 *   found within a group. In addition, these values will be automatically
 *   augmented with the key values observed in the input data.
 * @param {string} [method='value'] - The imputation method to use. One of
 *   'value', 'mean', 'median', 'max', 'min'.
 * @param {*} [value=0] - The constant value to use for imputation
 *   when using method 'value'.
 */

function Impute(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Impute.Definition = {
  'type': 'Impute',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'keyvals',
    'array': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'value',
    'values': ['value', 'mean', 'median', 'max', 'min']
  }, {
    'name': 'value',
    'default': 0
  }]
};

function getValue(_) {
  var m = _.method || Methods.value,
      v;

  if (Methods[m] == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized imputation method: ' + m);
  } else if (m === Methods.value) {
    v = _.value !== undefined ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}

function getField(_) {
  const f = _.field;
  return t => t ? f(t) : NaN;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Impute, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
        impute = getValue(_),
        field = getField(_),
        fName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.field),
        kName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.key),
        gNames = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
        groups = partition(pulse.source, _.groupby, _.key, _.keyvals),
        curr = [],
        prev = this.value,
        m = groups.domain.length,
        group,
        value,
        gVals,
        kVal,
        g,
        i,
        j,
        l,
        n,
        t;

    for (g = 0, l = groups.length; g < l; ++g) {
      group = groups[g];
      gVals = group.values;
      value = NaN; // add tuples for missing values

      for (j = 0; j < m; ++j) {
        if (group[j] != null) continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };

        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];

        t[kName] = kVal;
        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;
        curr.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    } // update pulse with imputed tuples


    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }

});

function partition(data, groupby, key, keyvals) {
  var get = f => f(t),
      groups = [],
      domain = keyvals ? keyvals.slice() : [],
      kMap = {},
      gMap = {},
      gVals,
      gKey,
      group,
      i,
      j,
      k,
      n,
      t;

  domain.forEach((k, i) => kMap[k] = i + 1);

  for (i = 0, n = data.length; i < n; ++i) {
    t = data[i];
    k = key(t);
    j = kMap[k] || (kMap[k] = domain.push(k));
    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';

    if (!(group = gMap[gKey])) {
      group = gMap[gKey] = [];
      groups.push(group);
      group.values = gVals;
    }

    group[j - 1] = t;
  }

  groups.domain = domain;
  return groups;
}

/**
 * Extend input tuples with aggregate values.
 * Calcuates aggregate values and joins them with the input stream.
 * @constructor
 */

function JoinAggregate(params) {
  Aggregate.call(this, params);
}
JoinAggregate.Definition = {
  'type': 'JoinAggregate',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(JoinAggregate, Aggregate, {
  transform(_, pulse) {
    const aggr = this,
          mod = _.modified();

    let cells; // process all input tuples to calculate aggregates

    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    } // update aggregation cells


    aggr.changes(); // write aggregate values to input tuples

    pulse.visit(pulse.SOURCE, t => {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse.reflow(mod).modifies(this._outputs);
  },

  changes() {
    const adds = this._adds,
          mods = this._mods;
    let i, n;

    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null; // for garbage collection
    }

    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null; // for garbage collection
    }

    this._alen = this._mlen = 0; // reset list of active cells
  }

});

/**
 * Compute kernel density estimates (KDE) for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {function(object): *} params.field - An accessor for the data field
 *   to estimate.
 * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.
 *   If zero or unspecified, the bandwidth is automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.cumulative=false] - A boolean flag indicating if a
 *   density (false) or cumulative distribution (true) should be generated.
 * @param {Array<number>} [params.extent] - The domain extent over which to
 *   plot the density. If unspecified, the [min, max] data extent is used.
 * @param {string} [params.resolve='independent'] - Indicates how parameters for
 *   multiple densities should be resolved. If "independent" (the default), each
 *   density may have its own domain extent and dynamic number of curve sample
 *   steps. If "shared", the KDE transform will ensure that all densities are
 *   defined over a shared domain and curve steps, enabling stacking.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */

function KDE(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
KDE.Definition = {
  'type': 'KDE',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'cumulative',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(KDE, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);

    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
            groups = partition$1(source, _.groupby, _.field),
            names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
            bandwidth = _.bandwidth,
            method = _.cumulative ? 'cdf' : 'pdf',
            as = _.as || ['value', 'density'],
            values = [];
      let domain = _.extent,
          minsteps = _.steps || _.minsteps || 25,
          maxsteps = _.steps || _.maxsteps || 200;

      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }

      if (_.resolve === 'shared') {
        if (!domain) domain = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(source, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }

      groups.forEach(g => {
        const density = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE)(g, bandwidth)[method],
              scale = _.counts ? g.length : 1,
              local = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(g);
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(density, local, minsteps, maxsteps).forEach(v => {
          const t = {};

          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }

          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale;
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }

    return out;
  }

});

/**
 * Generates a key function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string>} params.fields - The field name(s) for the key function.
 * @param {boolean} params.flat - A boolean flag indicating if the field names
 *  should be treated as flat property names, side-stepping nested field
 *  lookups normally indicated by dot or bracket notation.
 */

function Key(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$2, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Key, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$2(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.fields, _.flat);
}

/**
 * Load and parse data from an external source. Marshalls parameter
 * values and then invokes the Dataflow request method.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.url - The URL to load from.
 * @param {object} params.format - The data format options.
 */

function Load(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this._pending = null;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Load, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow;

    if (this._pending) {
      // update state and return pulse
      return output(this, pulse, this._pending);
    }

    if (stop(_)) return pulse.StopPropagation;

    if (_.values) {
      // parse and ingest values, return output pulse
      return output(this, pulse, df.parse(_.values, _.format));
    } else if (_.async) {
      // return promise for non-blocking async loading
      const p = df.request(_.url, _.format).then(res => {
        this._pending = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data);
        return df => df.touch(this);
      });
      return {
        async: p
      };
    } else {
      // return promise for synchronous loading
      return df.request(_.url, _.format).then(res => output(this, pulse, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data)));
    }
  }

});

function stop(_) {
  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));
}

function output(op, pulse, data) {
  data.forEach(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest);
  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}

/**
 * Extend tuples by joining them with values from a lookup table.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Map} params.index - The lookup table map.
 * @param {Array<function(object): *} params.fields - The fields to lookup.
 * @param {Array<string>} params.as - Output field names for each lookup value.
 * @param {*} [params.default] - A default value to use if lookup fails.
 */

function Lookup(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
}
Lookup.Definition = {
  'type': 'Lookup',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'index',
    'type': 'index',
    'params': [{
      'name': 'from',
      'type': 'data',
      'required': true
    }, {
      'name': 'key',
      'type': 'field',
      'required': true
    }]
  }, {
    'name': 'values',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }, {
    'name': 'default',
    'default': null
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Lookup, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const keys = _.fields,
          index = _.index,
          values = _.values,
          defaultValue = _.default == null ? null : _.default,
          reset = _.modified(),
          n = keys.length;

    let flag = reset ? pulse.SOURCE : pulse.ADD,
        out = pulse,
        as = _.as,
        set,
        m,
        mods;

    if (values) {
      m = values.length;

      if (n > 1 && !as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multi-field lookup requires explicit "as" parameter.');
      }

      if (as && as.length !== n * m) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('The "as" parameter has too few output field names.');
      }

      as = as || values.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName);

      set = function (t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index.get(keys[i](t));
          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);
        }
      };
    } else {
      if (!as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing output field names.');
      }

      set = function (t) {
        for (var i = 0, v; i < n; ++i) {
          v = index.get(keys[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }

    if (reset) {
      out = pulse.reflow(true);
    } else {
      mods = keys.some(k => pulse.modified(k.fields));
      flag |= mods ? pulse.MOD : 0;
    }

    pulse.visit(flag, set);
    return out.modifies(as);
  }

});

/**
 * Computes global min/max extents over a collection of extents.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<number>>} params.extents - The input extents.
 */

function MultiExtent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$1, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiExtent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }

  const ext = _.extents,
        n = ext.length;
  let min = +Infinity,
      max = -Infinity,
      i,
      e;

  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min) min = e[0];
    if (e[1] > max) max = e[1];
  }

  return [min, max];
}

/**
 * Merge a collection of value arrays.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<*>>} params.values - The input value arrrays.
 */

function MultiValues(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiValues, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);

function update(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);
}

/**
 * Operator whose value is simply its parameter hash. This operator is
 * useful for enabling reactive updates to values of nested objects.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */

function Params(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Params, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.modified(_.modified());
    this.value = _;
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples
  }

});

/**
 * Aggregate and pivot selected field values to become new fields.
 * This operator is useful to construction cross-tabulations.
 * @constructor
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *  to groupby. These fields act just like groupby fields of an Aggregate transform.
 * @param {function(object): *} params.field - The field to pivot on. The unique
 *  values of this field become new field names in the output stream.
 * @param {function(object): *} params.value - The field to populate pivoted fields.
 *  The aggregate values of this field become the values of the new pivoted fields.
 * @param {string} [params.op] - The aggregation operation for the value field,
 *  applied per cell in the output stream. The default is "sum".
 * @param {number} [params.limit] - An optional parameter indicating the maximum
 *  number of pivoted fields to generate. The pivoted field names are sorted in
 *  ascending order prior to enforcing the limit.
 */

function Pivot(params) {
  Aggregate.call(this, params);
}
Pivot.Definition = {
  'type': 'Pivot',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'value',
    'type': 'field',
    'required': true
  }, {
    'name': 'op',
    'type': 'enum',
    'values': ValidAggregateOps,
    'default': 'sum'
  }, {
    'name': 'limit',
    'type': 'number',
    'default': 0
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,

  transform(_, pulse) {
    return this._transform(aggregateParams(_, pulse), pulse);
  }

}); // Shoehorn a pivot transform into an aggregate transform!
// First collect all unique pivot field values.
// Then generate aggregate fields for each output pivot field.

function aggregateParams(_, pulse) {
  const key = _.field,
        value = _.value,
        op = (_.op === 'count' ? '__count__' : _.op) || 'sum',
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(key).concat((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(value)),
        keys = pivotKeys(key, _.limit || 0, pulse); // if data stream content changes, pivot fields may change
  // flag parameter modification to ensure re-initialization

  if (pulse.changed()) _.set('__pivot__', null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys.map(() => op),
    fields: keys.map(k => get(k, key, value, fields)),
    as: keys.map(k => k + ''),
    modified: _.modified.bind(_)
  };
} // Generate aggregate field accessor.
// Output NaN for non-existent values; aggregator will ignore!


function get(k, key, value, fields) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(d => key(d) === k ? value(d) : NaN, fields, k + '');
} // Collect (and optionally limit) all unique pivot values.


function pivotKeys(key, limit, pulse) {
  const map = {},
        list = [];
  pulse.visit(pulse.SOURCE, t => {
    const k = key(t);

    if (!map[k]) {
      map[k] = 1;
      list.push(k);
    }
  });
  list.sort(vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending);
  return limit ? list.slice(0, limit) : list;
}

/**
 * Partitions pre-faceted data into tuple subflows.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): Array<object>} params.field - The field
 *   accessor for an array of subflow tuple objects.
 */

function PreFacet(params) {
  Facet.call(this, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(PreFacet, Facet, {
  transform(_, pulse) {
    const flow = _.subflow,
          field = _.field,
          subflow = t => this.subflow((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), flow, pulse, t);

    if (_.modified('field') || field && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('PreFacet does not support field modification.');
    }

    this.initTargets(); // reset list of active subflows

    if (field) {
      pulse.visit(pulse.MOD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.mod(_));
      });
      pulse.visit(pulse.ADD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.add((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(_)));
      });
      pulse.visit(pulse.REM, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.rem(_));
      });
    } else {
      pulse.visit(pulse.MOD, t => subflow(t).mod(t));
      pulse.visit(pulse.ADD, t => subflow(t).add(t));
      pulse.visit(pulse.REM, t => subflow(t).rem(t));
    }

    if (pulse.clean()) {
      pulse.runAfter(() => this.clean());
    }

    return pulse;
  }

});

/**
 * Performs a relational projection, copying selected fields from source
 * tuples to a new set of derived tuples.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *} params.fields - The fields to project,
 *   as an array of field accessors. If unspecified, all fields will be
 *   copied with names unchanged.
 * @param {Array<string>} [params.as] - Output field names for each projected
 *   field. Any unspecified fields will use the field name provided by
 *   the field accessor.
 */

function Project(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Project.Definition = {
  'type': 'Project',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Project, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          fields = _.fields,
          as = fieldNames(_.fields, _.as || []),
          derive = fields ? (s, t) => project(s, t, fields, as) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive;
    let lut;

    if (this.value) {
      lut = this.value;
    } else {
      pulse = pulse.addAll();
      lut = this.value = {};
    }

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      out.rem.push(lut[id]);
      lut[id] = null;
    });
    pulse.visit(pulse.ADD, t => {
      const dt = derive(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({}));
      lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
      out.add.push(dt);
    });
    pulse.visit(pulse.MOD, t => {
      out.mod.push(derive(t, lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]));
    });
    return out;
  }

});

function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }

  return t;
}

/**
 * Proxy the value of another operator as a pure signal value.
 * Ensures no tuples are propagated.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {*} params.value - The value to proxy, becomes the value of this operator.
 */

function Proxy(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Proxy, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = _.value;
    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Generates sample quantile values from an input data stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the data field
 *   over which to calculate quantile values.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {Array<number>} [params.probs] - An array of probabilities in
 *   the range (0, 1) for which to compute quantile values. If not specified,
 *   the *step* parameter will be used.
 * @param {Array<number>} [params.step=0.01] - A probability step size for
 *   sampling quantile values. All values from one-half the step size up to
 *   1 (exclusive) will be sampled. This parameter is only used if the
 *   *quantiles* parameter is not provided.
 */

function Quantile(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Quantile.Definition = {
  'type': 'Quantile',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'probs',
    'type': 'number',
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 0.01
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['prob', 'value']
  }]
};
const EPSILON = 1e-14;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Quantile, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
          as = _.as || ['prob', 'value'];

    if (this.value && !_.modified() && !pulse.changed()) {
      out.source = this.value;
      return out;
    }

    const source = pulse.materialize(pulse.SOURCE).source,
          groups = partition$1(source, _.groupby, _.field),
          names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
          values = [],
          step = _.step || 0.01,
          p = _.probs || (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(step / 2, 1 - EPSILON, step),
          n = p.length;
    groups.forEach(g => {
      const q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quantiles)(g, p);

      for (let i = 0; i < n; ++i) {
        const t = {};

        for (let i = 0; i < names.length; ++i) {
          t[names[i]] = g.dims[i];
        }

        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values;
    return out;
  }

});

/**
 * Relays a data stream between data processing pipelines.
 * If the derive parameter is set, this transform will create derived
 * copies of observed tuples. This provides derived data streams in which
 * modifications to the tuples do not pollute an upstream data source.
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.derive=false] - Boolean flag indicating if
 *   the transform should make derived copies of incoming tuples.
 * @constructor
 */

function Relay(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Relay, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    let out, lut;

    if (this.value) {
      lut = this.value;
    } else {
      out = pulse = pulse.addAll();
      lut = this.value = {};
    }

    if (_.derive) {
      out = pulse.fork(pulse.NO_SOURCE);
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
        out.rem.push(lut[id]);
        lut[id] = null;
      });
      pulse.visit(pulse.ADD, t => {
        const dt = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
        out.add.push(dt);
      });
      pulse.visit(pulse.MOD, t => {
        const dt = lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)];

        for (const k in t) {
          dt[k] = t[k]; // down stream writes may overwrite re-derived tuples
          // conservatively mark all source fields as modified

          out.modifies(k);
        }

        out.mod.push(dt);
      });
    }

    return out;
  }

});

/**
 * Samples tuples passing through this operator.
 * Uses reservoir sampling to maintain a representative sample.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.size=1000] - The maximum number of samples.
 */

function Sample(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this.count = 0;
}
Sample.Definition = {
  'type': 'Sample',
  'metadata': {},
  'params': [{
    'name': 'size',
    'type': 'number',
    'default': 1000
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sample, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
          mod = _.modified('size'),
          num = _.size,
          map = this.value.reduce((m, t) => (m[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = 1, m), {});

    let res = this.value,
        cnt = this.count,
        cap = 0; // sample reservoir update function

    function update(t) {
      let p, idx;

      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.random)());

        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(p)]) out.rem.push(p); // eviction

          res[idx] = t;
        }
      }

      ++cnt;
    }

    if (pulse.rem.length) {
      // find all tuples that should be removed, add to output
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);

        if (map[id]) {
          map[id] = -1;
          out.rem.push(t);
        }

        --cnt;
      }); // filter removed tuples out of the sample reservoir

      res = res.filter(t => map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] !== -1);
    }

    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {
      // replenish sample if backing data source is available
      cap = cnt = res.length;
      pulse.visit(pulse.SOURCE, t => {
        // update, but skip previously sampled tuples
        if (!map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) update(t);
      });
      cap = -1;
    }

    if (mod && res.length > num) {
      const n = res.length - num;

      for (let i = 0; i < n; ++i) {
        map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(res[i])] = -1;
        out.rem.push(res[i]);
      }

      res = res.slice(n);
    }

    if (pulse.mod.length) {
      // propagate modified tuples in the sample reservoir
      pulse.visit(pulse.MOD, t => {
        if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) out.mod.push(t);
      });
    }

    if (pulse.add.length) {
      // update sample reservoir
      pulse.visit(pulse.ADD, update);
    }

    if (pulse.add.length || cap < 0) {
      // output newly added tuples
      out.add = res.filter(t => !map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]);
    }

    this.count = cnt;
    this.value = out.source = res;
    return out;
  }

});

/**
 * Generates data tuples for a specified sequence range of numbers.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} params.start - The first number in the sequence.
 * @param {number} params.stop - The last number (exclusive) in the sequence.
 * @param {number} [params.step=1] - The step size between numbers in the sequence.
 */

function Sequence(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Sequence.Definition = {
  'type': 'Sequence',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'start',
    'type': 'number',
    'required': true
  }, {
    'name': 'stop',
    'type': 'number',
    'required': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'data'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sequence, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) return;
    const out = pulse.materialize().fork(pulse.MOD),
          as = _.as || 'data';
    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;
    this.value = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__.default)(_.start, _.stop, _.step || 1).map(v => {
      const t = {};
      t[as] = v;
      return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t);
    });
    out.add = pulse.add.concat(this.value);
    return out;
  }

});

/**
 * Propagates a new pulse without any tuples so long as the input
 * pulse contains some added, removed or modified tuples.
 * @param {object} params - The parameters for this operator.
 * @constructor
 */

function Sieve(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sieve, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = pulse.source;
    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }

});

/**
 * Discretize dates to specific time units.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The data field containing date/time values.
 */

function TimeUnit(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const OUTPUT = ['unit0', 'unit1'];
TimeUnit.Definition = {
  'type': 'TimeUnit',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'units',
    'type': 'enum',
    'values': vega_time__WEBPACK_IMPORTED_MODULE_3__.TIME_UNITS,
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 40
  }, {
    'name': 'extent',
    'type': 'date',
    'array': true
  }, {
    'name': 'timezone',
    'type': 'enum',
    'default': 'local',
    'values': ['local', 'utc']
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': OUTPUT
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TimeUnit, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const field = _.field,
          band = _.interval !== false,
          utc = _.timezone === 'utc',
          floor = this._floor(_, pulse),
          offset = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcInterval : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeInterval)(floor.unit).offset,
          as = _.as || OUTPUT,
          u0 = as[0],
          u1 = as[1],
          step = floor.step;

    let min = floor.start || Infinity,
        max = floor.stop || -Infinity,
        flag = pulse.ADD;

    if (_.modified() || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
      min = Infinity;
      max = -Infinity;
    }

    pulse.visit(flag, t => {
      const v = field(t);
      let a, b;

      if (v == null) {
        t[u0] = null;
        if (band) t[u1] = null;
      } else {
        t[u0] = a = b = floor(v);
        if (band) t[u1] = b = offset(a, step);
        if (a < min) min = a;
        if (b > max) max = b;
      }
    });
    floor.start = min;
    floor.stop = max;
    return pulse.modifies(band ? as : u0);
  },

  _floor(_, pulse) {
    const utc = _.timezone === 'utc'; // get parameters

    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeBin)({
      extent: _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(pulse.materialize(pulse.SOURCE).source, _.field),
      maxbins: _.maxbins
    }); // check / standardize time units

    const tunits = (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeUnits)(units),
          prev = this.value || {},
          floor = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcFloor : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeFloor)(tunits, step);
    floor.unit = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(tunits);
    floor.units = tunits;
    floor.step = step;
    floor.start = prev.start;
    floor.stop = prev.stop;
    return this.value = floor;
  }

});

/**
 * An index that maps from unique, string-coerced, field values to tuples.
 * Assumes that the field serves as a unique key with no duplicate values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field accessor to index.
 */

function TupleIndex(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TupleIndex, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
          field = _.field,
          index = this.value,
          set = t => index.set(field(t), t);

    let mod = true;

    if (_.modified('field') || pulse.modified(field.fields)) {
      index.clear();
      pulse.visit(pulse.SOURCE, set);
    } else if (pulse.changed()) {
      pulse.visit(pulse.REM, t => index.delete(field(t)));
      pulse.visit(pulse.ADD, set);
    } else {
      mod = false;
    }

    this.modified(mod);
    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);
    return pulse.fork();
  }

});

/**
 * Extracts an array of values. Assumes the source data has already been
 * reduced as needed (e.g., by an upstream Aggregate transform).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The domain field to extract.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting the values. The comparator will be
 *   applied to backing tuples prior to value extraction.
 */

function Values(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Values, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);

    if (run) {
      this.value = (_.sort ? pulse.source.slice().sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort)) : pulse.source).map(_.field);
    }
  }

});

function WindowOp(op, field, param, as) {
  const fn = WindowOps[op](field, param);
  return {
    init: fn.init || vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    update: function (w, t) {
      t[as] = fn.next(w);
    }
  };
}
const WindowOps = {
  row_number: function () {
    return {
      next: w => w.index + 1
    };
  },
  rank: function () {
    let rank;
    return {
      init: () => rank = 1,
      next: w => {
        const i = w.index,
              data = w.data;
        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;
      }
    };
  },
  dense_rank: function () {
    let drank;
    return {
      init: () => drank = 1,
      next: w => {
        const i = w.index,
              d = w.data;
        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function () {
    const rank = WindowOps.rank(),
          next = rank.next;
    return {
      init: rank.init,
      next: w => (next(w) - 1) / (w.data.length - 1)
    };
  },
  cume_dist: function () {
    let cume;
    return {
      init: () => cume = 0,
      next: w => {
        const d = w.data,
              c = w.compare;
        let i = w.index;

        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;

          cume = i;
        }

        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function (field, num) {
    num = +num;
    if (!(num > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('ntile num must be greater than zero.');
    const cume = WindowOps.cume_dist(),
          next = cume.next;
    return {
      init: cume.init,
      next: w => Math.ceil(num * next(w))
    };
  },
  lag: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index - offset;
        return i >= 0 ? field(w.data[i]) : null;
      }
    };
  },
  lead: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index + offset,
              d = w.data;
        return i < d.length ? field(d[i]) : null;
      }
    };
  },
  first_value: function (field) {
    return {
      next: w => field(w.data[w.i0])
    };
  },
  last_value: function (field) {
    return {
      next: w => field(w.data[w.i1 - 1])
    };
  },
  nth_value: function (field, nth) {
    nth = +nth;
    if (!(nth > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('nth_value nth must be greater than zero.');
    return {
      next: w => {
        const i = w.i0 + (nth - 1);
        return i < w.i1 ? field(w.data[i]) : null;
      }
    };
  },
  prev_value: function (field) {
    let prev;
    return {
      init: () => prev = null,
      next: w => {
        const v = field(w.data[w.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function (field) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: w => {
        const d = w.data;
        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);
      }
    };
  }
};

function find(field, data, index) {
  for (let n = data.length; index < n; ++index) {
    const v = field(data[index]);
    if (v != null) return index;
  }

  return -1;
}

const ValidWindowOps = Object.keys(WindowOps);

function WindowState(_) {
  const ops = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.ops),
        fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.fields),
        params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.params),
        as = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.as),
        outputs = this.outputs = [],
        windows = this.windows = [],
        inputs = {},
        map = {},
        counts = [],
        measures = [];
  let countOnly = true;

  function visitInputs(f) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(f)).forEach(_ => inputs[_] = 1);
  }

  visitInputs(_.sort);
  ops.forEach((op, i) => {
    const field = fields[i],
          mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field),
          name = measureName(op, mname, as[i]);
    visitInputs(field);
    outputs.push(name); // Window operation

    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(WindowOps, op)) {
      windows.push(WindowOp(op, fields[i], params[i], name));
    } // Aggregate operation
    else {
        if (field == null && op !== 'count') {
          (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
        }

        if (op === 'count') {
          counts.push(name);
          return;
        }

        countOnly = false;
        let m = map[mname];

        if (!m) {
          m = map[mname] = [];
          m.field = field;
          measures.push(m);
        }

        m.push(createMeasure(op, name));
      }
  });

  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }

  this.inputs = Object.keys(inputs);
}
const prototype = WindowState.prototype;

prototype.init = function () {
  this.windows.forEach(_ => _.init());
  if (this.cell) this.cell.init();
};

prototype.update = function (w, t) {
  const cell = this.cell,
        wind = this.windows,
        data = w.data,
        m = wind && wind.length;
  let j;

  if (cell) {
    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);

    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);

    cell.set(t);
  }

  for (j = 0; j < m; ++j) wind[j].update(w, t);
};

function cell(measures, counts, countOnly) {
  measures = measures.map(m => compileMeasures(m, m.field));
  const cell = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };

  if (!countOnly) {
    var n = measures.length,
        a = cell.agg = Array(n),
        i = 0;

    for (; i < n; ++i) a[i] = new measures[i](cell);
  }

  if (cell.store) {
    var store = cell.data = new TupleStore();
  }

  cell.add = function (t) {
    cell.num += 1;
    if (countOnly) return;
    if (store) store.add(t);

    for (let i = 0; i < n; ++i) {
      a[i].add(a[i].get(t), t);
    }
  };

  cell.rem = function (t) {
    cell.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t);

    for (let i = 0; i < n; ++i) {
      a[i].rem(a[i].get(t), t);
    }
  };

  cell.set = function (t) {
    let i, n; // consolidate stored values

    if (store) store.values(); // update tuple properties

    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;

    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);
  };

  cell.init = function () {
    cell.num = 0;
    if (store) store.reset();

    for (let i = 0; i < n; ++i) a[i].init();
  };

  return cell;
}

/**
 * Perform window calculations and write results to the input stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.
 * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors
 *   for data fields to use as inputs to window operations.
 * @param {Array<*>} [params.params] - An array of parameter values for window operations.
 * @param {Array<string>} [params.as] - An array of output field names for window operations.
 * @param {Array<number>} [params.frame] - Window frame definition as two-element array.
 * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row
 *   number alone, ignoring peers with identical sort values. If false (default),
 *   the window boundaries will be adjusted to include peer values.
 */

function Window(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  'type': 'Window',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidWindowOps.concat(ValidAggregateOps)
  }, {
    'name': 'params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'frame',
    'type': 'number',
    'null': true,
    'array': true,
    'length': 2,
    'default': [null, 0]
  }, {
    'name': 'ignorePeers',
    'type': 'boolean',
    'default': false
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Window, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.stamp = pulse.stamp;

    const mod = _.modified(),
          cmp = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort),
          key = groupkey(_.groupby),
          group = t => this.group(key(t)); // initialize window state


    let state = this.state;

    if (!state || mod) {
      state = this.state = new WindowState(_);
    } // partition input tuples


    if (mod || pulse.modified(state.inputs)) {
      this.value = {};
      pulse.visit(pulse.SOURCE, t => group(t).add(t));
    } else {
      pulse.visit(pulse.REM, t => group(t).remove(t));
      pulse.visit(pulse.ADD, t => group(t).add(t));
    } // perform window calculations for each modified partition


    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }

    this._mlen = 0;
    this._mods = []; // TODO don't reflow everything?

    return pulse.reflow(mod).modifies(state.outputs);
  },

  group(key) {
    let group = this.value[key];

    if (!group) {
      group = this.value[key] = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid);
      group.stamp = -1;
    }

    if (group.stamp < this.stamp) {
      group.stamp = this.stamp;
      this._mods[this._mlen++] = group;
    }

    return group;
  }

});

function processPartition(list, state, cmp, _) {
  const sort = _.sort,
        range = sort && !_.ignorePeers,
        frame = _.frame || [null, 0],
        data = list.data(cmp),
        // use cmp for stable sort
  n = data.length,
        b = range ? (0,d3_array__WEBPACK_IMPORTED_MODULE_9__.default)(sort) : null,
        w = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: data,
    compare: sort || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(-1)
  };
  state.init();

  for (let i = 0; i < n; ++i) {
    setWindow(w, frame, i, n);
    if (range) adjustRange(w, b);
    state.update(w, data[i]);
  }
}

function setWindow(w, f, i, n) {
  w.p0 = w.i0;
  w.p1 = w.i1;
  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w.index = i;
} // if frame type is 'range', adjust window for peer values


function adjustRange(w, bisect) {
  const r0 = w.i0,
        r1 = w.i1 - 1,
        c = w.compare,
        d = w.data,
        n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);
}




/***/ }),

/***/ "./node_modules/vega-view-transforms/build/vega-view-transforms.module.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vega-view-transforms/build/vega-view-transforms.module.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bound": () => (/* binding */ Bound),
/* harmony export */   "identifier": () => (/* binding */ Identifier),
/* harmony export */   "mark": () => (/* binding */ Mark),
/* harmony export */   "overlap": () => (/* binding */ Overlap),
/* harmony export */   "render": () => (/* binding */ Render),
/* harmony export */   "viewlayout": () => (/* binding */ ViewLayout)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const TopLeft = 'top-left';
const TopRight = 'top-right';
const BottomLeft = 'bottom-left';
const BottomRight = 'bottom-right';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const X = 'x';
const Y = 'y';
const Group = 'group';
const AxisRole = 'axis';
const TitleRole = 'title';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const LegendRole = 'legend';
const RowHeader = 'row-header';
const RowFooter = 'row-footer';
const RowTitle = 'row-title';
const ColHeader = 'column-header';
const ColFooter = 'column-footer';
const ColTitle = 'column-title';
const Padding = 'padding';
const Symbols = 'symbol';
const Fit = 'fit';
const FitX = 'fit-x';
const FitY = 'fit-y';
const Pad = 'pad';
const None = 'none';
const All = 'all';
const Each = 'each';
const Flush = 'flush';
const Column = 'column';
const Row = 'row';

/**
 * Calculate bounding boxes for scenegraph items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - The scenegraph mark instance to bound.
 */

function Bound(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Bound, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow,
          mark = _.mark,
          type = mark.marktype,
          entry = vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Marks[type],
          bound = entry.bound;
    let markBounds = mark.bounds,
        rebound;

    if (entry.nested) {
      // multi-item marks have a single bounds instance
      if (mark.items.length) view.dirty(mark.items[0]);
      markBounds = boundItem(mark, bound);
      mark.items.forEach(item => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type === Group || _.modified()) {
      // operator parameters modified -> re-bound all items
      // updates group bounds in response to modified group content
      pulse.visit(pulse.MOD, item => view.dirty(item));
      markBounds.clear();
      mark.items.forEach(item => markBounds.union(boundItem(item, bound))); // force reflow for axes/legends/titles to propagate any layout changes

      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse.reflow();
      }
    } else {
      // incrementally update bounds, re-bound mark as needed
      rebound = pulse.changed(pulse.REM);
      pulse.visit(pulse.ADD, item => {
        markBounds.union(boundItem(item, bound));
      });
      pulse.visit(pulse.MOD, item => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound));
      });

      if (rebound) {
        markBounds.clear();
        mark.items.forEach(item => markBounds.union(item.bounds));
      }
    } // ensure mark bounds do not exceed any clipping region


    (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundClip)(mark);
    return pulse.modifies('bounds');
  }

});

function boundItem(item, bound, opt) {
  return bound(item.bounds.clear(), item, opt);
}

const COUNTER_NAME = ':vega_identifier:';
/**
 * Adds a unique identifier to all added tuples.
 * This transform creates a new signal that serves as an id counter.
 * As a result, the id counter is shared across all instances of this
 * transform, generating unique ids across multiple data streams. In
 * addition, this signal value can be included in a snapshot of the
 * dataflow state, enabling correct resumption of id allocation.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.as - The field name for the generated identifier.
 */

function Identifier(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, 0, params);
}
Identifier.Definition = {
  'type': 'Identifier',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'as',
    'type': 'string',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Identifier, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const counter = getCounter(pulse.dataflow),
          as = _.as;
    let id = counter.value;
    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);
    counter.set(this.value = id);
    return pulse;
  }

});

function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}

/**
 * Bind scenegraph items to a scenegraph mark instance.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.markdef - The mark definition for creating the mark.
 *   This is an object of legal scenegraph mark properties which *must* include
 *   the 'marktype' property.
 */

function Mark(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Mark, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let mark = this.value; // acquire mark on first invocation, bind context and group

    if (!mark) {
      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group) _.context.group = mark.group;
      mark.source = this.source; // point to upstream collector

      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    } // initialize entering items


    const Init = mark.marktype === Group ? vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.GroupItem : vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Item;
    pulse.visit(pulse.ADD, item => Init.call(item, mark)); // update clipping and/or interactive status

    if (_.modified('clip') || _.modified('interactive')) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true; // force scenegraph re-eval

      pulse.reflow();
    } // bind items array to scenegraph mark


    mark.items = pulse.source;
    return pulse;
  }

});

function lookup(_) {
  const g = _.groups,
        p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}

/**
 * Analyze items for overlap, changing opacity to hide items with
 * overlapping bounding boxes. This transform will preserve at least
 * two items (e.g., first and last) even if overlap persists.
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting items.
 * @param {object} [params.method] - The overlap removal method to apply.
 *   One of 'parity' (default, hide every other item until there is no
 *   more overlap) or 'greedy' (sequentially scan and hide and items that
 *   overlap with the last visible item).
 * @param {object} [params.boundScale] - A scale whose range should be used
 *   to bound the items. Items exceeding the bounds of the scale range
 *   will be treated as overlapping. If null or undefined, no bounds check
 *   will be applied.
 * @param {object} [params.boundOrient] - The orientation of the scale
 *   (top, bottom, left, or right) used to bound items. This parameter is
 *   ignored if boundScale is null or undefined.
 * @param {object} [params.boundTolerance] - The tolerance in pixels for
 *   bound inclusion testing (default 1). This specifies by how many pixels
 *   an item's bounds may exceed the scale range bounds and not be culled.
 * @constructor
 */

function Overlap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
const methods = {
  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);
  }
}; // compute bounding box intersection
// including padding pixels of separation

const intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);

const hasOverlap = (items, pad) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {
    if (intersect(a, b = items[i].bounds, pad)) return true;
  }
};

const hasBounds = item => {
  const b = item.bounds;
  return b.width() > 1 && b.height() > 1;
};

const boundTest = (scale, orient, tolerance) => {
  var range = scale.range(),
      b = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();

  if (orient === Top || orient === Bottom) {
    b.set(range[0], -Infinity, range[1], +Infinity);
  } else {
    b.set(-Infinity, range[0], +Infinity, range[1]);
  }

  b.expand(tolerance || 1);
  return item => b.encloses(item.bounds);
}; // reset all items to be fully opaque


const reset = source => {
  source.forEach(item => item.opacity = 1);
  return source;
}; // add all tuples to mod, fork pulse if parameters were modified
// fork prevents cross-stream tuple pollution (e.g., pulse from scale)


const reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');

(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Overlap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const reduce = methods[_.method] || methods.parity,
          sep = _.separation || 0;
    let source = pulse.materialize(pulse.SOURCE).source,
        items,
        test;
    if (!source || !source.length) return;

    if (!_.method) {
      // early exit if method is falsy
      if (_.modified('method')) {
        reset(source);
        pulse = reflow(pulse, _);
      }

      return pulse;
    } // skip labels with no content


    source = source.filter(hasBounds); // early exit, nothing to do

    if (!source.length) return;

    if (_.sort) {
      source = source.slice().sort(_.sort);
    }

    items = reset(source);
    pulse = reflow(pulse, _);

    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));

      if (items.length < 3 && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity) {
        if (items.length > 1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(items).opacity = 0;
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity = 1;
      }
    }

    if (_.boundScale && _.boundTolerance >= 0) {
      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source.forEach(item => {
        if (!test(item)) item.opacity = 0;
      });
    } // re-calculate mark bounds


    const bounds = items[0].mark.bounds.clear();
    source.forEach(item => {
      if (item.opacity) bounds.union(item.bounds);
    });
    return pulse;
  }

});

/**
 * Queue modified scenegraph items for rendering.
 * @constructor
 */

function Render(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Render, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;
    pulse.visit(pulse.ALL, item => view.dirty(item)); // set z-index dirty flag as needed

    if (pulse.fields && pulse.fields['zindex']) {
      const item = pulse.source && pulse.source[0];
      if (item) item.mark.zdirty = true;
    }
  }

});

const tempBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();
function set(item, property, value) {
  return item[property] === value ? 0 : (item[property] = value, 1);
}

function isYAxis(mark) {
  var orient = mark.items[0].orient;
  return orient === Left || orient === Right;
}

function axisIndices(datum) {
  let index = +datum.grid;
  return [datum.ticks ? index++ : -1, // ticks index
  datum.labels ? index++ : -1, // labels index
  index + +datum.domain // title index
  ];
}

function axisLayout(view, axis, width, height) {
  var item = axis.items[0],
      datum = item.datum,
      delta = item.translate != null ? item.translate : 0.5,
      orient = item.orient,
      indices = axisIndices(datum),
      range = item.range,
      offset = item.offset,
      position = item.position,
      minExtent = item.minExtent,
      maxExtent = item.maxExtent,
      title = datum.title && item.items[indices[2]].items[0],
      titlePadding = item.titlePadding,
      bounds = item.bounds,
      dl = title && (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title),
      x = 0,
      y = 0,
      i,
      s;
  tempBounds.clear().union(bounds);
  bounds.clear();
  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds); // position axis group and title

  switch (orient) {
    case Top:
      x = position || 0;
      y = -offset;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));
      bounds.add(0, -s).add(range, 0);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);
      break;

    case Left:
      x = -offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));
      bounds.add(-s, 0).add(0, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);
      break;

    case Right:
      x = width + offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));
      bounds.add(0, 0).add(s, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);
      break;

    case Bottom:
      x = position || 0;
      y = height + offset;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));
      bounds.add(0, 0).add(range, s);
      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);
      break;

    default:
      x = item.x;
      y = item.y;
  } // update bounds


  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.translate(x, y), item);

  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {
    item.bounds = tempBounds;
    view.dirty(item);
    item.bounds = bounds;
    view.dirty(item);
  }

  return item.mark.bounds.clear().union(bounds);
}

function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {
  const b = title.bounds;

  if (title.auto) {
    const v = sign * (offset + dl + pad);
    let dx = 0,
        dy = 0;
    view.dirty(title);
    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b.translate(-dx, -dy));
    view.dirty(title);
  }

  bounds.union(b);
}

const min = (a, b) => Math.floor(Math.min(a, b));

const max = (a, b) => Math.ceil(Math.max(a, b));

function gridLayoutGroups(group) {
  var groups = group.items,
      n = groups.length,
      i = 0,
      mark,
      items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  }; // layout axes, gather legends, collect bounds

  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;

    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;

        case RowHeader:
          views.rowheaders.push(...items);
          break;

        case RowFooter:
          views.rowfooters.push(...items);
          break;

        case ColHeader:
          views.colheaders.push(...items);
          break;

        case ColFooter:
          views.colfooters.push(...items);
          break;

        case RowTitle:
          views.rowtitle = items[0];
          break;

        case ColTitle:
          views.coltitle = items[0];
          break;

        default:
          views.marks.push(...items);
      }
    }
  }

  return views;
}

function bboxFlush(item) {
  return new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, item.width || 0, item.height || 0);
}

function bboxFull(item) {
  const b = item.bounds.clone();
  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));
}

function get(opt, key, d) {
  const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(opt) ? opt[key] : opt;
  return v != null ? v : d !== undefined ? d : 0;
}

function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}

function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty,
      bbox = opt.bounds === Flush ? bboxFlush : bboxFull,
      bounds = tempBounds.set(0, 0, 0, 0),
      alignCol = get(opt.align, Column),
      alignRow = get(opt.align, Row),
      padCol = get(opt.padding, Column),
      padRow = get(opt.padding, Row),
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      n = groups.length,
      xOffset = Array(n),
      xExtent = Array(ncols),
      xMax = 0,
      yOffset = Array(n),
      yExtent = Array(nrows),
      yMax = 0,
      dx = Array(n),
      dy = Array(n),
      boxes = Array(n),
      m,
      i,
      c,
      r,
      b,
      g,
      px,
      py,
      x,
      y,
      offset;

  for (i = 0; i < ncols; ++i) xExtent[i] = 0;

  for (i = 0; i < nrows; ++i) yExtent[i] = 0; // determine offsets for each group


  for (i = 0; i < n; ++i) {
    g = groups[i];
    b = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px = Math.ceil(b.x2));
    yMax = Math.max(yMax, py = Math.ceil(b.y2));
    xExtent[c] = Math.max(xExtent[c], px);
    yExtent[r] = Math.max(yExtent[r], py);
    xOffset[i] = padCol + offsetValue(b.x1);
    yOffset[i] = padRow + offsetValue(b.y1);
    if (dirty) view.dirty(groups[i]);
  } // set initial alignment offsets


  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  } // enforce column alignment constraints


  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset = 0, i = c; i < n; i += ncols) {
        if (offset < xOffset[i]) offset = xOffset[i];
      }

      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];
    }

    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  } // enforce row alignment constraints


  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {
        if (offset < yOffset[i]) offset = yOffset[i];
      }

      for (i = r * ncols; i < m; ++i) {
        yOffset[i] = offset + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset = 0, i = ncols; i < n; ++i) {
      if (offset < yOffset[i]) offset = yOffset[i];
    }

    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  } // perform horizontal grid layout


  for (x = 0, i = 0; i < n; ++i) {
    x = xOffset[i] + (i % ncols ? x : 0);
    dx[i] += x - groups[i].x;
  } // perform vertical grid layout


  for (c = 0; c < ncols; ++c) {
    for (y = 0, i = c; i < n; i += ncols) {
      y += yOffset[i];
      dy[i] += y - groups[i].y;
    }
  } // perform horizontal centering


  if (alignCol && get(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b = alignCol === All ? xMax : xExtent[i % ncols];
      x = b - boxes[i].x2 - groups[i].x - dx[i];
      if (x > 0) dx[i] += x / 2;
    }
  } // perform vertical centering


  if (alignRow && get(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y = b - boxes[i].y2 - groups[i].y - dy[i];
      if (y > 0) dy[i] += y / 2;
    }
  } // position grid relative to anchor


  for (i = 0; i < n; ++i) {
    bounds.union(boxes[i].translate(dx[i], dy[i]));
  }

  x = get(opt.anchor, X);
  y = get(opt.anchor, Y);

  switch (get(opt.anchor, Column)) {
    case End:
      x -= bounds.width();
      break;

    case Middle:
      x -= bounds.width() / 2;
  }

  switch (get(opt.anchor, Row)) {
    case End:
      y -= bounds.height();
      break;

    case Middle:
      y -= bounds.height() / 2;
  }

  x = Math.round(x);
  y = Math.round(y); // update mark positions, bounds, dirty

  bounds.clear();

  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }

  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x;
    g.y += dy[i] += y;
    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }

  return bounds;
}
function trellisLayout(view, group, opt) {
  var views = gridLayoutGroups(group),
      groups = views.marks,
      bbox = opt.bounds === Flush ? boundFlush : boundFull,
      off = opt.offset,
      ncols = opt.columns || groups.length,
      nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
      cells = nrows * ncols,
      x,
      y,
      x2,
      y2,
      anchor,
      band,
      offset; // -- initial grid layout

  const bounds = gridLayout(view, groups, opt);
  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid
  // -- layout grid headers and footers --
  // perform row header layout

  if (views.rowheaders) {
    band = get(opt.headerBand, Row, null);
    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);
  } // perform column header layout


  if (views.colheaders) {
    band = get(opt.headerBand, Column, null);
    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);
  } // perform row footer layout


  if (views.rowfooters) {
    band = get(opt.footerBand, Row, null);
    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);
  } // perform column footer layout


  if (views.colfooters) {
    band = get(opt.footerBand, Column, null);
    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);
  } // perform row title layout


  if (views.rowtitle) {
    anchor = get(opt.titleAnchor, Row);
    offset = get(off, 'rowTitle');
    offset = anchor === End ? x2 + offset : x - offset;
    band = get(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);
  } // perform column title layout


  if (views.coltitle) {
    anchor = get(opt.titleAnchor, Column);
    offset = get(off, 'columnTitle');
    offset = anchor === End ? y2 + offset : y - offset;
    band = get(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset, 1, bounds, band);
  }
}

function boundFlush(item, field) {
  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;
}

function boundFull(item, field) {
  return item.bounds[field];
}

function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {
  var n = groups.length,
      init = 0,
      edge = 0,
      i,
      j,
      k,
      m,
      b,
      h,
      g,
      x,
      y; // if no groups, early exit and return 0

  if (!n) return init; // compute margin

  for (i = start; i < n; i += stride) {
    if (groups[i]) init = agg(init, bound(groups[i], bf));
  } // if no headers, return margin calculation


  if (!headers.length) return init; // check if number of headers exceeds number of rows or columns

  if (headers.length > limit) {
    view.warn('Grid headers exceed limit: ' + limit);
    headers = headers.slice(0, limit);
  } // apply offset


  init += offset; // clear mark bounds for all headers

  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  } // layout each header


  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h = headers[j];
    b = h.mark.bounds; // search for nearest group to align to
    // necessary if table has empty cells

    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back); // assign coordinates and update bounds


    if (isX) {
      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());
      y = init;
    } else {
      x = init;
      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());
    }

    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));
    h.x = x;
    h.y = y;
    view.dirty(h); // update current edge of layout bounds

    edge = agg(edge, b[bf]);
  }

  return edge;
}

function layoutTitle(view, g, offset, isX, bounds, band) {
  if (!g) return;
  view.dirty(g); // compute title coordinates

  var x = offset,
      y = offset;
  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height()); // assign coordinates and update bounds

  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x;
  g.y = y; // queue title for redraw

  view.dirty(g);
}

function lookup$1(config, orient) {
  const opt = config[orient] || {};
  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;
} // if legends specify offset directly, use the maximum specified value


function offsets(legends, value) {
  let max = -Infinity;
  legends.forEach(item => {
    if (item.offset != null) max = Math.max(max, item.offset);
  });
  return max > -Infinity ? max : value;
}

function legendParams(g, orient, config, xb, yb, w, h) {
  const _ = lookup$1(config, orient),
        offset = offsets(g, _('offset', 0)),
        anchor = _('anchor', Start),
        mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;

  const p = {
    align: Each,
    bounds: _('bounds', Flush),
    columns: _('direction') === 'vertical' ? 1 : g.length,
    padding: _('margin', 8),
    center: _('center'),
    nodirty: true
  };

  switch (orient) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset,
        column: End,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;

    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset,
        row: End,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;

    case TopLeft:
      p.anchor = {
        x: offset,
        y: offset
      };
      break;

    case TopRight:
      p.anchor = {
        x: w - offset,
        y: offset,
        column: End
      };
      break;

    case BottomLeft:
      p.anchor = {
        x: offset,
        y: h - offset,
        row: End
      };
      break;

    case BottomRight:
      p.anchor = {
        x: w - offset,
        y: h - offset,
        column: End,
        row: End
      };
      break;
  }

  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0],
      datum = item.datum,
      orient = item.orient,
      bounds = item.bounds,
      x = item.x,
      y = item.y,
      w,
      h; // cache current bounds for later comparison

  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();
  bounds.clear(); // adjust legend to accommodate padding and title

  legendGroupLayout(view, item, item.items[0].items[0]); // aggregate bounds to determine size, and include origin

  bounds = legendBounds(item, bounds);
  w = 2 * item.padding;
  h = 2 * item.padding;

  if (!bounds.empty()) {
    w = Math.ceil(bounds.width() + w);
    h = Math.ceil(bounds.height() + h);
  }

  if (datum.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }

  if (orient !== None) {
    item.x = x = 0;
    item.y = y = 0;
  }

  item.width = w;
  item.height = h;
  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.set(x, y, x + w, y + h), item);
  item.mark.bounds.clear().union(bounds);
  return item;
}

function legendBounds(item, b) {
  // aggregate item bounds
  item.items.forEach(_ => b.union(_.bounds)); // anchor to legend origin

  b.x1 = item.padding;
  b.y1 = item.padding;
  return b;
}

function legendGroupLayout(view, item, entry) {
  var pad = item.padding,
      ex = pad - entry.x,
      ey = pad - entry.y;

  if (!item.datum.title) {
    if (ex || ey) translate(view, entry, ex, ey);
  } else {
    var title = item.items[1].items[0],
        anchor = title.anchor,
        tpad = item.titlePadding || 0,
        tx = pad - title.x,
        ty = pad - title.y;

    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;

      case Right:
      case Bottom:
        break;

      default:
        ey += title.bounds.height() + tpad;
    }

    if (ex || ey) translate(view, entry, ex, ey);

    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Right:
        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;

      case Bottom:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;
        break;

      default:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
    }

    if (tx || ty) translate(view, title, tx, ty); // translate legend if title pushes into negative coordinates

    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {
      translate(view, entry, -tx, 0);
      translate(view, title, -tx, 0);
    }
  }
}

function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {
  const grad = item.datum.type !== 'symbol',
        vgrad = title.datum.vgrad,
        e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,
        s = e.bounds[y ? 'y2' : 'x2'] - item.padding,
        u = vgrad && lr ? s : 0,
        v = vgrad && lr ? 0 : s,
        o = y <= 0 ? 0 : (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}

function translate(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}

function legendEntryLayout(entries) {
  // get max widths for each column
  const widths = entries.reduce((w, g) => {
    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);
    return w;
  }, {}); // set dimensions of legend entry groups

  entries.forEach(g => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}

function titleLayout(view, mark, width, height, viewBounds) {
  var group = mark.items[0],
      frame = group.frame,
      orient = group.orient,
      anchor = group.anchor,
      offset = group.offset,
      padding = group.padding,
      title = group.items[0].items[0],
      subtitle = group.items[1] && group.items[1].items[0],
      end = orient === Left || orient === Right ? height : width,
      start = 0,
      x = 0,
      y = 0,
      sx = 0,
      sy = 0,
      pos;

  if (frame !== Group) {
    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);
  } else if (orient === Left) {
    start = height, end = 0;
  }

  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;

  if (subtitle && subtitle.text) {
    // position subtitle
    switch (orient) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding;
        break;

      case Left:
        sx = title.bounds.width() + padding;
        break;

      case Right:
        sx = -title.bounds.width() - padding;
        break;
    }

    tempBounds.clear().union(subtitle.bounds);
    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));

    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds);
      subtitle.mark.bounds.clear().union(tempBounds);
      view.dirty(subtitle);
    }

    tempBounds.clear().union(subtitle.bounds);
  } else {
    tempBounds.clear();
  }

  tempBounds.union(title.bounds); // position title group

  switch (orient) {
    case Top:
      x = pos;
      y = viewBounds.y1 - tempBounds.height() - offset;
      break;

    case Left:
      x = viewBounds.x1 - tempBounds.width() - offset;
      y = pos;
      break;

    case Right:
      x = viewBounds.x2 + tempBounds.width() + offset;
      y = pos;
      break;

    case Bottom:
      x = pos;
      y = viewBounds.y2 + offset;
      break;

    default:
      x = group.x;
      y = group.y;
  }

  if (set(group, 'x', x) | set(group, 'y', y)) {
    tempBounds.translate(x, y);
    view.dirty(group);
    group.bounds.clear().union(tempBounds);
    mark.bounds.clear().union(tempBounds);
    view.dirty(group);
  }

  return group.bounds;
}

/**
 * Layout view elements such as axes and legends.
 * Also performs size adjustments.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - Scenegraph mark of groups to layout.
 */

function ViewLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(ViewLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;

    _.mark.items.forEach(group => {
      if (_.layout) trellisLayout(view, group, _.layout);
      layoutGroup(view, group, _);
    });

    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;
  }

});

function shouldReflow(group) {
  // We typically should reflow if layout is invoked (#2568), as child items
  // may have resized and reflow ensures group bounds are re-calculated.
  // However, legend entries have a special exception to avoid instability.
  // For example, if a selected legend symbol gains a stroke on hover,
  // we don't want to re-position subsequent elements in the legend.
  return group && group.mark.role !== 'legend-entry';
}

function layoutGroup(view, group, _) {
  var items = group.items,
      width = Math.max(0, group.width || 0),
      height = Math.max(0, group.height || 0),
      viewBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, width, height),
      xBounds = viewBounds.clone(),
      yBounds = viewBounds.clone(),
      legends = [],
      title,
      mark,
      orient,
      b,
      i,
      n; // layout axes, gather legends, collect bounds

  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];

    switch (mark.role) {
      case AxisRole:
        b = isYAxis(mark) ? xBounds : yBounds;
        b.union(axisLayout(view, mark, width, height));
        break;

      case TitleRole:
        title = mark;
        break;

      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;

      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;

      default:
        viewBounds.union(mark.bounds);
    }
  } // layout legends, adjust viewBounds


  if (legends.length) {
    // group legends by orient
    const l = {};
    legends.forEach(item => {
      orient = item.orient || Right;
      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);
    }); // perform grid layout for each orient group

    for (const orient in l) {
      const g = l[orient];
      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));
    } // update view bounds


    legends.forEach(item => {
      const b = item.bounds;

      if (!b.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item); // dirty previous location

        item.bounds = b;
        view.dirty(item);
      }

      if (_.autosize && _.autosize.type === Fit) {
        // For autosize fit, incorporate the orthogonal dimension only.
        // Legends that overrun the chart area will then be clipped;
        // otherwise the chart area gets reduced to nothing!
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds.add(b.x1, 0).add(b.x2, 0);
            break;

          case Top:
          case Bottom:
            viewBounds.add(0, b.y1).add(0, b.y2);
        }
      } else {
        viewBounds.union(b);
      }
    });
  } // combine bounding boxes


  viewBounds.union(xBounds).union(yBounds); // layout title, adjust bounds

  if (title) {
    viewBounds.union(titleLayout(view, title, width, height, viewBounds));
  } // override aggregated view bounds if content is clipped


  if (group.clip) {
    viewBounds.set(0, 0, group.width || 0, group.height || 0);
  } // perform size adjustment


  viewSizeLayout(view, group, viewBounds, _);
}

function viewSizeLayout(view, group, viewBounds, _) {
  const auto = _.autosize || {},
        type = auto.type;
  if (view._autosize < 1 || !type) return;
  let viewWidth = view._width,
      viewHeight = view._height,
      width = Math.max(0, group.width || 0),
      left = Math.max(0, Math.ceil(-viewBounds.x1)),
      height = Math.max(0, group.height || 0),
      top = Math.max(0, Math.ceil(-viewBounds.y1));
  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),
        bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));

  if (auto.contains === Padding) {
    const padding = view.padding();
    viewWidth -= padding.left + padding.right;
    viewHeight -= padding.top + padding.bottom;
  }

  if (type === None) {
    left = 0;
    top = 0;
    width = viewWidth;
    height = viewHeight;
  } else if (type === Fit) {
    width = Math.max(0, viewWidth - left - right);
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === FitX) {
    width = Math.max(0, viewWidth - left - right);
    viewHeight = height + top + bottom;
  } else if (type === FitY) {
    viewWidth = width + left + right;
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === Pad) {
    viewWidth = width + left + right;
    viewHeight = height + top + bottom;
  }

  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);
}




/***/ }),

/***/ "./node_modules/vega-view/build/vega-view.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/vega-view/build/vega-view.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "View": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-runtime */ "./node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/interval.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");









// initialize aria role and label attributes
function initializeAria(view) {
  const el = view.container();

  if (el) {
    el.setAttribute('role', 'graphics-document');
    el.setAttribute('aria-roleDescription', 'visualization');
    ariaLabel(el, view.description());
  }
} // update aria-label if we have a DOM container element

function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute('aria-label') : el.setAttribute('aria-label', desc);
}

function background (view) {
  // respond to background signal
  view.add(null, _ => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}

const Default = 'default';
function cursor (view) {
  // get cursor signal, add to dataflow if needed
  const cursor = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  })); // evaluate cursor on each mousemove event

  view.on(view.events('view', 'mousemove'), cursor, (_, event) => {
    const value = cursor.value,
          user = value ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : value.user : Default,
          item = event.item && event.item.cursor || null;
    return value && user === value.user && item == value.item ? value : {
      user: user,
      item: item
    };
  }); // when cursor signal updates, set visible cursor

  view.add(null, function (_) {
    let user = _.cursor,
        item = this.value;

    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(user)) {
      item = user.item;
      user = user.user;
    }

    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor
  });
}
function setCursor(view, cursor) {
  const el = view.globalCursor() ? typeof document !== 'undefined' && document.body : view.container();

  if (el) {
    return cursor == null ? el.style.removeProperty('cursor') : el.style.cursor = cursor;
  }
}

function dataref(view, name) {
  var data = view._runtime.data;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized data set: ' + name);
  }

  return data[name];
}
function data(name, values) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(values));
}
function change(name, changes) {
  if (!(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isChangeSet)(changes)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to changes must be a changeset.');
  }

  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().insert(_));
}
function remove(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(_));
}

function width(view) {
  var padding = view.padding();
  return Math.max(0, view._viewWidth + padding.left + padding.right);
}
function height(view) {
  var padding = view.padding();
  return Math.max(0, view._viewHeight + padding.top + padding.bottom);
}
function offset(view) {
  var padding = view.padding(),
      origin = view._origin;
  return [padding.left + origin[0], padding.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset(view),
      w = width(view),
      h = height(view);

  view._renderer.background(view.background());

  view._renderer.resize(w, h, origin);

  view._handler.origin(origin);

  view._resizeListeners.forEach(handler => {
    try {
      handler(w, h);
    } catch (error) {
      view.error(error);
    }
  });
}

/**
 * Extend an event with additional view-specific methods.
 * Adds a new property ('vega') to an event that provides a number
 * of methods for querying information about the current interaction.
 * The vega object provides the following methods:
 *   view - Returns the backing View instance.
 *   item - Returns the currently active scenegraph item (if any).
 *   group - Returns the currently active scenegraph group (if any).
 *     This method accepts a single string-typed argument indicating the name
 *     of the desired parent group. The scenegraph will be traversed from
 *     the item up towards the root to search for a matching group. If no
 *     argument is provided the enclosing group for the active item is
 *     returned, unless the item it itself a group, in which case it is
 *     returned directly.
 *   xy - Returns a two-element array containing the x and y coordinates for
 *     mouse or touch events. For touch events, this is based on the first
 *     elements in the changedTouches array. This method accepts a single
 *     argument: either an item instance or mark name that should serve as
 *     the reference coordinate system. If no argument is provided the
 *     top-level view coordinate system is assumed.
 *   x - Returns the current x-coordinate, accepts the same arguments as xy.
 *   y - Returns the current y-coordinate, accepts the same arguments as xy.
 * @param {Event} event - The input event to extend.
 * @param {Item} item - The currently active scenegraph item (if any).
 * @return {Event} - The extended input event.
 */

function eventExtend (view, event, item) {
  var r = view._renderer,
      el = r && r.canvas(),
      p,
      e,
      translate;

  if (el) {
    translate = offset(view);
    e = event.changedTouches ? event.changedTouches[0] : event;
    p = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.point)(e, el);
    p[0] -= translate[0];
    p[1] -= translate[1];
  }

  event.dataflow = view;
  event.item = item;
  event.vega = extension(view, item, p);
  return event;
}

function extension(view, item, point) {
  const itemGroup = item ? item.mark.marktype === 'group' ? item : item.mark.group : null;

  function group(name) {
    var g = itemGroup,
        i;
    if (name) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }

  function xy(item) {
    if (!item) return point;
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(item)) item = group(item);
    const p = point.slice();

    while (item) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
      item = item.mark && item.mark.group;
    }

    return p;
  }

  return {
    view: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(view),
    item: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(item || {}),
    group: group,
    xy: xy,
    x: item => xy(item)[0],
    y: item => xy(item)[1]
  };
}

const VIEW = 'view',
      TIMER = 'timer',
      WINDOW = 'window',
      NO_TRAP = {
  trap: false
};
/**
 * Initialize event handling configuration.
 * @param {object} config - The configuration settings.
 * @return {object}
 */

function initializeEventConfig(config) {
  const events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    defaults: {}
  }, config);

  const unpack = (obj, keys) => {
    keys.forEach(k => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj[k])) obj[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(obj[k]);
    });
  };

  unpack(events.defaults, ['prevent', 'allow']);
  unpack(events, ['view', 'window', 'selector']);
  return events;
}
function trackEventListener(view, sources, type, handler) {
  view._eventListeners.push({
    type: type,
    sources: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(sources),
    handler: handler
  });
}

function prevent(view, type) {
  var def = view._eventConfig.defaults,
      prevent = def.prevent,
      allow = def.allow;
  return prevent === false || allow === true ? false : prevent === true || allow === false ? true : prevent ? prevent[type] : allow ? !allow[type] : view.preventDefault();
}

function permit(view, key, type) {
  const rule = view._eventConfig && view._eventConfig[key];

  if (rule === false || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(rule) && !rule[type]) {
    view.warn(`Blocked ${key} ${type} event listener.`);
    return false;
  }

  return true;
}
/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @return {EventStream}
 */


function events(source, type, filter) {
  var view = this,
      s = new vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream(filter),
      send = function (e, item) {
    view.runAsync(null, () => {
      if (source === VIEW && prevent(view, type)) {
        e.preventDefault();
      }

      s.receive(eventExtend(view, e, item));
    });
  },
      sources;

  if (source === TIMER) {
    if (permit(view, 'timer', type)) {
      view.timer(send, type);
    }
  } else if (source === VIEW) {
    if (permit(view, 'view', type)) {
      // send traps errors, so use {trap: false} option
      view.addEventListener(type, send, NO_TRAP);
    }
  } else {
    if (source === WINDOW) {
      if (permit(view, 'window', type) && typeof window !== 'undefined') {
        sources = [window];
      }
    } else if (typeof document !== 'undefined') {
      if (permit(view, 'selector', type)) {
        sources = document.querySelectorAll(source);
      }
    }

    if (!sources) {
      view.warn('Can not resolve event source: ' + source);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type, send);
      }

      trackEventListener(view, sources, type, send);
    }
  }

  return s;
}

function itemFilter(event) {
  return event.item;
}

function markTarget(event) {
  // grab upstream collector feeding the mark operator
  return event.item.mark.source;
}

function invoke(name) {
  return function (_, event) {
    return event.vega.view().changeset().encode(event.item, name);
  };
}

function hover (hoverSet, leaveSet) {
  hoverSet = [hoverSet || 'hover'];
  leaveSet = [leaveSet || 'update', hoverSet[0]]; // invoke hover set upon mouseover

  this.on(this.events('view', 'mouseover', itemFilter), markTarget, invoke(hoverSet)); // invoke leave set upon mouseout

  this.on(this.events('view', 'mouseout', itemFilter), markTarget, invoke(leaveSet));
  return this;
}

/**
 * Finalize a View instance that is being removed.
 * Cancel any running timers.
 * Remove all external event listeners.
 * Remove any currently displayed tooltip.
 */
function finalize () {
  var tooltip = this._tooltip,
      timers = this._timers,
      listeners = this._eventListeners,
      n,
      m,
      e;
  n = timers.length;

  while (--n >= 0) {
    timers[n].stop();
  }

  n = listeners.length;

  while (--n >= 0) {
    e = listeners[n];
    m = e.sources.length;

    while (--m >= 0) {
      e.sources[m].removeEventListener(e.type, e.handler);
    }
  }

  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }

  return this;
}

function element (tag, attr, text) {
  const el = document.createElement(tag);

  for (const key in attr) el.setAttribute(key, attr[key]);

  if (text != null) el.textContent = text;
  return el;
}

const BindClass = 'vega-bind',
      NameClass = 'vega-bind-name',
      RadioClass = 'vega-bind-radio';
/**
 * Bind a signal to an external HTML input element. The resulting two-way
 * binding will propagate input changes to signals, and propagate signal
 * changes to the input element state. If this view instance has no parent
 * element, we assume the view is headless and no bindings are created.
 * @param {Element|string} el - The parent DOM element to which the input
 *   element should be appended as a child. If string-valued, this argument
 *   will be treated as a CSS selector. If null or undefined, the parent
 *   element of this view will be used as the element.
 * @param {object} param - The binding parameters which specify the signal
 *   to bind to, the input element type, and type-specific configuration.
 * @return {View} - This view instance.
 */

function bind (view, el, binding) {
  if (!el) return;
  const param = binding.param;
  let bind = binding.state;

  if (!bind) {
    bind = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: value => {
        if (value != view.signal(param.signal)) {
          view.runAsync(null, () => {
            bind.source = true;
            view.signal(param.signal, value);
          });
        }
      }
    };

    if (param.debounce) {
      bind.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(param.debounce, bind.update);
    }
  }

  const create = param.input == null && param.element ? target : generate;
  create(bind, el, param, view);

  if (!bind.active) {
    view.on(view._signals[param.signal], null, () => {
      bind.source ? bind.source = false : bind.set(view.signal(param.signal));
    });
    bind.active = true;
  }

  return bind;
}
/**
 * Bind the signal to an external EventTarget.
 */

function target(bind, node, param, view) {
  const type = param.event || 'input';

  const handler = () => bind.update(node.value); // initialize signal value to external input value


  view.signal(param.signal, node.value); // listen for changes on the element

  node.addEventListener(type, handler); // register with view, so we can remove it upon finalization

  trackEventListener(view, node, type, handler); // propagate change to element

  bind.set = value => {
    node.value = value;
    node.dispatchEvent(event(type));
  };
}

function event(type) {
  return typeof Event !== 'undefined' ? new Event(type) : {
    type
  };
}
/**
 * Generate an HTML input form element and bind it to a signal.
 */


function generate(bind, el, param, view) {
  const value = view.signal(param.signal);
  const div = element('div', {
    'class': BindClass
  });
  const wrapper = param.input === 'radio' ? div : div.appendChild(element('label'));
  wrapper.appendChild(element('span', {
    'class': NameClass
  }, param.name || param.signal));
  el.appendChild(div);
  let input = form;

  switch (param.input) {
    case 'checkbox':
      input = checkbox;
      break;

    case 'select':
      input = select;
      break;

    case 'radio':
      input = radio;
      break;

    case 'range':
      input = range;
      break;
  }

  input(bind, wrapper, param, value);
}
/**
 * Generates an arbitrary input form element.
 * The input type is controlled via user-provided parameters.
 */


function form(bind, el, param, value) {
  const node = element('input');

  for (const key in param) {
    if (key !== 'signal' && key !== 'element') {
      node.setAttribute(key === 'input' ? 'type' : key, param[key]);
    }
  }

  node.setAttribute('name', param.signal);
  node.value = value;
  el.appendChild(node);
  node.addEventListener('input', () => bind.update(node.value));
  bind.elements = [node];

  bind.set = value => node.value = value;
}
/**
 * Generates a checkbox input element.
 */


function checkbox(bind, el, param, value) {
  const attr = {
    type: 'checkbox',
    name: param.signal
  };
  if (value) attr.checked = true;
  const node = element('input', attr);
  el.appendChild(node);
  node.addEventListener('change', () => bind.update(node.checked));
  bind.elements = [node];

  bind.set = value => node.checked = !!value || null;
}
/**
 * Generates a selection list input element.
 */


function select(bind, el, param, value) {
  const node = element('select', {
    name: param.signal
  }),
        labels = param.labels || [];
  param.options.forEach((option, i) => {
    const attr = {
      value: option
    };
    if (valuesEqual(option, value)) attr.selected = true;
    node.appendChild(element('option', attr, (labels[i] || option) + ''));
  });
  el.appendChild(node);
  node.addEventListener('change', () => {
    bind.update(param.options[node.selectedIndex]);
  });
  bind.elements = [node];

  bind.set = value => {
    for (let i = 0, n = param.options.length; i < n; ++i) {
      if (valuesEqual(param.options[i], value)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}
/**
 * Generates a radio button group.
 */


function radio(bind, el, param, value) {
  const group = element('span', {
    'class': RadioClass
  }),
        labels = param.labels || [];
  el.appendChild(group);
  bind.elements = param.options.map((option, i) => {
    const attr = {
      type: 'radio',
      name: param.signal,
      value: option
    };
    if (valuesEqual(option, value)) attr.checked = true;
    const input = element('input', attr);
    input.addEventListener('change', () => bind.update(option));
    const label = element('label', {}, (labels[i] || option) + '');
    label.prepend(input);
    group.appendChild(label);
    return input;
  });

  bind.set = value => {
    const nodes = bind.elements,
          n = nodes.length;

    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value)) nodes[i].checked = true;
    }
  };
}
/**
 * Generates a slider input element.
 */


function range(bind, el, param, value) {
  value = value !== undefined ? value : (+param.max + +param.min) / 2;
  const max = param.max != null ? param.max : Math.max(100, +value) || 100,
        min = param.min || Math.min(0, max, +value) || 0,
        step = param.step || (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.tickStep)(min, max, 100);
  const node = element('input', {
    type: 'range',
    name: param.signal,
    min: min,
    max: max,
    step: step
  });
  node.value = value;
  const span = element('span', {}, +value);
  el.appendChild(node);
  el.appendChild(span);

  const update = () => {
    span.textContent = node.value;
    bind.update(+node.value);
  }; // subscribe to both input and change


  node.addEventListener('input', update);
  node.addEventListener('change', update);
  bind.elements = [node];

  bind.set = value => {
    node.value = value;
    span.textContent = value;
  };
}

function valuesEqual(a, b) {
  return a === b || a + '' === b + '';
}

function initializeRenderer (view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset(view), scaleFactor, opt).background(view.background());
}

function trap (view, fn) {
  return !fn ? null : function () {
    try {
      fn.apply(this, arguments);
    } catch (error) {
      view.error(error);
    }
  };
}

function initializeHandler (view, prevHandler, el, constructor) {
  // instantiate scenegraph handler
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset(view), view); // transfer event handlers

  if (prevHandler) {
    prevHandler.handlers().forEach(h => {
      handler.on(h.type, h.handler);
    });
  }

  return handler;
}

function initialize (el, elBind) {
  const view = this,
        type = view._renderType,
        config = view._eventConfig.bind,
        module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type); // containing dom element

  el = view._el = el ? lookup(view, el, true) : null; // initialize aria attributes

  initializeAria(view); // select appropriate renderer & handler

  if (!module) view.error('Unrecognized renderer type: ' + type);
  const Handler = module.handler || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler,
        Renderer = el ? module.renderer : module.headless; // initialize renderer and input handler

  view._renderer = !Renderer ? null : initializeRenderer(view, view._renderer, el, Renderer);
  view._handler = initializeHandler(view, view._handler, el, Handler);
  view._redraw = true; // initialize signal bindings

  if (el && config !== 'none') {
    elBind = elBind ? view._elBind = lookup(view, elBind, true) : el.appendChild(element('form', {
      'class': 'vega-bindings'
    }));

    view._bind.forEach(_ => {
      if (_.param.element && config !== 'container') {
        _.element = lookup(view, _.param.element, !!_.param.input);
      }
    });

    view._bind.forEach(_ => {
      bind(view, _.element || elBind, _);
    });
  }

  return view;
}

function lookup(view, el, clear) {
  if (typeof el === 'string') {
    if (typeof document !== 'undefined') {
      el = document.querySelector(el);

      if (!el) {
        view.error('Signal bind element not found: ' + el);
        return null;
      }
    } else {
      view.error('DOM document instance not found.');
      return null;
    }
  }

  if (el && clear) {
    try {
      el.innerHTML = '';
    } catch (e) {
      el = null;
      view.error(e);
    }
  }

  return el;
}

const number = _ => +_ || 0;

const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});

function padding (_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? {
    top: number(_.top),
    bottom: number(_.bottom),
    left: number(_.left),
    right: number(_.right)
  } : paddingObject(number(_));
}

/**
 * Render the current scene in a headless fashion.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A Promise that resolves to a renderer.
 */

async function renderHeadless (view, type, scaleFactor, opt) {
  const module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type),
        ctr = module && module.headless;
  if (!ctr) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}

/**
 * Produce an image URL for the visualization. Depending on the type
 * parameter, the generated URL contains data for either a PNG or SVG image.
 * The URL can be used (for example) to download images of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @param {string} type - The image type. One of 'svg', 'png' or 'canvas'.
 *   The 'canvas' and 'png' types are synonyms for a PNG image.
 * @return {Promise} - A promise that resolves to an image URL.
 */

async function renderToImageURL (type, scaleFactor) {
  if (type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.PNG) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized image type: ' + type);
  }

  const r = await renderHeadless(this, type, scaleFactor);
  return type === vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG ? toBlobURL(r.svg(), 'image/svg+xml') : r.canvas().toDataURL('image/png');
}

function toBlobURL(data, mime) {
  const blob = new Blob([data], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}

/**
 * Produce a Canvas instance containing a rendered visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to a Canvas instance.
 */

async function renderToCanvas (scaleFactor, opt) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}

/**
 * Produce a rendered SVG string of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to an SVG string.
 */

async function renderToSVG (scaleFactor) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG, scaleFactor);
  return r.svg();
}

function runtime (view, spec, expr) {
  return (0,vega_runtime__WEBPACK_IMPORTED_MODULE_4__.context)(view, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_functions__WEBPACK_IMPORTED_MODULE_3__.functionContext, expr).parse(spec);
}

function scale(name) {
  var scales = this._runtime.scales;

  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale or projection: ' + name);
  }

  return scales[name].value;
}

var Width = 'width',
    Height = 'height',
    Padding = 'padding',
    Skip = {
  skip: true
};
function viewWidth(view, width) {
  var a = view.autosize(),
      p = view.padding();
  return width - (a && a.contains === Padding ? p.left + p.right : 0);
}
function viewHeight(view, height) {
  var a = view.autosize(),
      p = view.padding();
  return height - (a && a.contains === Padding ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals,
      w = s[Width],
      h = s[Height],
      p = s[Padding];

  function resetSize() {
    view._autosize = view._resize = 1;
  } // respond to width signal


  view._resizeWidth = view.add(null, _ => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w
  }); // respond to height signal

  view._resizeHeight = view.add(null, _ => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h
  }); // respond to padding signal

  const resizePadding = view.add(null, resetSize, {
    pad: p
  }); // set rank to run immediately after source signal

  view._resizeWidth.rank = w.rank + 1;
  view._resizeHeight.rank = h.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth, viewHeight, width, height, origin, auto) {
  this.runAfter(view => {
    let rerun = 0; // reset autosize flag

    view._autosize = 0; // width value changed: update signal, skip resize op

    if (view.width() !== width) {
      rerun = 1;
      view.signal(Width, width, Skip); // set width, skip update calc

      view._resizeWidth.skip(true); // skip width resize handler

    } // height value changed: update signal, skip resize op


    if (view.height() !== height) {
      rerun = 1;
      view.signal(Height, height, Skip); // set height, skip update calc

      view._resizeHeight.skip(true); // skip height resize handler

    } // view width changed: update view property, set resize flag


    if (view._viewWidth !== viewWidth) {
      view._resize = 1;
      view._viewWidth = viewWidth;
    } // view height changed: update view property, set resize flag


    if (view._viewHeight !== viewHeight) {
      view._resize = 1;
      view._viewHeight = viewHeight;
    } // origin changed: update view property, set resize flag


    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    } // run dataflow on width/height signal change


    if (rerun) view.run('enter');
    if (auto) view.runAfter(v => v.resize());
  }, false, 1);
}

/**
 * Get the current view state, consisting of signal values and/or data sets.
 * @param {object} [options] - Options flags indicating which state to export.
 *   If unspecified, all signals and data sets will be exported.
 * @param {function(string, Operator):boolean} [options.signals] - Optional
 *   predicate function for testing if a signal should be included in the
 *   exported state. If unspecified, all signals will be included, except for
 *   those named 'parent' or those which refer to a Transform value.
 * @param {function(string, object):boolean} [options.data] - Optional
 *   predicate function for testing if a data set's input should be included
 *   in the exported state. If unspecified, all data sets that have been
 *   explicitly modified will be included.
 * @param {boolean} [options.recurse=true] - Flag indicating if the exported
 *   state should recursively include state from group mark sub-contexts.
 * @return {object} - An object containing the exported state values.
 */

function getState(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}

function dataTest(name, data) {
  return data.modified && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data.input.value) && name.indexOf('_:vega:_');
}

function signalTest(name, op) {
  return !(name === 'parent' || op instanceof vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms.proxy);
}
/**
 * Sets the current view state and updates the view by invoking run.
 * @param {object} state - A state object containing signal and/or
 *   data set values, following the format used by the getState method.
 * @return {View} - This view instance.
 */


function setState(state) {
  this.runAsync(null, v => {
    v._trigger = false;

    v._runtime.setState(state);
  }, v => {
    v._trigger = true;
  });
  return this;
}

function timer (callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed: elapsed
    });
  }

  this._timers.push((0,d3_timer__WEBPACK_IMPORTED_MODULE_7__.default)(tick, delay));
}

function defaultTooltip (handler, event, item, value) {
  const el = handler.element();
  if (el) el.setAttribute('title', formatTooltip(value));
}

function formatTooltip(value) {
  return value == null ? '' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? formatArray(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? formatObject(value) : value + '';
}

function formatObject(obj) {
  return Object.keys(obj).map(key => {
    const v = obj[key];
    return key + ': ' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? formatArray(v) : formatValue(v));
  }).join('\n');
}

function formatArray(value) {
  return '[' + value.map(formatValue).join(', ') + ']';
}

function formatValue(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? '[\u2026]' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? '{\u2026}' : value;
}

/**
 * Create a new View instance from a Vega dataflow runtime specification.
 * The generated View will not immediately be ready for display. Callers
 * should also invoke the initialize method (e.g., to set the parent
 * DOM element in browser-based deployment) and then invoke the run
 * method to evaluate the dataflow graph. Rendering will automatically
 * be performed upon dataflow runs.
 * @constructor
 * @param {object} spec - The Vega dataflow runtime specification.
 */

function View(spec, options) {
  const view = this;
  options = options || {};
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);

  if (options.locale || spec.locale) {
    const loc = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec.locale, options.locale);
    view.locale((0,vega_format__WEBPACK_IMPORTED_MODULE_5__.locale)(loc.number, loc.time));
  }

  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas;
  view._scenegraph = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Scenegraph();
  const root = view._scenegraph.root; // initialize renderer, handler and event management

  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
  view._handler = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = []; // initialize event configuration

  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor); // initialize dataflow graph

  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map(_ => ({
    state: null,
    param: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _)
  })); // initialize scenegraph

  if (ctx.root) ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items)); // initialize view size

  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view); // initialize background color

  background(view); // initialize cursor

  cursor(view); // initialize view description

  view.description(spec.description); // initialize hover proessing, if requested

  if (options.hover) view.hover(); // initialize DOM container(s) and renderer

  if (options.container) view.initialize(options.container, options.bind);
}

function lookupSignal(view, name) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(view._signals, name) ? view._signals[name] : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

function findOperatorHandler(op, handler) {
  const h = (op._targets || []).filter(op => op._update && op._update.handler === handler);
  return h.length ? h[0] : null;
}

function addOperatorListener(view, name, op, handler) {
  let h = findOperatorHandler(op, handler);

  if (!h) {
    h = trap(view, () => handler(name, op.value));
    h.handler = handler;
    view.on(op, null, h);
  }

  return view;
}

function removeOperatorListener(view, op, handler) {
  const h = findOperatorHandler(op, handler);
  if (h) op._targets.remove(h);
  return view;
}

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(View, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(encode, prerun, postrun) {
    // evaluate dataflow and prerun
    await vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.evaluate.call(this, encode, prerun); // render as needed

    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }

          await this._renderer.renderAsync(this._scenegraph.root);
        }

        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    } // evaluate postrun


    if (postrun) (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.asyncCallback)(this, postrun);
    return this;
  },

  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },

  // -- GET / SET ----
  description(text) {
    if (arguments.length) {
      const desc = text != null ? text + '' : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }

    return this._desc;
  },

  container() {
    return this._el;
  },

  scenegraph() {
    return this._scenegraph;
  },

  origin() {
    return this._origin.slice();
  },

  signal(name, value, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value, options);
  },

  width(_) {
    return arguments.length ? this.signal('width', _) : this.signal('width');
  },

  height(_) {
    return arguments.length ? this.signal('height', _) : this.signal('height');
  },

  padding(_) {
    return arguments.length ? this.signal('padding', padding(_)) : padding(this.signal('padding'));
  },

  autosize(_) {
    return arguments.length ? this.signal('autosize', _) : this.signal('autosize');
  },

  background(_) {
    return arguments.length ? this.signal('background', _) : this.signal('background');
  },

  renderer(type) {
    if (!arguments.length) return this._renderType;
    if (!(0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);

    if (type !== this._renderType) {
      this._renderType = type;

      this._resetRenderer();
    }

    return this;
  },

  tooltip(handler) {
    if (!arguments.length) return this._tooltip;

    if (handler !== this._tooltip) {
      this._tooltip = handler;

      this._resetRenderer();
    }

    return this;
  },

  loader(loader) {
    if (!arguments.length) return this._loader;

    if (loader !== this._loader) {
      vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.loader.call(this, loader);

      this._resetRenderer();
    }

    return this;
  },

  resize() {
    // set flag to perform autosize
    this._autosize = 1; // touch autosize signal to ensure top-level ViewLayout runs

    return this.touch(lookupSignal(this, 'autosize'));
  },

  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },

  // -- SIZING ----
  _resizeView: resizeView,

  // -- EVENT HANDLING ----
  addEventListener(type, handler, options) {
    let callback = handler;

    if (!(options && options.trap === false)) {
      // wrap callback in error handler
      callback = trap(this, handler);
      callback.raw = handler;
    }

    this._handler.on(type, callback);

    return this;
  },

  removeEventListener(type, handler) {
    var handlers = this._handler.handlers(type),
        i = handlers.length,
        h,
        t; // search registered handlers, remove if match found


    while (--i >= 0) {
      t = handlers[i].type;
      h = handlers[i].handler;

      if (type === t && (handler === h || handler === h.raw)) {
        this._handler.off(t, h);

        break;
      }
    }

    return this;
  },

  addResizeListener(handler) {
    const l = this._resizeListeners;

    if (l.indexOf(handler) < 0) {
      // add handler if it isn't already registered
      // note: error trapping handled elsewhere, so
      // no need to wrap handlers here
      l.push(handler);
    }

    return this;
  },

  removeResizeListener(handler) {
    var l = this._resizeListeners,
        i = l.indexOf(handler);

    if (i >= 0) {
      l.splice(i, 1);
    }

    return this;
  },

  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },

  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },

  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },

  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },

  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null); // clear previous cursor

        this._globalCursor = !!_;
        if (prev) setCursor(this, prev); // swap cursor
      }

      return this;
    } else {
      return this._globalCursor;
    }
  },

  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },

  timer,
  events,
  finalize,
  hover,
  // -- DATA ----
  data,
  change,
  insert,
  remove,
  // -- SCALES --
  scale,
  // -- INITIALIZATION ----
  initialize,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState,
  setState
});




/***/ }),

/***/ "./node_modules/vega-voronoi/build/vega-voronoi.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-voronoi/build/vega-voronoi.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "voronoi": () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-delaunay */ "./node_modules/d3-delaunay/src/delaunay.js");




function Voronoi(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Voronoi.Definition = {
  'type': 'Voronoi',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'default': [[-1e5, -1e5], [1e5, 1e5]],
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Voronoi, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const as = _.as || 'path',
          data = pulse.source; // nothing to do if no data

    if (!data || !data.length) return pulse; // configure and construct voronoi diagram

    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = d3_delaunay__WEBPACK_IMPORTED_MODULE_2__.default.from(data, _.x, _.y).voronoi(s); // map polygons to paths

    for (let i = 0, n = data.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data[i][as] = polygon ? toPathString(polygon) : null;
    }

    return pulse.reflow(_.modified()).modifies(as);
  }

}); // suppress duplicated end point vertices

function toPathString(p) {
  const x = p[0][0],
        y = p[0][1];
  let n = p.length - 1;

  for (; p[n][0] === x && p[n][1] === y; --n);

  return 'M' + p.slice(0, n + 1).join('L') + 'Z';
}




/***/ }),

/***/ "./node_modules/vega-wordcloud/build/vega-wordcloud.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-wordcloud/build/vega-wordcloud.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wordcloud": () => (/* binding */ Wordcloud)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/index.browser.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");






/*
Copyright (c) 2013, Jason Davies.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  * The name Jason Davies may not be used to endorse or promote products
    derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;
function cloud () {
  var size = [256, 256],
      text,
      font,
      fontSize,
      fontStyle,
      fontWeight,
      rotate,
      padding,
      spiral = archimedeanSpiral,
      words = [],
      random = Math.random,
      cloud = {};

  cloud.layout = function () {
    var contextAndRatio = getContext((0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)()),
        board = zeroArray((size[0] >> 5) * size[1]),
        bounds = null,
        n = words.length,
        i = -1,
        tags = [],
        data = words.map(d => ({
      text: text(d),
      font: font(d),
      style: fontStyle(d),
      weight: fontWeight(d),
      rotate: rotate(d),
      size: ~~(fontSize(d) + 1e-14),
      padding: padding(d),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: false,
      sprite: null,
      datum: d
    })).sort((a, b) => b.size - a.size);

    while (++i < n) {
      var d = data[i];
      d.x = size[0] * (random() + .5) >> 1;
      d.y = size[1] * (random() + .5) >> 1;
      cloudSprite(contextAndRatio, d, data, i);

      if (d.hasText && place(board, d, bounds)) {
        tags.push(d);
        if (bounds) cloudBounds(bounds, d);else bounds = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }]; // Temporary hack

        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }

    return tags;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    var startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < .5 ? 1 : -1,
        t = -dt,
        dxdy,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0,
              x = (tag.y + tag.y0) * sw + (lx >> 5),
              last;

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          tag.sprite = null;
          return true;
        }
      }
    }

    return false;
  }

  cloud.words = function (_) {
    if (arguments.length) {
      words = _;
      return cloud;
    } else {
      return words;
    }
  };

  cloud.size = function (_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud;
    } else {
      return size;
    }
  };

  cloud.font = function (_) {
    if (arguments.length) {
      font = functor(_);
      return cloud;
    } else {
      return font;
    }
  };

  cloud.fontStyle = function (_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud;
    } else {
      return fontStyle;
    }
  };

  cloud.fontWeight = function (_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud;
    } else {
      return fontWeight;
    }
  };

  cloud.rotate = function (_) {
    if (arguments.length) {
      rotate = functor(_);
      return cloud;
    } else {
      return rotate;
    }
  };

  cloud.text = function (_) {
    if (arguments.length) {
      text = functor(_);
      return cloud;
    } else {
      return text;
    }
  };

  cloud.spiral = function (_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud;
    } else {
      return spiral;
    }
  };

  cloud.fontSize = function (_) {
    if (arguments.length) {
      fontSize = functor(_);
      return cloud;
    } else {
      return fontSize;
    }
  };

  cloud.padding = function (_) {
    if (arguments.length) {
      padding = functor(_);
      return cloud;
    } else {
      return padding;
    }
  };

  cloud.random = function (_) {
    if (arguments.length) {
      random = _;
      return cloud;
    } else {
      return random;
    }
  };

  return cloud;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.

function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0,
      n = data.length,
      w,
      w32,
      h,
      i,
      j;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    w = c.measureText(d.text + 'm').width * ratio;
    h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);

    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }

    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    w = d.width;
    w32 = w >> 5;
    h = d.y1 - d.y0; // Zero the buffer

    for (i = 0; i < h * w32; i++) sprite[i] = 0;

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (j = 0; j < h; j++) {
      for (i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0,
      x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1],
      x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [],
      i = -1;

  while (++i < n) a[i] = 0;

  return a;
}

function functor(d) {
  return typeof d === 'function' ? d : function () {
    return d;
  };
}

var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

const Output = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'];
const Params = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];
function Wordcloud(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, cloud(), params);
}
Wordcloud.Definition = {
  'type': 'Wordcloud',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'font',
    'type': 'string',
    'expr': true,
    'default': 'sans-serif'
  }, {
    'name': 'fontStyle',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontWeight',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontSize',
    'type': 'number',
    'expr': true,
    'default': 14
  }, {
    'name': 'fontSizeRange',
    'type': 'number',
    'array': 'nullable',
    'default': [10, 50]
  }, {
    'name': 'rotate',
    'type': 'number',
    'expr': true,
    'default': 0
  }, {
    'name': 'text',
    'type': 'field'
  }, {
    'name': 'spiral',
    'type': 'string',
    'values': ['archimedean', 'rectangular']
  }, {
    'name': 'padding',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 7,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Wordcloud, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (_.size && !(_.size[0] && _.size[1])) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Wordcloud size dimensions must be non-zero.');
    }

    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(p) && pulse.modified(p.fields);
    }

    const mod = _.modified();

    if (!(mod || pulse.changed(pulse.ADD_REM) || Params.some(modp))) return;
    const data = pulse.materialize(pulse.SOURCE).source,
          layout = this.value,
          as = _.as || Output;
    let fontSize = _.fontSize || 14,
        range;
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(fontSize) ? range = _.fontSizeRange : fontSize = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(fontSize); // create font size scaling function as needed

    if (range) {
      const fsize = fontSize,
            sizeScale = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sqrt')().domain((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(data, fsize)).range(range);

      fontSize = x => sizeScale(fsize(x));
    }

    data.forEach(t => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    }); // configure layout

    const words = layout.words(data).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || 'archimedean').rotate(_.rotate || 0).font(_.font || 'sans-serif').fontStyle(_.fontStyle || 'normal').fontWeight(_.fontWeight || 'normal').fontSize(fontSize).random(vega_statistics__WEBPACK_IMPORTED_MODULE_4__.random).layout();
    const size = layout.size(),
          dx = size[0] >> 1,
          dy = size[1] >> 1,
          n = words.length;

    for (let i = 0, w, t; i < n; ++i) {
      w = words[i];
      t = w.datum;
      t[as[0]] = w.x + dx;
      t[as[1]] = w.y + dy;
      t[as[2]] = w.font;
      t[as[3]] = w.size;
      t[as[4]] = w.style;
      t[as[5]] = w.weight;
      t[as[6]] = w.rotate;
    }

    return pulse.reflow(mod).modifies(as);
  }

});




/***/ }),

/***/ "./node_modules/vega/build/vega.module.js":
/*!************************************************!*\
  !*** ./node_modules/vega/build/vega.module.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Debug),
/* harmony export */   "Error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Error),
/* harmony export */   "Info": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Info),
/* harmony export */   "None": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.None),
/* harmony export */   "Warn": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Warn),
/* harmony export */   "accessor": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor),
/* harmony export */   "accessorFields": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields),
/* harmony export */   "accessorName": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
/* harmony export */   "array": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.array),
/* harmony export */   "ascending": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending),
/* harmony export */   "clampRange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange),
/* harmony export */   "compare": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.compare),
/* harmony export */   "constant": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.constant),
/* harmony export */   "debounce": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   "error": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.error),
/* harmony export */   "extend": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extend),
/* harmony export */   "extent": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extent),
/* harmony export */   "extentIndex": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex),
/* harmony export */   "falsy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.falsy),
/* harmony export */   "fastmap": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap),
/* harmony export */   "field": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.field),
/* harmony export */   "flush": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.flush),
/* harmony export */   "hasOwnProperty": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty),
/* harmony export */   "id": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   "identity": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   "inherits": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits),
/* harmony export */   "inrange": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange),
/* harmony export */   "isArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray),
/* harmony export */   "isBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean),
/* harmony export */   "isDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate),
/* harmony export */   "isFunction": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction),
/* harmony export */   "isIterable": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable),
/* harmony export */   "isNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber),
/* harmony export */   "isObject": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject),
/* harmony export */   "isRegExp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp),
/* harmony export */   "isString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isString),
/* harmony export */   "key": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.key),
/* harmony export */   "lerp": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp),
/* harmony export */   "logger": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.logger),
/* harmony export */   "lruCache": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache),
/* harmony export */   "merge": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.merge),
/* harmony export */   "mergeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig),
/* harmony export */   "one": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.one),
/* harmony export */   "pad": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.pad),
/* harmony export */   "panLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear),
/* harmony export */   "panLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog),
/* harmony export */   "panPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow),
/* harmony export */   "panSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog),
/* harmony export */   "peek": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.peek),
/* harmony export */   "quarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter),
/* harmony export */   "repeat": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.repeat),
/* harmony export */   "span": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.span),
/* harmony export */   "splitAccessPath": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath),
/* harmony export */   "stringValue": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue),
/* harmony export */   "toBoolean": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean),
/* harmony export */   "toDate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate),
/* harmony export */   "toNumber": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber),
/* harmony export */   "toSet": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet),
/* harmony export */   "toString": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toString),
/* harmony export */   "truncate": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate),
/* harmony export */   "truthy": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy),
/* harmony export */   "utcquarter": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter),
/* harmony export */   "visitArray": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray),
/* harmony export */   "writeConfig": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.writeConfig),
/* harmony export */   "zero": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zero),
/* harmony export */   "zoomLinear": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear),
/* harmony export */   "zoomLog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog),
/* harmony export */   "zoomPow": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow),
/* harmony export */   "zoomSymlog": () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog),
/* harmony export */   "Dataflow": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow),
/* harmony export */   "EventStream": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream),
/* harmony export */   "MultiPulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.MultiPulse),
/* harmony export */   "Operator": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator),
/* harmony export */   "Parameters": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Parameters),
/* harmony export */   "Pulse": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Pulse),
/* harmony export */   "Transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   "changeset": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset),
/* harmony export */   "definition": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.definition),
/* harmony export */   "ingest": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest),
/* harmony export */   "isTuple": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isTuple),
/* harmony export */   "transform": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transform),
/* harmony export */   "transforms": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms),
/* harmony export */   "tupleid": () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid),
/* harmony export */   "bandwidthNRD": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bandwidthNRD),
/* harmony export */   "bin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bin),
/* harmony export */   "bootstrapCI": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bootstrapCI),
/* harmony export */   "cumulativeLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeLogNormal),
/* harmony export */   "cumulativeNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeNormal),
/* harmony export */   "cumulativeUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeUniform),
/* harmony export */   "densityLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityLogNormal),
/* harmony export */   "densityNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityNormal),
/* harmony export */   "densityUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityUniform),
/* harmony export */   "dotbin": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.dotbin),
/* harmony export */   "quantileLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileLogNormal),
/* harmony export */   "quantileNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileNormal),
/* harmony export */   "quantileUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileUniform),
/* harmony export */   "quantiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantiles),
/* harmony export */   "quartiles": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quartiles),
/* harmony export */   "random": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.random),
/* harmony export */   "randomInteger": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomInteger),
/* harmony export */   "randomKDE": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomKDE),
/* harmony export */   "randomLCG": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLCG),
/* harmony export */   "randomLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLogNormal),
/* harmony export */   "randomMixture": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomMixture),
/* harmony export */   "randomNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomNormal),
/* harmony export */   "randomUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomUniform),
/* harmony export */   "regressionExp": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionExp),
/* harmony export */   "regressionLinear": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLinear),
/* harmony export */   "regressionLoess": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLoess),
/* harmony export */   "regressionLog": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLog),
/* harmony export */   "regressionPoly": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPoly),
/* harmony export */   "regressionPow": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPow),
/* harmony export */   "regressionQuad": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionQuad),
/* harmony export */   "sampleCurve": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleCurve),
/* harmony export */   "sampleLogNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleLogNormal),
/* harmony export */   "sampleNormal": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleNormal),
/* harmony export */   "sampleUniform": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleUniform),
/* harmony export */   "setRandom": () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.setRandom),
/* harmony export */   "DATE": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DATE),
/* harmony export */   "DAY": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAY),
/* harmony export */   "DAYOFYEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAYOFYEAR),
/* harmony export */   "HOURS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.HOURS),
/* harmony export */   "MILLISECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MILLISECONDS),
/* harmony export */   "MINUTES": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MINUTES),
/* harmony export */   "MONTH": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MONTH),
/* harmony export */   "QUARTER": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.QUARTER),
/* harmony export */   "SECONDS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.SECONDS),
/* harmony export */   "TIME_UNITS": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.TIME_UNITS),
/* harmony export */   "WEEK": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.WEEK),
/* harmony export */   "YEAR": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.YEAR),
/* harmony export */   "dayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.dayofyear),
/* harmony export */   "timeBin": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeBin),
/* harmony export */   "timeFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeFloor),
/* harmony export */   "timeInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeInterval),
/* harmony export */   "timeOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeOffset),
/* harmony export */   "timeSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeSequence),
/* harmony export */   "timeUnitSpecifier": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnitSpecifier),
/* harmony export */   "timeUnits": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnits),
/* harmony export */   "utcFloor": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcFloor),
/* harmony export */   "utcInterval": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcInterval),
/* harmony export */   "utcOffset": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcOffset),
/* harmony export */   "utcSequence": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcSequence),
/* harmony export */   "utcdayofyear": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcdayofyear),
/* harmony export */   "utcweek": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcweek),
/* harmony export */   "week": () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.week),
/* harmony export */   "format": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.format),
/* harmony export */   "formats": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.formats),
/* harmony export */   "inferType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferType),
/* harmony export */   "inferTypes": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferTypes),
/* harmony export */   "loader": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.loader),
/* harmony export */   "read": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.read),
/* harmony export */   "responseType": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.responseType),
/* harmony export */   "typeParsers": () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.typeParsers),
/* harmony export */   "Bounds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Bounds),
/* harmony export */   "CanvasHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasHandler),
/* harmony export */   "CanvasRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasRenderer),
/* harmony export */   "Gradient": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Gradient),
/* harmony export */   "GroupItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.GroupItem),
/* harmony export */   "Handler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Handler),
/* harmony export */   "Item": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Item),
/* harmony export */   "Marks": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Marks),
/* harmony export */   "RenderType": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.RenderType),
/* harmony export */   "Renderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Renderer),
/* harmony export */   "ResourceLoader": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.ResourceLoader),
/* harmony export */   "SVGHandler": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGHandler),
/* harmony export */   "SVGRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGRenderer),
/* harmony export */   "SVGStringRenderer": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGStringRenderer),
/* harmony export */   "Scenegraph": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Scenegraph),
/* harmony export */   "boundClip": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundClip),
/* harmony export */   "boundContext": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundContext),
/* harmony export */   "boundItem": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundItem),
/* harmony export */   "boundMark": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundMark),
/* harmony export */   "boundStroke": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundStroke),
/* harmony export */   "domChild": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domChild),
/* harmony export */   "domClear": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domClear),
/* harmony export */   "domCreate": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domCreate),
/* harmony export */   "domFind": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domFind),
/* harmony export */   "font": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.font),
/* harmony export */   "fontFamily": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontFamily),
/* harmony export */   "fontSize": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontSize),
/* harmony export */   "intersect": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersect),
/* harmony export */   "intersectBoxLine": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectBoxLine),
/* harmony export */   "intersectPath": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPath),
/* harmony export */   "intersectPoint": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPoint),
/* harmony export */   "intersectRule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectRule),
/* harmony export */   "lineHeight": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.lineHeight),
/* harmony export */   "markup": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.markup),
/* harmony export */   "multiLineOffset": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.multiLineOffset),
/* harmony export */   "pathCurves": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathCurves),
/* harmony export */   "pathEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathEqual),
/* harmony export */   "pathParse": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathParse),
/* harmony export */   "pathRectangle": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRectangle),
/* harmony export */   "pathRender": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRender),
/* harmony export */   "pathSymbols": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathSymbols),
/* harmony export */   "pathTrail": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathTrail),
/* harmony export */   "point": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.point),
/* harmony export */   "renderModule": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.renderModule),
/* harmony export */   "resetSVGClipId": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGClipId),
/* harmony export */   "resetSVGDefIds": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGDefIds),
/* harmony export */   "sceneEqual": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneEqual),
/* harmony export */   "sceneFromJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneFromJSON),
/* harmony export */   "scenePickVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.scenePickVisit),
/* harmony export */   "sceneToJSON": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneToJSON),
/* harmony export */   "sceneVisit": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneVisit),
/* harmony export */   "sceneZOrder": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneZOrder),
/* harmony export */   "serializeXML": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.serializeXML),
/* harmony export */   "textMetrics": () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.textMetrics),
/* harmony export */   "interpolate": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolate),
/* harmony export */   "interpolateColors": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateColors),
/* harmony export */   "interpolateRange": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateRange),
/* harmony export */   "quantizeInterpolator": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.quantizeInterpolator),
/* harmony export */   "scale": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scale),
/* harmony export */   "scheme": () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scheme),
/* harmony export */   "projection": () => (/* reexport safe */ vega_projection__WEBPACK_IMPORTED_MODULE_18__.projection),
/* harmony export */   "View": () => (/* reexport safe */ vega_view__WEBPACK_IMPORTED_MODULE_19__.View),
/* harmony export */   "defaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.defaultLocale),
/* harmony export */   "formatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.numberFormatDefaultLocale),
/* harmony export */   "locale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.locale),
/* harmony export */   "resetDefaultLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.resetDefaultLocale),
/* harmony export */   "timeFormatLocale": () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.timeFormatDefaultLocale),
/* harmony export */   "expressionFunction": () => (/* reexport safe */ vega_functions__WEBPACK_IMPORTED_MODULE_21__.expressionFunction),
/* harmony export */   "parse": () => (/* reexport safe */ vega_parser__WEBPACK_IMPORTED_MODULE_22__.parse),
/* harmony export */   "runtimeContext": () => (/* reexport safe */ vega_runtime__WEBPACK_IMPORTED_MODULE_23__.context),
/* harmony export */   "codegenExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.codegenExpression),
/* harmony export */   "parseExpression": () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.parseExpression),
/* harmony export */   "parseSelector": () => (/* reexport safe */ vega_event_selector__WEBPACK_IMPORTED_MODULE_25__.parseSelector),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-transforms */ "./node_modules/vega-transforms/build/vega-transforms.module.js");
/* harmony import */ var vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-view-transforms */ "./node_modules/vega-view-transforms/build/vega-view-transforms.module.js");
/* harmony import */ var vega_encode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-encode */ "./node_modules/vega-encode/build/vega-encode.module.js");
/* harmony import */ var vega_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-geo */ "./node_modules/vega-geo/build/vega-geo.module.js");
/* harmony import */ var vega_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-force */ "./node_modules/vega-force/build/vega-force.module.js");
/* harmony import */ var vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-hierarchy */ "./node_modules/vega-hierarchy/build/vega-hierarchy.module.js");
/* harmony import */ var vega_label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vega-label */ "./node_modules/vega-label/build/vega-label.module.js");
/* harmony import */ var vega_regression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vega-regression */ "./node_modules/vega-regression/build/vega-regression.module.js");
/* harmony import */ var vega_voronoi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vega-voronoi */ "./node_modules/vega-voronoi/build/vega-voronoi.module.js");
/* harmony import */ var vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vega-wordcloud */ "./node_modules/vega-wordcloud/build/vega-wordcloud.module.js");
/* harmony import */ var vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vega-crossfilter */ "./node_modules/vega-crossfilter/build/vega-crossfilter.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! vega-projection */ "./node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var vega_view__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! vega-view */ "./node_modules/vega-view/build/vega-view.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_parser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! vega-parser */ "./node_modules/vega-parser/build/vega-parser.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! vega-runtime */ "./node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! vega-event-selector */ "./node_modules/vega-event-selector/build/vega-event-selector.module.js");





























var name = "vega";
var version$1 = "5.21.0";
var description = "The Vega visualization grammar.";
var keywords = [
	"vega",
	"visualization",
	"interaction",
	"dataflow",
	"library",
	"data",
	"d3"
];
var license = "BSD-3-Clause";
var author = "UW Interactive Data Lab (http://idl.cs.washington.edu)";
var main = "build/vega-node.js";
var module = "build/vega.module.js";
var unpkg = "build/vega.min.js";
var jsdelivr = "build/vega.min.js";
var types = "index.d.ts";
var repository = "vega/vega";
var scripts = {
	bundle: "rollup -c --config-bundle",
	prebuild: "rimraf build && rimraf build-es5",
	build: "rollup -c --config-core --config-bundle --config-ie",
	postbuild: "node schema-copy",
	pretest: "yarn build --config-test",
	test: "TZ=America/Los_Angeles tape 'test/**/*-test.js'",
	prepublishOnly: "yarn test && yarn build",
	postpublish: "./schema-deploy.sh"
};
var dependencies = {
	"vega-crossfilter": "~4.0.5",
	"vega-dataflow": "~5.7.4",
	"vega-encode": "~4.8.3",
	"vega-event-selector": "~3.0.0",
	"vega-expression": "~5.0.0",
	"vega-force": "~4.0.7",
	"vega-format": "~1.0.4",
	"vega-functions": "~5.12.1",
	"vega-geo": "~4.3.8",
	"vega-hierarchy": "~4.0.9",
	"vega-label": "~1.1.0",
	"vega-loader": "~4.4.1",
	"vega-parser": "~6.1.4",
	"vega-projection": "~1.4.5",
	"vega-regression": "~1.0.9",
	"vega-runtime": "~6.1.3",
	"vega-scale": "~7.1.1",
	"vega-scenegraph": "~4.9.4",
	"vega-statistics": "~1.7.10",
	"vega-time": "~2.0.4",
	"vega-transforms": "~4.9.4",
	"vega-typings": "~0.22.0",
	"vega-util": "~1.17.0",
	"vega-view": "~5.10.1",
	"vega-view-transforms": "~4.5.8",
	"vega-voronoi": "~4.1.5",
	"vega-wordcloud": "~4.1.3"
};
var devDependencies = {
	"vega-schema": "*"
};
var gitHead = "774165e29850b66ec8b79ba52a7955f1ab936ea6";
var pkg = {
	name: name,
	version: version$1,
	description: description,
	keywords: keywords,
	license: license,
	author: author,
	main: main,
	module: module,
	unpkg: unpkg,
	jsdelivr: jsdelivr,
	types: types,
	repository: repository,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	gitHead: gitHead
};

// -- Transforms -----
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_transforms__WEBPACK_IMPORTED_MODULE_2__, vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__, vega_encode__WEBPACK_IMPORTED_MODULE_4__, vega_geo__WEBPACK_IMPORTED_MODULE_5__, vega_force__WEBPACK_IMPORTED_MODULE_6__, vega_label__WEBPACK_IMPORTED_MODULE_8__, vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__, vega_regression__WEBPACK_IMPORTED_MODULE_9__, vega_voronoi__WEBPACK_IMPORTED_MODULE_10__, vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__, vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__); // -- Exports -----

const version = pkg.version;




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2FzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2Jpc2VjdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZGV2aWF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvZnN1bS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21heC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21lYW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZWRpYW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9tZXJnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL21pbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL251bWJlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3Blcm11dGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9xdWFudGlsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3F1aWNrc2VsZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1hcnJheS9zcmMvcmFuZ2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9zdW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy90aWNrcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3ZhcmlhbmNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1jb2xvci9zcmMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9jdWJlaGVsaXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWNvbG9yL3NyYy9tYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvZGVsYXVuYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWRlbGF1bmF5L3NyYy9wYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1kZWxhdW5heS9zcmMvcG9seWdvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZGVsYXVuYXkvc3JjL3Zvcm9ub2kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZHN2L3NyYy9kc3YuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jZW50ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb2xsaWRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9sY2cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9saW5rLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbWFueUJvZHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9zaW11bGF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZGVmYXVsdExvY2FsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9leHBvbmVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXREZWNpbWFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdEdyb3VwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdE51bWVyYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL2Zvcm1hdFByZWZpeEF1dG8uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0Um91bmRlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRTcGVjaWZpZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvZm9ybWF0VHJpbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9mb3JtYXRUeXBlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L3NyYy9sb2NhbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uRml4ZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWZvcm1hdC9zcmMvcHJlY2lzaW9uUHJlZml4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1mb3JtYXQvc3JjL3ByZWNpc2lvblJvdW5kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL21vbGx3ZWlkZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9hcmVhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2JvdW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9jYXJ0ZXNpYW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2VudHJvaWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYW50aW1lcmlkaWFuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvYnVmZmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY2xpcC9saW5lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvcmVjdGFuZ2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NsaXAvcmVqb2luLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2NvbXBvc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvZ3JhdGljdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvbm9vcC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2FyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9ib3VuZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9jZW50cm9pZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL2NvbnRleHQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wYXRoL21lYXN1cmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcGF0aC9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcG9pbnRFcXVhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wb2x5Z29uQ29udGFpbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hbGJlcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hbGJlcnNVc2EuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWxFcXVhbEFyZWEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9hemltdXRoYWxFcXVpZGlzdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2NvbmljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vY29uaWNDb25mb3JtYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jb25pY0VxdWFsQXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2NvbmljRXF1aWRpc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9jeWxpbmRyaWNhbEVxdWFsQXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2VxdWFsRWFydGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9lcXVpcmVjdGFuZ3VsYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9maXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9nbm9tb25pYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3Byb2plY3Rpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9tZXJjYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL25hdHVyYWxFYXJ0aDEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9vcnRob2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi9yZXNhbXBsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvL3NyYy9wcm9qZWN0aW9uL3N0ZXJlb2dyYXBoaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcHJvamVjdGlvbi90cmFuc3ZlcnNlTWVyY2F0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvcm90YXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWdlby9zcmMvc3RyZWFtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8vc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9hY2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvY2x1c3Rlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvYW5jZXN0b3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9jb3VudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZGVzY2VuZGFudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2VhY2hBZnRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZWFjaEJlZm9yZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvZmluZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9oaWVyYXJjaHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2l0ZXJhdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9sZWF2ZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvaGllcmFyY2h5L2xpbmtzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9wYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9zb3J0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL2hpZXJhcmNoeS9zdW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFjay9lbmNsb3NlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3BhY2svaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvcGFjay9zaWJsaW5ncy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy9wYXJ0aXRpb24uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvc3RyYXRpZnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL2JpbmFyeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL2RpY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3Jlc3F1YXJpZnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWhpZXJhcmNoeS9zcmMvdHJlZW1hcC9yb3VuZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaGllcmFyY2h5L3NyYy90cmVlbWFwL3NsaWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvc2xpY2VEaWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvc3JjL3RyZWVtYXAvc3F1YXJpZnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9hcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Jhc2lzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvYmFzaXNDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9jb2xvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2NvbnN0YW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvY3ViZWhlbGl4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvZGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL2Rpc2NyZXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaGNsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaHNsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaHVlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9sYWIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9udW1iZXJBcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL29iamVjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3BpZWNld2lzZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtaW50ZXJwb2xhdGUvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcmdiLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvcm91bmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy90cmFuc2Zvcm0vZGVjb21wb3NlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdHJhbnNmb3JtL3BhcnNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1pbnRlcnBvbGF0ZS9zcmMvdmFsdWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL3NyYy96b29tLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1wYXRoL3NyYy9wYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvYWRkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvY292ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9kYXRhLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZmluZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3F1YWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkdHJlZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Jvb3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9zaXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy92aXNpdEFmdGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2NvbnRpbnVvdXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9kaXZlcmdpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL2luaXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9sb2cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9uaWNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvbnVtYmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvb3JkaW5hbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3Bvdy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3F1YW50aWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy9zZXF1ZW50aWFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvc3ltbG9nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGhyZXNob2xkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zY2FsZS9zcmMvdGlja0Zvcm1hdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2NhbGUvc3JjL3RpbWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNjYWxlL3NyYy91dGNUaW1lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJjLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvYXJlYS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2FycmF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9iYXNpcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2Jhc2lzQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYmFzaXNPcGVuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvYnVuZGxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2FyZGluYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXJkaW5hbENsb3NlZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhcmRpbmFsT3Blbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL2NhdG11bGxSb20uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9jYXRtdWxsUm9tQ2xvc2VkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvY3VydmUvY2F0bXVsbFJvbU9wZW4uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9saW5lYXJDbG9zZWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9tb25vdG9uZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL2N1cnZlL25hdHVyYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9jdXJ2ZS9zdGVwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvbGluZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtc2hhcGUvc3JjL21hdGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9ub29wLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvcG9pbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvY2lyY2xlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2Nyb3NzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL2RpYW1vbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvc3F1YXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9zcmMvc3ltYm9sL3N0YXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvdHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXNoYXBlL3NyYy9zeW1ib2wvd3llLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lLWZvcm1hdC9zcmMvZGVmYXVsdExvY2FsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvc3JjL2xvY2FsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvZGF5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9kdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvaG91ci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21pbGxpc2Vjb25kLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9taW51dGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL21vbnRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy9zZWNvbmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3RpY2tzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy10aW1lL3NyYy91dGNEYXkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3V0Y0hvdXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3V0Y01pbnV0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZS9zcmMvdXRjTW9udGguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3V0Y1dlZWsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3V0Y1llYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3dlZWsuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWUvc3JjL3llYXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2QzLXRpbWVyL3NyYy9pbnRlcnZhbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtdGltZXIvc3JjL3RpbWVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kZWxhdW5hdG9yL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2Jib3guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvYmlzZWN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvaWRlbnRpdHkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbWVyZ2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbWVzaC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9uZWlnaGJvcnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvcXVhbnRpemUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvcmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9zdGl0Y2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvdHJhbnNmb3JtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3VudHJhbnNmb3JtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWNhbnZhcy9pbmRleC5icm93c2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWNhbnZhcy9zcmMvZG9tQ2FudmFzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWNyb3NzZmlsdGVyL2J1aWxkL3ZlZ2EtY3Jvc3NmaWx0ZXIubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWRhdGFmbG93L2J1aWxkL3ZlZ2EtZGF0YWZsb3cubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWVuY29kZS9idWlsZC92ZWdhLWVuY29kZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZXZlbnQtc2VsZWN0b3IvYnVpbGQvdmVnYS1ldmVudC1zZWxlY3Rvci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZXhwcmVzc2lvbi9idWlsZC92ZWdhLWV4cHJlc3Npb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWZvcmNlL2J1aWxkL3ZlZ2EtZm9yY2UubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWZvcm1hdC9idWlsZC92ZWdhLWZvcm1hdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZnVuY3Rpb25zL2J1aWxkL3ZlZ2EtZnVuY3Rpb25zLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1nZW8vYnVpbGQvdmVnYS1nZW8ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWhpZXJhcmNoeS9idWlsZC92ZWdhLWhpZXJhcmNoeS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtbGFiZWwvYnVpbGQvdmVnYS1sYWJlbC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtbG9hZGVyL2J1aWxkL3ZlZ2EtbG9hZGVyLmJyb3dzZXIubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXBhcnNlci9idWlsZC92ZWdhLXBhcnNlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtcHJvamVjdGlvbi9idWlsZC92ZWdhLXByb2plY3Rpb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXJlZ3Jlc3Npb24vYnVpbGQvdmVnYS1yZWdyZXNzaW9uLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1ydW50aW1lL2J1aWxkL3ZlZ2EtcnVudGltZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NhbGUvYnVpbGQvdmVnYS1zY2FsZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2NlbmVncmFwaC9idWlsZC92ZWdhLXNjZW5lZ3JhcGgubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXNlbGVjdGlvbnMvYnVpbGQvdmVnYS1zZWxlY3Rpb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXN0YXRpc3RpY3MvYnVpbGQvdmVnYS1zdGF0aXN0aWNzLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS10aW1lL2J1aWxkL3ZlZ2EtdGltZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtdHJhbnNmb3Jtcy9idWlsZC92ZWdhLXRyYW5zZm9ybXMubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXZpZXctdHJhbnNmb3Jtcy9idWlsZC92ZWdhLXZpZXctdHJhbnNmb3Jtcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etdmlldy9idWlsZC92ZWdhLXZpZXcubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXZvcm9ub2kvYnVpbGQvdmVnYS12b3Jvbm9pLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS13b3JkY2xvdWQvYnVpbGQvdmVnYS13b3JkY2xvdWQubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhL2J1aWxkL3ZlZ2EubW9kdWxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBZSxvQ0FBUztBQUN4QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRnVDO0FBQ0Y7QUFDSjs7QUFFakMsd0JBQXdCLHFEQUFRLENBQUMsa0RBQVM7QUFDbkM7QUFDQTtBQUNBLHFCQUFxQixxREFBUSxDQUFDLCtDQUFNO0FBQzNDLGlFQUFlLFdBQVcsRUFBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSWTs7QUFFdkMsNkJBQWUsb0NBQVM7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1E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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXOztBQUVYLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0IsZ0RBQUs7QUFDN0Is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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBLGtDQUFrQzs7O0FBR2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUIsaURBQU0sR0FBRztBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxNQUFNLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsNkRBQTZEO0FBQzdEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9wQm9IO0FBQ2pGO0FBQzhWO0FBQzNXO0FBQ0w7QUFDTztBQUNXOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlEQUFLO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVix1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTREOztBQUU1RCxvQkFBb0IscURBQVc7QUFDL0Isd0JBQXdCLHFEQUFXLGlCQUFpQjs7QUFFcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsK0NBQVE7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELGlEQUFNO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlEQUFZLFlBQVksK0NBQUk7QUFDdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGdEQUFLLENBQUMsZ0RBQUs7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnQkFBZ0IsNkNBQWEsRUFBRTs7QUFFL0IsY0FBYyw2Q0FBVztBQUN6QixXQUFXLDZDQUFRO0FBQ25CLFdBQVcsNkNBQVE7QUFDbkIsWUFBWSwwQ0FBUztBQUNyQixjQUFjLDhDQUFXO0FBQ3pCLFlBQVksOENBQVM7QUFDckIsV0FBVyw4Q0FBUSwwQkFBMEI7O0FBRTdDLGtCQUFrQiw4Q0FBZSwrQkFBK0I7O0FBRWhFLGlEQUFpRCw4Q0FBZTtBQUNoRSw4Q0FBOEMsb0RBQWtCO0FBQ2hFLDhDQUE4QyxvREFBa0I7QUFDaEUsK0NBQStDLHFEQUFtQjtBQUNsRSxpREFBaUQsdURBQXFCLCtCQUErQjs7QUFFckcsZ0RBQWdELDhDQUFjO0FBQzlELDZDQUE2QyxtREFBaUI7QUFDOUQsNkNBQTZDLG1EQUFpQjtBQUM5RCw4Q0FBOEMsb0RBQWtCO0FBQ2hFLGdEQUFnRCxzREFBb0IsK0JBQStCOztBQUVuRyxnQkFBZ0IsOENBQWE7QUFDN0IsZ0JBQWdCLDhDQUFhO0FBQzdCLGlCQUFpQiw4Q0FBYyxnQkFBZ0I7O0FBRS9DO0FBQ0EsZUFBZSw2Q0FBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFjO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdEQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixXQUFXOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBUTtBQUNuQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBQztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLGtEQUFPOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFlBQVksRUFBRTtBQUNkOzs7QUFHQTtBQUNBOztBQUVBLE1BQU0sbURBQVE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsK0NBQUk7QUFDN0M7QUFDQTs7QUFFQSxNQUFNLG1EQUFRO0FBQ2Q7QUFDQTtBQUNBOztBQUVBLE1BQU0sbURBQVE7QUFDZCxrQ0FBa0MsdURBQVksOEJBQThCLHNEQUFXLFVBQVUsZ0RBQUs7QUFDdEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixZQUFZLFNBQVM7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVywrQ0FBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQywrQ0FBSTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsRUFBRTtBQUNiLFlBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsRUFBRTtBQUNiLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsT0FBTztBQUNwQjtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSwrQ0FBSTtBQUNuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0NBQUk7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0M7O0FBRXhDLE1BQU0sbURBQVE7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtRUFBbUUsK0NBQUk7QUFDdkU7QUFDQTs7QUFFNGhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqekJ6WTtBQUNrUDtBQUM1VjtBQUNjO0FBQ2xCO0FBQ2tCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdILGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBVTtBQUNyQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFnQjtBQUMzQixHQUFHO0FBQ0g7QUFDQSxXQUFXLDZDQUFjO0FBQ3pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQVc7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQWE7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsNkNBQWlCO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDhDQUFtQjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyw4Q0FBZTtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyw4Q0FBcUI7QUFDaEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQW1CO0FBQzlCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLDhDQUFXO0FBQ3RCLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQWlCO0FBQzVCLEdBQUc7QUFDSDtBQUNBLGdCQUFnQixnREFBYztBQUM5QixjQUFjLGdEQUFjO0FBQzVCLEdBQUc7QUFDSDtBQUNBLFdBQVcsOENBQVk7QUFDdkIsR0FBRztBQUNIO0FBQ0EsV0FBVyw4Q0FBUztBQUNwQixHQUFHO0FBQ0g7QUFDQSxXQUFXLGdEQUFjO0FBQ3pCLEdBQUc7QUFDSDtBQUNBLFdBQVcsaURBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBYztBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhELHFGQUFxRjs7QUFFckYsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQSx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBYztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsT0FBTyx5REFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpREFBTTs7QUFFM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlEQUFNOztBQUVsRCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE1BQU0scURBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkNBQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7O0FB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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUEsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLFlBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0gsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FB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RztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGlEQUFNO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FB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QUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFlO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSxFQUFFOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxFQUFFOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFIOztBQUVySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixPQUFPO0FBQ2hDOztBQUVBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFF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Q0FBRyxFQUFFLDBDQUFPLEVBQUUsNENBQVMsRUFBRSw4Q0FBRSxFQUFFOztBQUUxRjs7QUFFbUIiLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYV9idWlsZF92ZWdhX21vZHVsZV9qcy5hOTE3MDEwOTkwNWRjYWJhOTI1Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuIiwiaW1wb3J0IGFzY2VuZGluZyBmcm9tIFwiLi9hc2NlbmRpbmcuanNcIjtcbmltcG9ydCBiaXNlY3RvciBmcm9tIFwiLi9iaXNlY3Rvci5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuY29uc3QgYXNjZW5kaW5nQmlzZWN0ID0gYmlzZWN0b3IoYXNjZW5kaW5nKTtcbmV4cG9ydCBjb25zdCBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbmV4cG9ydCBjb25zdCBiaXNlY3RMZWZ0ID0gYXNjZW5kaW5nQmlzZWN0LmxlZnQ7XG5leHBvcnQgY29uc3QgYmlzZWN0Q2VudGVyID0gYmlzZWN0b3IobnVtYmVyKS5jZW50ZXI7XG5leHBvcnQgZGVmYXVsdCBiaXNlY3RSaWdodDtcbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGYpIHtcbiAgbGV0IGRlbHRhID0gZjtcbiAgbGV0IGNvbXBhcmUgPSBmO1xuXG4gIGlmIChmLmxlbmd0aCA9PT0gMSkge1xuICAgIGRlbHRhID0gKGQsIHgpID0+IGYoZCkgLSB4O1xuICAgIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGYpO1xuICB9XG5cbiAgZnVuY3Rpb24gbGVmdChhLCB4LCBsbywgaGkpIHtcbiAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSAobG8gKyBoaSkgPj4+IDE7XG4gICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvO1xuICB9XG5cbiAgZnVuY3Rpb24gcmlnaHQoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gKGxvICsgaGkpID4+PiAxO1xuICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRlcihhLCB4LCBsbywgaGkpIHtcbiAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgIGNvbnN0IGkgPSBsZWZ0KGEsIHgsIGxvLCBoaSAtIDEpO1xuICAgIHJldHVybiBpID4gbG8gJiYgZGVsdGEoYVtpIC0gMV0sIHgpID4gLWRlbHRhKGFbaV0sIHgpID8gaSAtIDEgOiBpO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0LCBjZW50ZXIsIHJpZ2h0fTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xufVxuIiwiaW1wb3J0IHZhcmlhbmNlIGZyb20gXCIuL3ZhcmlhbmNlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldmlhdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgdiA9IHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZik7XG4gIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9weXRob24vY3B5dGhvbi9ibG9iL2E3NGVlYTIzOGY1YmFiYTE1Nzk3ZTJlOGI1NzBkMTUzYmM4NjkwYTcvTW9kdWxlcy9tYXRobW9kdWxlLmMjTDE0MjNcbmV4cG9ydCBjbGFzcyBBZGRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3BhcnRpYWxzID0gbmV3IEZsb2F0NjRBcnJheSgzMik7XG4gICAgdGhpcy5fbiA9IDA7XG4gIH1cbiAgYWRkKHgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fcGFydGlhbHM7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fbiAmJiBqIDwgMzI7IGorKykge1xuICAgICAgY29uc3QgeSA9IHBbal0sXG4gICAgICAgIGhpID0geCArIHksXG4gICAgICAgIGxvID0gTWF0aC5hYnMoeCkgPCBNYXRoLmFicyh5KSA/IHggLSAoaGkgLSB5KSA6IHkgLSAoaGkgLSB4KTtcbiAgICAgIGlmIChsbykgcFtpKytdID0gbG87XG4gICAgICB4ID0gaGk7XG4gICAgfVxuICAgIHBbaV0gPSB4O1xuICAgIHRoaXMuX24gPSBpICsgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YWx1ZU9mKCkge1xuICAgIGNvbnN0IHAgPSB0aGlzLl9wYXJ0aWFscztcbiAgICBsZXQgbiA9IHRoaXMuX24sIHgsIHksIGxvLCBoaSA9IDA7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICBoaSA9IHBbLS1uXTtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB4ID0gaGk7XG4gICAgICAgIHkgPSBwWy0tbl07XG4gICAgICAgIGhpID0geCArIHk7XG4gICAgICAgIGxvID0geSAtIChoaSAtIHgpO1xuICAgICAgICBpZiAobG8pIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG4gPiAwICYmICgobG8gPCAwICYmIHBbbiAtIDFdIDwgMCkgfHwgKGxvID4gMCAmJiBwW24gLSAxXSA+IDApKSkge1xuICAgICAgICB5ID0gbG8gKiAyO1xuICAgICAgICB4ID0gaGkgKyB5O1xuICAgICAgICBpZiAoeSA9PSB4IC0gaGkpIGhpID0geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICBjb25zdCBhZGRlciA9IG5ldyBBZGRlcigpO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgYWRkZXIuYWRkKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkge1xuICAgICAgICBhZGRlci5hZGQodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gK2FkZGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmN1bXN1bSh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgY29uc3QgYWRkZXIgPSBuZXcgQWRkZXIoKTtcbiAgbGV0IGluZGV4ID0gLTE7XG4gIHJldHVybiBGbG9hdDY0QXJyYXkuZnJvbSh2YWx1ZXMsIHZhbHVlb2YgPT09IHVuZGVmaW5lZFxuICAgICAgPyB2ID0+IGFkZGVyLmFkZCgrdiB8fCAwKVxuICAgICAgOiB2ID0+IGFkZGVyLmFkZCgrdmFsdWVvZih2LCArK2luZGV4LCB2YWx1ZXMpIHx8IDApXG4gICk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXgodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBtYXg7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGxcbiAgICAgICAgICAmJiAobWF4IDwgdmFsdWUgfHwgKG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcbiAgaWYgKHZhbHVlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICArK2NvdW50LCBzdW0gKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjb3VudCkgcmV0dXJuIHN1bSAvIGNvdW50O1xufVxuIiwiaW1wb3J0IHF1YW50aWxlIGZyb20gXCIuL3F1YW50aWxlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICByZXR1cm4gcXVhbnRpbGUodmFsdWVzLCAwLjUsIHZhbHVlb2YpO1xufVxuIiwiZnVuY3Rpb24qIGZsYXR0ZW4oYXJyYXlzKSB7XG4gIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgeWllbGQqIGFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlKGFycmF5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShmbGF0dGVuKGFycmF5cykpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSAhPSBudWxsXG4gICAgICAgICAgJiYgKG1pbiA+IHZhbHVlIHx8IChtaW4gPT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+PSB2YWx1ZSkpKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9PT0gbnVsbCA/IE5hTiA6ICt4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNvdXJjZSwga2V5cykge1xuICByZXR1cm4gQXJyYXkuZnJvbShrZXlzLCBrZXkgPT4gc291cmNlW2tleV0pO1xufVxuIiwiaW1wb3J0IG1heCBmcm9tIFwiLi9tYXguanNcIjtcbmltcG9ydCBtaW4gZnJvbSBcIi4vbWluLmpzXCI7XG5pbXBvcnQgcXVpY2tzZWxlY3QgZnJvbSBcIi4vcXVpY2tzZWxlY3QuanNcIjtcbmltcG9ydCBudW1iZXIsIHtudW1iZXJzfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVhbnRpbGUodmFsdWVzLCBwLCB2YWx1ZW9mKSB7XG4gIHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnModmFsdWVzLCB2YWx1ZW9mKSk7XG4gIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSkgcmV0dXJuO1xuICBpZiAoKHAgPSArcCkgPD0gMCB8fCBuIDwgMikgcmV0dXJuIG1pbih2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gbWF4KHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gbWF4KHF1aWNrc2VsZWN0KHZhbHVlcywgaTApLnN1YmFycmF5KDAsIGkwICsgMSkpLFxuICAgICAgdmFsdWUxID0gbWluKHZhbHVlcy5zdWJhcnJheShpMCArIDEpKTtcbiAgcmV0dXJuIHZhbHVlMCArICh2YWx1ZTEgLSB2YWx1ZTApICogKGkgLSBpMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIHAsIHZhbHVlb2YgPSBudW1iZXIpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn1cbiIsImltcG9ydCBhc2NlbmRpbmcgZnJvbSBcIi4vYXNjZW5kaW5nLmpzXCI7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3F1aWNrc2VsZWN0XG4vLyBJU0MgbGljZW5zZSwgQ29weXJpZ2h0IDIwMTggVmxhZGltaXIgQWdhZm9ua2luLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyYXksIGssIGxlZnQgPSAwLCByaWdodCA9IGFycmF5Lmxlbmd0aCAtIDEsIGNvbXBhcmUgPSBhc2NlbmRpbmcpIHtcbiAgd2hpbGUgKHJpZ2h0ID4gbGVmdCkge1xuICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBxdWlja3NlbGVjdChhcnJheSwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgIH1cblxuICAgIGNvbnN0IHQgPSBhcnJheVtrXTtcbiAgICBsZXQgaSA9IGxlZnQ7XG4gICAgbGV0IGogPSByaWdodDtcblxuICAgIHN3YXAoYXJyYXksIGxlZnQsIGspO1xuICAgIGlmIChjb21wYXJlKGFycmF5W3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFycmF5LCBsZWZ0LCByaWdodCk7XG5cbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgIHN3YXAoYXJyYXksIGksIGopLCArK2ksIC0tajtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2ldLCB0KSA8IDApICsraTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGFycmF5W2pdLCB0KSA+IDApIC0tajtcbiAgICB9XG5cbiAgICBpZiAoY29tcGFyZShhcnJheVtsZWZ0XSwgdCkgPT09IDApIHN3YXAoYXJyYXksIGxlZnQsIGopO1xuICAgIGVsc2UgKytqLCBzd2FwKGFycmF5LCBqLCByaWdodCk7XG5cbiAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcbiAgY29uc3QgdCA9IGFycmF5W2ldO1xuICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBzdGFydCA9ICtzdGFydCwgc3RvcCA9ICtzdG9wLCBzdGVwID0gKG4gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDIgPyAoc3RvcCA9IHN0YXJ0LCBzdGFydCA9IDAsIDEpIDogbiA8IDMgPyAxIDogK3N0ZXA7XG5cbiAgdmFyIGkgPSAtMSxcbiAgICAgIG4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSkgfCAwLFxuICAgICAgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gIH1cblxuICByZXR1cm4gcmFuZ2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzdW0odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGxldCBzdW0gPSAwO1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWUpIHtcbiAgICAgICAgc3VtICs9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpKSB7XG4gICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cbiIsInZhciBlMTAgPSBNYXRoLnNxcnQoNTApLFxuICAgIGU1ID0gTWF0aC5zcXJ0KDEwKSxcbiAgICBlMiA9IE1hdGguc3FydCgyKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciByZXZlcnNlLFxuICAgICAgaSA9IC0xLFxuICAgICAgbixcbiAgICAgIHRpY2tzLFxuICAgICAgc3RlcDtcblxuICBzdG9wID0gK3N0b3AsIHN0YXJ0ID0gK3N0YXJ0LCBjb3VudCA9ICtjb3VudDtcbiAgaWYgKHN0YXJ0ID09PSBzdG9wICYmIGNvdW50ID4gMCkgcmV0dXJuIFtzdGFydF07XG4gIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KSBuID0gc3RhcnQsIHN0YXJ0ID0gc3RvcCwgc3RvcCA9IG47XG4gIGlmICgoc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSkgPT09IDAgfHwgIWlzRmluaXRlKHN0ZXApKSByZXR1cm4gW107XG5cbiAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAvIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAvIHN0ZXApO1xuICAgIGlmIChyMCAqIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgKiBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpICogc3RlcDtcbiAgfSBlbHNlIHtcbiAgICBzdGVwID0gLXN0ZXA7XG4gICAgbGV0IHIwID0gTWF0aC5yb3VuZChzdGFydCAqIHN0ZXApLCByMSA9IE1hdGgucm91bmQoc3RvcCAqIHN0ZXApO1xuICAgIGlmIChyMCAvIHN0ZXAgPCBzdGFydCkgKytyMDtcbiAgICBpZiAocjEgLyBzdGVwID4gc3RvcCkgLS1yMTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gcjEgLSByMCArIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aWNrc1tpXSA9IChyMCArIGkpIC8gc3RlcDtcbiAgfVxuXG4gIGlmIChyZXZlcnNlKSB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksXG4gICAgICBlcnJvciA9IHN0ZXAgLyBNYXRoLnBvdygxMCwgcG93ZXIpO1xuICByZXR1cm4gcG93ZXIgPj0gMFxuICAgICAgPyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKSAqIE1hdGgucG93KDEwLCBwb3dlcilcbiAgICAgIDogLU1hdGgucG93KDEwLCAtcG93ZXIpIC8gKGVycm9yID49IGUxMCA/IDEwIDogZXJyb3IgPj0gZTUgPyA1IDogZXJyb3IgPj0gZTIgPyAyIDogMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHN0ZXAwID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDAsIGNvdW50KSxcbiAgICAgIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksXG4gICAgICBlcnJvciA9IHN0ZXAwIC8gc3RlcDE7XG4gIGlmIChlcnJvciA+PSBlMTApIHN0ZXAxICo9IDEwO1xuICBlbHNlIGlmIChlcnJvciA+PSBlNSkgc3RlcDEgKj0gNTtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTIpIHN0ZXAxICo9IDI7XG4gIHJldHVybiBzdG9wIDwgc3RhcnQgPyAtc3RlcDEgOiBzdGVwMTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgZGVsdGE7XG4gIGxldCBtZWFuID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGlmICh2YWx1ZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK2NvdW50O1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKSkgIT0gbnVsbCAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKytjb3VudDtcbiAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjb3VudCA+IDEpIHJldHVybiBzdW0gLyAoY291bnQgLSAxKTtcbn1cbiIsImltcG9ydCBkZWZpbmUsIHtleHRlbmR9IGZyb20gXCIuL2RlZmluZS5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG5leHBvcnQgdmFyIGRhcmtlciA9IDAuNztcbmV4cG9ydCB2YXIgYnJpZ2h0ZXIgPSAxIC8gZGFya2VyO1xuXG52YXIgcmVJID0gXCJcXFxccyooWystXT9cXFxcZCspXFxcXHMqXCIsXG4gICAgcmVOID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcXFxccypcIixcbiAgICByZVAgPSBcIlxcXFxzKihbKy1dP1xcXFxkKlxcXFwuP1xcXFxkKyg/OltlRV1bKy1dP1xcXFxkKyk/KSVcXFxccypcIixcbiAgICByZUhleCA9IC9eIyhbMC05YS1mXXszLDh9KSQvLFxuICAgIHJlUmdiSW50ZWdlciA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZUksIHJlSSwgcmVJXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpLFxuICAgIHJlUmdiYUludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYmFcXFxcKFwiICsgW3JlSSwgcmVJLCByZUksIHJlTl0gKyBcIlxcXFwpJFwiKSxcbiAgICByZVJnYmFQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZVAsIHJlUCwgcmVQLCByZU5dICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xQZXJjZW50ID0gbmV3IFJlZ0V4cChcIl5oc2xcXFxcKFwiICsgW3JlTiwgcmVQLCByZVBdICsgXCJcXFxcKSRcIiksXG4gICAgcmVIc2xhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsYVxcXFwoXCIgKyBbcmVOLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xuXG52YXIgbmFtZWQgPSB7XG4gIGFsaWNlYmx1ZTogMHhmMGY4ZmYsXG4gIGFudGlxdWV3aGl0ZTogMHhmYWViZDcsXG4gIGFxdWE6IDB4MDBmZmZmLFxuICBhcXVhbWFyaW5lOiAweDdmZmZkNCxcbiAgYXp1cmU6IDB4ZjBmZmZmLFxuICBiZWlnZTogMHhmNWY1ZGMsXG4gIGJpc3F1ZTogMHhmZmU0YzQsXG4gIGJsYWNrOiAweDAwMDAwMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkLFxuICBibHVlOiAweDAwMDBmZixcbiAgYmx1ZXZpb2xldDogMHg4YTJiZTIsXG4gIGJyb3duOiAweGE1MmEyYSxcbiAgYnVybHl3b29kOiAweGRlYjg4NyxcbiAgY2FkZXRibHVlOiAweDVmOWVhMCxcbiAgY2hhcnRyZXVzZTogMHg3ZmZmMDAsXG4gIGNob2NvbGF0ZTogMHhkMjY5MWUsXG4gIGNvcmFsOiAweGZmN2Y1MCxcbiAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkLFxuICBjb3Juc2lsazogMHhmZmY4ZGMsXG4gIGNyaW1zb246IDB4ZGMxNDNjLFxuICBjeWFuOiAweDAwZmZmZixcbiAgZGFya2JsdWU6IDB4MDAwMDhiLFxuICBkYXJrY3lhbjogMHgwMDhiOGIsXG4gIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiLFxuICBkYXJrZ3JheTogMHhhOWE5YTksXG4gIGRhcmtncmVlbjogMHgwMDY0MDAsXG4gIGRhcmtncmV5OiAweGE5YTlhOSxcbiAgZGFya2toYWtpOiAweGJkYjc2YixcbiAgZGFya21hZ2VudGE6IDB4OGIwMDhiLFxuICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmYsXG4gIGRhcmtvcmFuZ2U6IDB4ZmY4YzAwLFxuICBkYXJrb3JjaGlkOiAweDk5MzJjYyxcbiAgZGFya3JlZDogMHg4YjAwMDAsXG4gIGRhcmtzYWxtb246IDB4ZTk5NjdhLFxuICBkYXJrc2VhZ3JlZW46IDB4OGZiYzhmLFxuICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YixcbiAgZGFya3NsYXRlZ3JheTogMHgyZjRmNGYsXG4gIGRhcmtzbGF0ZWdyZXk6IDB4MmY0ZjRmLFxuICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMSxcbiAgZGFya3Zpb2xldDogMHg5NDAwZDMsXG4gIGRlZXBwaW5rOiAweGZmMTQ5MyxcbiAgZGVlcHNreWJsdWU6IDB4MDBiZmZmLFxuICBkaW1ncmF5OiAweDY5Njk2OSxcbiAgZGltZ3JleTogMHg2OTY5NjksXG4gIGRvZGdlcmJsdWU6IDB4MWU5MGZmLFxuICBmaXJlYnJpY2s6IDB4YjIyMjIyLFxuICBmbG9yYWx3aGl0ZTogMHhmZmZhZjAsXG4gIGZvcmVzdGdyZWVuOiAweDIyOGIyMixcbiAgZnVjaHNpYTogMHhmZjAwZmYsXG4gIGdhaW5zYm9ybzogMHhkY2RjZGMsXG4gIGdob3N0d2hpdGU6IDB4ZjhmOGZmLFxuICBnb2xkOiAweGZmZDcwMCxcbiAgZ29sZGVucm9kOiAweGRhYTUyMCxcbiAgZ3JheTogMHg4MDgwODAsXG4gIGdyZWVuOiAweDAwODAwMCxcbiAgZ3JlZW55ZWxsb3c6IDB4YWRmZjJmLFxuICBncmV5OiAweDgwODA4MCxcbiAgaG9uZXlkZXc6IDB4ZjBmZmYwLFxuICBob3RwaW5rOiAweGZmNjliNCxcbiAgaW5kaWFucmVkOiAweGNkNWM1YyxcbiAgaW5kaWdvOiAweDRiMDA4MixcbiAgaXZvcnk6IDB4ZmZmZmYwLFxuICBraGFraTogMHhmMGU2OGMsXG4gIGxhdmVuZGVyOiAweGU2ZTZmYSxcbiAgbGF2ZW5kZXJibHVzaDogMHhmZmYwZjUsXG4gIGxhd25ncmVlbjogMHg3Y2ZjMDAsXG4gIGxlbW9uY2hpZmZvbjogMHhmZmZhY2QsXG4gIGxpZ2h0Ymx1ZTogMHhhZGQ4ZTYsXG4gIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwLFxuICBsaWdodGN5YW46IDB4ZTBmZmZmLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMHhmYWZhZDIsXG4gIGxpZ2h0Z3JheTogMHhkM2QzZDMsXG4gIGxpZ2h0Z3JlZW46IDB4OTBlZTkwLFxuICBsaWdodGdyZXk6IDB4ZDNkM2QzLFxuICBsaWdodHBpbms6IDB4ZmZiNmMxLFxuICBsaWdodHNhbG1vbjogMHhmZmEwN2EsXG4gIGxpZ2h0c2VhZ3JlZW46IDB4MjBiMmFhLFxuICBsaWdodHNreWJsdWU6IDB4ODdjZWZhLFxuICBsaWdodHNsYXRlZ3JheTogMHg3Nzg4OTksXG4gIGxpZ2h0c2xhdGVncmV5OiAweDc3ODg5OSxcbiAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlLFxuICBsaWdodHllbGxvdzogMHhmZmZmZTAsXG4gIGxpbWU6IDB4MDBmZjAwLFxuICBsaW1lZ3JlZW46IDB4MzJjZDMyLFxuICBsaW5lbjogMHhmYWYwZTYsXG4gIG1hZ2VudGE6IDB4ZmYwMGZmLFxuICBtYXJvb246IDB4ODAwMDAwLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAweDY2Y2RhYSxcbiAgbWVkaXVtYmx1ZTogMHgwMDAwY2QsXG4gIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDMsXG4gIG1lZGl1bXB1cnBsZTogMHg5MzcwZGIsXG4gIG1lZGl1bXNlYWdyZWVuOiAweDNjYjM3MSxcbiAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IDB4MDBmYTlhLFxuICBtZWRpdW10dXJxdW9pc2U6IDB4NDhkMWNjLFxuICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1LFxuICBtaWRuaWdodGJsdWU6IDB4MTkxOTcwLFxuICBtaW50Y3JlYW06IDB4ZjVmZmZhLFxuICBtaXN0eXJvc2U6IDB4ZmZlNGUxLFxuICBtb2NjYXNpbjogMHhmZmU0YjUsXG4gIG5hdmFqb3doaXRlOiAweGZmZGVhZCxcbiAgbmF2eTogMHgwMDAwODAsXG4gIG9sZGxhY2U6IDB4ZmRmNWU2LFxuICBvbGl2ZTogMHg4MDgwMDAsXG4gIG9saXZlZHJhYjogMHg2YjhlMjMsXG4gIG9yYW5nZTogMHhmZmE1MDAsXG4gIG9yYW5nZXJlZDogMHhmZjQ1MDAsXG4gIG9yY2hpZDogMHhkYTcwZDYsXG4gIHBhbGVnb2xkZW5yb2Q6IDB4ZWVlOGFhLFxuICBwYWxlZ3JlZW46IDB4OThmYjk4LFxuICBwYWxldHVycXVvaXNlOiAweGFmZWVlZSxcbiAgcGFsZXZpb2xldHJlZDogMHhkYjcwOTMsXG4gIHBhcGF5YXdoaXA6IDB4ZmZlZmQ1LFxuICBwZWFjaHB1ZmY6IDB4ZmZkYWI5LFxuICBwZXJ1OiAweGNkODUzZixcbiAgcGluazogMHhmZmMwY2IsXG4gIHBsdW06IDB4ZGRhMGRkLFxuICBwb3dkZXJibHVlOiAweGIwZTBlNixcbiAgcHVycGxlOiAweDgwMDA4MCxcbiAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTksXG4gIHJlZDogMHhmZjAwMDAsXG4gIHJvc3licm93bjogMHhiYzhmOGYsXG4gIHJveWFsYmx1ZTogMHg0MTY5ZTEsXG4gIHNhZGRsZWJyb3duOiAweDhiNDUxMyxcbiAgc2FsbW9uOiAweGZhODA3MixcbiAgc2FuZHlicm93bjogMHhmNGE0NjAsXG4gIHNlYWdyZWVuOiAweDJlOGI1NyxcbiAgc2Vhc2hlbGw6IDB4ZmZmNWVlLFxuICBzaWVubmE6IDB4YTA1MjJkLFxuICBzaWx2ZXI6IDB4YzBjMGMwLFxuICBza3libHVlOiAweDg3Y2VlYixcbiAgc2xhdGVibHVlOiAweDZhNWFjZCxcbiAgc2xhdGVncmF5OiAweDcwODA5MCxcbiAgc2xhdGVncmV5OiAweDcwODA5MCxcbiAgc25vdzogMHhmZmZhZmEsXG4gIHNwcmluZ2dyZWVuOiAweDAwZmY3ZixcbiAgc3RlZWxibHVlOiAweDQ2ODJiNCxcbiAgdGFuOiAweGQyYjQ4YyxcbiAgdGVhbDogMHgwMDgwODAsXG4gIHRoaXN0bGU6IDB4ZDhiZmQ4LFxuICB0b21hdG86IDB4ZmY2MzQ3LFxuICB0dXJxdW9pc2U6IDB4NDBlMGQwLFxuICB2aW9sZXQ6IDB4ZWU4MmVlLFxuICB3aGVhdDogMHhmNWRlYjMsXG4gIHdoaXRlOiAweGZmZmZmZixcbiAgd2hpdGVzbW9rZTogMHhmNWY1ZjUsXG4gIHllbGxvdzogMHhmZmZmMDAsXG4gIHllbGxvd2dyZWVuOiAweDlhY2QzMlxufTtcblxuZGVmaW5lKENvbG9yLCBjb2xvciwge1xuICBjb3B5OiBmdW5jdGlvbihjaGFubmVscykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyB0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLCBjaGFubmVscyk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKS5kaXNwbGF5YWJsZSgpO1xuICB9LFxuICBoZXg6IGNvbG9yX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiBjb2xvcl9mb3JtYXRIZXgsXG4gIGZvcm1hdEhzbDogY29sb3JfZm9ybWF0SHNsLFxuICBmb3JtYXRSZ2I6IGNvbG9yX2Zvcm1hdFJnYixcbiAgdG9TdHJpbmc6IGNvbG9yX2Zvcm1hdFJnYlxufSk7XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhleCgpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0SGV4KCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdEhzbCgpIHtcbiAgcmV0dXJuIGhzbENvbnZlcnQodGhpcykuZm9ybWF0SHNsKCk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yX2Zvcm1hdFJnYigpIHtcbiAgcmV0dXJuIHRoaXMucmdiKCkuZm9ybWF0UmdiKCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbG9yKGZvcm1hdCkge1xuICB2YXIgbSwgbDtcbiAgZm9ybWF0ID0gKGZvcm1hdCArIFwiXCIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKG0gPSByZUhleC5leGVjKGZvcm1hdCkpID8gKGwgPSBtWzFdLmxlbmd0aCwgbSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbCA9PT0gNiA/IHJnYm4obSkgLy8gI2ZmMDAwMFxuICAgICAgOiBsID09PSAzID8gbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweGYwKSwgKG0gPj4gNCAmIDB4ZikgfCAobSAmIDB4ZjApLCAoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpLCAxKSAvLyAjZjAwXG4gICAgICA6IGwgPT09IDggPyByZ2JhKG0gPj4gMjQgJiAweGZmLCBtID4+IDE2ICYgMHhmZiwgbSA+PiA4ICYgMHhmZiwgKG0gJiAweGZmKSAvIDB4ZmYpIC8vICNmZjAwMDAwMFxuICAgICAgOiBsID09PSA0ID8gcmdiYSgobSA+PiAxMiAmIDB4ZikgfCAobSA+PiA4ICYgMHhmMCksIChtID4+IDggJiAweGYpIHwgKG0gPj4gNCAmIDB4ZjApLCAobSA+PiA0ICYgMHhmKSB8IChtICYgMHhmMCksICgoKG0gJiAweGYpIDw8IDQpIHwgKG0gJiAweGYpKSAvIDB4ZmYpIC8vICNmMDAwXG4gICAgICA6IG51bGwpIC8vIGludmFsaWQgaGV4XG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiQ29udmVydChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IFJnYjtcbiAgbyA9IG8ucmdiKCk7XG4gIHJldHVybiBuZXcgUmdiKG8uciwgby5nLCBvLmIsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IociwgZywgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHJnYkNvbnZlcnQocikgOiBuZXcgUmdiKHIsIGcsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgtMC41IDw9IHRoaXMuciAmJiB0aGlzLnIgPCAyNTUuNSlcbiAgICAgICAgJiYgKC0wLjUgPD0gdGhpcy5nICYmIHRoaXMuZyA8IDI1NS41KVxuICAgICAgICAmJiAoLTAuNSA8PSB0aGlzLmIgJiYgdGhpcy5iIDwgMjU1LjUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogcmdiX2Zvcm1hdEhleCwgLy8gRGVwcmVjYXRlZCEgVXNlIGNvbG9yLmZvcm1hdEhleC5cbiAgZm9ybWF0SGV4OiByZ2JfZm9ybWF0SGV4LFxuICBmb3JtYXRSZ2I6IHJnYl9mb3JtYXRSZ2IsXG4gIHRvU3RyaW5nOiByZ2JfZm9ybWF0UmdiXG59KSk7XG5cbmZ1bmN0aW9uIHJnYl9mb3JtYXRIZXgoKSB7XG4gIHJldHVybiBcIiNcIiArIGhleCh0aGlzLnIpICsgaGV4KHRoaXMuZykgKyBoZXgodGhpcy5iKTtcbn1cblxuZnVuY3Rpb24gcmdiX2Zvcm1hdFJnYigpIHtcbiAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gIHJldHVybiAoYSA9PT0gMSA/IFwicmdiKFwiIDogXCJyZ2JhKFwiKVxuICAgICAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5yKSB8fCAwKSkgKyBcIiwgXCJcbiAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICArIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmIpIHx8IDApKVxuICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbn1cblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHNsQ29udmVydChvKSB7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbmV3IEhzbChvLmgsIG8ucywgby5sLCBvLm9wYWNpdHkpO1xuICBpZiAoIShvIGluc3RhbmNlb2YgQ29sb3IpKSBvID0gY29sb3Iobyk7XG4gIGlmICghbykgcmV0dXJuIG5ldyBIc2w7XG4gIGlmIChvIGluc3RhbmNlb2YgSHNsKSByZXR1cm4gbztcbiAgbyA9IG8ucmdiKCk7XG4gIHZhciByID0gby5yIC8gMjU1LFxuICAgICAgZyA9IG8uZyAvIDI1NSxcbiAgICAgIGIgPSBvLmIgLyAyNTUsXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuICAgICAgaCA9IE5hTixcbiAgICAgIHMgPSBtYXggLSBtaW4sXG4gICAgICBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAocykge1xuICAgIGlmIChyID09PSBtYXgpIGggPSAoZyAtIGIpIC8gcyArIChnIDwgYikgKiA2O1xuICAgIGVsc2UgaWYgKGcgPT09IG1heCkgaCA9IChiIC0gcikgLyBzICsgMjtcbiAgICBlbHNlIGggPSAociAtIGcpIC8gcyArIDQ7XG4gICAgcyAvPSBsIDwgMC41ID8gbWF4ICsgbWluIDogMiAtIG1heCAtIG1pbjtcbiAgICBoICo9IDYwO1xuICB9IGVsc2Uge1xuICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICB9XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc2woaCwgcywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhzbENvbnZlcnQoaCkgOiBuZXcgSHNsKGgsIHMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gSHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShIc2wsIGhzbCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgSHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuaCAlIDM2MCArICh0aGlzLmggPCAwKSAqIDM2MCxcbiAgICAgICAgcyA9IGlzTmFOKGgpIHx8IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zLFxuICAgICAgICBsID0gdGhpcy5sLFxuICAgICAgICBtMiA9IGwgKyAobCA8IDAuNSA/IGwgOiAxIC0gbCkgKiBzLFxuICAgICAgICBtMSA9IDIgKiBsIC0gbTI7XG4gICAgcmV0dXJuIG5ldyBSZ2IoXG4gICAgICBoc2wycmdiKGggPj0gMjQwID8gaCAtIDI0MCA6IGggKyAxMjAsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGgsIG0xLCBtMiksXG4gICAgICBoc2wycmdiKGggPCAxMjAgPyBoICsgMjQwIDogaCAtIDEyMCwgbTEsIG0yKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH0sXG4gIGRpc3BsYXlhYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKDAgPD0gdGhpcy5zICYmIHRoaXMucyA8PSAxIHx8IGlzTmFOKHRoaXMucykpXG4gICAgICAgICYmICgwIDw9IHRoaXMubCAmJiB0aGlzLmwgPD0gMSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5vcGFjaXR5ICYmIHRoaXMub3BhY2l0eSA8PSAxKTtcbiAgfSxcbiAgZm9ybWF0SHNsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYSA9IHRoaXMub3BhY2l0eTsgYSA9IGlzTmFOKGEpID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKTtcbiAgICByZXR1cm4gKGEgPT09IDEgPyBcImhzbChcIiA6IFwiaHNsYShcIilcbiAgICAgICAgKyAodGhpcy5oIHx8IDApICsgXCIsIFwiXG4gICAgICAgICsgKHRoaXMucyB8fCAwKSAqIDEwMCArIFwiJSwgXCJcbiAgICAgICAgKyAodGhpcy5sIHx8IDApICogMTAwICsgXCIlXCJcbiAgICAgICAgKyAoYSA9PT0gMSA/IFwiKVwiIDogXCIsIFwiICsgYSArIFwiKVwiKTtcbiAgfVxufSkpO1xuXG4vKiBGcm9tIEZ2RCAxMy4zNywgQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCAzICovXG5mdW5jdGlvbiBoc2wycmdiKGgsIG0xLCBtMikge1xuICByZXR1cm4gKGggPCA2MCA/IG0xICsgKG0yIC0gbTEpICogaCAvIDYwXG4gICAgICA6IGggPCAxODAgPyBtMlxuICAgICAgOiBoIDwgMjQwID8gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MFxuICAgICAgOiBtMSkgKiAyNTU7XG59XG4iLCJpbXBvcnQgZGVmaW5lLCB7ZXh0ZW5kfSBmcm9tIFwiLi9kZWZpbmUuanNcIjtcbmltcG9ydCB7Q29sb3IsIHJnYkNvbnZlcnQsIFJnYiwgZGFya2VyLCBicmlnaHRlcn0gZnJvbSBcIi4vY29sb3IuanNcIjtcbmltcG9ydCB7ZGVncmVlcywgcmFkaWFuc30gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG52YXIgQSA9IC0wLjE0ODYxLFxuICAgIEIgPSArMS43ODI3NyxcbiAgICBDID0gLTAuMjkyMjcsXG4gICAgRCA9IC0wLjkwNjQ5LFxuICAgIEUgPSArMS45NzI5NCxcbiAgICBFRCA9IEUgKiBELFxuICAgIEVCID0gRSAqIEIsXG4gICAgQkNfREEgPSBCICogQyAtIEQgKiBBO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXhDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBDdWJlaGVsaXgpIHJldHVybiBuZXcgQ3ViZWhlbGl4KG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBSZ2IpKSBvID0gcmdiQ29udmVydChvKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIGwgPSAoQkNfREEgKiBiICsgRUQgKiByIC0gRUIgKiBnKSAvIChCQ19EQSArIEVEIC0gRUIpLFxuICAgICAgYmwgPSBiIC0gbCxcbiAgICAgIGsgPSAoRSAqIChnIC0gbCkgLSBDICogYmwpIC8gRCxcbiAgICAgIHMgPSBNYXRoLnNxcnQoayAqIGsgKyBibCAqIGJsKSAvIChFICogbCAqICgxIC0gbCkpLCAvLyBOYU4gaWYgbD0wIG9yIGw9MVxuICAgICAgaCA9IHMgPyBNYXRoLmF0YW4yKGssIGJsKSAqIGRlZ3JlZXMgLSAxMjAgOiBOYU47XG4gIHJldHVybiBuZXcgQ3ViZWhlbGl4KGggPCAwID8gaCArIDM2MCA6IGgsIHMsIGwsIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gY3ViZWhlbGl4Q29udmVydChoKSA6IG5ldyBDdWJlaGVsaXgoaCwgcywgbCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgdGhpcy5oID0gK2g7XG4gIHRoaXMucyA9ICtzO1xuICB0aGlzLmwgPSArbDtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShDdWJlaGVsaXgsIGN1YmVoZWxpeCwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGJyaWdodGVyIDogTWF0aC5wb3coYnJpZ2h0ZXIsIGspO1xuICAgIHJldHVybiBuZXcgQ3ViZWhlbGl4KHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IGlzTmFOKHRoaXMuaCkgPyAwIDogKHRoaXMuaCArIDEyMCkgKiByYWRpYW5zLFxuICAgICAgICBsID0gK3RoaXMubCxcbiAgICAgICAgYSA9IGlzTmFOKHRoaXMucykgPyAwIDogdGhpcy5zICogbCAqICgxIC0gbCksXG4gICAgICAgIGNvc2ggPSBNYXRoLmNvcyhoKSxcbiAgICAgICAgc2luaCA9IE1hdGguc2luKGgpO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgMjU1ICogKGwgKyBhICogKEEgKiBjb3NoICsgQiAqIHNpbmgpKSxcbiAgICAgIDI1NSAqIChsICsgYSAqIChDICogY29zaCArIEQgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoRSAqIGNvc2gpKSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBmYWN0b3J5LCBwcm90b3R5cGUpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gZmFjdG9yeS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIHByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHBhcmVudCwgZGVmaW5pdGlvbikge1xuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQucHJvdG90eXBlKTtcbiAgZm9yICh2YXIga2V5IGluIGRlZmluaXRpb24pIHByb3RvdHlwZVtrZXldID0gZGVmaW5pdGlvbltrZXldO1xuICByZXR1cm4gcHJvdG90eXBlO1xufVxuIiwiaW1wb3J0IGRlZmluZSwge2V4dGVuZH0gZnJvbSBcIi4vZGVmaW5lLmpzXCI7XG5pbXBvcnQge0NvbG9yLCByZ2JDb252ZXJ0LCBSZ2J9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5pbXBvcnQge2RlZ3JlZXMsIHJhZGlhbnN9IGZyb20gXCIuL21hdGguanNcIjtcblxuLy8gaHR0cHM6Ly9vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxuY29uc3QgSyA9IDE4LFxuICAgIFhuID0gMC45NjQyMixcbiAgICBZbiA9IDEsXG4gICAgWm4gPSAwLjgyNTIxLFxuICAgIHQwID0gNCAvIDI5LFxuICAgIHQxID0gNiAvIDI5LFxuICAgIHQyID0gMyAqIHQxICogdDEsXG4gICAgdDMgPSB0MSAqIHQxICogdDE7XG5cbmZ1bmN0aW9uIGxhYkNvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIExhYikgcmV0dXJuIG5ldyBMYWIoby5sLCBvLmEsIG8uYiwgby5vcGFjaXR5KTtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBoY2wybGFiKG8pO1xuICBpZiAoIShvIGluc3RhbmNlb2YgUmdiKSkgbyA9IHJnYkNvbnZlcnQobyk7XG4gIHZhciByID0gcmdiMmxyZ2Ioby5yKSxcbiAgICAgIGcgPSByZ2IybHJnYihvLmcpLFxuICAgICAgYiA9IHJnYjJscmdiKG8uYiksXG4gICAgICB5ID0geHl6MmxhYigoMC4yMjI1MDQ1ICogciArIDAuNzE2ODc4NiAqIGcgKyAwLjA2MDYxNjkgKiBiKSAvIFluKSwgeCwgejtcbiAgaWYgKHIgPT09IGcgJiYgZyA9PT0gYikgeCA9IHogPSB5OyBlbHNlIHtcbiAgICB4ID0geHl6MmxhYigoMC40MzYwNzQ3ICogciArIDAuMzg1MDY0OSAqIGcgKyAwLjE0MzA4MDQgKiBiKSAvIFhuKTtcbiAgICB6ID0geHl6MmxhYigoMC4wMTM5MzIyICogciArIDAuMDk3MTA0NSAqIGcgKyAwLjcxNDE3MzMgKiBiKSAvIFpuKTtcbiAgfVxuICByZXR1cm4gbmV3IExhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geiksIG8ub3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExhYihsLCBhLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMubCA9ICtsO1xuICB0aGlzLmEgPSArYTtcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoTGFiLCBsYWIsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgTGFiKHRoaXMubCArIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sIC0gSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ID0gKHRoaXMubCArIDE2KSAvIDExNixcbiAgICAgICAgeCA9IGlzTmFOKHRoaXMuYSkgPyB5IDogeSArIHRoaXMuYSAvIDUwMCxcbiAgICAgICAgeiA9IGlzTmFOKHRoaXMuYikgPyB5IDogeSAtIHRoaXMuYiAvIDIwMDtcbiAgICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICAgIHkgPSBZbiAqIGxhYjJ4eXooeSk7XG4gICAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIGxyZ2IycmdiKCAzLjEzMzg1NjEgKiB4IC0gMS42MTY4NjY3ICogeSAtIDAuNDkwNjE0NiAqIHopLFxuICAgICAgbHJnYjJyZ2IoLTAuOTc4NzY4NCAqIHggKyAxLjkxNjE0MTUgKiB5ICsgMC4wMzM0NTQwICogeiksXG4gICAgICBscmdiMnJnYiggMC4wNzE5NDUzICogeCAtIDAuMjI4OTkxNCAqIHkgKyAxLjQwNTI0MjcgKiB6KSxcbiAgICAgIHRoaXMub3BhY2l0eVxuICAgICk7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiBscmdiMnJnYih4KSB7XG4gIHJldHVybiAyNTUgKiAoeCA8PSAwLjAwMzEzMDggPyAxMi45MiAqIHggOiAxLjA1NSAqIE1hdGgucG93KHgsIDEgLyAyLjQpIC0gMC4wNTUpO1xufVxuXG5mdW5jdGlvbiByZ2IybHJnYih4KSB7XG4gIHJldHVybiAoeCAvPSAyNTUpIDw9IDAuMDQwNDUgPyB4IC8gMTIuOTIgOiBNYXRoLnBvdygoeCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBoY2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIY2wpIHJldHVybiBuZXcgSGNsKG8uaCwgby5jLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMYWIpKSBvID0gbGFiQ29udmVydChvKTtcbiAgaWYgKG8uYSA9PT0gMCAmJiBvLmIgPT09IDApIHJldHVybiBuZXcgSGNsKE5hTiwgMCA8IG8ubCAmJiBvLmwgPCAxMDAgPyAwIDogTmFOLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiBkZWdyZWVzO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGNoKGwsIGMsIGgsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGwpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoY2woaCwgYywgbCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQoaCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5mdW5jdGlvbiBoY2wybGFiKG8pIHtcbiAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgdmFyIGggPSBvLmggKiByYWRpYW5zO1xuICByZXR1cm4gbmV3IExhYihvLmwsIE1hdGguY29zKGgpICogby5jLCBNYXRoLnNpbihoKSAqIG8uYywgby5vcGFjaXR5KTtcbn1cblxuZGVmaW5lKEhjbCwgaGNsLCBleHRlbmQoQ29sb3IsIHtcbiAgYnJpZ2h0ZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IEhjbCh0aGlzLmgsIHRoaXMuYywgdGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIGRhcmtlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgcmdiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaGNsMmxhYih0aGlzKS5yZ2IoKTtcbiAgfVxufSkpO1xuIiwiZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuIiwiaW1wb3J0IERlbGF1bmF0b3IgZnJvbSBcImRlbGF1bmF0b3JcIjtcbmltcG9ydCBQYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbmltcG9ydCBQb2x5Z29uIGZyb20gXCIuL3BvbHlnb24uanNcIjtcbmltcG9ydCBWb3Jvbm9pIGZyb20gXCIuL3Zvcm9ub2kuanNcIjtcblxuY29uc3QgdGF1ID0gMiAqIE1hdGguUEksIHBvdyA9IE1hdGgucG93O1xuXG5mdW5jdGlvbiBwb2ludFgocCkge1xuICByZXR1cm4gcFswXTtcbn1cblxuZnVuY3Rpb24gcG9pbnRZKHApIHtcbiAgcmV0dXJuIHBbMV07XG59XG5cbi8vIEEgdHJpYW5ndWxhdGlvbiBpcyBjb2xsaW5lYXIgaWYgYWxsIGl0cyB0cmlhbmdsZXMgaGF2ZSBhIG5vbi1udWxsIGFyZWFcbmZ1bmN0aW9uIGNvbGxpbmVhcihkKSB7XG4gIGNvbnN0IHt0cmlhbmdsZXMsIGNvb3Jkc30gPSBkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNvbnN0IGEgPSAyICogdHJpYW5nbGVzW2ldLFxuICAgICAgICAgIGIgPSAyICogdHJpYW5nbGVzW2kgKyAxXSxcbiAgICAgICAgICBjID0gMiAqIHRyaWFuZ2xlc1tpICsgMl0sXG4gICAgICAgICAgY3Jvc3MgPSAoY29vcmRzW2NdIC0gY29vcmRzW2FdKSAqIChjb29yZHNbYiArIDFdIC0gY29vcmRzW2EgKyAxXSlcbiAgICAgICAgICAgICAgICAtIChjb29yZHNbYl0gLSBjb29yZHNbYV0pICogKGNvb3Jkc1tjICsgMV0gLSBjb29yZHNbYSArIDFdKTtcbiAgICBpZiAoY3Jvc3MgPiAxZS0xMCkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBqaXR0ZXIoeCwgeSwgcikge1xuICByZXR1cm4gW3ggKyBNYXRoLnNpbih4ICsgeSkgKiByLCB5ICsgTWF0aC5jb3MoeCAtIHkpICogcl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlbGF1bmF5IHtcbiAgc3RhdGljIGZyb20ocG9pbnRzLCBmeCA9IHBvaW50WCwgZnkgPSBwb2ludFksIHRoYXQpIHtcbiAgICByZXR1cm4gbmV3IERlbGF1bmF5KFwibGVuZ3RoXCIgaW4gcG9pbnRzXG4gICAgICAgID8gZmxhdEFycmF5KHBvaW50cywgZngsIGZ5LCB0aGF0KVxuICAgICAgICA6IEZsb2F0NjRBcnJheS5mcm9tKGZsYXRJdGVyYWJsZShwb2ludHMsIGZ4LCBmeSwgdGhhdCkpKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcbiAgICB0aGlzLl9kZWxhdW5hdG9yID0gbmV3IERlbGF1bmF0b3IocG9pbnRzKTtcbiAgICB0aGlzLmluZWRnZXMgPSBuZXcgSW50MzJBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgdGhpcy5faHVsbEluZGV4ID0gbmV3IEludDMyQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgIHRoaXMucG9pbnRzID0gdGhpcy5fZGVsYXVuYXRvci5jb29yZHM7XG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9kZWxhdW5hdG9yLnVwZGF0ZSgpO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdCgpIHtcbiAgICBjb25zdCBkID0gdGhpcy5fZGVsYXVuYXRvciwgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cbiAgICAvLyBjaGVjayBmb3IgY29sbGluZWFyXG4gICAgaWYgKGQuaHVsbCAmJiBkLmh1bGwubGVuZ3RoID4gMiAmJiBjb2xsaW5lYXIoZCkpIHtcbiAgICAgIHRoaXMuY29sbGluZWFyID0gSW50MzJBcnJheS5mcm9tKHtsZW5ndGg6IHBvaW50cy5sZW5ndGgvMn0sIChfLGkpID0+IGkpXG4gICAgICAgIC5zb3J0KChpLCBqKSA9PiBwb2ludHNbMiAqIGldIC0gcG9pbnRzWzIgKiBqXSB8fCBwb2ludHNbMiAqIGkgKyAxXSAtIHBvaW50c1syICogaiArIDFdKTsgLy8gZm9yIGV4YWN0IG5laWdoYm9yc1xuICAgICAgY29uc3QgZSA9IHRoaXMuY29sbGluZWFyWzBdLCBmID0gdGhpcy5jb2xsaW5lYXJbdGhpcy5jb2xsaW5lYXIubGVuZ3RoIC0gMV0sXG4gICAgICAgIGJvdW5kcyA9IFsgcG9pbnRzWzIgKiBlXSwgcG9pbnRzWzIgKiBlICsgMV0sIHBvaW50c1syICogZl0sIHBvaW50c1syICogZiArIDFdIF0sXG4gICAgICAgIHIgPSAxZS04ICogTWF0aC5oeXBvdChib3VuZHNbM10gLSBib3VuZHNbMV0sIGJvdW5kc1syXSAtIGJvdW5kc1swXSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGggLyAyOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IHAgPSBqaXR0ZXIocG9pbnRzWzIgKiBpXSwgcG9pbnRzWzIgKiBpICsgMV0sIHIpO1xuICAgICAgICBwb2ludHNbMiAqIGldID0gcFswXTtcbiAgICAgICAgcG9pbnRzWzIgKiBpICsgMV0gPSBwWzFdO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGVsYXVuYXRvciA9IG5ldyBEZWxhdW5hdG9yKHBvaW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbGxpbmVhcjtcbiAgICB9XG5cbiAgICBjb25zdCBoYWxmZWRnZXMgPSB0aGlzLmhhbGZlZGdlcyA9IHRoaXMuX2RlbGF1bmF0b3IuaGFsZmVkZ2VzO1xuICAgIGNvbnN0IGh1bGwgPSB0aGlzLmh1bGwgPSB0aGlzLl9kZWxhdW5hdG9yLmh1bGw7XG4gICAgY29uc3QgdHJpYW5nbGVzID0gdGhpcy50cmlhbmdsZXMgPSB0aGlzLl9kZWxhdW5hdG9yLnRyaWFuZ2xlcztcbiAgICBjb25zdCBpbmVkZ2VzID0gdGhpcy5pbmVkZ2VzLmZpbGwoLTEpO1xuICAgIGNvbnN0IGh1bGxJbmRleCA9IHRoaXMuX2h1bGxJbmRleC5maWxsKC0xKTtcblxuICAgIC8vIENvbXB1dGUgYW4gaW5kZXggZnJvbSBlYWNoIHBvaW50IHRvIGFuIChhcmJpdHJhcnkpIGluY29taW5nIGhhbGZlZGdlXG4gICAgLy8gVXNlZCB0byBnaXZlIHRoZSBmaXJzdCBuZWlnaGJvciBvZiBlYWNoIHBvaW50OyBmb3IgdGhpcyByZWFzb24sXG4gICAgLy8gb24gdGhlIGh1bGwgd2UgZ2l2ZSBwcmlvcml0eSB0byBleHRlcmlvciBoYWxmZWRnZXNcbiAgICBmb3IgKGxldCBlID0gMCwgbiA9IGhhbGZlZGdlcy5sZW5ndGg7IGUgPCBuOyArK2UpIHtcbiAgICAgIGNvbnN0IHAgPSB0cmlhbmdsZXNbZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxXTtcbiAgICAgIGlmIChoYWxmZWRnZXNbZV0gPT09IC0xIHx8IGluZWRnZXNbcF0gPT09IC0xKSBpbmVkZ2VzW3BdID0gZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBodWxsLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaHVsbEluZGV4W2h1bGxbaV1dID0gaTtcbiAgICB9XG5cbiAgICAvLyBkZWdlbmVyYXRlIGNhc2U6IDEgb3IgMiAoZGlzdGluY3QpIHBvaW50c1xuICAgIGlmIChodWxsLmxlbmd0aCA8PSAyICYmIGh1bGwubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy50cmlhbmdsZXMgPSBuZXcgSW50MzJBcnJheSgzKS5maWxsKC0xKTtcbiAgICAgIHRoaXMuaGFsZmVkZ2VzID0gbmV3IEludDMyQXJyYXkoMykuZmlsbCgtMSk7XG4gICAgICB0aGlzLnRyaWFuZ2xlc1swXSA9IGh1bGxbMF07XG4gICAgICB0aGlzLnRyaWFuZ2xlc1sxXSA9IGh1bGxbMV07XG4gICAgICB0aGlzLnRyaWFuZ2xlc1syXSA9IGh1bGxbMV07XG4gICAgICBpbmVkZ2VzW2h1bGxbMF1dID0gMTtcbiAgICAgIGlmIChodWxsLmxlbmd0aCA9PT0gMikgaW5lZGdlc1todWxsWzFdXSA9IDA7XG4gICAgfVxuICB9XG4gIHZvcm9ub2koYm91bmRzKSB7XG4gICAgcmV0dXJuIG5ldyBWb3Jvbm9pKHRoaXMsIGJvdW5kcyk7XG4gIH1cbiAgKm5laWdoYm9ycyhpKSB7XG4gICAgY29uc3Qge2luZWRnZXMsIGh1bGwsIF9odWxsSW5kZXgsIGhhbGZlZGdlcywgdHJpYW5nbGVzLCBjb2xsaW5lYXJ9ID0gdGhpcztcblxuICAgIC8vIGRlZ2VuZXJhdGUgY2FzZSB3aXRoIHNldmVyYWwgY29sbGluZWFyIHBvaW50c1xuICAgIGlmIChjb2xsaW5lYXIpIHtcbiAgICAgIGNvbnN0IGwgPSBjb2xsaW5lYXIuaW5kZXhPZihpKTtcbiAgICAgIGlmIChsID4gMCkgeWllbGQgY29sbGluZWFyW2wgLSAxXTtcbiAgICAgIGlmIChsIDwgY29sbGluZWFyLmxlbmd0aCAtIDEpIHlpZWxkIGNvbGxpbmVhcltsICsgMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZTAgPSBpbmVkZ2VzW2ldO1xuICAgIGlmIChlMCA9PT0gLTEpIHJldHVybjsgLy8gY29pbmNpZGVudCBwb2ludFxuICAgIGxldCBlID0gZTAsIHAwID0gLTE7XG4gICAgZG8ge1xuICAgICAgeWllbGQgcDAgPSB0cmlhbmdsZXNbZV07XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgcmV0dXJuOyAvLyBiYWQgdHJpYW5ndWxhdGlvblxuICAgICAgZSA9IGhhbGZlZGdlc1tlXTtcbiAgICAgIGlmIChlID09PSAtMSkge1xuICAgICAgICBjb25zdCBwID0gaHVsbFsoX2h1bGxJbmRleFtpXSArIDEpICUgaHVsbC5sZW5ndGhdO1xuICAgICAgICBpZiAocCAhPT0gcDApIHlpZWxkIHA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChlICE9PSBlMCk7XG4gIH1cbiAgZmluZCh4LCB5LCBpID0gMCkge1xuICAgIGlmICgoeCA9ICt4LCB4ICE9PSB4KSB8fCAoeSA9ICt5LCB5ICE9PSB5KSkgcmV0dXJuIC0xO1xuICAgIGNvbnN0IGkwID0gaTtcbiAgICBsZXQgYztcbiAgICB3aGlsZSAoKGMgPSB0aGlzLl9zdGVwKGksIHgsIHkpKSA+PSAwICYmIGMgIT09IGkgJiYgYyAhPT0gaTApIGkgPSBjO1xuICAgIHJldHVybiBjO1xuICB9XG4gIF9zdGVwKGksIHgsIHkpIHtcbiAgICBjb25zdCB7aW5lZGdlcywgaHVsbCwgX2h1bGxJbmRleCwgaGFsZmVkZ2VzLCB0cmlhbmdsZXMsIHBvaW50c30gPSB0aGlzO1xuICAgIGlmIChpbmVkZ2VzW2ldID09PSAtMSB8fCAhcG9pbnRzLmxlbmd0aCkgcmV0dXJuIChpICsgMSkgJSAocG9pbnRzLmxlbmd0aCA+PiAxKTtcbiAgICBsZXQgYyA9IGk7XG4gICAgbGV0IGRjID0gcG93KHggLSBwb2ludHNbaSAqIDJdLCAyKSArIHBvdyh5IC0gcG9pbnRzW2kgKiAyICsgMV0sIDIpO1xuICAgIGNvbnN0IGUwID0gaW5lZGdlc1tpXTtcbiAgICBsZXQgZSA9IGUwO1xuICAgIGRvIHtcbiAgICAgIGxldCB0ID0gdHJpYW5nbGVzW2VdO1xuICAgICAgY29uc3QgZHQgPSBwb3coeCAtIHBvaW50c1t0ICogMl0sIDIpICsgcG93KHkgLSBwb2ludHNbdCAqIDIgKyAxXSwgMik7XG4gICAgICBpZiAoZHQgPCBkYykgZGMgPSBkdCwgYyA9IHQ7XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgYnJlYWs7IC8vIGJhZCB0cmlhbmd1bGF0aW9uXG4gICAgICBlID0gaGFsZmVkZ2VzW2VdO1xuICAgICAgaWYgKGUgPT09IC0xKSB7XG4gICAgICAgIGUgPSBodWxsWyhfaHVsbEluZGV4W2ldICsgMSkgJSBodWxsLmxlbmd0aF07XG4gICAgICAgIGlmIChlICE9PSB0KSB7XG4gICAgICAgICAgaWYgKHBvdyh4IC0gcG9pbnRzW2UgKiAyXSwgMikgKyBwb3coeSAtIHBvaW50c1tlICogMiArIDFdLCAyKSA8IGRjKSByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChlICE9PSBlMCk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgcmVuZGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge3BvaW50cywgaGFsZmVkZ2VzLCB0cmlhbmdsZXN9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGhhbGZlZGdlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGogPSBoYWxmZWRnZXNbaV07XG4gICAgICBpZiAoaiA8IGkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdGkgPSB0cmlhbmdsZXNbaV0gKiAyO1xuICAgICAgY29uc3QgdGogPSB0cmlhbmdsZXNbal0gKiAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW3RpXSwgcG9pbnRzW3RpICsgMV0pO1xuICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW3RqXSwgcG9pbnRzW3RqICsgMV0pO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlckh1bGwoY29udGV4dCk7XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJQb2ludHMoY29udGV4dCwgciA9IDIpIHtcbiAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0ID09IG51bGwgPyBjb250ZXh0ID0gbmV3IFBhdGggOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qge3BvaW50c30gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHBvaW50c1tpXSwgeSA9IHBvaW50c1tpICsgMV07XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgciwgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCByLCAwLCB0YXUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIHJlbmRlckh1bGwoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7aHVsbCwgcG9pbnRzfSA9IHRoaXM7XG4gICAgY29uc3QgaCA9IGh1bGxbMF0gKiAyLCBuID0gaHVsbC5sZW5ndGg7XG4gICAgY29udGV4dC5tb3ZlVG8ocG9pbnRzW2hdLCBwb2ludHNbaCArIDFdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgaCA9IDIgKiBodWxsW2ldO1xuICAgICAgY29udGV4dC5saW5lVG8ocG9pbnRzW2hdLCBwb2ludHNbaCArIDFdKTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIGh1bGxQb2x5Z29uKCkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbjtcbiAgICB0aGlzLnJlbmRlckh1bGwocG9seWdvbik7XG4gICAgcmV0dXJuIHBvbHlnb24udmFsdWUoKTtcbiAgfVxuICByZW5kZXJUcmlhbmdsZShpLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY29udGV4dCA9PSBudWxsID8gY29udGV4dCA9IG5ldyBQYXRoIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHtwb2ludHMsIHRyaWFuZ2xlc30gPSB0aGlzO1xuICAgIGNvbnN0IHQwID0gdHJpYW5nbGVzW2kgKj0gM10gKiAyO1xuICAgIGNvbnN0IHQxID0gdHJpYW5nbGVzW2kgKyAxXSAqIDI7XG4gICAgY29uc3QgdDIgPSB0cmlhbmdsZXNbaSArIDJdICogMjtcbiAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbdDBdLCBwb2ludHNbdDAgKyAxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocG9pbnRzW3QxXSwgcG9pbnRzW3QxICsgMV0pO1xuICAgIGNvbnRleHQubGluZVRvKHBvaW50c1t0Ml0sIHBvaW50c1t0MiArIDFdKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgKnRyaWFuZ2xlUG9seWdvbnMoKSB7XG4gICAgY29uc3Qge3RyaWFuZ2xlc30gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gdHJpYW5nbGVzLmxlbmd0aCAvIDM7IGkgPCBuOyArK2kpIHtcbiAgICAgIHlpZWxkIHRoaXMudHJpYW5nbGVQb2x5Z29uKGkpO1xuICAgIH1cbiAgfVxuICB0cmlhbmdsZVBvbHlnb24oaSkge1xuICAgIGNvbnN0IHBvbHlnb24gPSBuZXcgUG9seWdvbjtcbiAgICB0aGlzLnJlbmRlclRyaWFuZ2xlKGksIHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uLnZhbHVlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdEFycmF5KHBvaW50cywgZngsIGZ5LCB0aGF0KSB7XG4gIGNvbnN0IG4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBhcnJheSA9IG5ldyBGbG9hdDY0QXJyYXkobiAqIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgYXJyYXlbaSAqIDJdID0gZnguY2FsbCh0aGF0LCBwLCBpLCBwb2ludHMpO1xuICAgIGFycmF5W2kgKiAyICsgMV0gPSBmeS5jYWxsKHRoYXQsIHAsIGksIHBvaW50cyk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiogZmxhdEl0ZXJhYmxlKHBvaW50cywgZngsIGZ5LCB0aGF0KSB7XG4gIGxldCBpID0gMDtcbiAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgIHlpZWxkIGZ4LmNhbGwodGhhdCwgcCwgaSwgcG9pbnRzKTtcbiAgICB5aWVsZCBmeS5jYWxsKHRoYXQsIHAsIGksIHBvaW50cyk7XG4gICAgKytpO1xuICB9XG59XG4iLCJjb25zdCBlcHNpbG9uID0gMWUtNjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICAgIHRoaXMuXyA9IFwiXCI7XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9YDtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIHRoaXMuXyArPSBgTCR7dGhpcy5feDEgPSAreH0sJHt0aGlzLl95MSA9ICt5fWA7XG4gIH1cbiAgYXJjKHgsIHksIHIpIHtcbiAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyO1xuICAgIGNvbnN0IHgwID0geCArIHI7XG4gICAgY29uc3QgeTAgPSB5O1xuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzXCIpO1xuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkgdGhpcy5fICs9IGBNJHt4MH0sJHt5MH1gO1xuICAgIGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuX3gxIC0geDApID4gZXBzaWxvbiB8fCBNYXRoLmFicyh0aGlzLl95MSAtIHkwKSA+IGVwc2lsb24pIHRoaXMuXyArPSBcIkxcIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICBpZiAoIXIpIHJldHVybjtcbiAgICB0aGlzLl8gKz0gYEEke3J9LCR7cn0sMCwxLDEsJHt4IC0gcn0sJHt5fUEke3J9LCR7cn0sMCwxLDEsJHt0aGlzLl94MSA9IHgwfSwke3RoaXMuX3kxID0geTB9YDtcbiAgfVxuICByZWN0KHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl8gKz0gYE0ke3RoaXMuX3gwID0gdGhpcy5feDEgPSAreH0sJHt0aGlzLl95MCA9IHRoaXMuX3kxID0gK3l9aCR7K3d9diR7K2h9aCR7LXd9WmA7XG4gIH1cbiAgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuXyB8fCBudWxsO1xuICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fID0gW107XG4gIH1cbiAgbW92ZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8ucHVzaChbeCwgeV0pO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLl8ucHVzaCh0aGlzLl9bMF0uc2xpY2UoKSk7XG4gIH1cbiAgbGluZVRvKHgsIHkpIHtcbiAgICB0aGlzLl8ucHVzaChbeCwgeV0pO1xuICB9XG4gIHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl8ubGVuZ3RoID8gdGhpcy5fIDogbnVsbDtcbiAgfVxufVxuIiwiaW1wb3J0IFBhdGggZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IFBvbHlnb24gZnJvbSBcIi4vcG9seWdvbi5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWb3Jvbm9pIHtcbiAgY29uc3RydWN0b3IoZGVsYXVuYXksIFt4bWluLCB5bWluLCB4bWF4LCB5bWF4XSA9IFswLCAwLCA5NjAsIDUwMF0pIHtcbiAgICBpZiAoISgoeG1heCA9ICt4bWF4KSA+PSAoeG1pbiA9ICt4bWluKSkgfHwgISgoeW1heCA9ICt5bWF4KSA+PSAoeW1pbiA9ICt5bWluKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm91bmRzXCIpO1xuICAgIHRoaXMuZGVsYXVuYXkgPSBkZWxhdW5heTtcbiAgICB0aGlzLl9jaXJjdW1jZW50ZXJzID0gbmV3IEZsb2F0NjRBcnJheShkZWxhdW5heS5wb2ludHMubGVuZ3RoICogMik7XG4gICAgdGhpcy52ZWN0b3JzID0gbmV3IEZsb2F0NjRBcnJheShkZWxhdW5heS5wb2ludHMubGVuZ3RoICogMik7XG4gICAgdGhpcy54bWF4ID0geG1heCwgdGhpcy54bWluID0geG1pbjtcbiAgICB0aGlzLnltYXggPSB5bWF4LCB0aGlzLnltaW4gPSB5bWluO1xuICAgIHRoaXMuX2luaXQoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5kZWxhdW5heS51cGRhdGUoKTtcbiAgICB0aGlzLl9pbml0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3Qge2RlbGF1bmF5OiB7cG9pbnRzLCBodWxsLCB0cmlhbmdsZXN9LCB2ZWN0b3JzfSA9IHRoaXM7XG5cbiAgICAvLyBDb21wdXRlIGNpcmN1bWNlbnRlcnMuXG4gICAgY29uc3QgY2lyY3VtY2VudGVycyA9IHRoaXMuY2lyY3VtY2VudGVycyA9IHRoaXMuX2NpcmN1bWNlbnRlcnMuc3ViYXJyYXkoMCwgdHJpYW5nbGVzLmxlbmd0aCAvIDMgKiAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIG4gPSB0cmlhbmdsZXMubGVuZ3RoLCB4LCB5OyBpIDwgbjsgaSArPSAzLCBqICs9IDIpIHtcbiAgICAgIGNvbnN0IHQxID0gdHJpYW5nbGVzW2ldICogMjtcbiAgICAgIGNvbnN0IHQyID0gdHJpYW5nbGVzW2kgKyAxXSAqIDI7XG4gICAgICBjb25zdCB0MyA9IHRyaWFuZ2xlc1tpICsgMl0gKiAyO1xuICAgICAgY29uc3QgeDEgPSBwb2ludHNbdDFdO1xuICAgICAgY29uc3QgeTEgPSBwb2ludHNbdDEgKyAxXTtcbiAgICAgIGNvbnN0IHgyID0gcG9pbnRzW3QyXTtcbiAgICAgIGNvbnN0IHkyID0gcG9pbnRzW3QyICsgMV07XG4gICAgICBjb25zdCB4MyA9IHBvaW50c1t0M107XG4gICAgICBjb25zdCB5MyA9IHBvaW50c1t0MyArIDFdO1xuXG4gICAgICBjb25zdCBkeCA9IHgyIC0geDE7XG4gICAgICBjb25zdCBkeSA9IHkyIC0geTE7XG4gICAgICBjb25zdCBleCA9IHgzIC0geDE7XG4gICAgICBjb25zdCBleSA9IHkzIC0geTE7XG4gICAgICBjb25zdCBibCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgY29uc3QgY2wgPSBleCAqIGV4ICsgZXkgKiBleTtcbiAgICAgIGNvbnN0IGFiID0gKGR4ICogZXkgLSBkeSAqIGV4KSAqIDI7XG5cbiAgICAgIGlmICghYWIpIHtcbiAgICAgICAgLy8gZGVnZW5lcmF0ZSBjYXNlIChjb2xsaW5lYXIgZGlhZ3JhbSlcbiAgICAgICAgeCA9ICh4MSArIHgzKSAvIDIgLSAxZTggKiBleTtcbiAgICAgICAgeSA9ICh5MSArIHkzKSAvIDIgKyAxZTggKiBleDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGFiKSA8IDFlLTgpIHtcbiAgICAgICAgLy8gYWxtb3N0IGVxdWFsIHBvaW50cyAoZGVnZW5lcmF0ZSB0cmlhbmdsZSlcbiAgICAgICAgeCA9ICh4MSArIHgzKSAvIDI7XG4gICAgICAgIHkgPSAoeTEgKyB5MykgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZCA9IDEgLyBhYjtcbiAgICAgICAgeCA9IHgxICsgKGV5ICogYmwgLSBkeSAqIGNsKSAqIGQ7XG4gICAgICAgIHkgPSB5MSArIChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuICAgICAgfVxuICAgICAgY2lyY3VtY2VudGVyc1tqXSA9IHg7XG4gICAgICBjaXJjdW1jZW50ZXJzW2ogKyAxXSA9IHk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBleHRlcmlvciBjZWxsIHJheXMuXG4gICAgbGV0IGggPSBodWxsW2h1bGwubGVuZ3RoIC0gMV07XG4gICAgbGV0IHAwLCBwMSA9IGggKiA0O1xuICAgIGxldCB4MCwgeDEgPSBwb2ludHNbMiAqIGhdO1xuICAgIGxldCB5MCwgeTEgPSBwb2ludHNbMiAqIGggKyAxXTtcbiAgICB2ZWN0b3JzLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICBoID0gaHVsbFtpXTtcbiAgICAgIHAwID0gcDEsIHgwID0geDEsIHkwID0geTE7XG4gICAgICBwMSA9IGggKiA0LCB4MSA9IHBvaW50c1syICogaF0sIHkxID0gcG9pbnRzWzIgKiBoICsgMV07XG4gICAgICB2ZWN0b3JzW3AwICsgMl0gPSB2ZWN0b3JzW3AxXSA9IHkwIC0geTE7XG4gICAgICB2ZWN0b3JzW3AwICsgM10gPSB2ZWN0b3JzW3AxICsgMV0gPSB4MSAtIHgwO1xuICAgIH1cbiAgfVxuICByZW5kZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB7ZGVsYXVuYXk6IHtoYWxmZWRnZXMsIGluZWRnZXMsIGh1bGx9LCBjaXJjdW1jZW50ZXJzLCB2ZWN0b3JzfSA9IHRoaXM7XG4gICAgaWYgKGh1bGwubGVuZ3RoIDw9IDEpIHJldHVybiBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gaGFsZmVkZ2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgaiA9IGhhbGZlZGdlc1tpXTtcbiAgICAgIGlmIChqIDwgaSkgY29udGludWU7XG4gICAgICBjb25zdCB0aSA9IE1hdGguZmxvb3IoaSAvIDMpICogMjtcbiAgICAgIGNvbnN0IHRqID0gTWF0aC5mbG9vcihqIC8gMykgKiAyO1xuICAgICAgY29uc3QgeGkgPSBjaXJjdW1jZW50ZXJzW3RpXTtcbiAgICAgIGNvbnN0IHlpID0gY2lyY3VtY2VudGVyc1t0aSArIDFdO1xuICAgICAgY29uc3QgeGogPSBjaXJjdW1jZW50ZXJzW3RqXTtcbiAgICAgIGNvbnN0IHlqID0gY2lyY3VtY2VudGVyc1t0aiArIDFdO1xuICAgICAgdGhpcy5fcmVuZGVyU2VnbWVudCh4aSwgeWksIHhqLCB5aiwgY29udGV4dCk7XG4gICAgfVxuICAgIGxldCBoMCwgaDEgPSBodWxsW2h1bGwubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgKytpKSB7XG4gICAgICBoMCA9IGgxLCBoMSA9IGh1bGxbaV07XG4gICAgICBjb25zdCB0ID0gTWF0aC5mbG9vcihpbmVkZ2VzW2gxXSAvIDMpICogMjtcbiAgICAgIGNvbnN0IHggPSBjaXJjdW1jZW50ZXJzW3RdO1xuICAgICAgY29uc3QgeSA9IGNpcmN1bWNlbnRlcnNbdCArIDFdO1xuICAgICAgY29uc3QgdiA9IGgwICogNDtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLl9wcm9qZWN0KHgsIHksIHZlY3RvcnNbdiArIDJdLCB2ZWN0b3JzW3YgKyAzXSk7XG4gICAgICBpZiAocCkgdGhpcy5fcmVuZGVyU2VnbWVudCh4LCB5LCBwWzBdLCBwWzFdLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlciAmJiBidWZmZXIudmFsdWUoKTtcbiAgfVxuICByZW5kZXJCb3VuZHMoY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0LnJlY3QodGhpcy54bWluLCB0aGlzLnltaW4sIHRoaXMueG1heCAtIHRoaXMueG1pbiwgdGhpcy55bWF4IC0gdGhpcy55bWluKTtcbiAgICByZXR1cm4gYnVmZmVyICYmIGJ1ZmZlci52YWx1ZSgpO1xuICB9XG4gIHJlbmRlckNlbGwoaSwgY29udGV4dCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGNvbnRleHQgPT0gbnVsbCA/IGNvbnRleHQgPSBuZXcgUGF0aCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jbGlwKGkpO1xuICAgIGlmIChwb2ludHMgPT09IG51bGwgfHwgIXBvaW50cy5sZW5ndGgpIHJldHVybjtcbiAgICBjb250ZXh0Lm1vdmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgbGV0IG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlIChwb2ludHNbMF0gPT09IHBvaW50c1tuLTJdICYmIHBvaW50c1sxXSA9PT0gcG9pbnRzW24tMV0gJiYgbiA+IDEpIG4gLT0gMjtcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IG47IGkgKz0gMikge1xuICAgICAgaWYgKHBvaW50c1tpXSAhPT0gcG9pbnRzW2ktMl0gfHwgcG9pbnRzW2krMV0gIT09IHBvaW50c1tpLTFdKVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHJldHVybiBidWZmZXIgJiYgYnVmZmVyLnZhbHVlKCk7XG4gIH1cbiAgKmNlbGxQb2x5Z29ucygpIHtcbiAgICBjb25zdCB7ZGVsYXVuYXk6IHtwb2ludHN9fSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoIC8gMjsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgY2VsbCA9IHRoaXMuY2VsbFBvbHlnb24oaSk7XG4gICAgICBpZiAoY2VsbCkgY2VsbC5pbmRleCA9IGksIHlpZWxkIGNlbGw7XG4gICAgfVxuICB9XG4gIGNlbGxQb2x5Z29uKGkpIHtcbiAgICBjb25zdCBwb2x5Z29uID0gbmV3IFBvbHlnb247XG4gICAgdGhpcy5yZW5kZXJDZWxsKGksIHBvbHlnb24pO1xuICAgIHJldHVybiBwb2x5Z29uLnZhbHVlKCk7XG4gIH1cbiAgX3JlbmRlclNlZ21lbnQoeDAsIHkwLCB4MSwgeTEsIGNvbnRleHQpIHtcbiAgICBsZXQgUztcbiAgICBjb25zdCBjMCA9IHRoaXMuX3JlZ2lvbmNvZGUoeDAsIHkwKTtcbiAgICBjb25zdCBjMSA9IHRoaXMuX3JlZ2lvbmNvZGUoeDEsIHkxKTtcbiAgICBpZiAoYzAgPT09IDAgJiYgYzEgPT09IDApIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIH0gZWxzZSBpZiAoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhTWzBdLCBTWzFdKTtcbiAgICAgIGNvbnRleHQubGluZVRvKFNbMl0sIFNbM10pO1xuICAgIH1cbiAgfVxuICBjb250YWlucyhpLCB4LCB5KSB7XG4gICAgaWYgKCh4ID0gK3gsIHggIT09IHgpIHx8ICh5ID0gK3ksIHkgIT09IHkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZGVsYXVuYXkuX3N0ZXAoaSwgeCwgeSkgPT09IGk7XG4gIH1cbiAgKm5laWdoYm9ycyhpKSB7XG4gICAgY29uc3QgY2kgPSB0aGlzLl9jbGlwKGkpO1xuICAgIGlmIChjaSkgZm9yIChjb25zdCBqIG9mIHRoaXMuZGVsYXVuYXkubmVpZ2hib3JzKGkpKSB7XG4gICAgICBjb25zdCBjaiA9IHRoaXMuX2NsaXAoaik7XG4gICAgICAvLyBmaW5kIHRoZSBjb21tb24gZWRnZVxuICAgICAgaWYgKGNqKSBsb29wOiBmb3IgKGxldCBhaSA9IDAsIGxpID0gY2kubGVuZ3RoOyBhaSA8IGxpOyBhaSArPSAyKSB7XG4gICAgICAgIGZvciAobGV0IGFqID0gMCwgbGogPSBjai5sZW5ndGg7IGFqIDwgbGo7IGFqICs9IDIpIHtcbiAgICAgICAgICBpZiAoY2lbYWldID09IGNqW2FqXVxuICAgICAgICAgICYmIGNpW2FpICsgMV0gPT0gY2pbYWogKyAxXVxuICAgICAgICAgICYmIGNpWyhhaSArIDIpICUgbGldID09IGNqWyhhaiArIGxqIC0gMikgJSBsal1cbiAgICAgICAgICAmJiBjaVsoYWkgKyAzKSAlIGxpXSA9PSBjalsoYWogKyBsaiAtIDEpICUgbGpdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB5aWVsZCBqO1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NlbGwoaSkge1xuICAgIGNvbnN0IHtjaXJjdW1jZW50ZXJzLCBkZWxhdW5heToge2luZWRnZXMsIGhhbGZlZGdlcywgdHJpYW5nbGVzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGUwID0gaW5lZGdlc1tpXTtcbiAgICBpZiAoZTAgPT09IC0xKSByZXR1cm4gbnVsbDsgLy8gY29pbmNpZGVudCBwb2ludFxuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGxldCBlID0gZTA7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdCA9IE1hdGguZmxvb3IoZSAvIDMpO1xuICAgICAgcG9pbnRzLnB1c2goY2lyY3VtY2VudGVyc1t0ICogMl0sIGNpcmN1bWNlbnRlcnNbdCAqIDIgKyAxXSk7XG4gICAgICBlID0gZSAlIDMgPT09IDIgPyBlIC0gMiA6IGUgKyAxO1xuICAgICAgaWYgKHRyaWFuZ2xlc1tlXSAhPT0gaSkgYnJlYWs7IC8vIGJhZCB0cmlhbmd1bGF0aW9uXG4gICAgICBlID0gaGFsZmVkZ2VzW2VdO1xuICAgIH0gd2hpbGUgKGUgIT09IGUwICYmIGUgIT09IC0xKTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIF9jbGlwKGkpIHtcbiAgICAvLyBkZWdlbmVyYXRlIGNhc2UgKDEgdmFsaWQgcG9pbnQ6IHJldHVybiB0aGUgYm94KVxuICAgIGlmIChpID09PSAwICYmIHRoaXMuZGVsYXVuYXkuaHVsbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBbdGhpcy54bWF4LCB0aGlzLnltaW4sIHRoaXMueG1heCwgdGhpcy55bWF4LCB0aGlzLnhtaW4sIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltaW5dO1xuICAgIH1cbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jZWxsKGkpO1xuICAgIGlmIChwb2ludHMgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHt2ZWN0b3JzOiBWfSA9IHRoaXM7XG4gICAgY29uc3QgdiA9IGkgKiA0O1xuICAgIHJldHVybiBWW3ZdIHx8IFZbdiArIDFdXG4gICAgICAgID8gdGhpcy5fY2xpcEluZmluaXRlKGksIHBvaW50cywgVlt2XSwgVlt2ICsgMV0sIFZbdiArIDJdLCBWW3YgKyAzXSlcbiAgICAgICAgOiB0aGlzLl9jbGlwRmluaXRlKGksIHBvaW50cyk7XG4gIH1cbiAgX2NsaXBGaW5pdGUoaSwgcG9pbnRzKSB7XG4gICAgY29uc3QgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IFAgPSBudWxsO1xuICAgIGxldCB4MCwgeTAsIHgxID0gcG9pbnRzW24gLSAyXSwgeTEgPSBwb2ludHNbbiAtIDFdO1xuICAgIGxldCBjMCwgYzEgPSB0aGlzLl9yZWdpb25jb2RlKHgxLCB5MSk7XG4gICAgbGV0IGUwLCBlMTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG47IGogKz0gMikge1xuICAgICAgeDAgPSB4MSwgeTAgPSB5MSwgeDEgPSBwb2ludHNbal0sIHkxID0gcG9pbnRzW2ogKyAxXTtcbiAgICAgIGMwID0gYzEsIGMxID0gdGhpcy5fcmVnaW9uY29kZSh4MSwgeTEpO1xuICAgICAgaWYgKGMwID09PSAwICYmIGMxID09PSAwKSB7XG4gICAgICAgIGUwID0gZTEsIGUxID0gMDtcbiAgICAgICAgaWYgKFApIFAucHVzaCh4MSwgeTEpO1xuICAgICAgICBlbHNlIFAgPSBbeDEsIHkxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBTLCBzeDAsIHN5MCwgc3gxLCBzeTE7XG4gICAgICAgIGlmIChjMCA9PT0gMCkge1xuICAgICAgICAgIGlmICgoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpKSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgW3N4MCwgc3kwLCBzeDEsIHN5MV0gPSBTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoUyA9IHRoaXMuX2NsaXBTZWdtZW50KHgxLCB5MSwgeDAsIHkwLCBjMSwgYzApKSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICAgICAgW3N4MSwgc3kxLCBzeDAsIHN5MF0gPSBTO1xuICAgICAgICAgIGUwID0gZTEsIGUxID0gdGhpcy5fZWRnZWNvZGUoc3gwLCBzeTApO1xuICAgICAgICAgIGlmIChlMCAmJiBlMSkgdGhpcy5fZWRnZShpLCBlMCwgZTEsIFAsIFAubGVuZ3RoKTtcbiAgICAgICAgICBpZiAoUCkgUC5wdXNoKHN4MCwgc3kwKTtcbiAgICAgICAgICBlbHNlIFAgPSBbc3gwLCBzeTBdO1xuICAgICAgICB9XG4gICAgICAgIGUwID0gZTEsIGUxID0gdGhpcy5fZWRnZWNvZGUoc3gxLCBzeTEpO1xuICAgICAgICBpZiAoZTAgJiYgZTEpIHRoaXMuX2VkZ2UoaSwgZTAsIGUxLCBQLCBQLmxlbmd0aCk7XG4gICAgICAgIGlmIChQKSBQLnB1c2goc3gxLCBzeTEpO1xuICAgICAgICBlbHNlIFAgPSBbc3gxLCBzeTFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoUCkge1xuICAgICAgZTAgPSBlMSwgZTEgPSB0aGlzLl9lZGdlY29kZShQWzBdLCBQWzFdKTtcbiAgICAgIGlmIChlMCAmJiBlMSkgdGhpcy5fZWRnZShpLCBlMCwgZTEsIFAsIFAubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29udGFpbnMoaSwgKHRoaXMueG1pbiArIHRoaXMueG1heCkgLyAyLCAodGhpcy55bWluICsgdGhpcy55bWF4KSAvIDIpKSB7XG4gICAgICByZXR1cm4gW3RoaXMueG1heCwgdGhpcy55bWluLCB0aGlzLnhtYXgsIHRoaXMueW1heCwgdGhpcy54bWluLCB0aGlzLnltYXgsIHRoaXMueG1pbiwgdGhpcy55bWluXTtcbiAgICB9XG4gICAgcmV0dXJuIFA7XG4gIH1cbiAgX2NsaXBTZWdtZW50KHgwLCB5MCwgeDEsIHkxLCBjMCwgYzEpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGMwID09PSAwICYmIGMxID09PSAwKSByZXR1cm4gW3gwLCB5MCwgeDEsIHkxXTtcbiAgICAgIGlmIChjMCAmIGMxKSByZXR1cm4gbnVsbDtcbiAgICAgIGxldCB4LCB5LCBjID0gYzAgfHwgYzE7XG4gICAgICBpZiAoYyAmIDBiMTAwMCkgeCA9IHgwICsgKHgxIC0geDApICogKHRoaXMueW1heCAtIHkwKSAvICh5MSAtIHkwKSwgeSA9IHRoaXMueW1heDtcbiAgICAgIGVsc2UgaWYgKGMgJiAwYjAxMDApIHggPSB4MCArICh4MSAtIHgwKSAqICh0aGlzLnltaW4gLSB5MCkgLyAoeTEgLSB5MCksIHkgPSB0aGlzLnltaW47XG4gICAgICBlbHNlIGlmIChjICYgMGIwMDEwKSB5ID0geTAgKyAoeTEgLSB5MCkgKiAodGhpcy54bWF4IC0geDApIC8gKHgxIC0geDApLCB4ID0gdGhpcy54bWF4O1xuICAgICAgZWxzZSB5ID0geTAgKyAoeTEgLSB5MCkgKiAodGhpcy54bWluIC0geDApIC8gKHgxIC0geDApLCB4ID0gdGhpcy54bWluO1xuICAgICAgaWYgKGMwKSB4MCA9IHgsIHkwID0geSwgYzAgPSB0aGlzLl9yZWdpb25jb2RlKHgwLCB5MCk7XG4gICAgICBlbHNlIHgxID0geCwgeTEgPSB5LCBjMSA9IHRoaXMuX3JlZ2lvbmNvZGUoeDEsIHkxKTtcbiAgICB9XG4gIH1cbiAgX2NsaXBJbmZpbml0ZShpLCBwb2ludHMsIHZ4MCwgdnkwLCB2eG4sIHZ5bikge1xuICAgIGxldCBQID0gQXJyYXkuZnJvbShwb2ludHMpLCBwO1xuICAgIGlmIChwID0gdGhpcy5fcHJvamVjdChQWzBdLCBQWzFdLCB2eDAsIHZ5MCkpIFAudW5zaGlmdChwWzBdLCBwWzFdKTtcbiAgICBpZiAocCA9IHRoaXMuX3Byb2plY3QoUFtQLmxlbmd0aCAtIDJdLCBQW1AubGVuZ3RoIC0gMV0sIHZ4biwgdnluKSkgUC5wdXNoKHBbMF0sIHBbMV0pO1xuICAgIGlmIChQID0gdGhpcy5fY2xpcEZpbml0ZShpLCBQKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDAsIG4gPSBQLmxlbmd0aCwgYzAsIGMxID0gdGhpcy5fZWRnZWNvZGUoUFtuIC0gMl0sIFBbbiAtIDFdKTsgaiA8IG47IGogKz0gMikge1xuICAgICAgICBjMCA9IGMxLCBjMSA9IHRoaXMuX2VkZ2Vjb2RlKFBbal0sIFBbaiArIDFdKTtcbiAgICAgICAgaWYgKGMwICYmIGMxKSBqID0gdGhpcy5fZWRnZShpLCBjMCwgYzEsIFAsIGopLCBuID0gUC5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbnRhaW5zKGksICh0aGlzLnhtaW4gKyB0aGlzLnhtYXgpIC8gMiwgKHRoaXMueW1pbiArIHRoaXMueW1heCkgLyAyKSkge1xuICAgICAgUCA9IFt0aGlzLnhtaW4sIHRoaXMueW1pbiwgdGhpcy54bWF4LCB0aGlzLnltaW4sIHRoaXMueG1heCwgdGhpcy55bWF4LCB0aGlzLnhtaW4sIHRoaXMueW1heF07XG4gICAgfVxuICAgIHJldHVybiBQO1xuICB9XG4gIF9lZGdlKGksIGUwLCBlMSwgUCwgaikge1xuICAgIHdoaWxlIChlMCAhPT0gZTEpIHtcbiAgICAgIGxldCB4LCB5O1xuICAgICAgc3dpdGNoIChlMCkge1xuICAgICAgICBjYXNlIDBiMDEwMTogZTAgPSAwYjAxMDA7IGNvbnRpbnVlOyAvLyB0b3AtbGVmdFxuICAgICAgICBjYXNlIDBiMDEwMDogZTAgPSAwYjAxMTAsIHggPSB0aGlzLnhtYXgsIHkgPSB0aGlzLnltaW47IGJyZWFrOyAvLyB0b3BcbiAgICAgICAgY2FzZSAwYjAxMTA6IGUwID0gMGIwMDEwOyBjb250aW51ZTsgLy8gdG9wLXJpZ2h0XG4gICAgICAgIGNhc2UgMGIwMDEwOiBlMCA9IDBiMTAxMCwgeCA9IHRoaXMueG1heCwgeSA9IHRoaXMueW1heDsgYnJlYWs7IC8vIHJpZ2h0XG4gICAgICAgIGNhc2UgMGIxMDEwOiBlMCA9IDBiMTAwMDsgY29udGludWU7IC8vIGJvdHRvbS1yaWdodFxuICAgICAgICBjYXNlIDBiMTAwMDogZTAgPSAwYjEwMDEsIHggPSB0aGlzLnhtaW4sIHkgPSB0aGlzLnltYXg7IGJyZWFrOyAvLyBib3R0b21cbiAgICAgICAgY2FzZSAwYjEwMDE6IGUwID0gMGIwMDAxOyBjb250aW51ZTsgLy8gYm90dG9tLWxlZnRcbiAgICAgICAgY2FzZSAwYjAwMDE6IGUwID0gMGIwMTAxLCB4ID0gdGhpcy54bWluLCB5ID0gdGhpcy55bWluOyBicmVhazsgLy8gbGVmdFxuICAgICAgfVxuICAgICAgaWYgKChQW2pdICE9PSB4IHx8IFBbaiArIDFdICE9PSB5KSAmJiB0aGlzLmNvbnRhaW5zKGksIHgsIHkpKSB7XG4gICAgICAgIFAuc3BsaWNlKGosIDAsIHgsIHkpLCBqICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChQLmxlbmd0aCA+IDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUC5sZW5ndGg7IGkrPSAyKSB7XG4gICAgICAgIGNvbnN0IGogPSAoaSArIDIpICUgUC5sZW5ndGgsIGsgPSAoaSArIDQpICUgUC5sZW5ndGg7XG4gICAgICAgIGlmIChQW2ldID09PSBQW2pdICYmIFBbal0gPT09IFBba11cbiAgICAgICAgfHwgUFtpICsgMV0gPT09IFBbaiArIDFdICYmIFBbaiArIDFdID09PSBQW2sgKyAxXSlcbiAgICAgICAgICBQLnNwbGljZShqLCAyKSwgaSAtPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gajtcbiAgfVxuICBfcHJvamVjdCh4MCwgeTAsIHZ4LCB2eSkge1xuICAgIGxldCB0ID0gSW5maW5pdHksIGMsIHgsIHk7XG4gICAgaWYgKHZ5IDwgMCkgeyAvLyB0b3BcbiAgICAgIGlmICh5MCA8PSB0aGlzLnltaW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueW1pbiAtIHkwKSAvIHZ5KSA8IHQpIHkgPSB0aGlzLnltaW4sIHggPSB4MCArICh0ID0gYykgKiB2eDtcbiAgICB9IGVsc2UgaWYgKHZ5ID4gMCkgeyAvLyBib3R0b21cbiAgICAgIGlmICh5MCA+PSB0aGlzLnltYXgpIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueW1heCAtIHkwKSAvIHZ5KSA8IHQpIHkgPSB0aGlzLnltYXgsIHggPSB4MCArICh0ID0gYykgKiB2eDtcbiAgICB9XG4gICAgaWYgKHZ4ID4gMCkgeyAvLyByaWdodFxuICAgICAgaWYgKHgwID49IHRoaXMueG1heCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoKGMgPSAodGhpcy54bWF4IC0geDApIC8gdngpIDwgdCkgeCA9IHRoaXMueG1heCwgeSA9IHkwICsgKHQgPSBjKSAqIHZ5O1xuICAgIH0gZWxzZSBpZiAodnggPCAwKSB7IC8vIGxlZnRcbiAgICAgIGlmICh4MCA8PSB0aGlzLnhtaW4pIHJldHVybiBudWxsO1xuICAgICAgaWYgKChjID0gKHRoaXMueG1pbiAtIHgwKSAvIHZ4KSA8IHQpIHggPSB0aGlzLnhtaW4sIHkgPSB5MCArICh0ID0gYykgKiB2eTtcbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuICBfZWRnZWNvZGUoeCwgeSkge1xuICAgIHJldHVybiAoeCA9PT0gdGhpcy54bWluID8gMGIwMDAxXG4gICAgICAgIDogeCA9PT0gdGhpcy54bWF4ID8gMGIwMDEwIDogMGIwMDAwKVxuICAgICAgICB8ICh5ID09PSB0aGlzLnltaW4gPyAwYjAxMDBcbiAgICAgICAgOiB5ID09PSB0aGlzLnltYXggPyAwYjEwMDAgOiAwYjAwMDApO1xuICB9XG4gIF9yZWdpb25jb2RlKHgsIHkpIHtcbiAgICByZXR1cm4gKHggPCB0aGlzLnhtaW4gPyAwYjAwMDFcbiAgICAgICAgOiB4ID4gdGhpcy54bWF4ID8gMGIwMDEwIDogMGIwMDAwKVxuICAgICAgICB8ICh5IDwgdGhpcy55bWluID8gMGIwMTAwXG4gICAgICAgIDogeSA+IHRoaXMueW1heCA/IDBiMTAwMCA6IDBiMDAwMCk7XG4gIH1cbn1cbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwidmFyIEVPTCA9IHt9LFxuICAgIEVPRiA9IHt9LFxuICAgIFFVT1RFID0gMzQsXG4gICAgTkVXTElORSA9IDEwLFxuICAgIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdIHx8IFxcXCJcXFwiXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgd2lkdGgpIHtcbiAgdmFyIHMgPSB2YWx1ZSArIFwiXCIsIGxlbmd0aCA9IHMubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkod2lkdGggLSBsZW5ndGggKyAxKS5qb2luKDApICsgcyA6IHM7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciA8IDAgPyBcIi1cIiArIHBhZCgteWVhciwgNilcbiAgICA6IHllYXIgPiA5OTk5ID8gXCIrXCIgKyBwYWQoeWVhciwgNilcbiAgICA6IHBhZCh5ZWFyLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gIHZhciBob3VycyA9IGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgIHNlY29uZHMgPSBkYXRlLmdldFVUQ1NlY29uZHMoKSxcbiAgICAgIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHJldHVybiBpc05hTihkYXRlKSA/IFwiSW52YWxpZCBEYXRlXCJcbiAgICAgIDogZm9ybWF0WWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArIHBhZChkYXRlLmdldFVUQ0RhdGUoKSwgMilcbiAgICAgICsgKG1pbGxpc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIi5cIiArIHBhZChtaWxsaXNlY29uZHMsIDMpICsgXCJaXCJcbiAgICAgIDogc2Vjb25kcyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCI6XCIgKyBwYWQoc2Vjb25kcywgMikgKyBcIlpcIlxuICAgICAgOiBtaW51dGVzIHx8IGhvdXJzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIlpcIlxuICAgICAgOiBcIlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZGVsaW1pdGVyKSB7XG4gIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLFxuICAgICAgREVMSU1JVEVSID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG5cbiAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgIHZhciBjb252ZXJ0LCBjb2x1bW5zLCByb3dzID0gcGFyc2VSb3dzKHRleHQsIGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgaWYgKGNvbnZlcnQpIHJldHVybiBjb252ZXJ0KHJvdywgaSAtIDEpO1xuICAgICAgY29sdW1ucyA9IHJvdywgY29udmVydCA9IGYgPyBjdXN0b21Db252ZXJ0ZXIocm93LCBmKSA6IG9iamVjdENvbnZlcnRlcihyb3cpO1xuICAgIH0pO1xuICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgIHZhciByb3dzID0gW10sIC8vIG91dHB1dCByb3dzXG4gICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgIG4gPSAwLCAvLyBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIHQsIC8vIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgZW9sID0gZmFsc2U7IC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9MP1xuXG4gICAgLy8gU3RyaXAgdGhlIHRyYWlsaW5nIG5ld2xpbmUuXG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpIC0tTjtcbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gUkVUVVJOKSAtLU47XG5cbiAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgIGlmIChlb2YpIHJldHVybiBFT0Y7XG4gICAgICBpZiAoZW9sKSByZXR1cm4gZW9sID0gZmFsc2UsIEVPTDtcblxuICAgICAgLy8gVW5lc2NhcGUgcXVvdGVzLlxuICAgICAgdmFyIGksIGogPSBJLCBjO1xuICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpO1xuICAgICAgICBpZiAoKGkgPSBJKSA+PSBOKSBlb2YgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqICsgMSwgaSAtIDEpLnJlcGxhY2UoL1wiXCIvZywgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgZGVsaW1pdGVyIG9yIG5ld2xpbmUuXG4gICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSkgZW9sID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gUkVUVVJOKSB7IGVvbCA9IHRydWU7IGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpICsrSTsgfVxuICAgICAgICBlbHNlIGlmIChjICE9PSBERUxJTUlURVIpIGNvbnRpbnVlO1xuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgIHJldHVybiBlb2YgPSB0cnVlLCB0ZXh0LnNsaWNlKGosIE4pO1xuICAgIH1cblxuICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgIHdoaWxlICh0ICE9PSBFT0wgJiYgdCAhPT0gRU9GKSByb3cucHVzaCh0KSwgdCA9IHRva2VuKCk7XG4gICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvd3M7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVmb3JtYXRCb2R5KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICB9KS5qb2luKGRlbGltaXRlcik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXQocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIFtjb2x1bW5zLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpXS5jb25jYXQocHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdEJvZHkocm93cywgY29sdW1ucykge1xuICAgIGlmIChjb2x1bW5zID09IG51bGwpIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgcmV0dXJuIHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogdmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZm9ybWF0RGF0ZSh2YWx1ZSlcbiAgICAgICAgOiByZUZvcm1hdC50ZXN0KHZhbHVlICs9IFwiXCIpID8gXCJcXFwiXCIgKyB2YWx1ZS5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGFyc2U6IHBhcnNlLFxuICAgIHBhcnNlUm93czogcGFyc2VSb3dzLFxuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdEJvZHk6IGZvcm1hdEJvZHksXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93cyxcbiAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICBmb3JtYXRWYWx1ZTogZm9ybWF0VmFsdWVcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIG5vZGVzLCBzdHJlbmd0aCA9IDE7XG5cbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlLFxuICAgICAgICBzeCA9IDAsXG4gICAgICAgIHN5ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgc3ggKz0gbm9kZS54LCBzeSArPSBub2RlLnk7XG4gICAgfVxuXG4gICAgZm9yIChzeCA9IChzeCAvIG4gLSB4KSAqIHN0cmVuZ3RoLCBzeSA9IChzeSAvIG4gLSB5KSAqIHN0cmVuZ3RoLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnggLT0gc3gsIG5vZGUueSAtPSBzeTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArXywgZm9yY2UpIDogeDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSArXywgZm9yY2UpIDogeTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQge3F1YWR0cmVlfSBmcm9tIFwiZDMtcXVhZHRyZWVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLnggKyBkLnZ4O1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueSArIGQudnk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cykge1xuICB2YXIgbm9kZXMsXG4gICAgICByYWRpaSxcbiAgICAgIHJhbmRvbSxcbiAgICAgIHN0cmVuZ3RoID0gMSxcbiAgICAgIGl0ZXJhdGlvbnMgPSAxO1xuXG4gIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHJhZGl1cyA9IGNvbnN0YW50KHJhZGl1cyA9PSBudWxsID8gMSA6ICtyYWRpdXMpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICB0cmVlLFxuICAgICAgICBub2RlLFxuICAgICAgICB4aSxcbiAgICAgICAgeWksXG4gICAgICAgIHJpLFxuICAgICAgICByaTI7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgdHJlZSA9IHF1YWR0cmVlKG5vZGVzLCB4LCB5KS52aXNpdEFmdGVyKHByZXBhcmUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHJpID0gcmFkaWlbbm9kZS5pbmRleF0sIHJpMiA9IHJpICogcmk7XG4gICAgICAgIHhpID0gbm9kZS54ICsgbm9kZS52eDtcbiAgICAgICAgeWkgPSBub2RlLnkgKyBub2RlLnZ5O1xuICAgICAgICB0cmVlLnZpc2l0KGFwcGx5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseShxdWFkLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgdmFyIGRhdGEgPSBxdWFkLmRhdGEsIHJqID0gcXVhZC5yLCByID0gcmkgKyByajtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmluZGV4ID4gbm9kZS5pbmRleCkge1xuICAgICAgICAgIHZhciB4ID0geGkgLSBkYXRhLnggLSBkYXRhLnZ4LFxuICAgICAgICAgICAgICB5ID0geWkgLSBkYXRhLnkgLSBkYXRhLnZ5LFxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICBpZiAobCA8IHIgKiByKSB7XG4gICAgICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgICAgICAgIGwgPSAociAtIChsID0gTWF0aC5zcXJ0KGwpKSkgLyBsICogc3RyZW5ndGg7XG4gICAgICAgICAgICBub2RlLnZ4ICs9ICh4ICo9IGwpICogKHIgPSAocmogKj0gcmopIC8gKHJpMiArIHJqKSk7XG4gICAgICAgICAgICBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjtcbiAgICAgICAgICAgIGRhdGEudnggLT0geCAqIChyID0gMSAtIHIpO1xuICAgICAgICAgICAgZGF0YS52eSAtPSB5ICogcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHgwID4geGkgKyByIHx8IHgxIDwgeGkgLSByIHx8IHkwID4geWkgKyByIHx8IHkxIDwgeWkgLSByO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUocXVhZCkge1xuICAgIGlmIChxdWFkLmRhdGEpIHJldHVybiBxdWFkLnIgPSByYWRpaVtxdWFkLmRhdGEuaW5kZXhdO1xuICAgIGZvciAodmFyIGkgPSBxdWFkLnIgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAocXVhZFtpXSAmJiBxdWFkW2ldLnIgPiBxdWFkLnIpIHtcbiAgICAgICAgcXVhZC5yID0gcXVhZFtpXS5yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHJhZGlpID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIF9yYW5kb20pIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBfcmFuZG9tO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZG9tKSB7XG4gIHJldHVybiAocmFuZG9tKCkgLSAwLjUpICogMWUtNjtcbn1cbiIsIi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9jb25ncnVlbnRpYWxfZ2VuZXJhdG9yI1BhcmFtZXRlcnNfaW5fY29tbW9uX3VzZVxuY29uc3QgYSA9IDE2NjQ1MjU7XG5jb25zdCBjID0gMTAxMzkwNDIyMztcbmNvbnN0IG0gPSA0Mjk0OTY3Mjk2OyAvLyAyXjMyXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgcyA9IDE7XG4gIHJldHVybiAoKSA9PiAocyA9IChhICogcyArIGMpICUgbSkgLyBtO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgamlnZ2xlIGZyb20gXCIuL2ppZ2dsZS5qc1wiO1xuXG5mdW5jdGlvbiBpbmRleChkKSB7XG4gIHJldHVybiBkLmluZGV4O1xufVxuXG5mdW5jdGlvbiBmaW5kKG5vZGVCeUlkLCBub2RlSWQpIHtcbiAgdmFyIG5vZGUgPSBub2RlQnlJZC5nZXQobm9kZUlkKTtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIG5vdCBmb3VuZDogXCIgKyBub2RlSWQpO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obGlua3MpIHtcbiAgdmFyIGlkID0gaW5kZXgsXG4gICAgICBzdHJlbmd0aCA9IGRlZmF1bHRTdHJlbmd0aCxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlID0gY29uc3RhbnQoMzApLFxuICAgICAgZGlzdGFuY2VzLFxuICAgICAgbm9kZXMsXG4gICAgICBjb3VudCxcbiAgICAgIGJpYXMsXG4gICAgICByYW5kb20sXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAobGlua3MgPT0gbnVsbCkgbGlua3MgPSBbXTtcblxuICBmdW5jdGlvbiBkZWZhdWx0U3RyZW5ndGgobGluaykge1xuICAgIHJldHVybiAxIC8gTWF0aC5taW4oY291bnRbbGluay5zb3VyY2UuaW5kZXhdLCBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBrID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxpbmssIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCBsLCBiOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tpXSwgc291cmNlID0gbGluay5zb3VyY2UsIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICB4ID0gdGFyZ2V0LnggKyB0YXJnZXQudnggLSBzb3VyY2UueCAtIHNvdXJjZS52eCB8fCBqaWdnbGUocmFuZG9tKTtcbiAgICAgICAgeSA9IHRhcmdldC55ICsgdGFyZ2V0LnZ5IC0gc291cmNlLnkgLSBzb3VyY2UudnkgfHwgamlnZ2xlKHJhbmRvbSk7XG4gICAgICAgIGwgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgIGwgPSAobCAtIGRpc3RhbmNlc1tpXSkgLyBsICogYWxwaGEgKiBzdHJlbmd0aHNbaV07XG4gICAgICAgIHggKj0gbCwgeSAqPSBsO1xuICAgICAgICB0YXJnZXQudnggLT0geCAqIChiID0gYmlhc1tpXSk7XG4gICAgICAgIHRhcmdldC52eSAtPSB5ICogYjtcbiAgICAgICAgc291cmNlLnZ4ICs9IHggKiAoYiA9IDEgLSBiKTtcbiAgICAgICAgc291cmNlLnZ5ICs9IHkgKiBiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgdmFyIGksXG4gICAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG0gPSBsaW5rcy5sZW5ndGgsXG4gICAgICAgIG5vZGVCeUlkID0gbmV3IE1hcChub2Rlcy5tYXAoKGQsIGkpID0+IFtpZChkLCBpLCBub2RlcyksIGRdKSksXG4gICAgICAgIGxpbms7XG5cbiAgICBmb3IgKGkgPSAwLCBjb3VudCA9IG5ldyBBcnJheShuKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBsaW5rLmluZGV4ID0gaTtcbiAgICAgIGlmICh0eXBlb2YgbGluay5zb3VyY2UgIT09IFwib2JqZWN0XCIpIGxpbmsuc291cmNlID0gZmluZChub2RlQnlJZCwgbGluay5zb3VyY2UpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnRhcmdldCAhPT0gXCJvYmplY3RcIikgbGluay50YXJnZXQgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnRhcmdldCk7XG4gICAgICBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gPSAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdIHx8IDApICsgMTtcbiAgICAgIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSA9IChjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGJpYXMgPSBuZXcgQXJyYXkobSk7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgYmlhc1tpXSA9IGNvdW50W2xpbmsuc291cmNlLmluZGV4XSAvIChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gKyBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0pO1xuICAgIH1cblxuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZVN0cmVuZ3RoKCk7XG4gICAgZGlzdGFuY2VzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplRGlzdGFuY2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVTdHJlbmd0aCgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gK3N0cmVuZ3RoKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZURpc3RhbmNlKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBkaXN0YW5jZXNbaV0gPSArZGlzdGFuY2UobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UubGlua3MgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGlua3MgPSBfLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IGxpbmtzO1xuICB9O1xuXG4gIGZvcmNlLmlkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gXywgZm9yY2UpIDogaWQ7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZVN0cmVuZ3RoKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemVEaXN0YW5jZSgpLCBmb3JjZSkgOiBkaXN0YW5jZTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQge3F1YWR0cmVlfSBmcm9tIFwiZDMtcXVhZHRyZWVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcbmltcG9ydCB7eCwgeX0gZnJvbSBcIi4vc2ltdWxhdGlvbi5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgbm9kZSxcbiAgICAgIHJhbmRvbSxcbiAgICAgIGFscGhhLFxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCgtMzApLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgZGlzdGFuY2VNaW4yID0gMSxcbiAgICAgIGRpc3RhbmNlTWF4MiA9IEluZmluaXR5LFxuICAgICAgdGhldGEyID0gMC44MTtcblxuICBmdW5jdGlvbiBmb3JjZShfKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihhY2N1bXVsYXRlKTtcbiAgICBmb3IgKGFscGhhID0gXywgaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgdHJlZS52aXNpdChhcHBseSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCBzdHJlbmd0aHNbbm9kZS5pbmRleF0gPSArc3RyZW5ndGgobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjdW11bGF0ZShxdWFkKSB7XG4gICAgdmFyIHN0cmVuZ3RoID0gMCwgcSwgYywgd2VpZ2h0ID0gMCwgeCwgeSwgaTtcblxuICAgIC8vIEZvciBpbnRlcm5hbCBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjaGlsZCBxdWFkcmFudHMuXG4gICAgaWYgKHF1YWQubGVuZ3RoKSB7XG4gICAgICBmb3IgKHggPSB5ID0gaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgaWYgKChxID0gcXVhZFtpXSkgJiYgKGMgPSBNYXRoLmFicyhxLnZhbHVlKSkpIHtcbiAgICAgICAgICBzdHJlbmd0aCArPSBxLnZhbHVlLCB3ZWlnaHQgKz0gYywgeCArPSBjICogcS54LCB5ICs9IGMgKiBxLnk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1YWQueCA9IHggLyB3ZWlnaHQ7XG4gICAgICBxdWFkLnkgPSB5IC8gd2VpZ2h0O1xuICAgIH1cblxuICAgIC8vIEZvciBsZWFmIG5vZGVzLCBhY2N1bXVsYXRlIGZvcmNlcyBmcm9tIGNvaW5jaWRlbnQgcXVhZHJhbnRzLlxuICAgIGVsc2Uge1xuICAgICAgcSA9IHF1YWQ7XG4gICAgICBxLnggPSBxLmRhdGEueDtcbiAgICAgIHEueSA9IHEuZGF0YS55O1xuICAgICAgZG8gc3RyZW5ndGggKz0gc3RyZW5ndGhzW3EuZGF0YS5pbmRleF07XG4gICAgICB3aGlsZSAocSA9IHEubmV4dCk7XG4gICAgfVxuXG4gICAgcXVhZC52YWx1ZSA9IHN0cmVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDEsIF8sIHgyKSB7XG4gICAgaWYgKCFxdWFkLnZhbHVlKSByZXR1cm4gdHJ1ZTtcblxuICAgIHZhciB4ID0gcXVhZC54IC0gbm9kZS54LFxuICAgICAgICB5ID0gcXVhZC55IC0gbm9kZS55LFxuICAgICAgICB3ID0geDIgLSB4MSxcbiAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAvLyBBcHBseSB0aGUgQmFybmVzLUh1dCBhcHByb3hpbWF0aW9uIGlmIHBvc3NpYmxlLlxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmICh3ICogdyAvIHRoZXRhMiA8IGwpIHtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNYXgyKSB7XG4gICAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geCAqIHg7XG4gICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgICAgICBub2RlLnZ4ICs9IHggKiBxdWFkLnZhbHVlICogYWxwaGEgLyBsO1xuICAgICAgICBub2RlLnZ5ICs9IHkgKiBxdWFkLnZhbHVlICogYWxwaGEgLyBsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIHBvaW50cyBkaXJlY3RseS5cbiAgICBlbHNlIGlmIChxdWFkLmxlbmd0aCB8fCBsID49IGRpc3RhbmNlTWF4MikgcmV0dXJuO1xuXG4gICAgLy8gTGltaXQgZm9yY2VzIGZvciB2ZXJ5IGNsb3NlIG5vZGVzOyByYW5kb21pemUgZGlyZWN0aW9uIGlmIGNvaW5jaWRlbnQuXG4gICAgaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSB8fCBxdWFkLm5leHQpIHtcbiAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geCAqIHg7XG4gICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgaWYgKGwgPCBkaXN0YW5jZU1pbjIpIGwgPSBNYXRoLnNxcnQoZGlzdGFuY2VNaW4yICogbCk7XG4gICAgfVxuXG4gICAgZG8gaWYgKHF1YWQuZGF0YSAhPT0gbm9kZSkge1xuICAgICAgdyA9IHN0cmVuZ3Roc1txdWFkLmRhdGEuaW5kZXhdICogYWxwaGEgLyBsO1xuICAgICAgbm9kZS52eCArPSB4ICogdztcbiAgICAgIG5vZGUudnkgKz0geSAqIHc7XG4gICAgfSB3aGlsZSAocXVhZCA9IHF1YWQubmV4dCk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZU1pbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZU1pbjIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KGRpc3RhbmNlTWluMik7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNYXggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNYXgyID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1heDIpO1xuICB9O1xuXG4gIGZvcmNlLnRoZXRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoZXRhMiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQodGhldGEyKTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQge2Rpc3BhdGNofSBmcm9tIFwiZDMtZGlzcGF0Y2hcIjtcbmltcG9ydCB7dGltZXJ9IGZyb20gXCJkMy10aW1lclwiO1xuaW1wb3J0IGxjZyBmcm9tIFwiLi9sY2cuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54O1xufVxuXG5leHBvcnQgZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5cbnZhciBpbml0aWFsUmFkaXVzID0gMTAsXG4gICAgaW5pdGlhbEFuZ2xlID0gTWF0aC5QSSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIHNpbXVsYXRpb24sXG4gICAgICBhbHBoYSA9IDEsXG4gICAgICBhbHBoYU1pbiA9IDAuMDAxLFxuICAgICAgYWxwaGFEZWNheSA9IDEgLSBNYXRoLnBvdyhhbHBoYU1pbiwgMSAvIDMwMCksXG4gICAgICBhbHBoYVRhcmdldCA9IDAsXG4gICAgICB2ZWxvY2l0eURlY2F5ID0gMC42LFxuICAgICAgZm9yY2VzID0gbmV3IE1hcCgpLFxuICAgICAgc3RlcHBlciA9IHRpbWVyKHN0ZXApLFxuICAgICAgZXZlbnQgPSBkaXNwYXRjaChcInRpY2tcIiwgXCJlbmRcIiksXG4gICAgICByYW5kb20gPSBsY2coKTtcblxuICBpZiAobm9kZXMgPT0gbnVsbCkgbm9kZXMgPSBbXTtcblxuICBmdW5jdGlvbiBzdGVwKCkge1xuICAgIHRpY2soKTtcbiAgICBldmVudC5jYWxsKFwidGlja1wiLCBzaW11bGF0aW9uKTtcbiAgICBpZiAoYWxwaGEgPCBhbHBoYU1pbikge1xuICAgICAgc3RlcHBlci5zdG9wKCk7XG4gICAgICBldmVudC5jYWxsKFwiZW5kXCIsIHNpbXVsYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soaXRlcmF0aW9ucykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuXG4gICAgaWYgKGl0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkgaXRlcmF0aW9ucyA9IDE7XG5cbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZXJhdGlvbnM7ICsraykge1xuICAgICAgYWxwaGEgKz0gKGFscGhhVGFyZ2V0IC0gYWxwaGEpICogYWxwaGFEZWNheTtcblxuICAgICAgZm9yY2VzLmZvckVhY2goZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgICAgZm9yY2UoYWxwaGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5meCA9PSBudWxsKSBub2RlLnggKz0gbm9kZS52eCAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueCA9IG5vZGUuZngsIG5vZGUudnggPSAwO1xuICAgICAgICBpZiAobm9kZS5meSA9PSBudWxsKSBub2RlLnkgKz0gbm9kZS52eSAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICBlbHNlIG5vZGUueSA9IG5vZGUuZnksIG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW11bGF0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUuaW5kZXggPSBpO1xuICAgICAgaWYgKG5vZGUuZnggIT0gbnVsbCkgbm9kZS54ID0gbm9kZS5meDtcbiAgICAgIGlmIChub2RlLmZ5ICE9IG51bGwpIG5vZGUueSA9IG5vZGUuZnk7XG4gICAgICBpZiAoaXNOYU4obm9kZS54KSB8fCBpc05hTihub2RlLnkpKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBpbml0aWFsUmFkaXVzICogTWF0aC5zcXJ0KDAuNSArIGkpLCBhbmdsZSA9IGkgKiBpbml0aWFsQW5nbGU7XG4gICAgICAgIG5vZGUueCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgbm9kZS55ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTmFOKG5vZGUudngpIHx8IGlzTmFOKG5vZGUudnkpKSB7XG4gICAgICAgIG5vZGUudnggPSBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRm9yY2UoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UuaW5pdGlhbGl6ZSkgZm9yY2UuaW5pdGlhbGl6ZShub2RlcywgcmFuZG9tKTtcbiAgICByZXR1cm4gZm9yY2U7XG4gIH1cblxuICBpbml0aWFsaXplTm9kZXMoKTtcblxuICByZXR1cm4gc2ltdWxhdGlvbiA9IHtcbiAgICB0aWNrOiB0aWNrLFxuXG4gICAgcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5yZXN0YXJ0KHN0ZXApLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnN0b3AoKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gXywgaW5pdGlhbGl6ZU5vZGVzKCksIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogbm9kZXM7XG4gICAgfSxcblxuICAgIGFscGhhOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhO1xuICAgIH0sXG5cbiAgICBhbHBoYU1pbjogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcbiAgICB9LFxuXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFEZWNheSA9ICtfLCBzaW11bGF0aW9uKSA6ICthbHBoYURlY2F5O1xuICAgIH0sXG5cbiAgICBhbHBoYVRhcmdldDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFUYXJnZXQgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYVRhcmdldDtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHlEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xuICAgIH0sXG5cbiAgICByYW5kb21Tb3VyY2U6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmRvbSA9IF8sIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogcmFuZG9tO1xuICAgIH0sXG5cbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKChfID09IG51bGwgPyBmb3JjZXMuZGVsZXRlKG5hbWUpIDogZm9yY2VzLnNldChuYW1lLCBpbml0aWFsaXplRm9yY2UoXykpKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5LFxuICAgICAgICAgIGQyLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgY2xvc2VzdDtcblxuICAgICAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgICAgIGVsc2UgcmFkaXVzICo9IHJhZGl1cztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGR4ID0geCAtIG5vZGUueDtcbiAgICAgICAgZHkgPSB5IC0gbm9kZS55O1xuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZDIgPCByYWRpdXMpIGNsb3Nlc3QgPSBub2RlLCByYWRpdXMgPSBkMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoZXZlbnQub24obmFtZSwgXyksIHNpbXVsYXRpb24pIDogZXZlbnQub24obmFtZSk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeHo7XG5cbiAgaWYgKHR5cGVvZiB4ICE9PSBcImZ1bmN0aW9uXCIpIHggPSBjb25zdGFudCh4ID09IG51bGwgPyAwIDogK3gpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eCArPSAoeHpbaV0gLSBub2RlLngpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHh6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHh6W2ldID0gK3gobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeDtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeSkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB5ejtcblxuICBpZiAodHlwZW9mIHkgIT09IFwiZnVuY3Rpb25cIikgeSA9IGNvbnN0YW50KHkgPT0gbnVsbCA/IDAgOiAreSk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ5ICs9ICh5eltpXSAtIG5vZGUueSkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeXogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBmb3JtYXRMb2NhbGUgZnJvbSBcIi4vbG9jYWxlLmpzXCI7XG5cbnZhciBsb2NhbGU7XG5leHBvcnQgdmFyIGZvcm1hdDtcbmV4cG9ydCB2YXIgZm9ybWF0UHJlZml4O1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgdGhvdXNhbmRzOiBcIixcIixcbiAgZ3JvdXBpbmc6IFszXSxcbiAgY3VycmVuY3k6IFtcIiRcIiwgXCJcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0O1xuICBmb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA9IGZvcm1hdERlY2ltYWxQYXJ0cyhNYXRoLmFicyh4KSksIHggPyB4WzFdIDogTmFOO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gTWF0aC5hYnMoeCA9IE1hdGgucm91bmQoeCkpID49IDFlMjFcbiAgICAgID8geC50b0xvY2FsZVN0cmluZyhcImVuXCIpLnJlcGxhY2UoLywvZywgXCJcIilcbiAgICAgIDogeC50b1N0cmluZygxMCk7XG59XG5cbi8vIENvbXB1dGVzIHRoZSBkZWNpbWFsIGNvZWZmaWNpZW50IGFuZCBleHBvbmVudCBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciB4IHdpdGhcbi8vIHNpZ25pZmljYW50IGRpZ2l0cyBwLCB3aGVyZSB4IGlzIHBvc2l0aXZlIGFuZCBwIGlzIGluIFsxLCAyMV0gb3IgdW5kZWZpbmVkLlxuLy8gRm9yIGV4YW1wbGUsIGZvcm1hdERlY2ltYWxQYXJ0cygxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGdyb3VwaW5nLCB0aG91c2FuZHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCB3aWR0aCkge1xuICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICB0ID0gW10sXG4gICAgICAgIGogPSAwLFxuICAgICAgICBnID0gZ3JvdXBpbmdbMF0sXG4gICAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAoaSA+IDAgJiYgZyA+IDApIHtcbiAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgdC5wdXNoKHZhbHVlLnN1YnN0cmluZyhpIC09IGcsIGkgKyBnKSk7XG4gICAgICBpZiAoKGxlbmd0aCArPSBnICsgMSkgPiB3aWR0aCkgYnJlYWs7XG4gICAgICBnID0gZ3JvdXBpbmdbaiA9IChqICsgMSkgJSBncm91cGluZy5sZW5ndGhdO1xuICAgIH1cblxuICAgIHJldHVybiB0LnJldmVyc2UoKS5qb2luKHRob3VzYW5kcyk7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihudW1lcmFscykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzAtOV0vZywgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIG51bWVyYWxzWytpXTtcbiAgICB9KTtcbiAgfTtcbn1cbiIsImltcG9ydCB7Zm9ybWF0RGVjaW1hbFBhcnRzfSBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5cbmV4cG9ydCB2YXIgcHJlZml4RXhwb25lbnQ7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHApIHtcbiAgdmFyIGQgPSBmb3JtYXREZWNpbWFsUGFydHMoeCwgcCk7XG4gIGlmICghZCkgcmV0dXJuIHggKyBcIlwiO1xuICB2YXIgY29lZmZpY2llbnQgPSBkWzBdLFxuICAgICAgZXhwb25lbnQgPSBkWzFdLFxuICAgICAgaSA9IGV4cG9uZW50IC0gKHByZWZpeEV4cG9uZW50ID0gTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQgLyAzKSkpICogMykgKyAxLFxuICAgICAgbiA9IGNvZWZmaWNpZW50Lmxlbmd0aDtcbiAgcmV0dXJuIGkgPT09IG4gPyBjb2VmZmljaWVudFxuICAgICAgOiBpID4gbiA/IGNvZWZmaWNpZW50ICsgbmV3IEFycmF5KGkgLSBuICsgMSkuam9pbihcIjBcIilcbiAgICAgIDogaSA+IDAgPyBjb2VmZmljaWVudC5zbGljZSgwLCBpKSArIFwiLlwiICsgY29lZmZpY2llbnQuc2xpY2UoaSlcbiAgICAgIDogXCIwLlwiICsgbmV3IEFycmF5KDEgLSBpKS5qb2luKFwiMFwiKSArIGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufVxuIiwiaW1wb3J0IHtmb3JtYXREZWNpbWFsUGFydHN9IGZyb20gXCIuL2Zvcm1hdERlY2ltYWwuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgcCkge1xuICB2YXIgZCA9IGZvcm1hdERlY2ltYWxQYXJ0cyh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn1cbiIsIi8vIFtbZmlsbF1hbGlnbl1bc2lnbl1bc3ltYm9sXVswXVt3aWR0aF1bLF1bLnByZWNpc2lvbl1bfl1bdHlwZV1cbnZhciByZSA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICBpZiAoIShtYXRjaCA9IHJlLmV4ZWMoc3BlY2lmaWVyKSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0OiBcIiArIHNwZWNpZmllcik7XG4gIHZhciBtYXRjaDtcbiAgcmV0dXJuIG5ldyBGb3JtYXRTcGVjaWZpZXIoe1xuICAgIGZpbGw6IG1hdGNoWzFdLFxuICAgIGFsaWduOiBtYXRjaFsyXSxcbiAgICBzaWduOiBtYXRjaFszXSxcbiAgICBzeW1ib2w6IG1hdGNoWzRdLFxuICAgIHplcm86IG1hdGNoWzVdLFxuICAgIHdpZHRoOiBtYXRjaFs2XSxcbiAgICBjb21tYTogbWF0Y2hbN10sXG4gICAgcHJlY2lzaW9uOiBtYXRjaFs4XSAmJiBtYXRjaFs4XS5zbGljZSgxKSxcbiAgICB0cmltOiBtYXRjaFs5XSxcbiAgICB0eXBlOiBtYXRjaFsxMF1cbiAgfSk7XG59XG5cbmZvcm1hdFNwZWNpZmllci5wcm90b3R5cGUgPSBGb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlOyAvLyBpbnN0YW5jZW9mXG5cbmV4cG9ydCBmdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIHRoaXMuZmlsbCA9IHNwZWNpZmllci5maWxsID09PSB1bmRlZmluZWQgPyBcIiBcIiA6IHNwZWNpZmllci5maWxsICsgXCJcIjtcbiAgdGhpcy5hbGlnbiA9IHNwZWNpZmllci5hbGlnbiA9PT0gdW5kZWZpbmVkID8gXCI+XCIgOiBzcGVjaWZpZXIuYWxpZ24gKyBcIlwiO1xuICB0aGlzLnNpZ24gPSBzcGVjaWZpZXIuc2lnbiA9PT0gdW5kZWZpbmVkID8gXCItXCIgOiBzcGVjaWZpZXIuc2lnbiArIFwiXCI7XG4gIHRoaXMuc3ltYm9sID0gc3BlY2lmaWVyLnN5bWJvbCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHNwZWNpZmllci5zeW1ib2wgKyBcIlwiO1xuICB0aGlzLnplcm8gPSAhIXNwZWNpZmllci56ZXJvO1xuICB0aGlzLndpZHRoID0gc3BlY2lmaWVyLndpZHRoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiArc3BlY2lmaWVyLndpZHRoO1xuICB0aGlzLmNvbW1hID0gISFzcGVjaWZpZXIuY29tbWE7XG4gIHRoaXMucHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogK3NwZWNpZmllci5wcmVjaXNpb247XG4gIHRoaXMudHJpbSA9ICEhc3BlY2lmaWVyLnRyaW07XG4gIHRoaXMudHlwZSA9IHNwZWNpZmllci50eXBlID09PSB1bmRlZmluZWQgPyBcIlwiIDogc3BlY2lmaWVyLnR5cGUgKyBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG4iLCIvLyBUcmltcyBpbnNpZ25pZmljYW50IHplcm9zLCBlLmcuLCByZXBsYWNlcyAxLjIwMDBrIHdpdGggMS4yay5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHMpIHtcbiAgb3V0OiBmb3IgKHZhciBuID0gcy5sZW5ndGgsIGkgPSAxLCBpMCA9IC0xLCBpMTsgaSA8IG47ICsraSkge1xuICAgIHN3aXRjaCAoc1tpXSkge1xuICAgICAgY2FzZSBcIi5cIjogaTAgPSBpMSA9IGk7IGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjogaWYgKGkwID09PSAwKSBpMCA9IGk7IGkxID0gaTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGlmIChpMCA+IDApIGkwID0gMDsgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpMCA+IDAgPyBzLnNsaWNlKDAsIGkwKSArIHMuc2xpY2UoaTEgKyAxKSA6IHM7XG59XG4iLCJpbXBvcnQgZm9ybWF0RGVjaW1hbCBmcm9tIFwiLi9mb3JtYXREZWNpbWFsLmpzXCI7XG5pbXBvcnQgZm9ybWF0UHJlZml4QXV0byBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgZm9ybWF0Um91bmRlZCBmcm9tIFwiLi9mb3JtYXRSb3VuZGVkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgXCIlXCI6ICh4LCBwKSA9PiAoeCAqIDEwMCkudG9GaXhlZChwKSxcbiAgXCJiXCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDIpLFxuICBcImNcIjogKHgpID0+IHggKyBcIlwiLFxuICBcImRcIjogZm9ybWF0RGVjaW1hbCxcbiAgXCJlXCI6ICh4LCBwKSA9PiB4LnRvRXhwb25lbnRpYWwocCksXG4gIFwiZlwiOiAoeCwgcCkgPT4geC50b0ZpeGVkKHApLFxuICBcImdcIjogKHgsIHApID0+IHgudG9QcmVjaXNpb24ocCksXG4gIFwib1wiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KSxcbiAgXCJwXCI6ICh4LCBwKSA9PiBmb3JtYXRSb3VuZGVkKHggKiAxMDAsIHApLFxuICBcInJcIjogZm9ybWF0Um91bmRlZCxcbiAgXCJzXCI6IGZvcm1hdFByZWZpeEF1dG8sXG4gIFwiWFwiOiAoeCkgPT4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSxcbiAgXCJ4XCI6ICh4KSA9PiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcbmltcG9ydCBmb3JtYXRHcm91cCBmcm9tIFwiLi9mb3JtYXRHcm91cC5qc1wiO1xuaW1wb3J0IGZvcm1hdE51bWVyYWxzIGZyb20gXCIuL2Zvcm1hdE51bWVyYWxzLmpzXCI7XG5pbXBvcnQgZm9ybWF0U3BlY2lmaWVyIGZyb20gXCIuL2Zvcm1hdFNwZWNpZmllci5qc1wiO1xuaW1wb3J0IGZvcm1hdFRyaW0gZnJvbSBcIi4vZm9ybWF0VHJpbS5qc1wiO1xuaW1wb3J0IGZvcm1hdFR5cGVzIGZyb20gXCIuL2Zvcm1hdFR5cGVzLmpzXCI7XG5pbXBvcnQge3ByZWZpeEV4cG9uZW50fSBmcm9tIFwiLi9mb3JtYXRQcmVmaXhBdXRvLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgcHJlZml4ZXMgPSBbXCJ5XCIsXCJ6XCIsXCJhXCIsXCJmXCIsXCJwXCIsXCJuXCIsXCLCtVwiLFwibVwiLFwiXCIsXCJrXCIsXCJNXCIsXCJHXCIsXCJUXCIsXCJQXCIsXCJFXCIsXCJaXCIsXCJZXCJdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihsb2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nID09PSB1bmRlZmluZWQgfHwgbG9jYWxlLnRob3VzYW5kcyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXRHcm91cChtYXAuY2FsbChsb2NhbGUuZ3JvdXBpbmcsIE51bWJlciksIGxvY2FsZS50aG91c2FuZHMgKyBcIlwiKSxcbiAgICAgIGN1cnJlbmN5UHJlZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzBdICsgXCJcIixcbiAgICAgIGN1cnJlbmN5U3VmZml4ID0gbG9jYWxlLmN1cnJlbmN5ID09PSB1bmRlZmluZWQgPyBcIlwiIDogbG9jYWxlLmN1cnJlbmN5WzFdICsgXCJcIixcbiAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCA9PT0gdW5kZWZpbmVkID8gXCIuXCIgOiBsb2NhbGUuZGVjaW1hbCArIFwiXCIsXG4gICAgICBudW1lcmFscyA9IGxvY2FsZS5udW1lcmFscyA9PT0gdW5kZWZpbmVkID8gaWRlbnRpdHkgOiBmb3JtYXROdW1lcmFscyhtYXAuY2FsbChsb2NhbGUubnVtZXJhbHMsIFN0cmluZykpLFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50ID09PSB1bmRlZmluZWQgPyBcIiVcIiA6IGxvY2FsZS5wZXJjZW50ICsgXCJcIixcbiAgICAgIG1pbnVzID0gbG9jYWxlLm1pbnVzID09PSB1bmRlZmluZWQgPyBcIuKIklwiIDogbG9jYWxlLm1pbnVzICsgXCJcIixcbiAgICAgIG5hbiA9IGxvY2FsZS5uYW4gPT09IHVuZGVmaW5lZCA/IFwiTmFOXCIgOiBsb2NhbGUubmFuICsgXCJcIjtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyKSB7XG4gICAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcik7XG5cbiAgICB2YXIgZmlsbCA9IHNwZWNpZmllci5maWxsLFxuICAgICAgICBhbGlnbiA9IHNwZWNpZmllci5hbGlnbixcbiAgICAgICAgc2lnbiA9IHNwZWNpZmllci5zaWduLFxuICAgICAgICBzeW1ib2wgPSBzcGVjaWZpZXIuc3ltYm9sLFxuICAgICAgICB6ZXJvID0gc3BlY2lmaWVyLnplcm8sXG4gICAgICAgIHdpZHRoID0gc3BlY2lmaWVyLndpZHRoLFxuICAgICAgICBjb21tYSA9IHNwZWNpZmllci5jb21tYSxcbiAgICAgICAgcHJlY2lzaW9uID0gc3BlY2lmaWVyLnByZWNpc2lvbixcbiAgICAgICAgdHJpbSA9IHNwZWNpZmllci50cmltLFxuICAgICAgICB0eXBlID0gc3BlY2lmaWVyLnR5cGU7XG5cbiAgICAvLyBUaGUgXCJuXCIgdHlwZSBpcyBhbiBhbGlhcyBmb3IgXCIsZ1wiLlxuICAgIGlmICh0eXBlID09PSBcIm5cIikgY29tbWEgPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBUaGUgXCJcIiB0eXBlLCBhbmQgYW55IGludmFsaWQgdHlwZSwgaXMgYW4gYWxpYXMgZm9yIFwiLjEyfmdcIi5cbiAgICBlbHNlIGlmICghZm9ybWF0VHlwZXNbdHlwZV0pIHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkICYmIChwcmVjaXNpb24gPSAxMiksIHRyaW0gPSB0cnVlLCB0eXBlID0gXCJnXCI7XG5cbiAgICAvLyBJZiB6ZXJvIGZpbGwgaXMgc3BlY2lmaWVkLCBwYWRkaW5nIGdvZXMgYWZ0ZXIgc2lnbiBhbmQgYmVmb3JlIGRpZ2l0cy5cbiAgICBpZiAoemVybyB8fCAoZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSkgemVybyA9IHRydWUsIGZpbGwgPSBcIjBcIiwgYWxpZ24gPSBcIj1cIjtcblxuICAgIC8vIENvbXB1dGUgdGhlIHByZWZpeCBhbmQgc3VmZml4LlxuICAgIC8vIEZvciBTSS1wcmVmaXgsIHRoZSBzdWZmaXggaXMgbGF6aWx5IGNvbXB1dGVkLlxuICAgIHZhciBwcmVmaXggPSBzeW1ib2wgPT09IFwiJFwiID8gY3VycmVuY3lQcmVmaXggOiBzeW1ib2wgPT09IFwiI1wiICYmIC9bYm94WF0vLnRlc3QodHlwZSkgPyBcIjBcIiArIHR5cGUudG9Mb3dlckNhc2UoKSA6IFwiXCIsXG4gICAgICAgIHN1ZmZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVN1ZmZpeCA6IC9bJXBdLy50ZXN0KHR5cGUpID8gcGVyY2VudCA6IFwiXCI7XG5cbiAgICAvLyBXaGF0IGZvcm1hdCBmdW5jdGlvbiBzaG91bGQgd2UgdXNlP1xuICAgIC8vIElzIHRoaXMgYW4gaW50ZWdlciB0eXBlP1xuICAgIC8vIENhbiB0aGlzIHR5cGUgZ2VuZXJhdGUgZXhwb25lbnRpYWwgbm90YXRpb24/XG4gICAgdmFyIGZvcm1hdFR5cGUgPSBmb3JtYXRUeXBlc1t0eXBlXSxcbiAgICAgICAgbWF5YmVTdWZmaXggPSAvW2RlZmdwcnMlXS8udGVzdCh0eXBlKTtcblxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCBwcmVjaXNpb24gaWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyBvciBjbGFtcCB0aGUgc3BlY2lmaWVkIHByZWNpc2lvbiB0byB0aGUgc3VwcG9ydGVkIHJhbmdlLlxuICAgIC8vIEZvciBzaWduaWZpY2FudCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzEsIDIxXS5cbiAgICAvLyBGb3IgZml4ZWQgcHJlY2lzaW9uLCBpdCBtdXN0IGJlIGluIFswLCAyMF0uXG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyA2XG4gICAgICAgIDogL1tncHJzXS8udGVzdCh0eXBlKSA/IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKVxuICAgICAgICA6IE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBwcmVjaXNpb24pKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlUHJlZml4ID0gcHJlZml4LFxuICAgICAgICAgIHZhbHVlU3VmZml4ID0gc3VmZml4LFxuICAgICAgICAgIGksIG4sIGM7XG5cbiAgICAgIGlmICh0eXBlID09PSBcImNcIikge1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9IGZvcm1hdFR5cGUodmFsdWUpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgIHZhbHVlID0gXCJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgc2lnbi4gLTAgaXMgbm90IGxlc3MgdGhhbiAwLCBidXQgMSAvIC0wIGlzIVxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCAxIC8gdmFsdWUgPCAwO1xuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIGluaXRpYWwgZm9ybWF0dGluZy5cbiAgICAgICAgdmFsdWUgPSBpc05hTih2YWx1ZSkgPyBuYW4gOiBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gYWZ0ZXIgZm9ybWF0dGluZywgYW5kIG5vIGV4cGxpY2l0IHBvc2l0aXZlIHNpZ24gaXMgcmVxdWVzdGVkLCBoaWRlIHRoZSBzaWduLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDAgJiYgc2lnbiAhPT0gXCIrXCIpIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBtaW51cykgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgLWV4cG9uZW50KE1hdGguYWJzKHN0ZXApKSk7XG59XG4iLCJpbXBvcnQgZXhwb25lbnQgZnJvbSBcIi4vZXhwb25lbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RlcCwgdmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWF4KC04LCBNYXRoLm1pbig4LCBNYXRoLmZsb29yKGV4cG9uZW50KHZhbHVlKSAvIDMpKSkgKiAzIC0gZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn1cbiIsImltcG9ydCBleHBvbmVudCBmcm9tIFwiLi9leHBvbmVudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihzdGVwLCBtYXgpIHtcbiAgc3RlcCA9IE1hdGguYWJzKHN0ZXApLCBtYXggPSBNYXRoLmFicyhtYXgpIC0gc3RlcDtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIGV4cG9uZW50KG1heCkgLSBleHBvbmVudChzdGVwKSkgKyAxO1xufVxuIiwiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciBzcXJ0MV8yID0gTWF0aC5TUVJUMV8yO1xuZXhwb3J0IHZhciBzcXJ0MiA9IHNxcnQoMik7XG5leHBvcnQgdmFyIHNxcnRQaSA9IHNxcnQocGkpO1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luY2koeCkge1xuICByZXR1cm4geCA/IHggLyBNYXRoLnNpbih4KSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIHggPiAwID8gTWF0aC5zcXJ0KHgpIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhbmgoeCkge1xuICB4ID0gZXhwKDIgKiB4KTtcbiAgcmV0dXJuICh4IC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpIC0gZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpICsgZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJzaW5oKHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyY29zaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxKSk7XG59XG4iLCJpbXBvcnQge2dlb1Byb2plY3Rpb24gYXMgcHJvamVjdGlvbn0gZnJvbSBcImQzLWdlb1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBwaSwgc2luLCBzcXJ0Mn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpIHtcbiAgdmFyIGNwc2luUGhpID0gY3AgKiBzaW4ocGhpKSwgaSA9IDMwLCBkZWx0YTtcbiAgZG8gcGhpIC09IGRlbHRhID0gKHBoaSArIHNpbihwaGkpIC0gY3BzaW5QaGkpIC8gKDEgKyBjb3MocGhpKSk7XG4gIHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgcmV0dXJuIHBoaSAvIDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2xsd2VpZGVCcm9tbGV5UmF3KGN4LCBjeSwgY3ApIHtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIFtjeCAqIGxhbWJkYSAqIGNvcyhwaGkgPSBtb2xsd2VpZGVCcm9tbGV5VGhldGEoY3AsIHBoaSkpLCBjeSAqIHNpbihwaGkpXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB5ID0gYXNpbih5IC8gY3kpLCBbeCAvIChjeCAqIGNvcyh5KSksIGFzaW4oKDIgKiB5ICsgc2luKDIgKiB5KSkgLyBjcCldO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuXG5leHBvcnQgdmFyIG1vbGx3ZWlkZVJhdyA9IG1vbGx3ZWlkZUJyb21sZXlSYXcoc3FydDIgLyBoYWxmUGksIHNxcnQyLCBwaSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihtb2xsd2VpZGVSYXcpXG4gICAgICAuc2NhbGUoMTY5LjUyOSk7XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YXRhbjIsIGNvcywgcXVhcnRlclBpLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4vbm9vcC5qc1wiO1xuaW1wb3J0IHN0cmVhbSBmcm9tIFwiLi9zdHJlYW0uanNcIjtcblxuZXhwb3J0IHZhciBhcmVhUmluZ1N1bSA9IG5ldyBBZGRlcigpO1xuXG4vLyBoZWxsbz9cblxudmFyIGFyZWFTdW0gPSBuZXcgQWRkZXIoKSxcbiAgICBsYW1iZGEwMCxcbiAgICBwaGkwMCxcbiAgICBsYW1iZGEwLFxuICAgIGNvc1BoaTAsXG4gICAgc2luUGhpMDtcblxuZXhwb3J0IHZhciBhcmVhU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJlYVJpbmcgPSArYXJlYVJpbmdTdW07XG4gICAgYXJlYVN1bS5hZGQoYXJlYVJpbmcgPCAwID8gdGF1ICsgYXJlYVJpbmcgOiBhcmVhUmluZyk7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcDtcbiAgfSxcbiAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3VtLmFkZCh0YXUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICBhcmVhUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3MocGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaSksIHNpblBoaTAgPSBzaW4ocGhpKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgcGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaTsgLy8gaGFsZiB0aGUgYW5ndWxhciBkaXN0YW5jZSBmcm9tIHNvdXRoIHBvbGVcblxuICAvLyBTcGhlcmljYWwgZXhjZXNzIEUgZm9yIGEgc3BoZXJpY2FsIHRyaWFuZ2xlIHdpdGggdmVydGljZXM6IHNvdXRoIHBvbGUsXG4gIC8vIHByZXZpb3VzIHBvaW50LCBjdXJyZW50IHBvaW50LiAgVXNlcyBhIGZvcm11bGEgZGVyaXZlZCBmcm9tIENhZ25vbGnigJlzXG4gIC8vIHRoZW9yZW0uICBTZWUgVG9kaHVudGVyLCBTcGhlcmljYWwgVHJpZy4gKDE4NzEpLCBTZWMuIDEwMywgRXEuICgyKS5cbiAgdmFyIGRMYW1iZGEgPSBsYW1iZGEgLSBsYW1iZGEwLFxuICAgICAgc2RMYW1iZGEgPSBkTGFtYmRhID49IDAgPyAxIDogLTEsXG4gICAgICBhZExhbWJkYSA9IHNkTGFtYmRhICogZExhbWJkYSxcbiAgICAgIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBrID0gc2luUGhpMCAqIHNpblBoaSxcbiAgICAgIHUgPSBjb3NQaGkwICogY29zUGhpICsgayAqIGNvcyhhZExhbWJkYSksXG4gICAgICB2ID0gayAqIHNkTGFtYmRhICogc2luKGFkTGFtYmRhKTtcbiAgYXJlYVJpbmdTdW0uYWRkKGF0YW4yKHYsIHUpKTtcblxuICAvLyBBZHZhbmNlIHRoZSBwcmV2aW91cyBwb2ludHMuXG4gIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3NQaGksIHNpblBoaTAgPSBzaW5QaGk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdCkge1xuICBhcmVhU3VtID0gbmV3IEFkZGVyKCk7XG4gIHN0cmVhbShvYmplY3QsIGFyZWFTdHJlYW0pO1xuICByZXR1cm4gYXJlYVN1bSAqIDI7XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YXJlYVN0cmVhbSwgYXJlYVJpbmdTdW19IGZyb20gXCIuL2FyZWEuanNcIjtcbmltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Dcm9zcywgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZSwgc3BoZXJpY2FsfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBkZWdyZWVzLCBlcHNpbG9uLCByYWRpYW5zfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuL3N0cmVhbS5qc1wiO1xuXG52YXIgbGFtYmRhMCwgcGhpMCwgbGFtYmRhMSwgcGhpMSwgLy8gYm91bmRzXG4gICAgbGFtYmRhMiwgLy8gcHJldmlvdXMgbGFtYmRhLWNvb3JkaW5hdGVcbiAgICBsYW1iZGEwMCwgcGhpMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgcDAsIC8vIHByZXZpb3VzIDNEIHBvaW50XG4gICAgZGVsdGFTdW0sXG4gICAgcmFuZ2VzLFxuICAgIHJhbmdlO1xuXG52YXIgYm91bmRzU3RyZWFtID0ge1xuICBwb2ludDogYm91bmRzUG9pbnQsXG4gIGxpbmVTdGFydDogYm91bmRzTGluZVN0YXJ0LFxuICBsaW5lRW5kOiBib3VuZHNMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1JpbmdQb2ludDtcbiAgICBib3VuZHNTdHJlYW0ubGluZVN0YXJ0ID0gYm91bmRzUmluZ1N0YXJ0O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzUmluZ0VuZDtcbiAgICBkZWx0YVN1bSA9IG5ldyBBZGRlcigpO1xuICAgIGFyZWFTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNMaW5lU3RhcnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNMaW5lRW5kO1xuICAgIGlmIChhcmVhUmluZ1N1bSA8IDApIGxhbWJkYTAgPSAtKGxhbWJkYTEgPSAxODApLCBwaGkwID0gLShwaGkxID0gOTApO1xuICAgIGVsc2UgaWYgKGRlbHRhU3VtID4gZXBzaWxvbikgcGhpMSA9IDkwO1xuICAgIGVsc2UgaWYgKGRlbHRhU3VtIDwgLWVwc2lsb24pIHBoaTAgPSAtOTA7XG4gICAgcmFuZ2VbMF0gPSBsYW1iZGEwLCByYW5nZVsxXSA9IGxhbWJkYTE7XG4gIH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgbGFtYmRhMCA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJvdW5kc1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xufVxuXG5mdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgdmFyIHAgPSBjYXJ0ZXNpYW4oW2xhbWJkYSAqIHJhZGlhbnMsIHBoaSAqIHJhZGlhbnNdKTtcbiAgaWYgKHAwKSB7XG4gICAgdmFyIG5vcm1hbCA9IGNhcnRlc2lhbkNyb3NzKHAwLCBwKSxcbiAgICAgICAgZXF1YXRvcmlhbCA9IFtub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDBdLFxuICAgICAgICBpbmZsZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGluZmxlY3Rpb24pO1xuICAgIGluZmxlY3Rpb24gPSBzcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMixcbiAgICAgICAgc2lnbiA9IGRlbHRhID4gMCA/IDEgOiAtMSxcbiAgICAgICAgbGFtYmRhaSA9IGluZmxlY3Rpb25bMF0gKiBkZWdyZWVzICogc2lnbixcbiAgICAgICAgcGhpaSxcbiAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzKGRlbHRhKSA+IDE4MDtcbiAgICBpZiAoYW50aW1lcmlkaWFuIF4gKHNpZ24gKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiAqIGxhbWJkYSkpIHtcbiAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgIGlmIChwaGlpID4gcGhpMSkgcGhpMSA9IHBoaWk7XG4gICAgfSBlbHNlIGlmIChsYW1iZGFpID0gKGxhbWJkYWkgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAoc2lnbiAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduICogbGFtYmRhKSkge1xuICAgICAgcGhpaSA9IC1pbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgIGlmIChwaGlpIDwgcGhpMCkgcGhpMCA9IHBoaWk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaGkgPCBwaGkwKSBwaGkwID0gcGhpO1xuICAgICAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG4gICAgfVxuICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEyKSB7XG4gICAgICAgIGlmIChhbmdsZShsYW1iZGEwLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpKSBsYW1iZGEwID0gbGFtYmRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGFtYmRhMSA+PSBsYW1iZGEwKSB7XG4gICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwKSBsYW1iZGEwID0gbGFtYmRhO1xuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGEyKSB7XG4gICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSkgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpKSBsYW1iZGEwID0gbGFtYmRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgfVxuICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG4gIHAwID0gcCwgbGFtYmRhMiA9IGxhbWJkYTtcbn1cblxuZnVuY3Rpb24gYm91bmRzTGluZVN0YXJ0KCkge1xuICBib3VuZHNTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0xpbmVFbmQoKSB7XG4gIHJhbmdlWzBdID0gbGFtYmRhMCwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgcDAgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgaWYgKHAwKSB7XG4gICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMjtcbiAgICBkZWx0YVN1bS5hZGQoYWJzKGRlbHRhKSA+IDE4MCA/IGRlbHRhICsgKGRlbHRhID4gMCA/IDM2MCA6IC0zNjApIDogZGVsdGEpO1xuICB9IGVsc2Uge1xuICAgIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgfVxuICBhcmVhU3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgbGluZVBvaW50KGxhbWJkYSwgcGhpKTtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ1N0YXJ0KCkge1xuICBhcmVhU3RyZWFtLmxpbmVTdGFydCgpO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nRW5kKCkge1xuICBib3VuZHNSaW5nUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbiAgYXJlYVN0cmVhbS5saW5lRW5kKCk7XG4gIGlmIChhYnMoZGVsdGFTdW0pID4gZXBzaWxvbikgbGFtYmRhMCA9IC0obGFtYmRhMSA9IDE4MCk7XG4gIHJhbmdlWzBdID0gbGFtYmRhMCwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICBwMCA9IG51bGw7XG59XG5cbi8vIEZpbmRzIHRoZSBsZWZ0LXJpZ2h0IGRpc3RhbmNlIGJldHdlZW4gdHdvIGxvbmdpdHVkZXMuXG4vLyBUaGlzIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyAobGFtYmRhMSAtIGxhbWJkYTAgKyAzNjDCsCkgJSAzNjDCsCwgZXhjZXB0IHRoYXQgd2Ugd2FudFxuLy8gdGhlIGRpc3RhbmNlIGJldHdlZW4gwrExODDCsCB0byBiZSAzNjDCsC5cbmZ1bmN0aW9uIGFuZ2xlKGxhbWJkYTAsIGxhbWJkYTEpIHtcbiAgcmV0dXJuIChsYW1iZGExIC09IGxhbWJkYTApIDwgMCA/IGxhbWJkYTEgKyAzNjAgOiBsYW1iZGExO1xufVxuXG5mdW5jdGlvbiByYW5nZUNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYVswXSAtIGJbMF07XG59XG5cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnMocmFuZ2UsIHgpIHtcbiAgcmV0dXJuIHJhbmdlWzBdIDw9IHJhbmdlWzFdID8gcmFuZ2VbMF0gPD0geCAmJiB4IDw9IHJhbmdlWzFdIDogeCA8IHJhbmdlWzBdIHx8IHJhbmdlWzFdIDwgeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZmVhdHVyZSkge1xuICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG5cbiAgcGhpMSA9IGxhbWJkYTEgPSAtKGxhbWJkYTAgPSBwaGkwID0gSW5maW5pdHkpO1xuICByYW5nZXMgPSBbXTtcbiAgc3RyZWFtKGZlYXR1cmUsIGJvdW5kc1N0cmVhbSk7XG5cbiAgLy8gRmlyc3QsIHNvcnQgcmFuZ2VzIGJ5IHRoZWlyIG1pbmltdW0gbG9uZ2l0dWRlcy5cbiAgaWYgKG4gPSByYW5nZXMubGVuZ3RoKSB7XG4gICAgcmFuZ2VzLnNvcnQocmFuZ2VDb21wYXJlKTtcblxuICAgIC8vIFRoZW4sIG1lcmdlIGFueSByYW5nZXMgdGhhdCBvdmVybGFwLlxuICAgIGZvciAoaSA9IDEsIGEgPSByYW5nZXNbMF0sIG1lcmdlZCA9IFthXTsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgIGlmIChyYW5nZUNvbnRhaW5zKGEsIGJbMF0pIHx8IHJhbmdlQ29udGFpbnMoYSwgYlsxXSkpIHtcbiAgICAgICAgaWYgKGFuZ2xlKGFbMF0sIGJbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpIGFbMV0gPSBiWzFdO1xuICAgICAgICBpZiAoYW5nbGUoYlswXSwgYVsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVswXSA9IGJbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgZmluZCB0aGUgbGFyZ2VzdCBnYXAgYmV0d2VlbiB0aGUgbWVyZ2VkIHJhbmdlcy5cbiAgICAvLyBUaGUgZmluYWwgYm91bmRpbmcgYm94IHdpbGwgYmUgdGhlIGludmVyc2Ugb2YgdGhpcyBnYXAuXG4gICAgZm9yIChkZWx0YU1heCA9IC1JbmZpbml0eSwgbiA9IG1lcmdlZC5sZW5ndGggLSAxLCBpID0gMCwgYSA9IG1lcmdlZFtuXTsgaSA8PSBuOyBhID0gYiwgKytpKSB7XG4gICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgaWYgKChkZWx0YSA9IGFuZ2xlKGFbMV0sIGJbMF0pKSA+IGRlbHRhTWF4KSBkZWx0YU1heCA9IGRlbHRhLCBsYW1iZGEwID0gYlswXSwgbGFtYmRhMSA9IGFbMV07XG4gICAgfVxuICB9XG5cbiAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuXG4gIHJldHVybiBsYW1iZGEwID09PSBJbmZpbml0eSB8fCBwaGkwID09PSBJbmZpbml0eVxuICAgICAgPyBbW05hTiwgTmFOXSwgW05hTiwgTmFOXV1cbiAgICAgIDogW1tsYW1iZGEwLCBwaGkwXSwgW2xhbWJkYTEsIHBoaTFdXTtcbn1cbiIsImltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgc2luLCBzcXJ0fSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gIHJldHVybiBbYXRhbjIoY2FydGVzaWFuWzFdLCBjYXJ0ZXNpYW5bMF0pLCBhc2luKGNhcnRlc2lhblsyXSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICB2YXIgbGFtYmRhID0gc3BoZXJpY2FsWzBdLCBwaGkgPSBzcGhlcmljYWxbMV0sIGNvc1BoaSA9IGNvcyhwaGkpO1xuICByZXR1cm4gW2Nvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSldO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gYVxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkFkZEluUGxhY2UoYSwgYikge1xuICBhWzBdICs9IGJbMF0sIGFbMV0gKz0gYlsxXSwgYVsyXSArPSBiWzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gIHJldHVybiBbdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICoga107XG59XG5cbi8vIFRPRE8gcmV0dXJuIGRcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGQpIHtcbiAgdmFyIGwgPSBzcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gIGRbMF0gLz0gbCwgZFsxXSAvPSBsLCBkWzJdIC89IGw7XG59XG4iLCJpbXBvcnQge0FkZGVyfSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7YXNpbiwgYXRhbjIsIGNvcywgZGVncmVlcywgZXBzaWxvbiwgZXBzaWxvbjIsIGh5cG90LCByYWRpYW5zLCBzaW4sIHNxcnR9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuL25vb3AuanNcIjtcbmltcG9ydCBzdHJlYW0gZnJvbSBcIi4vc3RyZWFtLmpzXCI7XG5cbnZhciBXMCwgVzEsXG4gICAgWDAsIFkwLCBaMCxcbiAgICBYMSwgWTEsIFoxLFxuICAgIFgyLCBZMiwgWjIsXG4gICAgbGFtYmRhMDAsIHBoaTAwLCAvLyBmaXJzdCBwb2ludFxuICAgIHgwLCB5MCwgejA7IC8vIHByZXZpb3VzIHBvaW50XG5cbnZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgc3BoZXJlOiBub29wLFxuICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQ7XG4gIH1cbn07XG5cbi8vIEFyaXRobWV0aWMgbWVhbiBvZiBDYXJ0ZXNpYW4gdmVjdG9ycy5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeCwgeSwgeikge1xuICArK1cwO1xuICBYMCArPSAoeCAtIFgwKSAvIFcwO1xuICBZMCArPSAoeSAtIFkwKSAvIFcwO1xuICBaMCArPSAoeiAtIFowKSAvIFcwO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50O1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIHcgPSBhdGFuMihzcXJ0KCh3ID0geTAgKiB6IC0gejAgKiB5KSAqIHcgKyAodyA9IHowICogeCAtIHgwICogeikgKiB3ICsgKHcgPSB4MCAqIHkgLSB5MCAqIHgpICogdyksIHgwICogeCArIHkwICogeSArIHowICogeik7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG4vLyBTZWUgSi4gRS4gQnJvY2ssIFRoZSBJbmVydGlhIFRlbnNvciBmb3IgYSBTcGhlcmljYWwgVHJpYW5nbGUsXG4vLyBKLiBBcHBsaWVkIE1lY2hhbmljcyA0MiwgMjM5ICgxOTc1KS5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50O1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gIHowID0gc2luKHBoaSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLFxuICAgICAgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLFxuICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgY3ggPSB5MCAqIHogLSB6MCAqIHksXG4gICAgICBjeSA9IHowICogeCAtIHgwICogeixcbiAgICAgIGN6ID0geDAgKiB5IC0geTAgKiB4LFxuICAgICAgbSA9IGh5cG90KGN4LCBjeSwgY3opLFxuICAgICAgdyA9IGFzaW4obSksIC8vIGxpbmUgd2VpZ2h0ID0gYW5nbGVcbiAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxuICBYMi5hZGQodiAqIGN4KTtcbiAgWTIuYWRkKHYgKiBjeSk7XG4gIFoyLmFkZCh2ICogY3opO1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihvYmplY3QpIHtcbiAgVzAgPSBXMSA9XG4gIFgwID0gWTAgPSBaMCA9XG4gIFgxID0gWTEgPSBaMSA9IDA7XG4gIFgyID0gbmV3IEFkZGVyKCk7XG4gIFkyID0gbmV3IEFkZGVyKCk7XG4gIFoyID0gbmV3IEFkZGVyKCk7XG4gIHN0cmVhbShvYmplY3QsIGNlbnRyb2lkU3RyZWFtKTtcblxuICB2YXIgeCA9ICtYMixcbiAgICAgIHkgPSArWTIsXG4gICAgICB6ID0gK1oyLFxuICAgICAgbSA9IGh5cG90KHgsIHksIHopO1xuXG4gIC8vIElmIHRoZSBhcmVhLXdlaWdodGVkIGNjZW50cm9pZCBpcyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBsZW5ndGgtd2VpZ2h0ZWQgY2NlbnRyb2lkLlxuICBpZiAobSA8IGVwc2lsb24yKSB7XG4gICAgeCA9IFgxLCB5ID0gWTEsIHogPSBaMTtcbiAgICAvLyBJZiB0aGUgZmVhdHVyZSBoYXMgemVybyBsZW5ndGgsIGZhbGwgYmFjayB0byBhcml0aG1ldGljIG1lYW4gb2YgcG9pbnQgdmVjdG9ycy5cbiAgICBpZiAoVzEgPCBlcHNpbG9uKSB4ID0gWDAsIHkgPSBZMCwgeiA9IFowO1xuICAgIG0gPSBoeXBvdCh4LCB5LCB6KTtcbiAgICAvLyBJZiB0aGUgZmVhdHVyZSBzdGlsbCBoYXMgYW4gdW5kZWZpbmVkIGNjZW50cm9pZCwgdGhlbiByZXR1cm4uXG4gICAgaWYgKG0gPCBlcHNpbG9uMikgcmV0dXJuIFtOYU4sIE5hTl07XG4gIH1cblxuICByZXR1cm4gW2F0YW4yKHksIHgpICogZGVncmVlcywgYXNpbih6IC8gbSkgKiBkZWdyZWVzXTtcbn1cbiIsImltcG9ydCB7Y2FydGVzaWFuLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlLCBzcGhlcmljYWx9IGZyb20gXCIuL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQge2Fjb3MsIGNvcywgZGVncmVlcywgZXBzaWxvbiwgcmFkaWFucywgc2luLCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcbmltcG9ydCB7cm90YXRlUmFkaWFuc30gZnJvbSBcIi4vcm90YXRpb24uanNcIjtcblxuLy8gR2VuZXJhdGVzIGEgY2lyY2xlIGNlbnRlcmVkIGF0IFswwrAsIDDCsF0sIHdpdGggYSBnaXZlbiByYWRpdXMgYW5kIHByZWNpc2lvbi5cbmV4cG9ydCBmdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xuICBpZiAoIWRlbHRhKSByZXR1cm47XG4gIHZhciBjb3NSYWRpdXMgPSBjb3MocmFkaXVzKSxcbiAgICAgIHNpblJhZGl1cyA9IHNpbihyYWRpdXMpLFxuICAgICAgc3RlcCA9IGRpcmVjdGlvbiAqIGRlbHRhO1xuICBpZiAodDAgPT0gbnVsbCkge1xuICAgIHQwID0gcmFkaXVzICsgZGlyZWN0aW9uICogdGF1O1xuICAgIHQxID0gcmFkaXVzIC0gc3RlcCAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdDAgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MCk7XG4gICAgdDEgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MSk7XG4gICAgaWYgKGRpcmVjdGlvbiA+IDAgPyB0MCA8IHQxIDogdDAgPiB0MSkgdDAgKz0gZGlyZWN0aW9uICogdGF1O1xuICB9XG4gIGZvciAodmFyIHBvaW50LCB0ID0gdDA7IGRpcmVjdGlvbiA+IDAgPyB0ID4gdDEgOiB0IDwgdDE7IHQgLT0gc3RlcCkge1xuICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3ModCksIC1zaW5SYWRpdXMgKiBzaW4odCldKTtcbiAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgfVxufVxuXG4vLyBSZXR1cm5zIHRoZSBzaWduZWQgYW5nbGUgb2YgYSBjYXJ0ZXNpYW4gcG9pbnQgcmVsYXRpdmUgdG8gW2Nvc1JhZGl1cywgMCwgMF0uXG5mdW5jdGlvbiBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCBwb2ludCkge1xuICBwb2ludCA9IGNhcnRlc2lhbihwb2ludCksIHBvaW50WzBdIC09IGNvc1JhZGl1cztcbiAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShwb2ludCk7XG4gIHZhciByYWRpdXMgPSBhY29zKC1wb2ludFsxXSk7XG4gIHJldHVybiAoKC1wb2ludFsyXSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzKSArIHRhdSAtIGVwc2lsb24pICUgdGF1O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGNlbnRlciA9IGNvbnN0YW50KFswLCAwXSksXG4gICAgICByYWRpdXMgPSBjb25zdGFudCg5MCksXG4gICAgICBwcmVjaXNpb24gPSBjb25zdGFudCg2KSxcbiAgICAgIHJpbmcsXG4gICAgICByb3RhdGUsXG4gICAgICBzdHJlYW0gPSB7cG9pbnQ6IHBvaW50fTtcblxuICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgIHhbMF0gKj0gZGVncmVlcywgeFsxXSAqPSBkZWdyZWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsXG4gICAgICAgIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgcmluZyA9IFtdO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoLWNbMF0gKiByYWRpYW5zLCAtY1sxXSAqIHJhZGlhbnMsIDApLmludmVydDtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICBjID0ge3R5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddfTtcbiAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbK19bMF0sICtfWzFdXSksIGNpcmNsZSkgOiBjZW50ZXI7XG4gIH07XG5cbiAgY2lyY2xlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHJhZGl1cztcbiAgfTtcblxuICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNpc2lvbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcHJlY2lzaW9uO1xuICB9O1xuXG4gIHJldHVybiBjaXJjbGU7XG59XG4iLCJpbXBvcnQgY2xpcCBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHthYnMsIGF0YW4sIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBwaSwgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGlwKFxuICBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0sXG4gIGNsaXBBbnRpbWVyaWRpYW5MaW5lLFxuICBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsXG4gIFstcGksIC1oYWxmUGldXG4pO1xuXG4vLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBubyBpbnRlcnNlY3Rpb25zOyAyIC0gdGhlcmUgd2VyZVxuLy8gaW50ZXJzZWN0aW9ucywgYW5kIHRoZSBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBzaG91bGQgYmUgcmVqb2luZWQuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgdmFyIGxhbWJkYTAgPSBOYU4sXG4gICAgICBwaGkwID0gTmFOLFxuICAgICAgc2lnbjAgPSBOYU4sXG4gICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuXG4gIHJldHVybiB7XG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIGNsZWFuID0gMTtcbiAgICB9LFxuICAgIHBvaW50OiBmdW5jdGlvbihsYW1iZGExLCBwaGkxKSB7XG4gICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpIDogLXBpLFxuICAgICAgICAgIGRlbHRhID0gYWJzKGxhbWJkYTEgLSBsYW1iZGEwKTtcbiAgICAgIGlmIChhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uKSB7IC8vIGxpbmUgY3Jvc3NlcyBhIHBvbGVcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTAsIHBoaTAgPSAocGhpMCArIHBoaTEpIC8gMiA+IDAgPyBoYWxmUGkgOiAtaGFsZlBpKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2lnbjAgIT09IHNpZ24xICYmIGRlbHRhID49IHBpKSB7IC8vIGxpbmUgY3Jvc3NlcyBhbnRpbWVyaWRpYW5cbiAgICAgICAgaWYgKGFicyhsYW1iZGEwIC0gc2lnbjApIDwgZXBzaWxvbikgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb247IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbikgbGFtYmRhMSAtPSBzaWduMSAqIGVwc2lsb247XG4gICAgICAgIHBoaTAgPSBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgIGNsZWFuID0gMDtcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xuICAgICAgc2lnbjAgPSBzaWduMTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIGxhbWJkYTAgPSBwaGkwID0gTmFOO1xuICAgIH0sXG4gICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDIgLSBjbGVhbjsgLy8gaWYgaW50ZXJzZWN0aW9ucywgcmVqb2luIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KGxhbWJkYTAsIHBoaTAsIGxhbWJkYTEsIHBoaTEpIHtcbiAgdmFyIGNvc1BoaTAsXG4gICAgICBjb3NQaGkxLFxuICAgICAgc2luTGFtYmRhMExhbWJkYTEgPSBzaW4obGFtYmRhMCAtIGxhbWJkYTEpO1xuICByZXR1cm4gYWJzKHNpbkxhbWJkYTBMYW1iZGExKSA+IGVwc2lsb25cbiAgICAgID8gYXRhbigoc2luKHBoaTApICogKGNvc1BoaTEgPSBjb3MocGhpMSkpICogc2luKGxhbWJkYTEpXG4gICAgICAgICAgLSBzaW4ocGhpMSkgKiAoY29zUGhpMCA9IGNvcyhwaGkwKSkgKiBzaW4obGFtYmRhMCkpXG4gICAgICAgICAgLyAoY29zUGhpMCAqIGNvc1BoaTEgKiBzaW5MYW1iZGEwTGFtYmRhMSkpXG4gICAgICA6IChwaGkwICsgcGhpMSkgLyAyO1xufVxuXG5mdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gIHZhciBwaGk7XG4gIGlmIChmcm9tID09IG51bGwpIHtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBoYWxmUGk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQocGksIC1waGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCAwKTtcbiAgICBzdHJlYW0ucG9pbnQoLXBpLCBwaGkpO1xuICB9IGVsc2UgaWYgKGFicyhmcm9tWzBdIC0gdG9bMF0pID4gZXBzaWxvbikge1xuICAgIHZhciBsYW1iZGEgPSBmcm9tWzBdIDwgdG9bMF0gPyBwaSA6IC1waTtcbiAgICBwaGkgPSBkaXJlY3Rpb24gKiBsYW1iZGEgLyAyO1xuICAgIHN0cmVhbS5wb2ludCgtbGFtYmRhLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gIH1cbn1cbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgbGluZXMgPSBbXSxcbiAgICAgIGxpbmU7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHksIG0pIHtcbiAgICAgIGxpbmUucHVzaChbeCwgeSwgbV0pO1xuICAgIH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgcmVqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgfSxcbiAgICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxpbmVzO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbiwgY2FydGVzaWFuQWRkSW5QbGFjZSwgY2FydGVzaWFuQ3Jvc3MsIGNhcnRlc2lhbkRvdCwgY2FydGVzaWFuU2NhbGUsIHNwaGVyaWNhbH0gZnJvbSBcIi4uL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHtjaXJjbGVTdHJlYW19IGZyb20gXCIuLi9jaXJjbGUuanNcIjtcbmltcG9ydCB7YWJzLCBjb3MsIGVwc2lsb24sIHBpLCByYWRpYW5zLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHBvaW50RXF1YWwgZnJvbSBcIi4uL3BvaW50RXF1YWwuanNcIjtcbmltcG9ydCBjbGlwIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cykge1xuICB2YXIgY3IgPSBjb3MocmFkaXVzKSxcbiAgICAgIGRlbHRhID0gNiAqIHJhZGlhbnMsXG4gICAgICBzbWFsbFJhZGl1cyA9IGNyID4gMCxcbiAgICAgIG5vdEhlbWlzcGhlcmUgPSBhYnMoY3IpID4gZXBzaWxvbjsgLy8gVE9ETyBvcHRpbWlzZSBmb3IgdGhpcyBjb21tb24gY2FzZVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgZnJvbSwgdG8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBjb3MobGFtYmRhKSAqIGNvcyhwaGkpID4gY3I7XG4gIH1cblxuICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgdmFyIHBvaW50MCwgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwLCAvLyB2aXNpYmlsaXR5IG9mIHByZXZpb3VzIHBvaW50XG4gICAgICAgIHYwMCwgLy8gdmlzaWJpbGl0eSBvZiBmaXJzdCBwb2ludFxuICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICBjbGVhbiA9IDE7XG4gICAgICB9LFxuICAgICAgcG9pbnQ6IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwb2ludDEgPSBbbGFtYmRhLCBwaGldLFxuICAgICAgICAgICAgcG9pbnQyLFxuICAgICAgICAgICAgdiA9IHZpc2libGUobGFtYmRhLCBwaGkpLFxuICAgICAgICAgICAgYyA9IHNtYWxsUmFkaXVzXG4gICAgICAgICAgICAgID8gdiA/IDAgOiBjb2RlKGxhbWJkYSwgcGhpKVxuICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkgOiAtcGkpLCBwaGkpIDogMDtcbiAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSlcbiAgICAgICAgICAgIHBvaW50MVsyXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAvLyBvdXRzaWRlIGdvaW5nIGluXG4gICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5zaWRlIGdvaW5nIG91dFxuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSwgMik7XG4gICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvZGVzIGZvciB0d28gcG9pbnRzIGFyZSBkaWZmZXJlbnQsIG9yIGFyZSBib3RoIHplcm8sXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIHRoaXMgc2VnbWVudCBpbnRlcnNlY3RzIHdpdGggdGhlIHNtYWxsIGNpcmNsZS5cbiAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzBdWzBdLCB0WzBdWzFdLCAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIXBvaW50RXF1YWwocG9pbnQwLCBwb2ludDEpKSkge1xuICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHYwKSBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBwb2ludDAgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIC8vIFJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBpZiB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gYW5kIGxhc3QgcG9pbnRzIHdlcmUgdmlzaWJsZS5cbiAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuIHwgKCh2MDAgJiYgdjApIDw8IDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBJbnRlcnNlY3RzIHRoZSBncmVhdCBjaXJjbGUgYmV0d2VlbiBhIGFuZCBiIHdpdGggdGhlIGNsaXAgY2lyY2xlLlxuICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgdmFyIHBhID0gY2FydGVzaWFuKGEpLFxuICAgICAgICBwYiA9IGNhcnRlc2lhbihiKTtcblxuICAgIC8vIFdlIGhhdmUgdHdvIHBsYW5lcywgbjEucCA9IGQxIGFuZCBuMi5wID0gZDIuXG4gICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gbGluZSBwKHQpID0gYzEgbjEgKyBjMiBuMiArIHQgKG4xIOKoryBuMikuXG4gICAgdmFyIG4xID0gWzEsIDAsIDBdLCAvLyBub3JtYWxcbiAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLFxuICAgICAgICBuMm4yID0gY2FydGVzaWFuRG90KG4yLCBuMiksXG4gICAgICAgIG4xbjIgPSBuMlswXSwgLy8gY2FydGVzaWFuRG90KG4xLCBuMiksXG4gICAgICAgIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuXG4gICAgLy8gVHdvIHBvbGFyIHBvaW50cy5cbiAgICBpZiAoIWRldGVybWluYW50KSByZXR1cm4gIXR3byAmJiBhO1xuXG4gICAgdmFyIGMxID0gIGNyICogbjJuMiAvIGRldGVybWluYW50LFxuICAgICAgICBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgbjF4bjIgPSBjYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLFxuICAgICAgICBBID0gY2FydGVzaWFuU2NhbGUobjEsIGMxKSxcbiAgICAgICAgQiA9IGNhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgY2FydGVzaWFuQWRkSW5QbGFjZShBLCBCKTtcblxuICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cbiAgICB2YXIgdSA9IG4xeG4yLFxuICAgICAgICB3ID0gY2FydGVzaWFuRG90KEEsIHUpLFxuICAgICAgICB1dSA9IGNhcnRlc2lhbkRvdCh1LCB1KSxcbiAgICAgICAgdDIgPSB3ICogdyAtIHV1ICogKGNhcnRlc2lhbkRvdChBLCBBKSAtIDEpO1xuXG4gICAgaWYgKHQyIDwgMCkgcmV0dXJuO1xuXG4gICAgdmFyIHQgPSBzcXJ0KHQyKSxcbiAgICAgICAgcSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocSwgQSk7XG4gICAgcSA9IHNwaGVyaWNhbChxKTtcblxuICAgIGlmICghdHdvKSByZXR1cm4gcTtcblxuICAgIC8vIFR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgIHZhciBsYW1iZGEwID0gYVswXSxcbiAgICAgICAgbGFtYmRhMSA9IGJbMF0sXG4gICAgICAgIHBoaTAgPSBhWzFdLFxuICAgICAgICBwaGkxID0gYlsxXSxcbiAgICAgICAgejtcblxuICAgIGlmIChsYW1iZGExIDwgbGFtYmRhMCkgeiA9IGxhbWJkYTAsIGxhbWJkYTAgPSBsYW1iZGExLCBsYW1iZGExID0gejtcblxuICAgIHZhciBkZWx0YSA9IGxhbWJkYTEgLSBsYW1iZGEwLFxuICAgICAgICBwb2xhciA9IGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24sXG4gICAgICAgIG1lcmlkaWFuID0gcG9sYXIgfHwgZGVsdGEgPCBlcHNpbG9uO1xuXG4gICAgaWYgKCFwb2xhciAmJiBwaGkxIDwgcGhpMCkgeiA9IHBoaTAsIHBoaTAgPSBwaGkxLCBwaGkxID0gejtcblxuICAgIC8vIENoZWNrIHRoYXQgdGhlIGZpcnN0IHBvaW50IGlzIGJldHdlZW4gYSBhbmQgYi5cbiAgICBpZiAobWVyaWRpYW5cbiAgICAgICAgPyBwb2xhclxuICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgIDogcGhpMCA8PSBxWzFdICYmIHFbMV0gPD0gcGhpMVxuICAgICAgICA6IGRlbHRhID4gcGkgXiAobGFtYmRhMCA8PSBxWzBdICYmIHFbMF0gPD0gbGFtYmRhMSkpIHtcbiAgICAgIHZhciBxMSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxMSwgQSk7XG4gICAgICByZXR1cm4gW3EsIHNwaGVyaWNhbChxMSldO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdlbmVyYXRlcyBhIDQtYml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgcmVsYXRpdmUgdG9cbiAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cbiAgZnVuY3Rpb24gY29kZShsYW1iZGEsIHBoaSkge1xuICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiBwaSAtIHJhZGl1cyxcbiAgICAgICAgY29kZSA9IDA7XG4gICAgaWYgKGxhbWJkYSA8IC1yKSBjb2RlIHw9IDE7IC8vIGxlZnRcbiAgICBlbHNlIGlmIChsYW1iZGEgPiByKSBjb2RlIHw9IDI7IC8vIHJpZ2h0XG4gICAgaWYgKHBoaSA8IC1yKSBjb2RlIHw9IDQ7IC8vIGJlbG93XG4gICAgZWxzZSBpZiAocGhpID4gcikgY29kZSB8PSA4OyAvLyBhYm92ZVxuICAgIHJldHVybiBjb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGksIHJhZGl1cyAtIHBpXSk7XG59XG4iLCJpbXBvcnQgY2xpcEJ1ZmZlciBmcm9tIFwiLi9idWZmZXIuanNcIjtcbmltcG9ydCBjbGlwUmVqb2luIGZyb20gXCIuL3Jlam9pbi5qc1wiO1xuaW1wb3J0IHtlcHNpbG9uLCBoYWxmUGl9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgcG9seWdvbkNvbnRhaW5zIGZyb20gXCIuLi9wb2x5Z29uQ29udGFpbnMuanNcIjtcbmltcG9ydCB7bWVyZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2ludFZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc3RhcnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHNpbmspIHtcbiAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLFxuICAgICAgICByaW5nQnVmZmVyID0gY2xpcEJ1ZmZlcigpLFxuICAgICAgICByaW5nU2luayA9IGNsaXBMaW5lKHJpbmdCdWZmZXIpLFxuICAgICAgICBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlLFxuICAgICAgICBwb2x5Z29uLFxuICAgICAgICBzZWdtZW50cyxcbiAgICAgICAgcmluZztcblxuICAgIHZhciBjbGlwID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgY2xpcC5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIGNsaXAubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc2VnbWVudHMgPSBtZXJnZShzZWdtZW50cyk7XG4gICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBzdGFydCk7XG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzaW5rKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydEluc2lkZSkge1xuICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uRW5kKCksIHBvbHlnb25TdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICB9LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICBzaW5rLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIGlmIChwb2ludFZpc2libGUobGFtYmRhLCBwaGkpKSBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludExpbmUobGFtYmRhLCBwaGkpIHtcbiAgICAgIGxpbmUucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICBsaW5lLmxpbmVFbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludFJpbmcobGFtYmRhLCBwaGkpIHtcbiAgICAgIHJpbmcucHVzaChbbGFtYmRhLCBwaGldKTtcbiAgICAgIHJpbmdTaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICByaW5nU2luay5saW5lU3RhcnQoKTtcbiAgICAgIHJpbmcgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgcmluZ1NpbmsubGluZUVuZCgpO1xuXG4gICAgICB2YXIgY2xlYW4gPSByaW5nU2luay5jbGVhbigpLFxuICAgICAgICAgIHJpbmdTZWdtZW50cyA9IHJpbmdCdWZmZXIucmVzdWx0KCksXG4gICAgICAgICAgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sXG4gICAgICAgICAgc2VnbWVudCxcbiAgICAgICAgICBwb2ludDtcblxuICAgICAgcmluZy5wb3AoKTtcbiAgICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgICAgIHJpbmcgPSBudWxsO1xuXG4gICAgICBpZiAoIW4pIHJldHVybjtcblxuICAgICAgLy8gTm8gaW50ZXJzZWN0aW9ucy5cbiAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgc2VnbWVudCA9IHJpbmdTZWdtZW50c1swXTtcbiAgICAgICAgaWYgKChtID0gc2VnbWVudC5sZW5ndGggLSAxKSA+IDApIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzaW5rLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWpvaW4gY29ubmVjdGVkIHNlZ21lbnRzLlxuICAgICAgLy8gVE9ETyByZXVzZSByaW5nQnVmZmVyLnJlam9pbigpP1xuICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMikgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuXG4gICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIodmFsaWRTZWdtZW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsaXA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZhbGlkU2VnbWVudChzZWdtZW50KSB7XG4gIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG59XG5cbi8vIEludGVyc2VjdGlvbnMgYXJlIHNvcnRlZCBhbG9uZyB0aGUgY2xpcCBlZGdlLiBGb3IgYm90aCBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuLy8gYW5kIGNpcmNsZSBjbGlwcGluZywgdGhlIHNhbWUgY29tcGFyaXNvbiBpcyB1c2VkLlxuZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYVsxXSlcbiAgICAgICAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBiWzFdKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAodDAgPiAwKSBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICBpZiAodDEgPCAxKSBiWzBdID0gYXggKyB0MSAqIGR4LCBiWzFdID0gYXkgKyB0MSAqIGR5O1xuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IGNsaXBCdWZmZXIgZnJvbSBcIi4vYnVmZmVyLmpzXCI7XG5pbXBvcnQgY2xpcExpbmUgZnJvbSBcIi4vbGluZS5qc1wiO1xuaW1wb3J0IGNsaXBSZWpvaW4gZnJvbSBcIi4vcmVqb2luLmpzXCI7XG5pbXBvcnQge21lcmdlfSBmcm9tIFwiZDMtYXJyYXlcIjtcblxudmFyIGNsaXBNYXggPSAxZTksIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IG1lcmdlKHNlZ21lbnRzKSkubGVuZ3RoO1xuICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgICBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICBmaXJzdCA9IHRydWU7XG4gICAgICB2XyA9IGZhbHNlO1xuICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHJhdGhlciB0aGFuIHNwZWNpYWwtY2FzZSBwb2x5Z29ucywgc2ltcGx5IGhhbmRsZSB0aGVtIHNlcGFyYXRlbHkuXG4gICAgLy8gSWRlYWxseSwgY29pbmNpZGVudCBpbnRlcnNlY3Rpb24gcG9pbnRzIHNob3VsZCBiZSBqaXR0ZXJlZCB0byBhdm9pZFxuICAgIC8vIGNsaXBwaW5nIGlzc3Vlcy5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgIGlmICh2X18gJiYgdl8pIGJ1ZmZlclN0cmVhbS5yZWpvaW4oKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJTdHJlYW0ucmVzdWx0KCkpO1xuICAgICAgfVxuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgaWYgKHZfKSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgdiA9IHZpc2libGUoeCwgeSk7XG4gICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFt4LCB5XSk7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodiAmJiB2XykgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgYSA9IFt4XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHhfKSksIHlfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeV8pKV0sXG4gICAgICAgICAgICAgIGIgPSBbeCA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHgpKSwgeSA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHkpKV07XG4gICAgICAgICAgaWYgKGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSkge1xuICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChhWzBdLCBhWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChiWzBdLCBiWzFdKTtcbiAgICAgICAgICAgIGlmICghdikgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xpcFN0cmVhbTtcbiAgfTtcbn1cbiIsImltcG9ydCBwb2ludEVxdWFsIGZyb20gXCIuLi9wb2ludEVxdWFsLmpzXCI7XG5pbXBvcnQge2Vwc2lsb259IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgdGhpcy54ID0gcG9pbnQ7XG4gIHRoaXMueiA9IHBvaW50cztcbiAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG59XG5cbi8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuLy8gaW50byBpdHMgdmlzaWJsZSBsaW5lIHNlZ21lbnRzLCBhbmQgcmVqb2lucyB0aGUgc2VnbWVudHMgYnkgaW50ZXJwb2xhdGluZ1xuLy8gYWxvbmcgdGhlIGNsaXAgZWRnZS5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSkge1xuICB2YXIgc3ViamVjdCA9IFtdLFxuICAgICAgY2xpcCA9IFtdLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbihzZWdtZW50KSB7XG4gICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xuXG4gICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkge1xuICAgICAgaWYgKCFwMFsyXSAmJiAhcDFbMl0pIHtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaGFuZGxlIGRlZ2VuZXJhdGUgY2FzZXMgYnkgbW92aW5nIHRoZSBwb2ludFxuICAgICAgcDFbMF0gKz0gMiAqIGVwc2lsb247XG4gICAgfVxuXG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBzZWdtZW50LCBudWxsLCB0cnVlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBudWxsLCB4LCB0cnVlKSk7XG4gIH0pO1xuXG4gIGlmICghc3ViamVjdC5sZW5ndGgpIHJldHVybjtcblxuICBjbGlwLnNvcnQoY29tcGFyZUludGVyc2VjdGlvbik7XG4gIGxpbmsoc3ViamVjdCk7XG4gIGxpbmsoY2xpcCk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgY2xpcFtpXS5lID0gc3RhcnRJbnNpZGUgPSAhc3RhcnRJbnNpZGU7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLFxuICAgICAgcG9pbnRzLFxuICAgICAgcG9pbnQ7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICAvLyBGaW5kIGZpcnN0IHVudmlzaXRlZCBpbnRlcnNlY3Rpb24uXG4gICAgdmFyIGN1cnJlbnQgPSBzdGFydCxcbiAgICAgICAgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoY3VycmVudC52KSBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydCkgcmV0dXJuO1xuICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgZG8ge1xuICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQucC56O1xuICAgICAgICAgIGZvciAoaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQucC54LCAtMSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgfSB3aGlsZSAoIWN1cnJlbnQudik7XG4gICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaW5rKGFycmF5KSB7XG4gIGlmICghKG4gPSBhcnJheS5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBhID0gYXJyYXlbMF0sXG4gICAgICBiO1xuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEubiA9IGIgPSBhcnJheVtpXTtcbiAgICBiLnAgPSBhO1xuICAgIGEgPSBiO1xuICB9XG4gIGEubiA9IGIgPSBhcnJheVswXTtcbiAgYi5wID0gYTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcblxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gIH1cblxuICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpIGNvbXBvc2UuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gIH07XG5cbiAgcmV0dXJuIGNvbXBvc2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7cmFuZ2V9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthYnMsIGNlaWwsIGVwc2lsb259IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gIHZhciB5ID0gcmFuZ2UoeTAsIHkxIC0gZXBzaWxvbiwgZHkpLmNvbmNhdCh5MSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgdmFyIHggPSByYW5nZSh4MCwgeDEgLSBlcHNpbG9uLCBkeCkuY29uY2F0KHgxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHkpIHsgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFt4LCB5XTsgfSk7IH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgdmFyIHgxLCB4MCwgWDEsIFgwLFxuICAgICAgeTEsIHkwLCBZMSwgWTAsXG4gICAgICBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCxcbiAgICAgIHgsIHksIFgsIFksXG4gICAgICBwcmVjaXNpb24gPSAyLjU7XG5cbiAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzKCl9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgcmV0dXJuIHJhbmdlKGNlaWwoWDAgLyBEWCkgKiBEWCwgWDEsIERYKS5tYXAoWClcbiAgICAgICAgLmNvbmNhdChyYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAuY29uY2F0KHJhbmdlKGNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gYWJzKHggJSBEWCkgPiBlcHNpbG9uOyB9KS5tYXAoeCkpXG4gICAgICAgIC5jb25jYXQocmFuZ2UoY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbih5KSB7IHJldHVybiBhYnMoeSAlIERZKSA+IGVwc2lsb247IH0pLm1hcCh5KSk7XG4gIH1cblxuICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHsgcmV0dXJuIHt0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTsgfSk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICBjb29yZGluYXRlczogW1xuICAgICAgICBYKFgwKS5jb25jYXQoXG4gICAgICAgIFkoWTEpLnNsaWNlKDEpLFxuICAgICAgICBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksXG4gICAgICAgIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSlcbiAgICAgIF1cbiAgICB9O1xuICB9O1xuXG4gIGdyYXRpY3VsZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1tYMCwgWTBdLCBbWDEsIFkxXV07XG4gICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgIGlmIChYMCA+IFgxKSBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICBpZiAoeTAgPiB5MSkgXyA9IHkwLCB5MCA9IHkxLCB5MSA9IF87XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF0aWN1bGUuc3RlcE1pbm9yKCk7XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWFqb3IoXykuc3RlcE1pbm9yKF8pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWFqb3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW0RYLCBEWV07XG4gICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5zdGVwTWlub3IgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG4gICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICByZXR1cm4gZ3JhdGljdWxlO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgIHByZWNpc2lvbiA9ICtfO1xuICAgIHggPSBncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgIHkgPSBncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICBYID0gZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICBZID0gZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICByZXR1cm4gZ3JhdGljdWxlXG4gICAgICAuZXh0ZW50TWFqb3IoW1stMTgwLCAtOTAgKyBlcHNpbG9uXSwgWzE4MCwgOTAgLSBlcHNpbG9uXV0pXG4gICAgICAuZXh0ZW50TWlub3IoW1stMTgwLCAtODAgLSBlcHNpbG9uXSwgWzE4MCwgODAgKyBlcHNpbG9uXV0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ3JhdGljdWxlMTAoKSB7XG4gIHJldHVybiBncmF0aWN1bGUoKSgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiB4O1xuIiwiZXhwb3J0IHZhciBlcHNpbG9uID0gMWUtNjtcbmV4cG9ydCB2YXIgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCB2YXIgcGkgPSBNYXRoLlBJO1xuZXhwb3J0IHZhciBoYWxmUGkgPSBwaSAvIDI7XG5leHBvcnQgdmFyIHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCB2YXIgdGF1ID0gcGkgKiAyO1xuXG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgdmFyIGFicyA9IE1hdGguYWJzO1xuZXhwb3J0IHZhciBhdGFuID0gTWF0aC5hdGFuO1xuZXhwb3J0IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgdmFyIGNvcyA9IE1hdGguY29zO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuZXhwb3J0IHZhciBoeXBvdCA9IE1hdGguaHlwb3Q7XG5leHBvcnQgdmFyIGxvZyA9IE1hdGgubG9nO1xuZXhwb3J0IHZhciBwb3cgPSBNYXRoLnBvdztcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG5leHBvcnQgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub29wKCkge31cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHthYnN9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgYXJlYVN1bSA9IG5ldyBBZGRlcigpLFxuICAgIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCksXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGFyZWFTdHJlYW0gPSB7XG4gIHBvaW50OiBub29wLFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgIGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFSaW5nRW5kO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0ubGluZUVuZCA9IGFyZWFTdHJlYW0ucG9pbnQgPSBub29wO1xuICAgIGFyZWFTdW0uYWRkKGFicyhhcmVhUmluZ1N1bSkpO1xuICAgIGFyZWFSaW5nU3VtID0gbmV3IEFkZGVyKCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtIC8gMjtcbiAgICBhcmVhU3VtID0gbmV3IEFkZGVyKCk7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZWFSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnRGaXJzdDtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QoeCwgeSkge1xuICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50O1xuICB4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geTtcbn1cblxuZnVuY3Rpb24gYXJlYVBvaW50KHgsIHkpIHtcbiAgYXJlYVJpbmdTdW0uYWRkKHkwICogeCAtIHgwICogeSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KHgwMCwgeTAwKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJlYVN0cmVhbTtcbiIsImltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbnZhciB4MCA9IEluZmluaXR5LFxuICAgIHkwID0geDAsXG4gICAgeDEgPSAteDAsXG4gICAgeTEgPSB4MTtcblxudmFyIGJvdW5kc1N0cmVhbSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50LFxuICBsaW5lU3RhcnQ6IG5vb3AsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcCxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm91bmRzID0gW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAgPSB4MCA9IEluZmluaXR5KTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludCh4LCB5KSB7XG4gIGlmICh4IDwgeDApIHgwID0geDtcbiAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gIGlmICh5ID4geTEpIHkxID0geTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYm91bmRzU3RyZWFtO1xuIiwiaW1wb3J0IHtzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG4vLyBUT0RPIEVuZm9yY2UgcG9zaXRpdmUgYXJlYSBmb3IgZXh0ZXJpb3IsIG5lZ2F0aXZlIGFyZWEgZm9yIGludGVyaW9yP1xuXG52YXIgWDAgPSAwLFxuICAgIFkwID0gMCxcbiAgICBaMCA9IDAsXG4gICAgWDEgPSAwLFxuICAgIFkxID0gMCxcbiAgICBaMSA9IDAsXG4gICAgWDIgPSAwLFxuICAgIFkyID0gMCxcbiAgICBaMiA9IDAsXG4gICAgeDAwLFxuICAgIHkwMCxcbiAgICB4MCxcbiAgICB5MDtcblxudmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjZW50cm9pZCA9IFoyID8gW1gyIC8gWjIsIFkyIC8gWjJdXG4gICAgICAgIDogWjEgPyBbWDEgLyBaMSwgWTEgLyBaMV1cbiAgICAgICAgOiBaMCA/IFtYMCAvIFowLCBZMCAvIFowXVxuICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgWDAgPSBZMCA9IFowID1cbiAgICBYMSA9IFkxID0gWjEgPVxuICAgIFgyID0gWTIgPSBaMiA9IDA7XG4gICAgcmV0dXJuIGNlbnRyb2lkO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50KHgsIHkpIHtcbiAgWDAgKz0geDtcbiAgWTAgKz0geTtcbiAgKytaMDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0TGluZTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0TGluZSh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gIGNlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgWjEgKz0gejtcbiAgY2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQoKSB7XG4gIGNlbnRyb2lkUG9pbnRSaW5nKHgwMCwgeTAwKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludFJpbmc7XG4gIGNlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gIHZhciBkeCA9IHggLSB4MCxcbiAgICAgIGR5ID0geSAtIHkwLFxuICAgICAgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gIFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gIFoxICs9IHo7XG5cbiAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgWDIgKz0geiAqICh4MCArIHgpO1xuICBZMiArPSB6ICogKHkwICsgeSk7XG4gIFoyICs9IHogKiAzO1xuICBjZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2VudHJvaWRTdHJlYW07XG4iLCJpbXBvcnQge3RhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBub29wIGZyb20gXCIuLi9ub29wLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fcG9pbnQgPSBOYU47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZXN1bHQ6IG5vb3Bcbn07XG4iLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQgc3RyZWFtIGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBwYXRoQXJlYSBmcm9tIFwiLi9hcmVhLmpzXCI7XG5pbXBvcnQgcGF0aEJvdW5kcyBmcm9tIFwiLi9ib3VuZHMuanNcIjtcbmltcG9ydCBwYXRoQ2VudHJvaWQgZnJvbSBcIi4vY2VudHJvaWQuanNcIjtcbmltcG9ydCBQYXRoQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0LmpzXCI7XG5pbXBvcnQgcGF0aE1lYXN1cmUgZnJvbSBcIi4vbWVhc3VyZS5qc1wiO1xuaW1wb3J0IFBhdGhTdHJpbmcgZnJvbSBcIi4vc3RyaW5nLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgdmFyIHBvaW50UmFkaXVzID0gNC41LFxuICAgICAgcHJvamVjdGlvblN0cmVhbSxcbiAgICAgIGNvbnRleHRTdHJlYW07XG5cbiAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzID09PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK3BvaW50UmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICB9XG5cbiAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQXJlYSkpO1xuICAgIHJldHVybiBwYXRoQXJlYS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLm1lYXN1cmUgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBzdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKHBhdGhNZWFzdXJlKSk7XG4gICAgcmV0dXJuIHBhdGhNZWFzdXJlLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGguYm91bmRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgc3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShwYXRoQm91bmRzKSk7XG4gICAgcmV0dXJuIHBhdGhCb3VuZHMucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHN0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0ocGF0aENlbnRyb2lkKSk7XG4gICAgcmV0dXJuIHBhdGhDZW50cm9pZC5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdGlvblN0cmVhbSA9IF8gPT0gbnVsbCA/IChwcm9qZWN0aW9uID0gbnVsbCwgaWRlbnRpdHkpIDogKHByb2plY3Rpb24gPSBfKS5zdHJlYW0sIHBhdGgpIDogcHJvamVjdGlvbjtcbiAgfTtcblxuICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICBjb250ZXh0U3RyZWFtID0gXyA9PSBudWxsID8gKGNvbnRleHQgPSBudWxsLCBuZXcgUGF0aFN0cmluZykgOiBuZXcgUGF0aENvbnRleHQoY29udGV4dCA9IF8pO1xuICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cyhwb2ludFJhZGl1cyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwb2ludFJhZGl1cztcbiAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5jb250ZXh0KGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHtBZGRlcn0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge3NxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG52YXIgbGVuZ3RoU3VtID0gbmV3IEFkZGVyKCksXG4gICAgbGVuZ3RoUmluZyxcbiAgICB4MDAsXG4gICAgeTAwLFxuICAgIHgwLFxuICAgIHkwO1xuXG52YXIgbGVuZ3RoU3RyZWFtID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAobGVuZ3RoUmluZykgbGVuZ3RoUG9pbnQoeDAwLCB5MDApO1xuICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtO1xuICAgIGxlbmd0aFN1bSA9IG5ldyBBZGRlcigpO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QoeCwgeSkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbiAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50KHgsIHkpIHtcbiAgeDAgLT0geCwgeTAgLT0geTtcbiAgbGVuZ3RoU3VtLmFkZChzcXJ0KHgwICogeDAgKyB5MCAqIHkwKSk7XG4gIHgwID0geCwgeTAgPSB5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBsZW5ndGhTdHJlYW07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICB0aGlzLl9zdHJpbmcgPSBbXTtcbn1cblxuUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gIF9yYWRpdXM6IDQuNSxcbiAgX2NpcmNsZTogY2lyY2xlKDQuNSksXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgaWYgKChfID0gK18pICE9PSB0aGlzLl9yYWRpdXMpIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXMuX2NpcmNsZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fc3RyaW5nLnB1c2goXCJaXCIpO1xuICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDoge1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTFwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fY2lyY2xlID09IG51bGwpIHRoaXMuX2NpcmNsZSA9IGNpcmNsZSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0cmluZy5qb2luKFwiXCIpO1xuICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNpcmNsZShyYWRpdXMpIHtcbiAgcmV0dXJuIFwibTAsXCIgKyByYWRpdXNcbiAgICAgICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXNcbiAgICAgICsgXCJ6XCI7XG59XG4iLCJpbXBvcnQge2FicywgZXBzaWxvbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbn1cbiIsImltcG9ydCB7QWRkZXJ9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtjYXJ0ZXNpYW4sIGNhcnRlc2lhbkNyb3NzLCBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlfSBmcm9tIFwiLi9jYXJ0ZXNpYW4uanNcIjtcbmltcG9ydCB7YWJzLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBlcHNpbG9uMiwgaGFsZlBpLCBwaSwgcXVhcnRlclBpLCBzaWduLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBsb25naXR1ZGUocG9pbnQpIHtcbiAgaWYgKGFicyhwb2ludFswXSkgPD0gcGkpXG4gICAgcmV0dXJuIHBvaW50WzBdO1xuICBlbHNlXG4gICAgcmV0dXJuIHNpZ24ocG9pbnRbMF0pICogKChhYnMocG9pbnRbMF0pICsgcGkpICUgdGF1IC0gcGkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwb2x5Z29uLCBwb2ludCkge1xuICB2YXIgbGFtYmRhID0gbG9uZ2l0dWRlKHBvaW50KSxcbiAgICAgIHBoaSA9IHBvaW50WzFdLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICB2YXIgc3VtID0gbmV3IEFkZGVyKCk7XG5cbiAgaWYgKHNpblBoaSA9PT0gMSkgcGhpID0gaGFsZlBpICsgZXBzaWxvbjtcbiAgZWxzZSBpZiAoc2luUGhpID09PSAtMSkgcGhpID0gLWhhbGZQaSAtIGVwc2lsb247XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKG0gPSAocmluZyA9IHBvbHlnb25baV0pLmxlbmd0aCkpIGNvbnRpbnVlO1xuICAgIHZhciByaW5nLFxuICAgICAgICBtLFxuICAgICAgICBwb2ludDAgPSByaW5nW20gLSAxXSxcbiAgICAgICAgbGFtYmRhMCA9IGxvbmdpdHVkZShwb2ludDApLFxuICAgICAgICBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgc2luUGhpMCA9IHNpbihwaGkwKSxcbiAgICAgICAgY29zUGhpMCA9IGNvcyhwaGkwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLFxuICAgICAgICAgIGxhbWJkYTEgPSBsb25naXR1ZGUocG9pbnQxKSxcbiAgICAgICAgICBwaGkxID0gcG9pbnQxWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgICBzaW5QaGkxID0gc2luKHBoaTEpLFxuICAgICAgICAgIGNvc1BoaTEgPSBjb3MocGhpMSksXG4gICAgICAgICAgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgICBzaWduID0gZGVsdGEgPj0gMCA/IDEgOiAtMSxcbiAgICAgICAgICBhYnNEZWx0YSA9IHNpZ24gKiBkZWx0YSxcbiAgICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnNEZWx0YSA+IHBpLFxuICAgICAgICAgIGsgPSBzaW5QaGkwICogc2luUGhpMTtcblxuICAgICAgc3VtLmFkZChhdGFuMihrICogc2lnbiAqIHNpbihhYnNEZWx0YSksIGNvc1BoaTAgKiBjb3NQaGkxICsgayAqIGNvcyhhYnNEZWx0YSkpKTtcbiAgICAgIGFuZ2xlICs9IGFudGltZXJpZGlhbiA/IGRlbHRhICsgc2lnbiAqIHRhdSA6IGRlbHRhO1xuXG4gICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcbiAgICAgIC8vIGFuZCBhcmUgdGhlIGxhdGl0dWRlcyBzbWFsbGVyIHRoYW4gdGhlIHBhcmFsbGVsIChwaGkpP1xuICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgLy9cbiAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgLy9cbiAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cblxuICByZXR1cm4gKGFuZ2xlIDwgLWVwc2lsb24gfHwgYW5nbGUgPCBlcHNpbG9uICYmIHN1bSA8IC1lcHNpbG9uMikgXiAod2luZGluZyAmIDEpO1xufVxuIiwiaW1wb3J0IGNvbmljRXF1YWxBcmVhIGZyb20gXCIuL2NvbmljRXF1YWxBcmVhLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxuICAgICAgLnBhcmFsbGVscyhbMjkuNSwgNDUuNV0pXG4gICAgICAuc2NhbGUoMTA3MClcbiAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcbiAgICAgIC5yb3RhdGUoWzk2LCAwXSlcbiAgICAgIC5jZW50ZXIoWy0wLjYsIDM4LjddKTtcbn1cbiIsImltcG9ydCB7ZXBzaWxvbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCBhbGJlcnMgZnJvbSBcIi4vYWxiZXJzLmpzXCI7XG5pbXBvcnQgY29uaWNFcXVhbEFyZWEgZnJvbSBcIi4vY29uaWNFcXVhbEFyZWEuanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcblxuLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4vLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbmZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7IH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0uc3BoZXJlKCk7IH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLmxpbmVFbmQoKTsgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gIH07XG59XG5cbi8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4vLyA5NjDDlzUwMC4gVGhlIHByb2plY3Rpb24gYWxzbyB3b3JrcyBxdWl0ZSB3ZWxsIGF0IDk2MMOXNjAwIGlmIHlvdSBjaGFuZ2UgdGhlXG4vLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxuLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuLy8gaHR0cDovL2Vnc2MudXNncy5nb3YvaXNiL3B1YnMvTWFwUHJvamVjdGlvbnMvcHJvamVjdGlvbnMuaHRtbCNhbGJlcnNcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIGxvd2VyNDggPSBhbGJlcnMoKSwgbG93ZXI0OFBvaW50LFxuICAgICAgYWxhc2thID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XG4gICAgICBoYXdhaWkgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU3LCAwXSkuY2VudGVyKFstMywgMTkuOV0pLnBhcmFsbGVscyhbOCwgMThdKSwgaGF3YWlpUG9pbnQsIC8vIEVTUkk6MTAyMDA3XG4gICAgICBwb2ludCwgcG9pbnRTdHJlYW0gPSB7cG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH19O1xuXG4gIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgfHwgKGFsYXNrYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgfHwgKGhhd2FpaVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gIH1cblxuICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSxcbiAgICAgICAgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksXG4gICAgICAgIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssXG4gICAgICAgIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgcmV0dXJuICh5ID49IDAuMTIwICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjQyNSAmJiB4IDwgLTAuMjE0ID8gYWxhc2thXG4gICAgICAgIDogeSA+PSAwLjE2NiAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC4yMTQgJiYgeCA8IC0wLjExNSA/IGhhd2FpaVxuICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleChbbG93ZXI0OC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaS5zdHJlYW0oc3RyZWFtKV0pO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICBsb3dlcjQ4LnByZWNpc2lvbihfKSwgYWxhc2thLnByZWNpc2lvbihfKSwgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfTtcblxuICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgIGxvd2VyNDguc2NhbGUoXyksIGFsYXNrYS5zY2FsZShfICogMC4zNSksIGhhd2FpaS5zY2FsZShfKTtcbiAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgfTtcblxuICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuXG4gICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OFxuICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDU1ICogaywgeSAtIDAuMjM4ICoga10sIFt4ICsgMC40NTUgKiBrLCB5ICsgMC4yMzggKiBrXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgYWxhc2thUG9pbnQgPSBhbGFza2FcbiAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMzA3ICogaywgeSArIDAuMjAxICoga10pXG4gICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24sIHkgKyAwLjEyMCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjIwNSAqIGssIHkgKyAwLjIxMiAqIGtdKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4xMTUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICByZXR1cm4gcmVzZXQoKTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KGFsYmVyc1VzYSwgZXh0ZW50LCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgoYWxiZXJzVXNhLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KGFsYmVyc1VzYSwgaGVpZ2h0LCBvYmplY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBhbGJlcnNVc2E7XG4gIH1cblxuICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xufVxuIiwiaW1wb3J0IHthc2luLCBhdGFuMiwgY29zLCBzaW4sIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhemltdXRoYWxSYXcoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgY3ggPSBjb3MoeCksXG4gICAgICAgIGN5ID0gY29zKHkpLFxuICAgICAgICBrID0gc2NhbGUoY3ggKiBjeSk7XG4gICAgICAgIGlmIChrID09PSBJbmZpbml0eSkgcmV0dXJuIFsyLCAwXTtcbiAgICByZXR1cm4gW1xuICAgICAgayAqIGN5ICogc2luKHgpLFxuICAgICAgayAqIHNpbih5KVxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGF6aW11dGhhbEludmVydChhbmdsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB6ID0gc3FydCh4ICogeCArIHkgKiB5KSxcbiAgICAgICAgYyA9IGFuZ2xlKHopLFxuICAgICAgICBzYyA9IHNpbihjKSxcbiAgICAgICAgY2MgPSBjb3MoYyk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHggKiBzYywgeiAqIGNjKSxcbiAgICAgIGFzaW4oeiAmJiB5ICogc2MgLyB6KVxuICAgIF07XG4gIH1cbn1cbiIsImltcG9ydCB7YXNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7YXppbXV0aGFsUmF3LCBhemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IHZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oY3hjeSkge1xuICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG59KTtcblxuYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXNpbih6IC8gMik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWFsQXJlYVJhdylcbiAgICAgIC5zY2FsZSgxMjQuNzUpXG4gICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xufVxuIiwiaW1wb3J0IHthY29zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2F6aW11dGhhbFJhdywgYXppbXV0aGFsSW52ZXJ0fSBmcm9tIFwiLi9hemltdXRoYWwuanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCB2YXIgYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oYykge1xuICByZXR1cm4gKGMgPSBhY29zKGMpKSAmJiBjIC8gc2luKGMpO1xufSk7XG5cbmF6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiB6O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVpZGlzdGFudFJhdylcbiAgICAgIC5zY2FsZSg3OS40MTg4KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn1cbiIsImltcG9ydCB7ZGVncmVlcywgcGksIHJhZGlhbnN9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3Byb2plY3Rpb25NdXRhdG9yfSBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uaWNQcm9qZWN0aW9uKHByb2plY3RBdCkge1xuICB2YXIgcGhpMCA9IDAsXG4gICAgICBwaGkxID0gcGkgLyAzLFxuICAgICAgbSA9IHByb2plY3Rpb25NdXRhdG9yKHByb2plY3RBdCksXG4gICAgICBwID0gbShwaGkwLCBwaGkxKTtcblxuICBwLnBhcmFsbGVscyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0ocGhpMCA9IF9bMF0gKiByYWRpYW5zLCBwaGkxID0gX1sxXSAqIHJhZGlhbnMpIDogW3BoaTAgKiBkZWdyZWVzLCBwaGkxICogZGVncmVlc107XG4gIH07XG5cbiAgcmV0dXJuIHA7XG59XG4iLCJpbXBvcnQge2FicywgYXRhbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBsb2csIHBpLCBwb3csIHNpZ24sIHNpbiwgc3FydCwgdGFufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtjb25pY1Byb2plY3Rpb259IGZyb20gXCIuL2NvbmljLmpzXCI7XG5pbXBvcnQge21lcmNhdG9yUmF3fSBmcm9tIFwiLi9tZXJjYXRvci5qc1wiO1xuXG5mdW5jdGlvbiB0YW55KHkpIHtcbiAgcmV0dXJuIHRhbigoaGFsZlBpICsgeSkgLyAyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsUmF3KHkwLCB5MSkge1xuICB2YXIgY3kwID0gY29zKHkwKSxcbiAgICAgIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogbG9nKGN5MCAvIGNvcyh5MSkpIC8gbG9nKHRhbnkoeTEpIC8gdGFueSh5MCkpLFxuICAgICAgZiA9IGN5MCAqIHBvdyh0YW55KHkwKSwgbikgLyBuO1xuXG4gIGlmICghbikgcmV0dXJuIG1lcmNhdG9yUmF3O1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIGlmIChmID4gMCkgeyBpZiAoeSA8IC1oYWxmUGkgKyBlcHNpbG9uKSB5ID0gLWhhbGZQaSArIGVwc2lsb247IH1cbiAgICBlbHNlIHsgaWYgKHkgPiBoYWxmUGkgLSBlcHNpbG9uKSB5ID0gaGFsZlBpIC0gZXBzaWxvbjsgfVxuICAgIHZhciByID0gZiAvIHBvdyh0YW55KHkpLCBuKTtcbiAgICByZXR1cm4gW3IgKiBzaW4obiAqIHgpLCBmIC0gciAqIGNvcyhuICogeCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGZ5ID0gZiAtIHksIHIgPSBzaWduKG4pICogc3FydCh4ICogeCArIGZ5ICogZnkpLFxuICAgICAgbCA9IGF0YW4yKHgsIGFicyhmeSkpICogc2lnbihmeSk7XG4gICAgaWYgKGZ5ICogbiA8IDApXG4gICAgICBsIC09IHBpICogc2lnbih4KSAqIHNpZ24oZnkpO1xuICAgIHJldHVybiBbbCAvIG4sIDIgKiBhdGFuKHBvdyhmIC8gciwgMSAvIG4pKSAtIGhhbGZQaV07XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljQ29uZm9ybWFsUmF3KVxuICAgICAgLnNjYWxlKDEwOS41KVxuICAgICAgLnBhcmFsbGVscyhbMzAsIDMwXSk7XG59XG4iLCJpbXBvcnQge2FicywgYXNpbiwgYXRhbjIsIGNvcywgZXBzaWxvbiwgcGksIHNpZ24sIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7Y29uaWNQcm9qZWN0aW9ufSBmcm9tIFwiLi9jb25pYy5qc1wiO1xuaW1wb3J0IHtjeWxpbmRyaWNhbEVxdWFsQXJlYVJhd30gZnJvbSBcIi4vY3lsaW5kcmljYWxFcXVhbEFyZWEuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhUmF3KHkwLCB5MSkge1xuICB2YXIgc3kwID0gc2luKHkwKSwgbiA9IChzeTAgKyBzaW4oeTEpKSAvIDI7XG5cbiAgLy8gQXJlIHRoZSBwYXJhbGxlbHMgc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBFcXVhdG9yP1xuICBpZiAoYWJzKG4pIDwgZXBzaWxvbikgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcblxuICB2YXIgYyA9IDEgKyBzeTAgKiAoMiAqIG4gLSBzeTApLCByMCA9IHNxcnQoYykgLyBuO1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIHZhciByID0gc3FydChjIC0gMiAqIG4gKiBzaW4oeSkpIC8gbjtcbiAgICByZXR1cm4gW3IgKiBzaW4oeCAqPSBuKSwgcjAgLSByICogY29zKHgpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByMHkgPSByMCAtIHksXG4gICAgICAgIGwgPSBhdGFuMih4LCBhYnMocjB5KSkgKiBzaWduKHIweSk7XG4gICAgaWYgKHIweSAqIG4gPCAwKVxuICAgICAgbCAtPSBwaSAqIHNpZ24oeCkgKiBzaWduKHIweSk7XG4gICAgcmV0dXJuIFtsIC8gbiwgYXNpbigoYyAtICh4ICogeCArIHIweSAqIHIweSkgKiBuICogbikgLyAoMiAqIG4pKV07XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1YWxBcmVhUmF3KVxuICAgICAgLnNjYWxlKDE1NS40MjQpXG4gICAgICAuY2VudGVyKFswLCAzMy42NDQyXSk7XG59XG4iLCJpbXBvcnQge2FicywgYXRhbjIsIGNvcywgZXBzaWxvbiwgcGksIHNpZ24sIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7Y29uaWNQcm9qZWN0aW9ufSBmcm9tIFwiLi9jb25pYy5qc1wiO1xuaW1wb3J0IHtlcXVpcmVjdGFuZ3VsYXJSYXd9IGZyb20gXCIuL2VxdWlyZWN0YW5ndWxhci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudFJhdyh5MCwgeTEpIHtcbiAgdmFyIGN5MCA9IGNvcyh5MCksXG4gICAgICBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IChjeTAgLSBjb3MoeTEpKSAvICh5MSAtIHkwKSxcbiAgICAgIGcgPSBjeTAgLyBuICsgeTA7XG5cbiAgaWYgKGFicyhuKSA8IGVwc2lsb24pIHJldHVybiBlcXVpcmVjdGFuZ3VsYXJSYXc7XG5cbiAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgdmFyIGd5ID0gZyAtIHksIG54ID0gbiAqIHg7XG4gICAgcmV0dXJuIFtneSAqIHNpbihueCksIGcgLSBneSAqIGNvcyhueCldO1xuICB9XG5cbiAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGd5ID0gZyAtIHksXG4gICAgICAgIGwgPSBhdGFuMih4LCBhYnMoZ3kpKSAqIHNpZ24oZ3kpO1xuICAgIGlmIChneSAqIG4gPCAwKVxuICAgICAgbCAtPSBwaSAqIHNpZ24oeCkgKiBzaWduKGd5KTtcbiAgICByZXR1cm4gW2wgLyBuLCBnIC0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBneSAqIGd5KV07XG4gIH07XG5cbiAgcmV0dXJuIHByb2plY3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoMTMxLjE1NClcbiAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcbn1cbiIsImltcG9ydCB7YXNpbiwgY29zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyhwaGkwKSB7XG4gIHZhciBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbihwaGkpIC8gY29zUGhpMF07XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG4iLCJpbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGNvcywgZXBzaWxvbjIsIHNpbiwgc3FydH0gZnJvbSBcIi4uL21hdGguanNcIjtcblxudmFyIEExID0gMS4zNDAyNjQsXG4gICAgQTIgPSAtMC4wODExMDYsXG4gICAgQTMgPSAwLjAwMDg5MyxcbiAgICBBNCA9IDAuMDAzNzk2LFxuICAgIE0gPSBzcXJ0KDMpIC8gMixcbiAgICBpdGVyYXRpb25zID0gMTI7XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEVhcnRoUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHZhciBsID0gYXNpbihNICogc2luKHBoaSkpLCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiBjb3MobCkgLyAoTSAqIChBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpKSksXG4gICAgbCAqIChBMSArIEEyICogbDIgKyBsNiAqIChBMyArIEE0ICogbDIpKVxuICBdO1xufVxuXG5lcXVhbEVhcnRoUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGwgPSB5LCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgZm9yICh2YXIgaSA9IDAsIGRlbHRhLCBmeSwgZnB5OyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XG4gICAgZnkgPSBsICogKEExICsgQTIgKiBsMiArIGw2ICogKEEzICsgQTQgKiBsMikpIC0geTtcbiAgICBmcHkgPSBBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpO1xuICAgIGwgLT0gZGVsdGEgPSBmeSAvIGZweSwgbDIgPSBsICogbCwgbDYgPSBsMiAqIGwyICogbDI7XG4gICAgaWYgKGFicyhkZWx0YSkgPCBlcHNpbG9uMikgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICBNICogeCAqIChBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpKSAvIGNvcyhsKSxcbiAgICBhc2luKHNpbihsKSAvIE0pXG4gIF07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZXF1YWxFYXJ0aFJhdylcbiAgICAgIC5zY2FsZSgxNzcuMTU4KTtcbn1cbiIsImltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG59XG5cbmVxdWlyZWN0YW5ndWxhclJhdy5pbnZlcnQgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihlcXVpcmVjdGFuZ3VsYXJSYXcpXG4gICAgICAuc2NhbGUoMTUyLjYzKTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyBnZW9TdHJlYW19IGZyb20gXCIuLi9zdHJlYW0uanNcIjtcbmltcG9ydCBib3VuZHNTdHJlYW0gZnJvbSBcIi4uL3BhdGgvYm91bmRzLmpzXCI7XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSkpO1xuICBmaXRCb3VuZHMoYm91bmRzU3RyZWFtLnJlc3VsdCgpKTtcbiAgaWYgKGNsaXAgIT0gbnVsbCkgcHJvamVjdGlvbi5jbGlwRXh0ZW50KGNsaXApO1xuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcbiAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbihiKSB7XG4gICAgdmFyIHcgPSArd2lkdGgsXG4gICAgICAgIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSxcbiAgICAgICAgeCA9ICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMixcbiAgICAgICAgeSA9IC1rICogYlswXVsxXTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG4iLCJpbXBvcnQge2F0YW4sIGNvcywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHthemltdXRoYWxJbnZlcnR9IGZyb20gXCIuL2F6aW11dGhhbC5qc1wiO1xuaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gY29zKHgpICogY3k7XG4gIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbn1cblxuZ25vbW9uaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGF0YW4pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZ25vbW9uaWNSYXcpXG4gICAgICAuc2NhbGUoMTQ0LjA0OSlcbiAgICAgIC5jbGlwQW5nbGUoNjApO1xufVxuIiwiaW1wb3J0IGNsaXBSZWN0YW5nbGUgZnJvbSBcIi4uL2NsaXAvcmVjdGFuZ2xlLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5pbXBvcnQge2ZpdEV4dGVudCwgZml0U2l6ZSwgZml0V2lkdGgsIGZpdEhlaWdodH0gZnJvbSBcIi4vZml0LmpzXCI7XG5pbXBvcnQge2NvcywgZGVncmVlcywgcmFkaWFucywgc2lufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIC8vIHNjYWxlLCB0cmFuc2xhdGUgYW5kIHJlZmxlY3RcbiAgICAgIGFscGhhID0gMCwgY2EsIHNhLCAvLyBhbmdsZVxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxuICAgICAga3ggPSAxLCBreSA9IDEsXG4gICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1lcih7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgdmFyIHAgPSBwcm9qZWN0aW9uKFt4LCB5XSlcbiAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludChwWzBdLCBwWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBwb3N0Y2xpcCA9IGlkZW50aXR5LFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBreCA9IGsgKiBzeDtcbiAgICBreSA9IGsgKiBzeTtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2plY3Rpb24gKHApIHtcbiAgICB2YXIgeCA9IHBbMF0gKiBreCwgeSA9IHBbMV0gKiBreTtcbiAgICBpZiAoYWxwaGEpIHtcbiAgICAgIHZhciB0ID0geSAqIGNhIC0geCAqIHNhO1xuICAgICAgeCA9IHggKiBjYSArIHkgKiBzYTtcbiAgICAgIHkgPSB0O1xuICAgIH0gICAgXG4gICAgcmV0dXJuIFt4ICsgdHgsIHkgKyB0eV07XG4gIH1cbiAgcHJvamVjdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHggPSBwWzBdIC0gdHgsIHkgPSBwWzFdIC0gdHk7XG4gICAgaWYgKGFscGhhKSB7XG4gICAgICB2YXIgdCA9IHkgKiBjYSArIHggKiBzYTtcbiAgICAgIHggPSB4ICogY2EgLSB5ICogc2E7XG4gICAgICB5ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIFt4IC8ga3gsIHkgLyBreV07XG4gIH07XG4gIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gdHJhbnNmb3JtKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSk7XG4gIH07XG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG4gIHByb2plY3Rpb24uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwb3N0Y2xpcCA9IF8gPT0gbnVsbCA/ICh4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIGlkZW50aXR5KSA6IGNsaXBSZWN0YW5nbGUoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSksIHJlc2V0KCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlc2V0KCkpIDogaztcbiAgfTtcbiAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHggPSArX1swXSwgdHkgPSArX1sxXSwgcmVzZXQoKSkgOiBbdHgsIHR5XTtcbiAgfVxuICBwcm9qZWN0aW9uLmFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhID0gXyAlIDM2MCAqIHJhZGlhbnMsIHNhID0gc2luKGFscGhhKSwgY2EgPSBjb3MoYWxwaGEpLCByZXNldCgpKSA6IGFscGhhICogZGVncmVlcztcbiAgfTtcbiAgcHJvamVjdGlvbi5yZWZsZWN0WCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeCA9IF8gPyAtMSA6IDEsIHJlc2V0KCkpIDogc3ggPCAwO1xuICB9O1xuICBwcm9qZWN0aW9uLnJlZmxlY3RZID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN5ID0gXyA/IC0xIDogMSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gIH07XG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcbiAgcHJvamVjdGlvbi5maXRXaWR0aCA9IGZ1bmN0aW9uKHdpZHRoLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdGlvbjtcbn1cbiIsImltcG9ydCBjbGlwQW50aW1lcmlkaWFuIGZyb20gXCIuLi9jbGlwL2FudGltZXJpZGlhbi5qc1wiO1xuaW1wb3J0IGNsaXBDaXJjbGUgZnJvbSBcIi4uL2NsaXAvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY2xpcFJlY3RhbmdsZSBmcm9tIFwiLi4vY2xpcC9yZWN0YW5nbGUuanNcIjtcbmltcG9ydCBjb21wb3NlIGZyb20gXCIuLi9jb21wb3NlLmpzXCI7XG5pbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4uL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQge2NvcywgZGVncmVlcywgcmFkaWFucywgc2luLCBzcXJ0fSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtyb3RhdGVSYWRpYW5zfSBmcm9tIFwiLi4vcm90YXRpb24uanNcIjtcbmltcG9ydCB7dHJhbnNmb3JtZXJ9IGZyb20gXCIuLi90cmFuc2Zvcm0uanNcIjtcbmltcG9ydCB7Zml0RXh0ZW50LCBmaXRTaXplLCBmaXRXaWR0aCwgZml0SGVpZ2h0fSBmcm9tIFwiLi9maXQuanNcIjtcbmltcG9ydCByZXNhbXBsZSBmcm9tIFwiLi9yZXNhbXBsZS5qc1wiO1xuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSkge1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgIHggKj0gc3g7IHkgKj0gc3k7XG4gICAgcmV0dXJuIFtkeCArIGsgKiB4LCBkeSAtIGsgKiB5XTtcbiAgfVxuICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbKHggLSBkeCkgLyBrICogc3gsIChkeSAtIHkpIC8gayAqIHN5XTtcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgZHgsIGR5LCBzeCwgc3ksIGFscGhhKSB7XG4gIGlmICghYWxwaGEpIHJldHVybiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHksIHN4LCBzeSk7XG4gIHZhciBjb3NBbHBoYSA9IGNvcyhhbHBoYSksXG4gICAgICBzaW5BbHBoYSA9IHNpbihhbHBoYSksXG4gICAgICBhID0gY29zQWxwaGEgKiBrLFxuICAgICAgYiA9IHNpbkFscGhhICogayxcbiAgICAgIGFpID0gY29zQWxwaGEgLyBrLFxuICAgICAgYmkgPSBzaW5BbHBoYSAvIGssXG4gICAgICBjaSA9IChzaW5BbHBoYSAqIGR5IC0gY29zQWxwaGEgKiBkeCkgLyBrLFxuICAgICAgZmkgPSAoc2luQWxwaGEgKiBkeCArIGNvc0FscGhhICogZHkpIC8gaztcbiAgZnVuY3Rpb24gdHJhbnNmb3JtKHgsIHkpIHtcbiAgICB4ICo9IHN4OyB5ICo9IHN5O1xuICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICB9XG4gIHRyYW5zZm9ybS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFtzeCAqIChhaSAqIHggLSBiaSAqIHkgKyBjaSksIHN5ICogKGZpIC0gYmkgKiB4IC0gYWkgKiB5KV07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9qZWN0OyB9KSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gIHZhciBwcm9qZWN0LFxuICAgICAgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgYWxwaGEgPSAwLCAvLyBwb3N0LXJvdGF0ZSBhbmdsZVxuICAgICAgc3ggPSAxLCAvLyByZWZsZWN0WFxuICAgICAgc3kgPSAxLCAvLyByZWZsZWN0WFxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cbiAgICAgIHByb2plY3RSZXNhbXBsZSxcbiAgICAgIHByb2plY3RUcmFuc2Zvcm0sXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICB9XG5cbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlY2VudGVyKCkpIDogaztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMsIGRlbHRhUGhpICogZGVncmVlcywgZGVsdGFHYW1tYSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5yZWZsZWN0WCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzeCA9IF8gPyAtMSA6IDEsIHJlY2VudGVyKCkpIDogc3ggPCAwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucmVmbGVjdFkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3kgPSBfID8gLTEgOiAxLCByZWNlbnRlcigpKSA6IHN5IDwgMDtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0UmVzYW1wbGUgPSByZXNhbXBsZShwcm9qZWN0VHJhbnNmb3JtLCBkZWx0YTIgPSBfICogXyksIHJlc2V0KCkpIDogc3FydChkZWx0YTIpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0RXh0ZW50ID0gZnVuY3Rpb24oZXh0ZW50LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbihzaXplLCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpO1xuICB9O1xuXG4gIHByb2plY3Rpb24uZml0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0LCBvYmplY3QpIHtcbiAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICB2YXIgY2VudGVyID0gc2NhbGVUcmFuc2xhdGVSb3RhdGUoaywgMCwgMCwgc3gsIHN5LCBhbHBoYSkuYXBwbHkobnVsbCwgcHJvamVjdChsYW1iZGEsIHBoaSkpLFxuICAgICAgICB0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCB4IC0gY2VudGVyWzBdLCB5IC0gY2VudGVyWzFdLCBzeCwgc3ksIGFscGhhKTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtKTtcbiAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtID0gY29tcG9zZShyb3RhdGUsIHByb2plY3RUcmFuc2Zvcm0pO1xuICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gIH07XG59XG4iLCJpbXBvcnQge2F0YW4sIGV4cCwgaGFsZlBpLCBsb2csIHBpLCB0YW4sIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCByb3RhdGlvbiBmcm9tIFwiLi4vcm90YXRpb24uanNcIjtcbmltcG9ydCBwcm9qZWN0aW9uIGZyb20gXCIuL2luZGV4LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICByZXR1cm4gW2xhbWJkYSwgbG9nKHRhbigoaGFsZlBpICsgcGhpKSAvIDIpKV07XG59XG5cbm1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIFt4LCAyICogYXRhbihleHAoeSkpIC0gaGFsZlBpXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbWVyY2F0b3JQcm9qZWN0aW9uKG1lcmNhdG9yUmF3KVxuICAgICAgLnNjYWxlKDk2MSAvIHRhdSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICB2YXIgbSA9IHByb2plY3Rpb24ocHJvamVjdCksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHNjYWxlID0gbS5zY2FsZSxcbiAgICAgIHRyYW5zbGF0ZSA9IG0udHJhbnNsYXRlLFxuICAgICAgY2xpcEV4dGVudCA9IG0uY2xpcEV4dGVudCxcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MTsgLy8gY2xpcCBleHRlbnRcblxuICBtLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlKF8pLCByZWNsaXAoKSkgOiBzY2FsZSgpO1xuICB9O1xuXG4gIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZShfKSwgcmVjbGlwKCkpIDogdHJhbnNsYXRlKCk7XG4gIH07XG5cbiAgbS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyKF8pLCByZWNsaXAoKSkgOiBjZW50ZXIoKTtcbiAgfTtcblxuICBtLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKF8gPT0gbnVsbCA/IHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCA6ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSksIHJlY2xpcCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjbGlwKCkge1xuICAgIHZhciBrID0gcGkgKiBzY2FsZSgpLFxuICAgICAgICB0ID0gbShyb3RhdGlvbihtLnJvdGF0ZSgpKS5pbnZlcnQoWzAsIDBdKSk7XG4gICAgcmV0dXJuIGNsaXBFeHRlbnQoeDAgPT0gbnVsbFxuICAgICAgICA/IFtbdFswXSAtIGssIHRbMV0gLSBrXSwgW3RbMF0gKyBrLCB0WzFdICsga11dIDogcHJvamVjdCA9PT0gbWVyY2F0b3JSYXdcbiAgICAgICAgPyBbW01hdGgubWF4KHRbMF0gLSBrLCB4MCksIHkwXSwgW01hdGgubWluKHRbMF0gKyBrLCB4MSksIHkxXV1cbiAgICAgICAgOiBbW3gwLCBNYXRoLm1heCh0WzFdIC0gaywgeTApXSwgW3gxLCBNYXRoLm1pbih0WzFdICsgaywgeTEpXV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlY2xpcCgpO1xufVxuIiwiaW1wb3J0IHByb2plY3Rpb24gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7YWJzLCBlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbmF0dXJhbEVhcnRoMVJhdyhsYW1iZGEsIHBoaSkge1xuICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICByZXR1cm4gW1xuICAgIGxhbWJkYSAqICgwLjg3MDcgLSAwLjEzMTk3OSAqIHBoaTIgKyBwaGk0ICogKC0wLjAxMzc5MSArIHBoaTQgKiAoMC4wMDM5NzEgKiBwaGkyIC0gMC4wMDE1MjkgKiBwaGk0KSkpLFxuICAgIHBoaSAqICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKyBwaGk0ICogKC0wLjA0NDQ3NSArIDAuMDI4ODc0ICogcGhpMiAtIDAuMDA1OTE2ICogcGhpNCkpKVxuICBdO1xufVxuXG5uYXR1cmFsRWFydGgxUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHBoaSA9IHksIGkgPSAyNSwgZGVsdGE7XG4gIGRvIHtcbiAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSkgLSB5KSAvXG4gICAgICAgICgxLjAwNzIyNiArIHBoaTIgKiAoMC4wMTUwODUgKiAzICsgcGhpNCAqICgtMC4wNDQ0NzUgKiA3ICsgMC4wMjg4NzQgKiA5ICogcGhpMiAtIDAuMDA1OTE2ICogMTEgKiBwaGk0KSkpO1xuICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgcmV0dXJuIFtcbiAgICB4IC8gKDAuODcwNyArIChwaGkyID0gcGhpICogcGhpKSAqICgtMC4xMzE5NzkgKyBwaGkyICogKC0wLjAxMzc5MSArIHBoaTIgKiBwaGkyICogcGhpMiAqICgwLjAwMzk3MSAtIDAuMDAxNTI5ICogcGhpMikpKSksXG4gICAgcGhpXG4gIF07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24obmF0dXJhbEVhcnRoMVJhdylcbiAgICAgIC5zY2FsZSgxNzUuMjk1KTtcbn1cbiIsImltcG9ydCB7YXNpbiwgY29zLCBlcHNpbG9uLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2F6aW11dGhhbEludmVydH0gZnJvbSBcIi4vYXppbXV0aGFsLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9ncmFwaGljUmF3KHgsIHkpIHtcbiAgcmV0dXJuIFtjb3MoeSkgKiBzaW4oeCksIHNpbih5KV07XG59XG5cbm9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihvcnRob2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjQ5LjUpXG4gICAgICAuY2xpcEFuZ2xlKDkwICsgZXBzaWxvbik7XG59XG4iLCJpbXBvcnQge2NhcnRlc2lhbn0gZnJvbSBcIi4uL2NhcnRlc2lhbi5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGVwc2lsb24sIHJhZGlhbnMsIHNxcnR9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge3RyYW5zZm9ybWVyfSBmcm9tIFwiLi4vdHJhbnNmb3JtLmpzXCI7XG5cbnZhciBtYXhEZXB0aCA9IDE2LCAvLyBtYXhpbXVtIGRlcHRoIG9mIHN1YmRpdmlzaW9uXG4gICAgY29zTWluRGlzdGFuY2UgPSBjb3MoMzAgKiByYWRpYW5zKTsgLy8gY29zKG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSlcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocHJvamVjdCwgZGVsdGEyKSB7XG4gIHJldHVybiArZGVsdGEyID8gcmVzYW1wbGUocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIHtcblxuICBmdW5jdGlvbiByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgbGFtYmRhMSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgIHZhciBkeCA9IHgxIC0geDAsXG4gICAgICAgIGR5ID0geTEgLSB5MCxcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoZDIgPiA0ICogZGVsdGEyICYmIGRlcHRoLS0pIHtcbiAgICAgIHZhciBhID0gYTAgKyBhMSxcbiAgICAgICAgICBiID0gYjAgKyBiMSxcbiAgICAgICAgICBjID0gYzAgKyBjMSxcbiAgICAgICAgICBtID0gc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLFxuICAgICAgICAgIHBoaTIgPSBhc2luKGMgLz0gbSksXG4gICAgICAgICAgbGFtYmRhMiA9IGFicyhhYnMoYykgLSAxKSA8IGVwc2lsb24gfHwgYWJzKGxhbWJkYTAgLSBsYW1iZGExKSA8IGVwc2lsb24gPyAobGFtYmRhMCArIGxhbWJkYTEpIC8gMiA6IGF0YW4yKGIsIGEpLFxuICAgICAgICAgIHAgPSBwcm9qZWN0KGxhbWJkYTIsIHBoaTIpLFxuICAgICAgICAgIHgyID0gcFswXSxcbiAgICAgICAgICB5MiA9IHBbMV0sXG4gICAgICAgICAgZHgyID0geDIgLSB4MCxcbiAgICAgICAgICBkeTIgPSB5MiAtIHkwLFxuICAgICAgICAgIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgIGlmIChkeiAqIGR6IC8gZDIgPiBkZWx0YTIgLy8gcGVycGVuZGljdWxhciBwcm9qZWN0ZWQgZGlzdGFuY2VcbiAgICAgICAgICB8fCBhYnMoKGR4ICogZHgyICsgZHkgKiBkeTIpIC8gZDIgLSAwLjUpID4gMC4zIC8vIG1pZHBvaW50IGNsb3NlIHRvIGFuIGVuZFxuICAgICAgICAgIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7IC8vIGFuZ3VsYXIgZGlzdGFuY2VcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MiwgeTIsIGxhbWJkYTIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgbGFtYmRhMiwgYSwgYiwgYywgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBsYW1iZGEwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIGxhbWJkYTAsIHgwLCB5MCwgYTAsIGIwLCBjMDsgLy8gcHJldmlvdXMgcG9pbnRcblxuICAgIHZhciByZXNhbXBsZVN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7IHN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gcmluZ1N0YXJ0OyB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7IHN0cmVhbS5wb2x5Z29uRW5kKCk7IHJlc2FtcGxlU3RyZWFtLmxpbmVTdGFydCA9IGxpbmVTdGFydDsgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICB4MCA9IE5hTjtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgdmFyIGMgPSBjYXJ0ZXNpYW4oW2xhbWJkYSwgcGhpXSksIHAgPSBwcm9qZWN0KGxhbWJkYSwgcGhpKTtcbiAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIGxhbWJkYTAgPSBsYW1iZGEsIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGxpbmVTdGFydCgpO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgIGxpbmVQb2ludChsYW1iZGEwMCA9IGxhbWJkYSwgcGhpKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAwLCB5MDAsIGxhbWJkYTAwLCBhMDAsIGIwMCwgYzAwLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgbGluZUVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNhbXBsZVN0cmVhbTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YXRhbiwgY29zLCBzaW59IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5pbXBvcnQge2F6aW11dGhhbEludmVydH0gZnJvbSBcIi4vYXppbXV0aGFsLmpzXCI7XG5pbXBvcnQgcHJvamVjdGlvbiBmcm9tIFwiLi9pbmRleC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RlcmVvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gIHZhciBjeSA9IGNvcyh5KSwgayA9IDEgKyBjb3MoeCkgKiBjeTtcbiAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xufVxuXG5zdGVyZW9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXRhbih6KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oc3RlcmVvZ3JhcGhpY1JhdylcbiAgICAgIC5zY2FsZSgyNTApXG4gICAgICAuY2xpcEFuZ2xlKDE0Mik7XG59XG4iLCJpbXBvcnQge2F0YW4sIGV4cCwgaGFsZlBpLCBsb2csIHRhbn0gZnJvbSBcIi4uL21hdGguanNcIjtcbmltcG9ydCB7bWVyY2F0b3JQcm9qZWN0aW9ufSBmcm9tIFwiLi9tZXJjYXRvci5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbG9nKHRhbigoaGFsZlBpICsgcGhpKSAvIDIpKSwgLWxhbWJkYV07XG59XG5cbnRyYW5zdmVyc2VNZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiBbLXksIDIgKiBhdGFuKGV4cCh4KSkgLSBoYWxmUGldO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IG0ucm90YXRlO1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gIH07XG5cbiAgbS5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0ZShbMCwgMCwgOTBdKVxuICAgICAgLnNjYWxlKDE1OS4xNTUpO1xufVxuIiwiaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGF0YW4yLCBjb3MsIGRlZ3JlZXMsIHBpLCByYWRpYW5zLCBzaW4sIHRhdX0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbYWJzKGxhbWJkYSkgPiBwaSA/IGxhbWJkYSArIE1hdGgucm91bmQoLWxhbWJkYSAvIHRhdSkgKiB0YXUgOiBsYW1iZGEsIHBoaV07XG59XG5cbnJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1KSA/IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gY29tcG9zZShyb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSksIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpKVxuICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgIDogKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKVxuICAgIDogcm90YXRpb25JZGVudGl0eSk7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICByZXR1cm4gZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gbGFtYmRhICs9IGRlbHRhTGFtYmRhLCBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHZhciByb3RhdGlvbiA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSk7XG4gIHJvdGF0aW9uLmludmVydCA9IGZvcndhcmRSb3RhdGlvbkxhbWJkYSgtZGVsdGFMYW1iZGEpO1xuICByZXR1cm4gcm90YXRpb247XG59XG5cbmZ1bmN0aW9uIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgdmFyIGNvc0RlbHRhUGhpID0gY29zKGRlbHRhUGhpKSxcbiAgICAgIHNpbkRlbHRhUGhpID0gc2luKGRlbHRhUGhpKSxcbiAgICAgIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksXG4gICAgICBzaW5EZWx0YUdhbW1hID0gc2luKGRlbHRhR2FtbWEpO1xuXG4gIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhUGhpICsgeCAqIHNpbkRlbHRhUGhpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih5ICogY29zRGVsdGFHYW1tYSAtIGsgKiBzaW5EZWx0YUdhbW1hLCB4ICogY29zRGVsdGFQaGkgLSB6ICogc2luRGVsdGFQaGkpLFxuICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgIF07XG4gIH1cblxuICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgICAgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgICAgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YVBoaSAtIHggKiBzaW5EZWx0YVBoaSlcbiAgICBdO1xuICB9O1xuXG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocm90YXRlKSB7XG4gIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMocm90YXRlWzBdICogcmFkaWFucywgcm90YXRlWzFdICogcmFkaWFucywgcm90YXRlLmxlbmd0aCA+IDIgPyByb3RhdGVbMl0gKiByYWRpYW5zIDogMCk7XG5cbiAgZnVuY3Rpb24gZm9yd2FyZChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG4iLCJmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICBzdHJlYW1HZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIHN0cmVhbU9iamVjdFR5cGUgPSB7XG4gIEZlYXR1cmU6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBzdHJlYW0pO1xuICB9LFxuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH1cbn07XG5cbnZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW0uc3BoZXJlKCk7XG4gIH0sXG4gIFBvaW50OiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gIH0sXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgfSxcbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0pO1xuICB9LFxuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgd2hpbGUgKCsraSA8IG4pIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICBzdHJlYW0ubGluZUVuZCgpO1xufVxuXG5mdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAxKTtcbiAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHRyYW5zZm9ybWVyKG1ldGhvZHMpXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG4iLCJleHBvcnQgZnVuY3Rpb24gb3B0aW9uYWwoZikge1xuICByZXR1cm4gZiA9PSBudWxsID8gbnVsbCA6IHJlcXVpcmVkKGYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZWQoZikge1xuICBpZiAodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZjtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4geFxuICAgID8geCAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oeCk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gIHZhciBtID0gYXJyYXkubGVuZ3RoLFxuICAgICAgdCxcbiAgICAgIGk7XG5cbiAgd2hpbGUgKG0pIHtcbiAgICBpID0gTWF0aC5yYW5kb20oKSAqIG0tLSB8IDA7XG4gICAgdCA9IGFycmF5W21dO1xuICAgIGFycmF5W21dID0gYXJyYXlbaV07XG4gICAgYXJyYXlbaV0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuIiwiZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG59XG5cbmZ1bmN0aW9uIG1lYW5YKGNoaWxkcmVuKSB7XG4gIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UobWVhblhSZWR1Y2UsIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBtZWFuWFJlZHVjZSh4LCBjKSB7XG4gIHJldHVybiB4ICsgYy54O1xufVxuXG5mdW5jdGlvbiBtYXhZKGNoaWxkcmVuKSB7XG4gIHJldHVybiAxICsgY2hpbGRyZW4ucmVkdWNlKG1heFlSZWR1Y2UsIDApO1xufVxuXG5mdW5jdGlvbiBtYXhZUmVkdWNlKHksIGMpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHksIGMueSk7XG59XG5cbmZ1bmN0aW9uIGxlYWZMZWZ0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuO1xuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bMF07XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBsZWFmUmlnaHQobm9kZSkge1xuICB2YXIgY2hpbGRyZW47XG4gIHdoaWxlIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIG5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbHVzdGVyKHJvb3QpIHtcbiAgICB2YXIgcHJldmlvdXNOb2RlLFxuICAgICAgICB4ID0gMDtcblxuICAgIC8vIEZpcnN0IHdhbGssIGNvbXB1dGluZyB0aGUgaW5pdGlhbCB4ICYgeSB2YWx1ZXMuXG4gICAgcm9vdC5lYWNoQWZ0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBub2RlLnggPSBtZWFuWChjaGlsZHJlbik7XG4gICAgICAgIG5vZGUueSA9IG1heFkoY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGxlZnQgPSBsZWFmTGVmdChyb290KSxcbiAgICAgICAgcmlnaHQgPSBsZWFmUmlnaHQocm9vdCksXG4gICAgICAgIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICB4MSA9IHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDI7XG5cbiAgICAvLyBTZWNvbmQgd2Fsaywgbm9ybWFsaXppbmcgeCAmIHkgdG8gdGhlIGRlc2lyZWQgc2l6ZS5cbiAgICByZXR1cm4gcm9vdC5lYWNoQWZ0ZXIobm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0gcm9vdC54KSAqIGR4O1xuICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBkeTtcbiAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIGR4O1xuICAgICAgbm9kZS55ID0gKDEgLSAocm9vdC55ID8gbm9kZS55IC8gcm9vdC55IDogMSkpICogZHk7XG4gICAgfSk7XG4gIH1cblxuICBjbHVzdGVyLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIGNsdXN0ZXIpIDogc2VwYXJhdGlvbjtcbiAgfTtcblxuICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICB9O1xuXG4gIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIGNsdXN0ZXI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gY29uc3RhbnRaZXJvKCkge1xuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXTtcbiAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuIiwiZnVuY3Rpb24gY291bnQobm9kZSkge1xuICB2YXIgc3VtID0gMCxcbiAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gIGlmICghaSkgc3VtID0gMTtcbiAgZWxzZSB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcbiAgbm9kZS52YWx1ZSA9IHN1bTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmVhY2hBZnRlcihjb3VudCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20odGhpcyk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaywgdGhhdCkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMpIHtcbiAgICBjYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsICsraW5kZXgsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIHRoYXQpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXSwgbmV4dCA9IFtdLCBjaGlsZHJlbiwgaSwgbiwgaW5kZXggPSAtMTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIG5leHQucHVzaChub2RlKTtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsICsraW5kZXgsIHRoaXMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIHRoYXQpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXSwgY2hpbGRyZW4sIGksIGluZGV4ID0gLTE7XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBjYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsICsraW5kZXgsIHRoaXMpO1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGF0KSB7XG4gIGxldCBpbmRleCA9IC0xO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcykge1xuICAgIGlmIChjYWxsYmFjay5jYWxsKHRoYXQsIG5vZGUsICsraW5kZXgsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBub2RlX2NvdW50IGZyb20gXCIuL2NvdW50LmpzXCI7XG5pbXBvcnQgbm9kZV9lYWNoIGZyb20gXCIuL2VhY2guanNcIjtcbmltcG9ydCBub2RlX2VhY2hCZWZvcmUgZnJvbSBcIi4vZWFjaEJlZm9yZS5qc1wiO1xuaW1wb3J0IG5vZGVfZWFjaEFmdGVyIGZyb20gXCIuL2VhY2hBZnRlci5qc1wiO1xuaW1wb3J0IG5vZGVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgbm9kZV9zdW0gZnJvbSBcIi4vc3VtLmpzXCI7XG5pbXBvcnQgbm9kZV9zb3J0IGZyb20gXCIuL3NvcnQuanNcIjtcbmltcG9ydCBub2RlX3BhdGggZnJvbSBcIi4vcGF0aC5qc1wiO1xuaW1wb3J0IG5vZGVfYW5jZXN0b3JzIGZyb20gXCIuL2FuY2VzdG9ycy5qc1wiO1xuaW1wb3J0IG5vZGVfZGVzY2VuZGFudHMgZnJvbSBcIi4vZGVzY2VuZGFudHMuanNcIjtcbmltcG9ydCBub2RlX2xlYXZlcyBmcm9tIFwiLi9sZWF2ZXMuanNcIjtcbmltcG9ydCBub2RlX2xpbmtzIGZyb20gXCIuL2xpbmtzLmpzXCI7XG5pbXBvcnQgbm9kZV9pdGVyYXRvciBmcm9tIFwiLi9pdGVyYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoaWVyYXJjaHkoZGF0YSwgY2hpbGRyZW4pIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICBkYXRhID0gW3VuZGVmaW5lZCwgZGF0YV07XG4gICAgaWYgKGNoaWxkcmVuID09PSB1bmRlZmluZWQpIGNoaWxkcmVuID0gbWFwQ2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkge1xuICAgIGNoaWxkcmVuID0gb2JqZWN0Q2hpbGRyZW47XG4gIH1cblxuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzID0gW3Jvb3RdLFxuICAgICAgY2hpbGQsXG4gICAgICBjaGlsZHMsXG4gICAgICBpLFxuICAgICAgbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbihub2RlLmRhdGEpKSAmJiAobiA9IChjaGlsZHMgPSBBcnJheS5mcm9tKGNoaWxkcykpLmxlbmd0aCkpIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHM7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IGNoaWxkc1tpXSA9IG5ldyBOb2RlKGNoaWxkc1tpXSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290LmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIG5vZGVfY29weSgpIHtcbiAgcmV0dXJuIGhpZXJhcmNoeSh0aGlzKS5lYWNoQmVmb3JlKGNvcHlEYXRhKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q2hpbGRyZW4oZCkge1xuICByZXR1cm4gZC5jaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oZCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkKSA/IGRbMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5RGF0YShub2RlKSB7XG4gIGlmIChub2RlLmRhdGEudmFsdWUgIT09IHVuZGVmaW5lZCkgbm9kZS52YWx1ZSA9IG5vZGUuZGF0YS52YWx1ZTtcbiAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLmRhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSGVpZ2h0KG5vZGUpIHtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIGRvIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudCkgJiYgKG5vZGUuaGVpZ2h0IDwgKytoZWlnaHQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIE5vZGUoZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRlcHRoID1cbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG59XG5cbk5vZGUucHJvdG90eXBlID0gaGllcmFyY2h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE5vZGUsXG4gIGNvdW50OiBub2RlX2NvdW50LFxuICBlYWNoOiBub2RlX2VhY2gsXG4gIGVhY2hBZnRlcjogbm9kZV9lYWNoQWZ0ZXIsXG4gIGVhY2hCZWZvcmU6IG5vZGVfZWFjaEJlZm9yZSxcbiAgZmluZDogbm9kZV9maW5kLFxuICBzdW06IG5vZGVfc3VtLFxuICBzb3J0OiBub2RlX3NvcnQsXG4gIHBhdGg6IG5vZGVfcGF0aCxcbiAgYW5jZXN0b3JzOiBub2RlX2FuY2VzdG9ycyxcbiAgZGVzY2VuZGFudHM6IG5vZGVfZGVzY2VuZGFudHMsXG4gIGxlYXZlczogbm9kZV9sZWF2ZXMsXG4gIGxpbmtzOiBub2RlX2xpbmtzLFxuICBjb3B5OiBub2RlX2NvcHksXG4gIFtTeW1ib2wuaXRlcmF0b3JdOiBub2RlX2l0ZXJhdG9yXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qKCkge1xuICB2YXIgbm9kZSA9IHRoaXMsIGN1cnJlbnQsIG5leHQgPSBbbm9kZV0sIGNoaWxkcmVuLCBpLCBuO1xuICBkbyB7XG4gICAgY3VycmVudCA9IG5leHQucmV2ZXJzZSgpLCBuZXh0ID0gW107XG4gICAgd2hpbGUgKG5vZGUgPSBjdXJyZW50LnBvcCgpKSB7XG4gICAgICB5aWVsZCBub2RlO1xuICAgICAgaWYgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAobmV4dC5sZW5ndGgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBsZWF2ZXMgPSBbXTtcbiAgdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGxlYXZlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsZWF2ZXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLCBsaW5rcyA9IFtdO1xuICByb290LmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICE9PSByb290KSB7IC8vIERvbuKAmXQgaW5jbHVkZSB0aGUgcm9vdOKAmXMgcGFyZW50LCBpZiBhbnkuXG4gICAgICBsaW5rcy5wdXNoKHtzb3VyY2U6IG5vZGUucGFyZW50LCB0YXJnZXQ6IG5vZGV9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGlua3M7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihlbmQpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcyxcbiAgICAgIGFuY2VzdG9yID0gbGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSxcbiAgICAgIG5vZGVzID0gW3N0YXJ0XTtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBhbmNlc3Rvcikge1xuICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgIG5vZGVzLnB1c2goc3RhcnQpO1xuICB9XG4gIHZhciBrID0gbm9kZXMubGVuZ3RoO1xuICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xuICAgIG5vZGVzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5mdW5jdGlvbiBsZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiBhO1xuICB2YXIgYU5vZGVzID0gYS5hbmNlc3RvcnMoKSxcbiAgICAgIGJOb2RlcyA9IGIuYW5jZXN0b3JzKCksXG4gICAgICBjID0gbnVsbDtcbiAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICBjID0gYTtcbiAgICBhID0gYU5vZGVzLnBvcCgpO1xuICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb21wYXJlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG4gICAgfVxuICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHN1bSA9ICt2YWx1ZShub2RlLmRhdGEpIHx8IDAsXG4gICAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcbiAgICBub2RlLnZhbHVlID0gc3VtO1xuICB9KTtcbn1cbiIsImltcG9ydCB7c2h1ZmZsZX0gZnJvbSBcIi4uL2FycmF5LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNpcmNsZXMpIHtcbiAgdmFyIGkgPSAwLCBuID0gKGNpcmNsZXMgPSBzaHVmZmxlKEFycmF5LmZyb20oY2lyY2xlcykpKS5sZW5ndGgsIEIgPSBbXSwgcCwgZTtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBwID0gY2lyY2xlc1tpXTtcbiAgICBpZiAoZSAmJiBlbmNsb3Nlc1dlYWsoZSwgcCkpICsraTtcbiAgICBlbHNlIGUgPSBlbmNsb3NlQmFzaXMoQiA9IGV4dGVuZEJhc2lzKEIsIHApKSwgaSA9IDA7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICB2YXIgaSwgajtcblxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCKSkge1xuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgTWF0aC5tYXgoYS5yLCBiLnIsIDEpICogMWUtOSwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSxcbiAgICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeDEgKyB4MiArIHgyMSAvIGwgKiByMjEpIC8gMixcbiAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMucixcbiAgICAgIGEyID0geDEgLSB4MixcbiAgICAgIGEzID0geDEgLSB4MyxcbiAgICAgIGIyID0geTEgLSB5MixcbiAgICAgIGIzID0geTEgLSB5MyxcbiAgICAgIGMyID0gcjIgLSByMSxcbiAgICAgIGMzID0gcjMgLSByMSxcbiAgICAgIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLFxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgICBhYiA9IGEzICogYjIgLSBhMiAqIGIzLFxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgICAgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSxcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICAgIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLFxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgIHk6IHkxICsgeWEgKyB5YiAqIHIsXG4gICAgcjogclxuICB9O1xufVxuIiwiaW1wb3J0IHtwYWNrRW5jbG9zZX0gZnJvbSBcIi4vc2libGluZ3MuanNcIjtcbmltcG9ydCB7b3B0aW9uYWx9IGZyb20gXCIuLi9hY2Nlc3NvcnMuanNcIjtcbmltcG9ydCBjb25zdGFudCwge2NvbnN0YW50WmVyb30gZnJvbSBcIi4uL2NvbnN0YW50LmpzXCI7XG5cbmZ1bmN0aW9uIGRlZmF1bHRSYWRpdXMoZCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHJhZGl1cyA9IG51bGwsXG4gICAgICBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xuXG4gIGZ1bmN0aW9uIHBhY2socm9vdCkge1xuICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xuICAgIGlmIChyYWRpdXMpIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKHJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgMC41KSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZCgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMpKVxuICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKGNvbnN0YW50WmVybywgMSkpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4ocGFkZGluZywgcm9vdC5yIC8gTWF0aC5taW4oZHgsIGR5KSkpXG4gICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoTWF0aC5taW4oZHgsIGR5KSAvICgyICogcm9vdC5yKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IG9wdGlvbmFsKHgpLCBwYWNrKSA6IHJhZGl1cztcbiAgfTtcblxuICBwYWNrLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFjaykgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYWNrLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCBwYWNrKSA6IHBhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIHBhY2s7XG59XG5cbmZ1bmN0aW9uIHJhZGl1c0xlYWYocmFkaXVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLnIgPSBNYXRoLm1heCgwLCArcmFkaXVzKG5vZGUpIHx8IDApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGRyZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLFxuICAgICAgICAgIGU7XG5cbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yICs9IHI7XG4gICAgICBlID0gcGFja0VuY2xvc2UoY2hpbGRyZW4pO1xuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgLT0gcjtcbiAgICAgIG5vZGUuciA9IGUgKyByO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlQ2hpbGQoaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlLnggPSBwYXJlbnQueCArIGsgKiBub2RlLng7XG4gICAgICBub2RlLnkgPSBwYXJlbnQueSArIGsgKiBub2RlLnk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0IGFycmF5IGZyb20gXCIuLi9hcnJheS5qc1wiO1xuaW1wb3J0IGVuY2xvc2UgZnJvbSBcIi4vZW5jbG9zZS5qc1wiO1xuXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsXG4gICAgICBkeSA9IGIueSAtIGEueSwgeSwgYjIsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgIGlmIChhMiA+IGIyKSB7XG4gICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBiLnggLSB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBhMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYS54ICsgYy5yO1xuICAgIGMueSA9IGEueTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICB2YXIgYSA9IG5vZGUuXyxcbiAgICAgIGIgPSBub2RlLm5leHQuXyxcbiAgICAgIGFiID0gYS5yICsgYi5yLFxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIE5vZGUoY2lyY2xlKSB7XG4gIHRoaXMuXyA9IGNpcmNsZTtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWNrRW5jbG9zZShjaXJjbGVzKSB7XG4gIGlmICghKG4gPSAoY2lyY2xlcyA9IGFycmF5KGNpcmNsZXMpKS5sZW5ndGgpKSByZXR1cm4gMDtcblxuICB2YXIgYSwgYiwgYywgbiwgYWEsIGNhLCBpLCBqLCBrLCBzaiwgc2s7XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcbiAgaWYgKCEobiA+IDIpKSByZXR1cm4gYS5yICsgYi5yO1xuXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcblxuICAvLyBJbml0aWFsaXplIHRoZSBmcm9udC1jaGFpbiB1c2luZyB0aGUgZmlyc3QgdGhyZWUgY2lyY2xlcyBhLCBiIGFuZCBjLlxuICBhID0gbmV3IE5vZGUoYSksIGIgPSBuZXcgTm9kZShiKSwgYyA9IG5ldyBOb2RlKGMpO1xuICBhLm5leHQgPSBjLnByZXZpb3VzID0gYjtcbiAgYi5uZXh0ID0gYS5wcmV2aW91cyA9IGM7XG4gIGMubmV4dCA9IGIucHJldmlvdXMgPSBhO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXG4gIHBhY2s6IGZvciAoaSA9IDM7IGkgPCBuOyArK2kpIHtcbiAgICBwbGFjZShhLl8sIGIuXywgYyA9IGNpcmNsZXNbaV0pLCBjID0gbmV3IE5vZGUoYyk7XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGluZyBjaXJjbGUgb24gdGhlIGZyb250LWNoYWluLCBpZiBhbnkuXG4gICAgLy8g4oCcQ2xvc2VuZXNz4oCdIGlzIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlIGFsb25nIHRoZSBmcm9udC1jaGFpbi5cbiAgICAvLyDigJxBaGVhZOKAnSBvciDigJxiZWhpbmTigJ0gaXMgbGlrZXdpc2UgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UuXG4gICAgaiA9IGIubmV4dCwgayA9IGEucHJldmlvdXMsIHNqID0gYi5fLnIsIHNrID0gYS5fLnI7XG4gICAgZG8ge1xuICAgICAgaWYgKHNqIDw9IHNrKSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGouXywgYy5fKSkge1xuICAgICAgICAgIGIgPSBqLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2ogKz0gai5fLnIsIGogPSBqLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJzZWN0cyhrLl8sIGMuXykpIHtcbiAgICAgICAgICBhID0gaywgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcbiAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICB9XG4gICAgICAgIHNrICs9IGsuXy5yLCBrID0gay5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChqICE9PSBrLm5leHQpO1xuXG4gICAgLy8gU3VjY2VzcyEgSW5zZXJ0IHRoZSBuZXcgY2lyY2xlIGMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGMucHJldmlvdXMgPSBhLCBjLm5leHQgPSBiLCBhLm5leHQgPSBiLnByZXZpb3VzID0gYiA9IGM7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXcgY2xvc2VzdCBjaXJjbGUgcGFpciB0byB0aGUgY2VudHJvaWQuXG4gICAgYWEgPSBzY29yZShhKTtcbiAgICB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSB7XG4gICAgICBpZiAoKGNhID0gc2NvcmUoYykpIDwgYWEpIHtcbiAgICAgICAgYSA9IGMsIGFhID0gY2E7XG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBhLm5leHQ7XG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBlbmNsb3NpbmcgY2lyY2xlIG9mIHRoZSBmcm9udCBjaGFpbi5cbiAgYSA9IFtiLl9dLCBjID0gYjsgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikgYS5wdXNoKGMuXyk7IGMgPSBlbmNsb3NlKGEpO1xuXG4gIC8vIFRyYW5zbGF0ZSB0aGUgY2lyY2xlcyB0byBwdXQgdGhlIGVuY2xvc2luZyBjaXJjbGUgYXJvdW5kIHRoZSBvcmlnaW4uXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGEgPSBjaXJjbGVzW2ldLCBhLnggLT0gYy54LCBhLnkgLT0gYy55O1xuXG4gIHJldHVybiBjLnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNpcmNsZXMpIHtcbiAgcGFja0VuY2xvc2UoY2lyY2xlcyk7XG4gIHJldHVybiBjaXJjbGVzO1xufVxuIiwiaW1wb3J0IHJvdW5kTm9kZSBmcm9tIFwiLi90cmVlbWFwL3JvdW5kLmpzXCI7XG5pbXBvcnQgdHJlZW1hcERpY2UgZnJvbSBcIi4vdHJlZW1hcC9kaWNlLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZyA9IDAsXG4gICAgICByb3VuZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHBhcnRpdGlvbihyb290KSB7XG4gICAgdmFyIG4gPSByb290LmhlaWdodCArIDE7XG4gICAgcm9vdC54MCA9XG4gICAgcm9vdC55MCA9IHBhZGRpbmc7XG4gICAgcm9vdC54MSA9IGR4O1xuICAgIHJvb3QueTEgPSBkeSAvIG47XG4gICAgcm9vdC5lYWNoQmVmb3JlKHBvc2l0aW9uTm9kZShkeSwgbikpO1xuICAgIGlmIChyb3VuZCkgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUoZHksIG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgdHJlZW1hcERpY2Uobm9kZSwgbm9kZS54MCwgZHkgKiAobm9kZS5kZXB0aCArIDEpIC8gbiwgbm9kZS54MSwgZHkgKiAobm9kZS5kZXB0aCArIDIpIC8gbik7XG4gICAgICB9XG4gICAgICB2YXIgeDAgPSBub2RlLngwLFxuICAgICAgICAgIHkwID0gbm9kZS55MCxcbiAgICAgICAgICB4MSA9IG5vZGUueDEgLSBwYWRkaW5nLFxuICAgICAgICAgIHkxID0gbm9kZS55MSAtIHBhZGRpbmc7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBub2RlLngwID0geDA7XG4gICAgICBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDE7XG4gICAgICBub2RlLnkxID0geTE7XG4gICAgfTtcbiAgfVxuXG4gIHBhcnRpdGlvbi5yb3VuZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgcGFydGl0aW9uKSA6IHJvdW5kO1xuICB9O1xuXG4gIHBhcnRpdGlvbi5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHBhcnRpdGlvbikgOiBbZHgsIGR5XTtcbiAgfTtcblxuICBwYXJ0aXRpb24ucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gK3gsIHBhcnRpdGlvbikgOiBwYWRkaW5nO1xuICB9O1xuXG4gIHJldHVybiBwYXJ0aXRpb247XG59XG4iLCJpbXBvcnQge3JlcXVpcmVkfSBmcm9tIFwiLi9hY2Nlc3NvcnMuanNcIjtcbmltcG9ydCB7Tm9kZSwgY29tcHV0ZUhlaWdodH0gZnJvbSBcIi4vaGllcmFyY2h5L2luZGV4LmpzXCI7XG5cbnZhciBwcmVyb290ID0ge2RlcHRoOiAtMX0sXG4gICAgYW1iaWd1b3VzID0ge307XG5cbmZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gIHJldHVybiBkLmlkO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICByZXR1cm4gZC5wYXJlbnRJZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpZCA9IGRlZmF1bHRJZCxcbiAgICAgIHBhcmVudElkID0gZGVmYXVsdFBhcmVudElkO1xuXG4gIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKGRhdGEpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBpLFxuICAgICAgICByb290LFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgbm9kZUtleSxcbiAgICAgICAgbm9kZUJ5S2V5ID0gbmV3IE1hcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGQgPSBub2Rlc1tpXSwgbm9kZSA9IG5vZGVzW2ldID0gbmV3IE5vZGUoZCk7XG4gICAgICBpZiAoKG5vZGVJZCA9IGlkKGQsIGksIGRhdGEpKSAhPSBudWxsICYmIChub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgbm9kZUtleSA9IG5vZGUuaWQgPSBub2RlSWQ7XG4gICAgICAgIG5vZGVCeUtleS5zZXQobm9kZUtleSwgbm9kZUJ5S2V5Lmhhcyhub2RlS2V5KSA/IGFtYmlndW91cyA6IG5vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKChub2RlSWQgPSBwYXJlbnRJZChkLCBpLCBkYXRhKSkgIT0gbnVsbCAmJiAobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgIG5vZGUucGFyZW50ID0gbm9kZUlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlSWQgPSBub2RlLnBhcmVudCkge1xuICAgICAgICBwYXJlbnQgPSBub2RlQnlLZXkuZ2V0KG5vZGVJZCk7XG4gICAgICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGFtYmlndW91cykgdGhyb3cgbmV3IEVycm9yKFwiYW1iaWd1b3VzOiBcIiArIG5vZGVJZCk7XG4gICAgICAgIGlmIChwYXJlbnQuY2hpbGRyZW4pIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICBlbHNlIHBhcmVudC5jaGlsZHJlbiA9IFtub2RlXTtcbiAgICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocm9vdCkgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgcm9vdHNcIik7XG4gICAgICAgIHJvb3QgPSBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcm9vdCkgdGhyb3cgbmV3IEVycm9yKFwibm8gcm9vdFwiKTtcbiAgICByb290LnBhcmVudCA9IHByZXJvb3Q7XG4gICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5kZXB0aCA9IG5vZGUucGFyZW50LmRlcHRoICsgMTsgLS1uOyB9KS5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xuICAgIHJvb3QucGFyZW50ID0gbnVsbDtcbiAgICBpZiAobiA+IDApIHRocm93IG5ldyBFcnJvcihcImN5Y2xlXCIpO1xuXG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBzdHJhdGlmeS5pZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBpZDtcbiAgfTtcblxuICBzdHJhdGlmeS5wYXJlbnRJZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYXJlbnRJZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBwYXJlbnRJZDtcbiAgfTtcblxuICByZXR1cm4gc3RyYXRpZnk7XG59XG4iLCJpbXBvcnQge05vZGV9IGZyb20gXCIuL2hpZXJhcmNoeS9pbmRleC5qc1wiO1xuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbn1cblxuLy8gZnVuY3Rpb24gcmFkaWFsU2VwYXJhdGlvbihhLCBiKSB7XG4vLyAgIHJldHVybiAoYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDIpIC8gYS5kZXB0aDtcbi8vIH1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlIChvclxuLy8gc3ViZm9yZXN0KS4gSXQgcmV0dXJucyB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyLiBUaGlzIHN1Y2Nlc3NvciBpc1xuLy8gZWl0aGVyIGdpdmVuIGJ5IHRoZSBsZWZ0bW9zdCBjaGlsZCBvZiB2IG9yIGJ5IHRoZSB0aHJlYWQgb2Ygdi4gVGhlIGZ1bmN0aW9uXG4vLyByZXR1cm5zIG51bGwgaWYgYW5kIG9ubHkgaWYgdiBpcyBvbiB0aGUgaGlnaGVzdCBsZXZlbCBvZiBpdHMgc3VidHJlZS5cbmZ1bmN0aW9uIG5leHRMZWZ0KHYpIHtcbiAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkcmVuID8gY2hpbGRyZW5bMF0gOiB2LnQ7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd29ya3MgYW5hbG9nb3VzbHkgdG8gbmV4dExlZnQuXG5mdW5jdGlvbiBuZXh0UmlnaHQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSA6IHYudDtcbn1cblxuLy8gU2hpZnRzIHRoZSBjdXJyZW50IHN1YnRyZWUgcm9vdGVkIGF0IHcrLiBUaGlzIGlzIGRvbmUgYnkgaW5jcmVhc2luZ1xuLy8gcHJlbGltKHcrKSBhbmQgbW9kKHcrKSBieSBzaGlmdC5cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHdtLCB3cCwgc2hpZnQpIHtcbiAgdmFyIGNoYW5nZSA9IHNoaWZ0IC8gKHdwLmkgLSB3bS5pKTtcbiAgd3AuYyAtPSBjaGFuZ2U7XG4gIHdwLnMgKz0gc2hpZnQ7XG4gIHdtLmMgKz0gY2hhbmdlO1xuICB3cC56ICs9IHNoaWZ0O1xuICB3cC5tICs9IHNoaWZ0O1xufVxuXG4vLyBBbGwgb3RoZXIgc2hpZnRzLCBhcHBsaWVkIHRvIHRoZSBzbWFsbGVyIHN1YnRyZWVzIGJldHdlZW4gdy0gYW5kIHcrLCBhcmVcbi8vIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uLiBUbyBwcmVwYXJlIHRoZSBzaGlmdHMsIHdlIGhhdmUgdG8gYWRqdXN0XG4vLyBjaGFuZ2UodyspLCBzaGlmdCh3KyksIGFuZCBjaGFuZ2Uody0pLlxuZnVuY3Rpb24gZXhlY3V0ZVNoaWZ0cyh2KSB7XG4gIHZhciBzaGlmdCA9IDAsXG4gICAgICBjaGFuZ2UgPSAwLFxuICAgICAgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIHc7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIHcgPSBjaGlsZHJlbltpXTtcbiAgICB3LnogKz0gc2hpZnQ7XG4gICAgdy5tICs9IHNoaWZ0O1xuICAgIHNoaWZ0ICs9IHcucyArIChjaGFuZ2UgKz0gdy5jKTtcbiAgfVxufVxuXG4vLyBJZiB2aS3igJlzIGFuY2VzdG9yIGlzIGEgc2libGluZyBvZiB2LCByZXR1cm5zIHZpLeKAmXMgYW5jZXN0b3IuIE90aGVyd2lzZSxcbi8vIHJldHVybnMgdGhlIHNwZWNpZmllZCAoZGVmYXVsdCkgYW5jZXN0b3IuXG5mdW5jdGlvbiBuZXh0QW5jZXN0b3IodmltLCB2LCBhbmNlc3Rvcikge1xuICByZXR1cm4gdmltLmEucGFyZW50ID09PSB2LnBhcmVudCA/IHZpbS5hIDogYW5jZXN0b3I7XG59XG5cbmZ1bmN0aW9uIFRyZWVOb2RlKG5vZGUsIGkpIHtcbiAgdGhpcy5fID0gbm9kZTtcbiAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5BID0gbnVsbDsgLy8gZGVmYXVsdCBhbmNlc3RvclxuICB0aGlzLmEgPSB0aGlzOyAvLyBhbmNlc3RvclxuICB0aGlzLnogPSAwOyAvLyBwcmVsaW1cbiAgdGhpcy5tID0gMDsgLy8gbW9kXG4gIHRoaXMuYyA9IDA7IC8vIGNoYW5nZVxuICB0aGlzLnMgPSAwOyAvLyBzaGlmdFxuICB0aGlzLnQgPSBudWxsOyAvLyB0aHJlYWRcbiAgdGhpcy5pID0gaTsgLy8gbnVtYmVyXG59XG5cblRyZWVOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiB0cmVlUm9vdChyb290KSB7XG4gIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKHJvb3QsIDApLFxuICAgICAgbm9kZSxcbiAgICAgIG5vZGVzID0gW3RyZWVdLFxuICAgICAgY2hpbGQsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLl8uY2hpbGRyZW4pIHtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobiA9IGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSBuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbm9kZXMucHVzaChjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV0gPSBuZXcgVHJlZU5vZGUoY2hpbGRyZW5baV0sIGkpKTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAodHJlZS5wYXJlbnQgPSBuZXcgVHJlZU5vZGUobnVsbCwgMCkpLmNoaWxkcmVuID0gW3RyZWVdO1xuICByZXR1cm4gdHJlZTtcbn1cblxuLy8gTm9kZS1saW5rIHRyZWUgZGlhZ3JhbSB1c2luZyB0aGUgUmVpbmdvbGQtVGlsZm9yZCBcInRpZHlcIiBhbGdvcml0aG1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHRyZWUocm9vdCkge1xuICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgdXNpbmcgQnVjaGhlaW0gZXQgYWwu4oCZcyBhbGdvcml0aG0uXG4gICAgdC5lYWNoQWZ0ZXIoZmlyc3RXYWxrKSwgdC5wYXJlbnQubSA9IC10Lno7XG4gICAgdC5lYWNoQmVmb3JlKHNlY29uZFdhbGspO1xuXG4gICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxuICAgIGlmIChub2RlU2l6ZSkgcm9vdC5lYWNoQmVmb3JlKHNpemVOb2RlKTtcblxuICAgIC8vIElmIGEgZml4ZWQgdHJlZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeSBiYXNlZCBvbiB0aGUgZXh0ZW50LlxuICAgIC8vIENvbXB1dGUgdGhlIGxlZnQtbW9zdCwgcmlnaHQtbW9zdCwgYW5kIGRlcHRoLW1vc3Qgbm9kZXMgZm9yIGV4dGVudHMuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVmdCA9IHJvb3QsXG4gICAgICAgICAgcmlnaHQgPSByb290LFxuICAgICAgICAgIGJvdHRvbSA9IHJvb3Q7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gbGVmdCA9PT0gcmlnaHQgPyAxIDogc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICAgIHR4ID0gcyAtIGxlZnQueCxcbiAgICAgICAgICBreCA9IGR4IC8gKHJpZ2h0LnggKyBzICsgdHgpLFxuICAgICAgICAgIGt5ID0gZHkgLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xuICAvLyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIHRoZSBjaGlsZHJlbiBvZiB2LCBhcyB3ZWxsIGFzIHRoZSBmdW5jdGlvblxuICAvLyBBUFBPUlRJT04uIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIEVYRUNVVEUgU0hJRlRTLCB0aGVcbiAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cbiAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgICBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLFxuICAgICAgICB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcbiAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICB9XG4gICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGFsbCByZWFsIHgtY29vcmRpbmF0ZXMgYnkgc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIHJlY3Vyc2l2ZWx5LlxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgdi5tICs9IHYucGFyZW50Lm07XG4gIH1cblxuICAvLyBUaGUgY29yZSBvZiB0aGUgYWxnb3JpdGhtLiBIZXJlLCBhIG5ldyBzdWJ0cmVlIGlzIGNvbWJpbmVkIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcbiAgLy8gY29udG91cnMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWUgdXAgdG8gdGhlIGhpZ2hlc3QgY29tbW9uIGxldmVsLiBUaGVcbiAgLy8gdmVydGljZXMgdXNlZCBmb3IgdGhlIHRyYXZlcnNhbHMgYXJlIHZpKywgdmktLCB2by0sIGFuZCB2byssIHdoZXJlIHRoZVxuICAvLyBzdXBlcnNjcmlwdCBvIG1lYW5zIG91dHNpZGUgYW5kIGkgbWVhbnMgaW5zaWRlLCB0aGUgc3Vic2NyaXB0IC0gbWVhbnMgbGVmdFxuICAvLyBzdWJ0cmVlIGFuZCArIG1lYW5zIHJpZ2h0IHN1YnRyZWUuIEZvciBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgYWxvbmcgdGhlXG4gIC8vIGNvbnRvdXIsIHdlIHVzZSByZXNwZWN0aXZlIHZhcmlhYmxlcyBzaSssIHNpLSwgc28tLCBhbmQgc28rLiBXaGVuZXZlciB0d29cbiAgLy8gbm9kZXMgb2YgdGhlIGluc2lkZSBjb250b3VycyBjb25mbGljdCwgd2UgY29tcHV0ZSB0aGUgbGVmdCBvbmUgb2YgdGhlXG4gIC8vIGdyZWF0ZXN0IHVuY29tbW9uIGFuY2VzdG9ycyB1c2luZyB0aGUgZnVuY3Rpb24gQU5DRVNUT1IgYW5kIGNhbGwgTU9WRVxuICAvLyBTVUJUUkVFIHRvIHNoaWZ0IHRoZSBzdWJ0cmVlIGFuZCBwcmVwYXJlIHRoZSBzaGlmdHMgb2Ygc21hbGxlciBzdWJ0cmVlcy5cbiAgLy8gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cbiAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgaWYgKHcpIHtcbiAgICAgIHZhciB2aXAgPSB2LFxuICAgICAgICAgIHZvcCA9IHYsXG4gICAgICAgICAgdmltID0gdyxcbiAgICAgICAgICB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgIHNpcCA9IHZpcC5tLFxuICAgICAgICAgIHNvcCA9IHZvcC5tLFxuICAgICAgICAgIHNpbSA9IHZpbS5tLFxuICAgICAgICAgIHNvbSA9IHZvbS5tLFxuICAgICAgICAgIHNoaWZ0O1xuICAgICAgd2hpbGUgKHZpbSA9IG5leHRSaWdodCh2aW0pLCB2aXAgPSBuZXh0TGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgIHZvbSA9IG5leHRMZWZ0KHZvbSk7XG4gICAgICAgIHZvcCA9IG5leHRSaWdodCh2b3ApO1xuICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgfVxuICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcbiAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgIH1cbiAgICAgIGlmICh2aXAgJiYgIW5leHRMZWZ0KHZvbSkpIHtcbiAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgbm9kZS54ICo9IGR4O1xuICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgfVxuXG4gIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgdHJlZSkgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gdHJlZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIHN1bSwgc3VtcyA9IG5ldyBBcnJheShuICsgMSk7XG5cbiAgZm9yIChzdW1zWzBdID0gc3VtID0gaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzdW1zW2kgKyAxXSA9IHN1bSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgfVxuXG4gIHBhcnRpdGlvbigwLCBuLCBwYXJlbnQudmFsdWUsIHgwLCB5MCwgeDEsIHkxKTtcblxuICBmdW5jdGlvbiBwYXJ0aXRpb24oaSwgaiwgdmFsdWUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKGkgPj0gaiAtIDEpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICBub2RlLngwID0geDAsIG5vZGUueTAgPSB5MDtcbiAgICAgIG5vZGUueDEgPSB4MSwgbm9kZS55MSA9IHkxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZU9mZnNldCA9IHN1bXNbaV0sXG4gICAgICAgIHZhbHVlVGFyZ2V0ID0gKHZhbHVlIC8gMikgKyB2YWx1ZU9mZnNldCxcbiAgICAgICAgayA9IGkgKyAxLFxuICAgICAgICBoaSA9IGogLSAxO1xuXG4gICAgd2hpbGUgKGsgPCBoaSkge1xuICAgICAgdmFyIG1pZCA9IGsgKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChzdW1zW21pZF0gPCB2YWx1ZVRhcmdldCkgayA9IG1pZCArIDE7XG4gICAgICBlbHNlIGhpID0gbWlkO1xuICAgIH1cblxuICAgIGlmICgodmFsdWVUYXJnZXQgLSBzdW1zW2sgLSAxXSkgPCAoc3Vtc1trXSAtIHZhbHVlVGFyZ2V0KSAmJiBpICsgMSA8IGspIC0taztcblxuICAgIHZhciB2YWx1ZUxlZnQgPSBzdW1zW2tdIC0gdmFsdWVPZmZzZXQsXG4gICAgICAgIHZhbHVlUmlnaHQgPSB2YWx1ZSAtIHZhbHVlTGVmdDtcblxuICAgIGlmICgoeDEgLSB4MCkgPiAoeTEgLSB5MCkpIHtcbiAgICAgIHZhciB4ayA9IHZhbHVlID8gKHgwICogdmFsdWVSaWdodCArIHgxICogdmFsdWVMZWZ0KSAvIHZhbHVlIDogeDE7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHhrLCB5MSk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeGssIHkwLCB4MSwgeTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeWsgPSB2YWx1ZSA/ICh5MCAqIHZhbHVlUmlnaHQgKyB5MSAqIHZhbHVlTGVmdCkgLyB2YWx1ZSA6IHkxO1xuICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4MSwgeWspO1xuICAgICAgcGFydGl0aW9uKGssIGosIHZhbHVlUmlnaHQsIHgwLCB5aywgeDEsIHkxKTtcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh4MSAtIHgwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTE7XG4gICAgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn1cbiIsImltcG9ydCByb3VuZE5vZGUgZnJvbSBcIi4vcm91bmQuanNcIjtcbmltcG9ydCBzcXVhcmlmeSBmcm9tIFwiLi9zcXVhcmlmeS5qc1wiO1xuaW1wb3J0IHtyZXF1aXJlZH0gZnJvbSBcIi4uL2FjY2Vzc29ycy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50LCB7Y29uc3RhbnRaZXJvfSBmcm9tIFwiLi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciB0aWxlID0gc3F1YXJpZnksXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZ1N0YWNrID0gWzBdLFxuICAgICAgcGFkZGluZ0lubmVyID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1RvcCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdSaWdodCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdCb3R0b20gPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nTGVmdCA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiB0cmVlbWFwKHJvb3QpIHtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gMDtcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5O1xuICAgIHJvb3QuZWFjaEJlZm9yZShwb3NpdGlvbk5vZGUpO1xuICAgIHBhZGRpbmdTdGFjayA9IFswXTtcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKG5vZGUpIHtcbiAgICB2YXIgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoXSxcbiAgICAgICAgeDAgPSBub2RlLngwICsgcCxcbiAgICAgICAgeTAgPSBub2RlLnkwICsgcCxcbiAgICAgICAgeDEgPSBub2RlLngxIC0gcCxcbiAgICAgICAgeTEgPSBub2RlLnkxIC0gcDtcbiAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgIG5vZGUueDAgPSB4MDtcbiAgICBub2RlLnkwID0geTA7XG4gICAgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTEgPSB5MTtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoICsgMV0gPSBwYWRkaW5nSW5uZXIobm9kZSkgLyAyO1xuICAgICAgeDAgKz0gcGFkZGluZ0xlZnQobm9kZSkgLSBwO1xuICAgICAgeTAgKz0gcGFkZGluZ1RvcChub2RlKSAtIHA7XG4gICAgICB4MSAtPSBwYWRkaW5nUmlnaHQobm9kZSkgLSBwO1xuICAgICAgeTEgLT0gcGFkZGluZ0JvdHRvbShub2RlKSAtIHA7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICB0aWxlKG5vZGUsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gIH1cblxuICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCB0cmVlbWFwKSA6IHJvdW5kO1xuICB9O1xuXG4gIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlbWFwKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHRyZWVtYXAudGlsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWxlID0gcmVxdWlyZWQoeCksIHRyZWVtYXApIDogdGlsZTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdJbm5lcih4KS5wYWRkaW5nT3V0ZXIoeCkgOiB0cmVlbWFwLnBhZGRpbmdJbm5lcigpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ1RvcCh4KS5wYWRkaW5nUmlnaHQoeCkucGFkZGluZ0JvdHRvbSh4KS5wYWRkaW5nTGVmdCh4KSA6IHRyZWVtYXAucGFkZGluZ1RvcCgpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1RvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nVG9wID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1RvcDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdSaWdodCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nUmlnaHQ7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nQm90dG9tID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdCb3R0b20gPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nQm90dG9tO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0xlZnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0xlZnQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nTGVmdDtcbiAgfTtcblxuICByZXR1cm4gdHJlZW1hcDtcbn1cbiIsImltcG9ydCB0cmVlbWFwRGljZSBmcm9tIFwiLi9kaWNlLmpzXCI7XG5pbXBvcnQgdHJlZW1hcFNsaWNlIGZyb20gXCIuL3NsaWNlLmpzXCI7XG5pbXBvcnQge3BoaSwgc3F1YXJpZnlSYXRpb30gZnJvbSBcIi4vc3F1YXJpZnkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuXG4gIGZ1bmN0aW9uIHJlc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmICgocm93cyA9IHBhcmVudC5fc3F1YXJpZnkpICYmIChyb3dzLnJhdGlvID09PSByYXRpbykpIHtcbiAgICAgIHZhciByb3dzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBub2RlcyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIG0gPSByb3dzLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IHBhcmVudC52YWx1ZTtcblxuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgcm93ID0gcm93c1tqXSwgbm9kZXMgPSByb3cuY2hpbGRyZW47XG4gICAgICAgIGZvciAoaSA9IHJvdy52YWx1ZSA9IDAsIG4gPSBub2Rlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHJvdy52YWx1ZSArPSBub2Rlc1tpXS52YWx1ZTtcbiAgICAgICAgaWYgKHJvdy5kaWNlKSB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHZhbHVlID8geTAgKz0gKHkxIC0geTApICogcm93LnZhbHVlIC8gdmFsdWUgOiB5MSk7XG4gICAgICAgIGVsc2UgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB2YWx1ZSA/IHgwICs9ICh4MSAtIHgwKSAqIHJvdy52YWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcbiAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuX3NxdWFyaWZ5ID0gcm93cyA9IHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgcm93cy5yYXRpbyA9IHJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIHJlc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3F1YXJpZnk7XG59KShwaGkpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSkge1xuICBub2RlLngwID0gTWF0aC5yb3VuZChub2RlLngwKTtcbiAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XG4gIG5vZGUueDEgPSBNYXRoLnJvdW5kKG5vZGUueDEpO1xuICBub2RlLnkxID0gTWF0aC5yb3VuZChub2RlLnkxKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh5MSAtIHkwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDE7XG4gICAgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn1cbiIsImltcG9ydCBkaWNlIGZyb20gXCIuL2RpY2UuanNcIjtcbmltcG9ydCBzbGljZSBmcm9tIFwiLi9zbGljZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIChwYXJlbnQuZGVwdGggJiAxID8gc2xpY2UgOiBkaWNlKShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbn1cbiIsImltcG9ydCB0cmVlbWFwRGljZSBmcm9tIFwiLi9kaWNlLmpzXCI7XG5pbXBvcnQgdHJlZW1hcFNsaWNlIGZyb20gXCIuL3NsaWNlLmpzXCI7XG5cbmV4cG9ydCB2YXIgcGhpID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHJvd3MgPSBbXSxcbiAgICAgIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgcm93LFxuICAgICAgbm9kZVZhbHVlLFxuICAgICAgaTAgPSAwLFxuICAgICAgaTEgPSAwLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgIGR4LCBkeSxcbiAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlLFxuICAgICAgc3VtVmFsdWUsXG4gICAgICBtaW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlLFxuICAgICAgbmV3UmF0aW8sXG4gICAgICBtaW5SYXRpbyxcbiAgICAgIGFscGhhLFxuICAgICAgYmV0YTtcblxuICB3aGlsZSAoaTAgPCBuKSB7XG4gICAgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTA7XG5cbiAgICAvLyBGaW5kIHRoZSBuZXh0IG5vbi1lbXB0eSBub2RlLlxuICAgIGRvIHN1bVZhbHVlID0gbm9kZXNbaTErK10udmFsdWU7IHdoaWxlICghc3VtVmFsdWUgJiYgaTEgPCBuKTtcbiAgICBtaW5WYWx1ZSA9IG1heFZhbHVlID0gc3VtVmFsdWU7XG4gICAgYWxwaGEgPSBNYXRoLm1heChkeSAvIGR4LCBkeCAvIGR5KSAvICh2YWx1ZSAqIHJhdGlvKTtcbiAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgIG1pblJhdGlvID0gTWF0aC5tYXgobWF4VmFsdWUgLyBiZXRhLCBiZXRhIC8gbWluVmFsdWUpO1xuXG4gICAgLy8gS2VlcCBhZGRpbmcgbm9kZXMgd2hpbGUgdGhlIGFzcGVjdCByYXRpbyBtYWludGFpbnMgb3IgaW1wcm92ZXMuXG4gICAgZm9yICg7IGkxIDwgbjsgKytpMSkge1xuICAgICAgc3VtVmFsdWUgKz0gbm9kZVZhbHVlID0gbm9kZXNbaTFdLnZhbHVlO1xuICAgICAgaWYgKG5vZGVWYWx1ZSA8IG1pblZhbHVlKSBtaW5WYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGlmIChub2RlVmFsdWUgPiBtYXhWYWx1ZSkgbWF4VmFsdWUgPSBub2RlVmFsdWU7XG4gICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgICAgbmV3UmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG4gICAgICBpZiAobmV3UmF0aW8gPiBtaW5SYXRpbykgeyBzdW1WYWx1ZSAtPSBub2RlVmFsdWU7IGJyZWFrOyB9XG4gICAgICBtaW5SYXRpbyA9IG5ld1JhdGlvO1xuICAgIH1cblxuICAgIC8vIFBvc2l0aW9uIGFuZCByZWNvcmQgdGhlIHJvdyBvcmllbnRhdGlvbi5cbiAgICByb3dzLnB1c2gocm93ID0ge3ZhbHVlOiBzdW1WYWx1ZSwgZGljZTogZHggPCBkeSwgY2hpbGRyZW46IG5vZGVzLnNsaWNlKGkwLCBpMSl9KTtcbiAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgdmFsdWUgPyB5MCArPSBkeSAqIHN1bVZhbHVlIC8gdmFsdWUgOiB5MSk7XG4gICAgZWxzZSB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gZHggKiBzdW1WYWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcbiAgICB2YWx1ZSAtPSBzdW1WYWx1ZSwgaTAgPSBpMTtcbiAgfVxuXG4gIHJldHVybiByb3dzO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNxdWFyaWZ5O1xufSkocGhpKTtcbiIsImltcG9ydCB2YWx1ZSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuaW1wb3J0IG51bWJlckFycmF5LCB7aXNOdW1iZXJBcnJheX0gZnJvbSBcIi4vbnVtYmVyQXJyYXkuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gKGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheSA6IGdlbmVyaWNBcnJheSkoYSwgYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmljQXJyYXkoYSwgYikge1xuICB2YXIgbmIgPSBiID8gYi5sZW5ndGggOiAwLFxuICAgICAgbmEgPSBhID8gTWF0aC5taW4obmIsIGEubGVuZ3RoKSA6IDAsXG4gICAgICB4ID0gbmV3IEFycmF5KG5hKSxcbiAgICAgIGMgPSBuZXcgQXJyYXkobmIpLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgeFtpXSA9IHZhbHVlKGFbaV0sIGJbaV0pO1xuICBmb3IgKDsgaSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIGNbaV0gPSB4W2ldKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdCA8PSAwID8gKHQgPSAwKSA6IHQgPj0gMSA/ICh0ID0gMSwgbiAtIDEpIDogTWF0aC5mbG9vcih0ICogbiksXG4gICAgICAgIHYxID0gdmFsdWVzW2ldLFxuICAgICAgICB2MiA9IHZhbHVlc1tpICsgMV0sXG4gICAgICAgIHYwID0gaSA+IDAgPyB2YWx1ZXNbaSAtIDFdIDogMiAqIHYxIC0gdjIsXG4gICAgICAgIHYzID0gaSA8IG4gLSAxID8gdmFsdWVzW2kgKyAyXSA6IDIgKiB2MiAtIHYxO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmFzaXN9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLmZsb29yKCgodCAlPSAxKSA8IDAgPyArK3QgOiB0KSAqIG4pLFxuICAgICAgICB2MCA9IHZhbHVlc1soaSArIG4gLSAxKSAlIG5dLFxuICAgICAgICB2MSA9IHZhbHVlc1tpICUgbl0sXG4gICAgICAgIHYyID0gdmFsdWVzWyhpICsgMSkgJSBuXSxcbiAgICAgICAgdjMgPSB2YWx1ZXNbKGkgKyAyKSAlIG5dO1xuICAgIHJldHVybiBiYXNpcygodCAtIGkgLyBuKSAqIG4sIHYwLCB2MSwgdjIsIHYzKTtcbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodWUoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2FtbWEoeSkge1xuICByZXR1cm4gKHkgPSAreSkgPT09IDEgPyBub2dhbW1hIDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIC0gYSA/IGV4cG9uZW50aWFsKGEsIGIsIHkpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vZ2FtbWEoYSwgYikge1xuICB2YXIgZCA9IGIgLSBhO1xuICByZXR1cm4gZCA/IGxpbmVhcihhLCBkKSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgeCA9PiAoKSA9PiB4O1xuIiwiaW1wb3J0IHtjdWJlaGVsaXggYXMgY29sb3JDdWJlaGVsaXh9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGNvbG9yLCB7aHVlfSBmcm9tIFwiLi9jb2xvci5qc1wiO1xuXG5mdW5jdGlvbiBjdWJlaGVsaXgoaHVlKSB7XG4gIHJldHVybiAoZnVuY3Rpb24gY3ViZWhlbGl4R2FtbWEoeSkge1xuICAgIHkgPSAreTtcblxuICAgIGZ1bmN0aW9uIGN1YmVoZWxpeChzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckN1YmVoZWxpeChzdGFydCkpLmgsIChlbmQgPSBjb2xvckN1YmVoZWxpeChlbmQpKS5oKSxcbiAgICAgICAgICBzID0gY29sb3Ioc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBjb2xvcihzdGFydC5sLCBlbmQubCksXG4gICAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgICAgc3RhcnQubCA9IGwoTWF0aC5wb3codCwgeSkpO1xuICAgICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY3ViZWhlbGl4LmdhbW1hID0gY3ViZWhlbGl4R2FtbWE7XG5cbiAgICByZXR1cm4gY3ViZWhlbGl4O1xuICB9KSgxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3ViZWhlbGl4KGh1ZSk7XG5leHBvcnQgdmFyIGN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXgoY29sb3IpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgZCA9IG5ldyBEYXRlO1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZC5zZXRUaW1lKGEgKiAoMSAtIHQpICsgYiAqIHQpLCBkO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cbiIsImltcG9ydCB7aGNsIGFzIGNvbG9ySGNsfSBmcm9tIFwiZDMtY29sb3JcIjtcbmltcG9ydCBjb2xvciwge2h1ZX0gZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZnVuY3Rpb24gaGNsKGh1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHZhciBoID0gaHVlKChzdGFydCA9IGNvbG9ySGNsKHN0YXJ0KSkuaCwgKGVuZCA9IGNvbG9ySGNsKGVuZCkpLmgpLFxuICAgICAgICBjID0gY29sb3Ioc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gY29sb3Ioc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gY29sb3Ioc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgIHN0YXJ0LmMgPSBjKHQpO1xuICAgICAgc3RhcnQubCA9IGwodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBoY2woaHVlKTtcbmV4cG9ydCB2YXIgaGNsTG9uZyA9IGhjbChjb2xvcik7XG4iLCJpbXBvcnQge2hzbCBhcyBjb2xvckhzbH0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IsIHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmZ1bmN0aW9uIGhzbChodWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSgoc3RhcnQgPSBjb2xvckhzbChzdGFydCkpLmgsIChlbmQgPSBjb2xvckhzbChlbmQpKS5oKSxcbiAgICAgICAgcyA9IGNvbG9yKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IGNvbG9yKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5zID0gcyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaHNsKGh1ZSk7XG5leHBvcnQgdmFyIGhzbExvbmcgPSBoc2woY29sb3IpO1xuIiwiaW1wb3J0IHtodWV9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGkgPSBodWUoK2EsICtiKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgeCA9IGkodCk7XG4gICAgcmV0dXJuIHggLSAzNjAgKiBNYXRoLmZsb29yKHggLyAzNjApO1xuICB9O1xufVxuIiwiZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlfSBmcm9tIFwiLi92YWx1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlQXJyYXl9IGZyb20gXCIuL2FycmF5LmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVCYXNpc30gZnJvbSBcIi4vYmFzaXMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUJhc2lzQ2xvc2VkfSBmcm9tIFwiLi9iYXNpc0Nsb3NlZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGF0ZX0gZnJvbSBcIi4vZGF0ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlRGlzY3JldGV9IGZyb20gXCIuL2Rpc2NyZXRlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIdWV9IGZyb20gXCIuL2h1ZS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlTnVtYmVyfSBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZU51bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlT2JqZWN0fSBmcm9tIFwiLi9vYmplY3QuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJvdW5kfSBmcm9tIFwiLi9yb3VuZC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGludGVycG9sYXRlU3RyaW5nfSBmcm9tIFwiLi9zdHJpbmcuanNcIjtcbmV4cG9ydCB7aW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3MsIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnfSBmcm9tIFwiLi90cmFuc2Zvcm0vaW5kZXguanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVpvb219IGZyb20gXCIuL3pvb20uanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZVJnYiwgcmdiQmFzaXMgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpcywgcmdiQmFzaXNDbG9zZWQgYXMgaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZH0gZnJvbSBcIi4vcmdiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIc2wsIGhzbExvbmcgYXMgaW50ZXJwb2xhdGVIc2xMb25nfSBmcm9tIFwiLi9oc2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUxhYn0gZnJvbSBcIi4vbGFiLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgaW50ZXJwb2xhdGVIY2wsIGhjbExvbmcgYXMgaW50ZXJwb2xhdGVIY2xMb25nfSBmcm9tIFwiLi9oY2wuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeCwgY3ViZWhlbGl4TG9uZyBhcyBpbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmd9IGZyb20gXCIuL2N1YmVoZWxpeC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHBpZWNld2lzZX0gZnJvbSBcIi4vcGllY2V3aXNlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgcXVhbnRpemV9IGZyb20gXCIuL3F1YW50aXplLmpzXCI7XG4iLCJpbXBvcnQge2xhYiBhcyBjb2xvckxhYn0gZnJvbSBcImQzLWNvbG9yXCI7XG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29sb3IuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFiKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGwgPSBjb2xvcigoc3RhcnQgPSBjb2xvckxhYihzdGFydCkpLmwsIChlbmQgPSBjb2xvckxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBjb2xvcihzdGFydC5hLCBlbmQuYSksXG4gICAgICBiID0gY29sb3Ioc3RhcnQuYiwgZW5kLmIpLFxuICAgICAgb3BhY2l0eSA9IGNvbG9yKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gYSA9ICthLCBiID0gK2IsIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKCFiKSBiID0gW107XG4gIHZhciBuID0gYSA/IE1hdGgubWluKGIubGVuZ3RoLCBhLmxlbmd0aCkgOiAwLFxuICAgICAgYyA9IGIuc2xpY2UoKSxcbiAgICAgIGk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY1tpXSA9IGFbaV0gKiAoMSAtIHQpICsgYltpXSAqIHQ7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlckFycmF5KHgpIHtcbiAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh4KSAmJiAhKHggaW5zdGFuY2VvZiBEYXRhVmlldyk7XG59XG4iLCJpbXBvcnQgdmFsdWUgZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYSwgYikge1xuICB2YXIgaSA9IHt9LFxuICAgICAgYyA9IHt9LFxuICAgICAgaztcblxuICBpZiAoYSA9PT0gbnVsbCB8fCB0eXBlb2YgYSAhPT0gXCJvYmplY3RcIikgYSA9IHt9O1xuICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIikgYiA9IHt9O1xuXG4gIGZvciAoayBpbiBiKSB7XG4gICAgaWYgKGsgaW4gYSkge1xuICAgICAgaVtrXSA9IHZhbHVlKGFba10sIGJba10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjW2tdID0gYltrXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cbiIsImltcG9ydCB7ZGVmYXVsdCBhcyB2YWx1ZX0gZnJvbSBcIi4vdmFsdWUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGllY2V3aXNlKGludGVycG9sYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyA9PT0gdW5kZWZpbmVkKSB2YWx1ZXMgPSBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbiAgdmFyIGkgPSAwLCBuID0gdmFsdWVzLmxlbmd0aCAtIDEsIHYgPSB2YWx1ZXNbMF0sIEkgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gIHdoaWxlIChpIDwgbikgSVtpXSA9IGludGVycG9sYXRlKHYsIHYgPSB2YWx1ZXNbKytpXSk7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihuIC0gMSwgTWF0aC5mbG9vcih0ICo9IG4pKSk7XG4gICAgcmV0dXJuIElbaV0odCAtIGkpO1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJwb2xhdG9yLCBuKSB7XG4gIHZhciBzYW1wbGVzID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcihpIC8gKG4gLSAxKSk7XG4gIHJldHVybiBzYW1wbGVzO1xufVxuIiwiaW1wb3J0IHtyZ2IgYXMgY29sb3JSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IGJhc2lzIGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5pbXBvcnQgYmFzaXNDbG9zZWQgZnJvbSBcIi4vYmFzaXNDbG9zZWQuanNcIjtcbmltcG9ydCBub2dhbW1hLCB7Z2FtbWF9IGZyb20gXCIuL2NvbG9yLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYihzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvcigoc3RhcnQgPSBjb2xvclJnYihzdGFydCkpLnIsIChlbmQgPSBjb2xvclJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYi5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2I7XG59KSgxKTtcblxuZnVuY3Rpb24gcmdiU3BsaW5lKHNwbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sb3JzKSB7XG4gICAgdmFyIG4gPSBjb2xvcnMubGVuZ3RoLFxuICAgICAgICByID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBnID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBpLCBjb2xvcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb2xvciA9IGNvbG9yUmdiKGNvbG9yc1tpXSk7XG4gICAgICByW2ldID0gY29sb3IuciB8fCAwO1xuICAgICAgZ1tpXSA9IGNvbG9yLmcgfHwgMDtcbiAgICAgIGJbaV0gPSBjb2xvci5iIHx8IDA7XG4gICAgfVxuICAgIHIgPSBzcGxpbmUocik7XG4gICAgZyA9IHNwbGluZShnKTtcbiAgICBiID0gc3BsaW5lKGIpO1xuICAgIGNvbG9yLm9wYWNpdHkgPSAxO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBjb2xvci5yID0gcih0KTtcbiAgICAgIGNvbG9yLmcgPSBnKHQpO1xuICAgICAgY29sb3IuYiA9IGIodCk7XG4gICAgICByZXR1cm4gY29sb3IgKyBcIlwiO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMpO1xuZXhwb3J0IHZhciByZ2JCYXNpc0Nsb3NlZCA9IHJnYlNwbGluZShiYXNpc0Nsb3NlZCk7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgPSArYiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKiAoMSAtIHQpICsgYiAqIHQpO1xuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZyxcbiAgICByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGJpID0gcmVBLmxhc3RJbmRleCA9IHJlQi5sYXN0SW5kZXggPSAwLCAvLyBzY2FuIGluZGV4IGZvciBuZXh0IG51bWJlciBpbiBiXG4gICAgICBhbSwgLy8gY3VycmVudCBtYXRjaCBpbiBhXG4gICAgICBibSwgLy8gY3VycmVudCBtYXRjaCBpbiBiXG4gICAgICBicywgLy8gc3RyaW5nIHByZWNlZGluZyBjdXJyZW50IG51bWJlciBpbiBiLCBpZiBhbnlcbiAgICAgIGkgPSAtMSwgLy8gaW5kZXggaW4gc1xuICAgICAgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcblxuICAvLyBDb2VyY2UgaW5wdXRzIHRvIHN0cmluZ3MuXG4gIGEgPSBhICsgXCJcIiwgYiA9IGIgKyBcIlwiO1xuXG4gIC8vIEludGVycG9sYXRlIHBhaXJzIG9mIG51bWJlcnMgaW4gYSAmIGIuXG4gIHdoaWxlICgoYW0gPSByZUEuZXhlYyhhKSlcbiAgICAgICYmIChibSA9IHJlQi5leGVjKGIpKSkge1xuICAgIGlmICgoYnMgPSBibS5pbmRleCkgPiBiaSkgeyAvLyBhIHN0cmluZyBwcmVjZWRlcyB0aGUgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYnM7XG4gICAgfVxuICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkgeyAvLyBudW1iZXJzIGluIGEgJiBiIG1hdGNoXG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICAgIGVsc2Ugc1srK2ldID0gYm07XG4gICAgfSBlbHNlIHsgLy8gaW50ZXJwb2xhdGUgbm9uLW1hdGNoaW5nIG51bWJlcnNcbiAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICBxLnB1c2goe2k6IGksIHg6IG51bWJlcihhbSwgYm0pfSk7XG4gICAgfVxuICAgIGJpID0gcmVCLmxhc3RJbmRleDtcbiAgfVxuXG4gIC8vIEFkZCByZW1haW5zIG9mIGIuXG4gIGlmIChiaSA8IGIubGVuZ3RoKSB7XG4gICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgLy8gY29hbGVzY2Ugd2l0aCBwcmV2aW91cyBzdHJpbmdcbiAgICBlbHNlIHNbKytpXSA9IGJzO1xuICB9XG5cbiAgLy8gU3BlY2lhbCBvcHRpbWl6YXRpb24gZm9yIG9ubHkgYSBzaW5nbGUgbWF0Y2guXG4gIC8vIE90aGVyd2lzZSwgaW50ZXJwb2xhdGUgZWFjaCBvZiB0aGUgbnVtYmVycyBhbmQgcmVqb2luIHRoZSBzdHJpbmcuXG4gIHJldHVybiBzLmxlbmd0aCA8IDIgPyAocVswXVxuICAgICAgPyBvbmUocVswXS54KVxuICAgICAgOiB6ZXJvKGIpKVxuICAgICAgOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgICAgICB9KTtcbn1cbiIsInZhciBkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcblxuZXhwb3J0IHZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIHNjYWxlWCwgc2NhbGVZLCBza2V3WDtcbiAgaWYgKHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKSkgYSAvPSBzY2FsZVgsIGIgLz0gc2NhbGVYO1xuICBpZiAoc2tld1ggPSBhICogYyArIGIgKiBkKSBjIC09IGEgKiBza2V3WCwgZCAtPSBiICogc2tld1g7XG4gIGlmIChzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCkpIGMgLz0gc2NhbGVZLCBkIC89IHNjYWxlWSwgc2tld1ggLz0gc2NhbGVZO1xuICBpZiAoYSAqIGQgPCBiICogYykgYSA9IC1hLCBiID0gLWIsIHNrZXdYID0gLXNrZXdYLCBzY2FsZVggPSAtc2NhbGVYO1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0ZVg6IGUsXG4gICAgdHJhbnNsYXRlWTogZixcbiAgICByb3RhdGU6IE1hdGguYXRhbjIoYiwgYSkgKiBkZWdyZWVzLFxuICAgIHNrZXdYOiBNYXRoLmF0YW4oc2tld1gpICogZGVncmVlcyxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWVxuICB9O1xufVxuIiwiaW1wb3J0IG51bWJlciBmcm9tIFwiLi4vbnVtYmVyLmpzXCI7XG5pbXBvcnQge3BhcnNlQ3NzLCBwYXJzZVN2Z30gZnJvbSBcIi4vcGFyc2UuanNcIjtcblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2UsIHB4Q29tbWEsIHB4UGFyZW4sIGRlZ1BhcmVuKSB7XG5cbiAgZnVuY3Rpb24gcG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIgXCIgOiBcIlwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNsYXRlKHhhLCB5YSwgeGIsIHliLCBzLCBxKSB7XG4gICAgaWYgKHhhICE9PSB4YiB8fCB5YSAhPT0geWIpIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKFwidHJhbnNsYXRlKFwiLCBudWxsLCBweENvbW1hLCBudWxsLCBweFBhcmVuKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgfHwgeWIpIHtcbiAgICAgIHMucHVzaChcInRyYW5zbGF0ZShcIiArIHhiICsgcHhDb21tYSArIHliICsgcHhQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgLSBiID4gMTgwKSBiICs9IDM2MDsgZWxzZSBpZiAoYiAtIGEgPiAxODApIGEgKz0gMzYwOyAvLyBzaG9ydGVzdCBwYXRoXG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJyb3RhdGUoXCIgKyBiICsgZGVnUGFyZW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNrZXdYKGEsIGIsIHMsIHEpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgcS5wdXNoKHtpOiBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgZGVnUGFyZW4pIC0gMiwgeDogbnVtYmVyKGEsIGIpfSk7XG4gICAgfSBlbHNlIGlmIChiKSB7XG4gICAgICBzLnB1c2gocG9wKHMpICsgXCJza2V3WChcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2gocG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7aTogaSAtIDQsIHg6IG51bWJlcih4YSwgeGIpfSwge2k6IGkgLSAyLCB4OiBudW1iZXIoeWEsIHliKX0pO1xuICAgIH0gZWxzZSBpZiAoeGIgIT09IDEgfHwgeWIgIT09IDEpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiICsgeGIgKyBcIixcIiArIHliICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICAgIHEgPSBbXTsgLy8gbnVtYmVyIGludGVycG9sYXRvcnNcbiAgICBhID0gcGFyc2UoYSksIGIgPSBwYXJzZShiKTtcbiAgICB0cmFuc2xhdGUoYS50cmFuc2xhdGVYLCBhLnRyYW5zbGF0ZVksIGIudHJhbnNsYXRlWCwgYi50cmFuc2xhdGVZLCBzLCBxKTtcbiAgICByb3RhdGUoYS5yb3RhdGUsIGIucm90YXRlLCBzLCBxKTtcbiAgICBza2V3WChhLnNrZXdYLCBiLnNrZXdYLCBzLCBxKTtcbiAgICBzY2FsZShhLnNjYWxlWCwgYS5zY2FsZVksIGIuc2NhbGVYLCBiLnNjYWxlWSwgcywgcSk7XG4gICAgYSA9IGIgPSBudWxsOyAvLyBnY1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcS5sZW5ndGgsIG87XG4gICAgICB3aGlsZSAoKytpIDwgbikgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VDc3MsIFwicHgsIFwiLCBcInB4KVwiLCBcImRlZylcIik7XG5leHBvcnQgdmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcbiIsImltcG9ydCBkZWNvbXBvc2UsIHtpZGVudGl0eX0gZnJvbSBcIi4vZGVjb21wb3NlLmpzXCI7XG5cbnZhciBzdmdOb2RlO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ3NzKHZhbHVlKSB7XG4gIGNvbnN0IG0gPSBuZXcgKHR5cGVvZiBET01NYXRyaXggPT09IFwiZnVuY3Rpb25cIiA/IERPTU1hdHJpeCA6IFdlYktpdENTU01hdHJpeCkodmFsdWUgKyBcIlwiKTtcbiAgcmV0dXJuIG0uaXNJZGVudGl0eSA/IGlkZW50aXR5IDogZGVjb21wb3NlKG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdmcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgaWYgKCFzdmdOb2RlKSBzdmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpO1xuICBzdmdOb2RlLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB2YWx1ZSk7XG4gIGlmICghKHZhbHVlID0gc3ZnTm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpKSkgcmV0dXJuIGlkZW50aXR5O1xuICB2YWx1ZSA9IHZhbHVlLm1hdHJpeDtcbiAgcmV0dXJuIGRlY29tcG9zZSh2YWx1ZS5hLCB2YWx1ZS5iLCB2YWx1ZS5jLCB2YWx1ZS5kLCB2YWx1ZS5lLCB2YWx1ZS5mKTtcbn1cbiIsImltcG9ydCB7Y29sb3J9IGZyb20gXCJkMy1jb2xvclwiO1xuaW1wb3J0IHJnYiBmcm9tIFwiLi9yZ2IuanNcIjtcbmltcG9ydCB7Z2VuZXJpY0FycmF5fSBmcm9tIFwiLi9hcnJheS5qc1wiO1xuaW1wb3J0IGRhdGUgZnJvbSBcIi4vZGF0ZS5qc1wiO1xuaW1wb3J0IG51bWJlciBmcm9tIFwiLi9udW1iZXIuanNcIjtcbmltcG9ydCBvYmplY3QgZnJvbSBcIi4vb2JqZWN0LmpzXCI7XG5pbXBvcnQgc3RyaW5nIGZyb20gXCIuL3N0cmluZy5qc1wiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyQXJyYXksIHtpc051bWJlckFycmF5fSBmcm9tIFwiLi9udW1iZXJBcnJheS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gY29sb3IoYikpID8gKGIgPSBjLCByZ2IpIDogc3RyaW5nKVxuICAgICAgOiBiIGluc3RhbmNlb2YgY29sb3IgPyByZ2JcbiAgICAgIDogYiBpbnN0YW5jZW9mIERhdGUgPyBkYXRlXG4gICAgICA6IGlzTnVtYmVyQXJyYXkoYikgPyBudW1iZXJBcnJheVxuICAgICAgOiBBcnJheS5pc0FycmF5KGIpID8gZ2VuZXJpY0FycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59XG4iLCJ2YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIHpvb21SaG8ocmhvLCByaG8yLCByaG80KSB7XG5cbiAgLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuICAvLyBwMSA9IFt1eDEsIHV5MSwgdzFdXG4gIGZ1bmN0aW9uIHpvb20ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgICAgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLFxuICAgICAgICBkeCA9IHV4MSAtIHV4MCxcbiAgICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICAgIGksXG4gICAgICAgIFM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHUwIOKJhSB1MS5cbiAgICBpZiAoZDIgPCBlcHNpbG9uMikge1xuICAgICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgICAgaSA9IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgICAgdXkwICsgdCAqIGR5LFxuICAgICAgICAgIHcwICogTWF0aC5leHAocmhvICogdCAqIFMpXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhbCBjYXNlLlxuICAgIGVsc2Uge1xuICAgICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgICBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIHJobzQgKiBkMikgLyAoMiAqIHcwICogcmhvMiAqIGQxKSxcbiAgICAgICAgICBiMSA9ICh3MSAqIHcxIC0gdzAgKiB3MCAtIHJobzQgKiBkMikgLyAoMiAqIHcxICogcmhvMiAqIGQxKSxcbiAgICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgICAgcjEgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjEgKiBiMSArIDEpIC0gYjEpO1xuICAgICAgUyA9IChyMSAtIHIwKSAvIHJobztcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzID0gdCAqIFMsXG4gICAgICAgICAgICBjb3NocjAgPSBjb3NoKHIwKSxcbiAgICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB1eDAgKyB1ICogZHgsXG4gICAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICAgIHcwICogY29zaHIwIC8gY29zaChyaG8gKiBzICsgcjApXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwICogcmhvIC8gTWF0aC5TUVJUMjtcblxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgem9vbS5yaG8gPSBmdW5jdGlvbihfKSB7XG4gICAgdmFyIF8xID0gTWF0aC5tYXgoMWUtMywgK18pLCBfMiA9IF8xICogXzEsIF80ID0gXzIgKiBfMjtcbiAgICByZXR1cm4gem9vbVJobyhfMSwgXzIsIF80KTtcbiAgfTtcblxuICByZXR1cm4gem9vbTtcbn0pKE1hdGguU1FSVDIsIDIsIDQpO1xuIiwiY29uc3QgcGkgPSBNYXRoLlBJLFxuICAgIHRhdSA9IDIgKiBwaSxcbiAgICBlcHNpbG9uID0gMWUtNixcbiAgICB0YXVFcHNpbG9uID0gdGF1IC0gZXBzaWxvbjtcblxuZnVuY3Rpb24gUGF0aCgpIHtcbiAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl94MSA9IHRoaXMuX3kxID0gbnVsbDsgLy8gZW5kIG9mIGN1cnJlbnQgc3VicGF0aFxuICB0aGlzLl8gPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBwYXRoKCkge1xuICByZXR1cm4gbmV3IFBhdGg7XG59XG5cblBhdGgucHJvdG90eXBlID0gcGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3gxICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl94MSA9IHRoaXMuX3gwLCB0aGlzLl95MSA9IHRoaXMuX3kwO1xuICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgIH1cbiAgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIlFcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gIH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiQ1wiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAoK3gyKSArIFwiLFwiICsgKCt5MikgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBhcmNUbzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICB4MSA9ICt4MSwgeTEgPSAreTEsIHgyID0gK3gyLCB5MiA9ICt5MiwgciA9ICtyO1xuICAgIHZhciB4MCA9IHRoaXMuX3gxLFxuICAgICAgICB5MCA9IHRoaXMuX3kxLFxuICAgICAgICB4MjEgPSB4MiAtIHgxLFxuICAgICAgICB5MjEgPSB5MiAtIHkxLFxuICAgICAgICB4MDEgPSB4MCAtIHgxLFxuICAgICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgICBsMDFfMiA9IHgwMSAqIHgwMSArIHkwMSAqIHkwMTtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MSx5MSkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPciwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgwLHkwKT8gRG8gbm90aGluZy5cbiAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpO1xuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3IsIGNjdyA9ICEhY2N3O1xuICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksXG4gICAgICAgIGR5ID0gciAqIE1hdGguc2luKGEwKSxcbiAgICAgICAgeDAgPSB4ICsgZHgsXG4gICAgICAgIHkwID0geSArIGR5LFxuICAgICAgICBjdyA9IDEgXiBjY3csXG4gICAgICAgIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDAseTApLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5feDEgLSB4MCkgPiBlcHNpbG9uIHx8IE1hdGguYWJzKHRoaXMuX3kxIC0geTApID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIGVtcHR5PyBXZeKAmXJlIGRvbmUuXG4gICAgaWYgKCFyKSByZXR1cm47XG5cbiAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgaWYgKGRhIDwgMCkgZGEgPSBkYSAlIHRhdSArIHRhdTtcblxuICAgIC8vIElzIHRoaXMgYSBjb21wbGV0ZSBjaXJjbGU/IERyYXcgdHdvIGFyY3MgdG8gY29tcGxldGUgdGhlIGNpcmNsZS5cbiAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh4IC0gZHgpICsgXCIsXCIgKyAoeSAtIGR5KSArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4MCkgKyBcIixcIiArICh0aGlzLl95MSA9IHkwKTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgIGVsc2UgaWYgKGRhID4gZXBzaWxvbikge1xuICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgfVxuICB9LFxuICByZWN0OiBmdW5jdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpICsgXCJoXCIgKyAoK3cpICsgXCJ2XCIgKyAoK2gpICsgXCJoXCIgKyAoLXcpICsgXCJaXCI7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBjb25zdCB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSxcbiAgICAgIHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpO1xuICByZXR1cm4gYWRkKHRoaXMuY292ZXIoeCwgeSksIHgsIHksIGQpO1xufVxuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgdmFyIGQsIGksIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeHogPSBuZXcgQXJyYXkobiksXG4gICAgICB5eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHgwID0gSW5maW5pdHksXG4gICAgICB5MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eTtcblxuICAvLyBDb21wdXRlIHRoZSBwb2ludHMgYW5kIHRoZWlyIGV4dGVudC5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgY29udGludWU7XG4gICAgeHpbaV0gPSB4O1xuICAgIHl6W2ldID0geTtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICAgIGlmICh5IDwgeTApIHkwID0geTtcbiAgICBpZiAoeSA+IHkxKSB5MSA9IHk7XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlIG5vICh2YWxpZCkgcG9pbnRzLCBhYm9ydC5cbiAgaWYgKHgwID4geDEgfHwgeTAgPiB5MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCkuY292ZXIoeDEsIHkxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSB8fCBpc05hTih5ID0gK3kpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTE7XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3RpbmcgcXVhZHJhbnQgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgICB5MSA9ICh5MCA9IE1hdGguZmxvb3IoeSkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCB8fCAxLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxIHx8IHkwID4geSB8fCB5ID49IHkxKSB7XG4gICAgICBpID0gKHkgPCB5MCkgPDwgMSB8ICh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgeiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB6LCB5MSA9IHkwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogeDEgPSB4MCArIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgICAgY2FzZSAzOiB4MCA9IHgxIC0geiwgeTAgPSB5MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gIHZhciBkYXRhLFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICB5MyA9IHRoaXMuX3kxLFxuICAgICAgcXVhZHMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgeDAsIHkwLCB4MywgeTMpKTtcbiAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgZWxzZSB7XG4gICAgeDAgPSB4IC0gcmFkaXVzLCB5MCA9IHkgLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXM7XG4gICAgcmFkaXVzICo9IHJhZGl1cztcbiAgfVxuXG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgcXVhZHJhbnQgY2Fu4oCZdCBjb250YWluIGEgY2xvc2VyIG5vZGUuXG4gICAgaWYgKCEobm9kZSA9IHEubm9kZSlcbiAgICAgICAgfHwgKHgxID0gcS54MCkgPiB4M1xuICAgICAgICB8fCAoeTEgPSBxLnkwKSA+IHkzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDBcbiAgICAgICAgfHwgKHkyID0gcS55MSkgPCB5MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgcXVhZHJhbnQuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyLFxuICAgICAgICAgIHltID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgcXVhZHMucHVzaChcbiAgICAgICAgbmV3IFF1YWQobm9kZVszXSwgeG0sIHltLCB4MiwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzJdLCB4MSwgeW0sIHhtLCB5MiksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMV0sIHhtLCB5MSwgeDIsIHltKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVswXSwgeDEsIHkxLCB4bSwgeW0pXG4gICAgICApO1xuXG4gICAgICAvLyBWaXNpdCB0aGUgY2xvc2VzdCBxdWFkcmFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHkgPj0geW0pIDw8IDEgfCAoeCA+PSB4bSkpIHtcbiAgICAgICAgcSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBxdWFkc1txdWFkcy5sZW5ndGggLSAxXSA9IHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGlmIChkMiA8IHJhZGl1cykge1xuICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyYWRpdXMgPSBkMik7XG4gICAgICAgIHgwID0geCAtIGQsIHkwID0geSAtIGQ7XG4gICAgICAgIHgzID0geCArIGQsIHkzID0geSArIGQ7XG4gICAgICAgIGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLm5vZGUgPSBub2RlO1xuICB0aGlzLngwID0geDA7XG4gIHRoaXMueTAgPSB5MDtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG59XG4iLCJpbXBvcnQgdHJlZV9hZGQsIHthZGRBbGwgYXMgdHJlZV9hZGRBbGx9IGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHRyZWVfY292ZXIgZnJvbSBcIi4vY292ZXIuanNcIjtcbmltcG9ydCB0cmVlX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHRyZWVfZXh0ZW50IGZyb20gXCIuL2V4dGVudC5qc1wiO1xuaW1wb3J0IHRyZWVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgdHJlZV9yZW1vdmUsIHtyZW1vdmVBbGwgYXMgdHJlZV9yZW1vdmVBbGx9IGZyb20gXCIuL3JlbW92ZS5qc1wiO1xuaW1wb3J0IHRyZWVfcm9vdCBmcm9tIFwiLi9yb290LmpzXCI7XG5pbXBvcnQgdHJlZV9zaXplIGZyb20gXCIuL3NpemUuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0IGZyb20gXCIuL3Zpc2l0LmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdEFmdGVyIGZyb20gXCIuL3Zpc2l0QWZ0ZXIuanNcIjtcbmltcG9ydCB0cmVlX3gsIHtkZWZhdWx0WH0gZnJvbSBcIi4veC5qc1wiO1xuaW1wb3J0IHRyZWVfeSwge2RlZmF1bHRZfSBmcm9tIFwiLi95LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YWR0cmVlKG5vZGVzLCB4LCB5KSB7XG4gIHZhciB0cmVlID0gbmV3IFF1YWR0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIFF1YWR0cmVlKHgsIHksIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgdGhpcy5fcm9vdCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gbGVhZl9jb3B5KGxlYWYpIHtcbiAgdmFyIGNvcHkgPSB7ZGF0YTogbGVhZi5kYXRhfSwgbmV4dCA9IGNvcHk7XG4gIHdoaWxlIChsZWFmID0gbGVhZi5uZXh0KSBuZXh0ID0gbmV4dC5uZXh0ID0ge2RhdGE6IGxlYWYuZGF0YX07XG4gIHJldHVybiBjb3B5O1xufVxuXG52YXIgdHJlZVByb3RvID0gcXVhZHRyZWUucHJvdG90eXBlID0gUXVhZHRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBRdWFkdHJlZSh0aGlzLl94LCB0aGlzLl95LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoNCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDQpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gdHJlZV9yZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7XG50cmVlUHJvdG8ueSA9IHRyZWVfeTtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICByZXRhaW5lcixcbiAgICAgIHByZXZpb3VzLFxuICAgICAgbmV4dCxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICByaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdGhpcztcblxuICAvLyBGaW5kIHRoZSBsZWFmIG5vZGUgZm9yIHRoZSBwb2ludC5cbiAgLy8gV2hpbGUgZGVzY2VuZGluZywgYWxzbyByZXRhaW4gdGhlIGRlZXBlc3QgcGFyZW50IHdpdGggYSBub24tcmVtb3ZlZCBzaWJsaW5nLlxuICBpZiAobm9kZS5sZW5ndGgpIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgYnJlYWs7XG4gICAgaWYgKHBhcmVudFsoaSArIDEpICYgM10gfHwgcGFyZW50WyhpICsgMikgJiAzXSB8fCBwYXJlbnRbKGkgKyAzKSAmIDNdKSByZXRhaW5lciA9IHBhcmVudCwgaiA9IGk7XG4gIH1cblxuICAvLyBGaW5kIHRoZSBwb2ludCB0byByZW1vdmUuXG4gIHdoaWxlIChub2RlLmRhdGEgIT09IGQpIGlmICghKHByZXZpb3VzID0gbm9kZSwgbm9kZSA9IG5vZGUubmV4dCkpIHJldHVybiB0aGlzO1xuICBpZiAobmV4dCA9IG5vZGUubmV4dCkgZGVsZXRlIG5vZGUubmV4dDtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29pbmNpZGVudCBwb2ludHMsIHJlbW92ZSBqdXN0IHRoZSBwb2ludC5cbiAgaWYgKHByZXZpb3VzKSByZXR1cm4gKG5leHQgPyBwcmV2aW91cy5uZXh0ID0gbmV4dCA6IGRlbGV0ZSBwcmV2aW91cy5uZXh0KSwgdGhpcztcblxuICAvLyBJZiB0aGlzIGlzIHRoZSByb290IHBvaW50LCByZW1vdmUgaXQuXG4gIGlmICghcGFyZW50KSByZXR1cm4gdGhpcy5fcm9vdCA9IG5leHQsIHRoaXM7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVhZi5cbiAgbmV4dCA/IHBhcmVudFtpXSA9IG5leHQgOiBkZWxldGUgcGFyZW50W2ldO1xuXG4gIC8vIElmIHRoZSBwYXJlbnQgbm93IGNvbnRhaW5zIGV4YWN0bHkgb25lIGxlYWYsIGNvbGxhcHNlIHN1cGVyZmx1b3VzIHBhcmVudHMuXG4gIGlmICgobm9kZSA9IHBhcmVudFswXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzJdIHx8IHBhcmVudFszXSlcbiAgICAgICYmIG5vZGUgPT09IChwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImltcG9ydCBRdWFkIGZyb20gXCIuL3F1YWQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHF1YWRzID0gW10sIG5leHQgPSBbXSwgcTtcbiAgaWYgKHRoaXMuX3Jvb3QpIHF1YWRzLnB1c2gobmV3IFF1YWQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIHZhciBub2RlID0gcS5ub2RlO1xuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeW0sIHhtLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICB9XG4gICAgbmV4dC5wdXNoKHEpO1xuICB9XG4gIHdoaWxlIChxID0gbmV4dC5wb3AoKSkge1xuICAgIGNhbGxiYWNrKHEubm9kZSwgcS54MCwgcS55MCwgcS54MSwgcS55MSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFgoZCkge1xuICByZXR1cm4gZFswXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl94ID0gXywgdGhpcykgOiB0aGlzLl94O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feSA9IF8sIHRoaXMpIDogdGhpcy5feTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnN0YW50cyh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgaW50ZXJwb2xhdGVWYWx1ZSwgaW50ZXJwb2xhdGVOdW1iZXIsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgbnVtYmVyIGZyb20gXCIuL251bWJlci5qc1wiO1xuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoaXNOYU4oYikgPyBOYU4gOiAwLjUpO1xufVxuXG5mdW5jdGlvbiBjbGFtcGVyKGEsIGIpIHtcbiAgdmFyIHQ7XG4gIGlmIChhID4gYikgdCA9IGEsIGEgPSBiLCBiID0gdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubWF4KGEsIE1hdGgubWluKGIsIHgpKTsgfTtcbn1cblxuLy8gbm9ybWFsaXplKGEsIGIpKHgpIHRha2VzIGEgZG9tYWluIHZhbHVlIHggaW4gW2EsYl0gYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHQgaW4gWzAsMV0uXG4vLyBpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJhbmdlIHZhbHVlIHggaW4gW2EsYl0uXG5mdW5jdGlvbiBiaW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBub3JtYWxpemUoZDEsIGQwKSwgcjAgPSBpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gbm9ybWFsaXplKGQwLCBkMSksIHIwID0gaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSkge1xuICB2YXIgaiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxLFxuICAgICAgZCA9IG5ldyBBcnJheShqKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkoaiksXG4gICAgICBpID0gLTE7XG5cbiAgLy8gUmV2ZXJzZSBkZXNjZW5kaW5nIGRvbWFpbnMuXG4gIGlmIChkb21haW5bal0gPCBkb21haW5bMF0pIHtcbiAgICBkb21haW4gPSBkb21haW4uc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgZFtpXSA9IG5vcm1hbGl6ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSBpbnRlcnBvbGF0ZShyYW5nZVtpXSwgcmFuZ2VbaSArIDFdKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgdmFyIGkgPSBiaXNlY3QoZG9tYWluLCB4LCAxLCBqKSAtIDE7XG4gICAgcmV0dXJuIHJbaV0oZFtpXSh4KSk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIGRvbWFpbiA9IHVuaXQsXG4gICAgICByYW5nZSA9IHVuaXQsXG4gICAgICBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlVmFsdWUsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICB1bnRyYW5zZm9ybSxcbiAgICAgIHVua25vd24sXG4gICAgICBjbGFtcCA9IGlkZW50aXR5LFxuICAgICAgcGllY2V3aXNlLFxuICAgICAgb3V0cHV0LFxuICAgICAgaW5wdXQ7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCk7XG4gICAgaWYgKGNsYW1wICE9PSBpZGVudGl0eSkgY2xhbXAgPSBjbGFtcGVyKGRvbWFpblswXSwgZG9tYWluW24gLSAxXSk7XG4gICAgcGllY2V3aXNlID0gbiA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbi5tYXAodHJhbnNmb3JtKSwgcmFuZ2UsIGludGVycG9sYXRlKSkpKHRyYW5zZm9ybShjbGFtcCh4KSkpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiBjbGFtcCh1bnRyYW5zZm9ybSgoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlLCBkb21haW4ubWFwKHRyYW5zZm9ybSksIGludGVycG9sYXRlTnVtYmVyKSkpKHkpKSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IEFycmF5LmZyb20oXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlID0gQXJyYXkuZnJvbShfKSwgcmVzY2FsZSgpKSA6IHJhbmdlLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBpbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlUm91bmQsIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGFtcCA9IF8gPyB0cnVlIDogaWRlbnRpdHksIHJlc2NhbGUoKSkgOiBjbGFtcCAhPT0gaWRlbnRpdHk7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCwgdSkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHVudHJhbnNmb3JtID0gdTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250aW51b3VzKCkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoKShpZGVudGl0eSwgaWRlbnRpdHkpO1xufVxuIiwiaW1wb3J0IHtpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVSb3VuZCwgcGllY2V3aXNlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcbmltcG9ydCB7aWRlbnRpdHl9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdEludGVycG9sYXRvcn0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IHtsaW5lYXJpc2h9IGZyb20gXCIuL2xpbmVhci5qc1wiO1xuaW1wb3J0IHtsb2dnaXNofSBmcm9tIFwiLi9sb2cuanNcIjtcbmltcG9ydCB7Y29weX0gZnJvbSBcIi4vc2VxdWVudGlhbC5qc1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZy5qc1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvdy5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMC41LFxuICAgICAgeDIgPSAxLFxuICAgICAgcyA9IDEsXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICBrMTAsXG4gICAgICBrMjEsXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gaXNOYU4oeCA9ICt4KSA/IHVua25vd24gOiAoeCA9IDAuNSArICgoeCA9ICt0cmFuc2Zvcm0oeCkpIC0gdDEpICogKHMgKiB4IDwgcyAqIHQxID8gazEwIDogazIxKSwgaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCkpIDogeCkpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKFt4MCwgeDEsIHgyXSA9IF8sIHQwID0gdHJhbnNmb3JtKHgwID0gK3gwKSwgdDEgPSB0cmFuc2Zvcm0oeDEgPSAreDEpLCB0MiA9IHRyYW5zZm9ybSh4MiA9ICt4MiksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHMgPSB0MSA8IHQwID8gLTEgOiAxLCBzY2FsZSkgOiBbeDAsIHgxLCB4Ml07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmFuZ2UoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHIwLCByMSwgcjI7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbcjAsIHIxLCByMl0gPSBfLCBpbnRlcnBvbGF0b3IgPSBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIFtyMCwgcjEsIHIyXSksIHNjYWxlKSA6IFtpbnRlcnBvbGF0b3IoMCksIGludGVycG9sYXRvcigwLjUpLCBpbnRlcnBvbGF0b3IoMSldO1xuICAgIH07XG4gIH1cblxuICBzY2FsZS5yYW5nZSA9IHJhbmdlKGludGVycG9sYXRlKTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gcmFuZ2UoaW50ZXJwb2xhdGVSb3VuZCk7XG5cbiAgc2NhbGUudW5rbm93biA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh1bmtub3duID0gXywgc2NhbGUpIDogdW5rbm93bjtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHRyYW5zZm9ybSA9IHQsIHQwID0gdCh4MCksIHQxID0gdCh4MSksIHQyID0gdCh4MiksIGsxMCA9IHQwID09PSB0MSA/IDAgOiAwLjUgLyAodDEgLSB0MCksIGsyMSA9IHQxID09PSB0MiA/IDAgOiAwLjUgLyAodDIgLSB0MSksIHMgPSB0MSA8IHQwID8gLTEgOiAxO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGl2ZXJnaW5nKCkge1xuICB2YXIgc2NhbGUgPSBsaW5lYXJpc2godHJhbnNmb3JtZXIoKShpZGVudGl0eSkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nTG9nKCkge1xuICB2YXIgc2NhbGUgPSBsb2dnaXNoKHRyYW5zZm9ybWVyKCkpLmRvbWFpbihbMC4xLCAxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpdmVyZ2luZ1N5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgZGl2ZXJnaW5nU3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGl2ZXJnaW5nUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBkaXZlcmdpbmdQb3coKSkuZXhwb25lbnQoc2NhbGUuZXhwb25lbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZlcmdpbmdTcXJ0KCkge1xuICByZXR1cm4gZGl2ZXJnaW5nUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCBudW1iZXIgZnJvbSBcIi4vbnVtYmVyLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlkZW50aXR5KGRvbWFpbikge1xuICB2YXIgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHg7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBzY2FsZTtcblxuICBzY2FsZS5kb21haW4gPSBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBBcnJheS5mcm9tKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZGVudGl0eShkb21haW4pLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgZG9tYWluID0gYXJndW1lbnRzLmxlbmd0aCA/IEFycmF5LmZyb20oZG9tYWluLCBudW1iZXIpIDogWzAsIDFdO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGluaXRSYW5nZShkb21haW4sIHJhbmdlKSB7XG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogYnJlYWs7XG4gICAgY2FzZSAxOiB0aGlzLnJhbmdlKGRvbWFpbik7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRoaXMucmFuZ2UocmFuZ2UpLmRvbWFpbihkb21haW4pOyBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRJbnRlcnBvbGF0b3IoZG9tYWluLCBpbnRlcnBvbGF0b3IpIHtcbiAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiBicmVhaztcbiAgICBjYXNlIDE6IHtcbiAgICAgIGlmICh0eXBlb2YgZG9tYWluID09PSBcImZ1bmN0aW9uXCIpIHRoaXMuaW50ZXJwb2xhdG9yKGRvbWFpbik7XG4gICAgICBlbHNlIHRoaXMucmFuZ2UoZG9tYWluKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICB0aGlzLmRvbWFpbihkb21haW4pO1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcnBvbGF0b3IgPT09IFwiZnVuY3Rpb25cIikgdGhpcy5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yKTtcbiAgICAgIGVsc2UgdGhpcy5yYW5nZShpbnRlcnBvbGF0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IHt0aWNrcywgdGlja0luY3JlbWVudH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQgY29udGludW91cywge2NvcHl9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQgdGlja0Zvcm1hdCBmcm9tIFwiLi90aWNrRm9ybWF0LmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gdGlja3MoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCk7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQsIHNwZWNpZmllcik7XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG5cbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHZhciBpMCA9IDA7XG4gICAgdmFyIGkxID0gZC5sZW5ndGggLSAxO1xuICAgIHZhciBzdGFydCA9IGRbaTBdO1xuICAgIHZhciBzdG9wID0gZFtpMV07XG4gICAgdmFyIHByZXN0ZXA7XG4gICAgdmFyIHN0ZXA7XG4gICAgdmFyIG1heEl0ZXIgPSAxMDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cbiAgICBcbiAgICB3aGlsZSAobWF4SXRlci0tID4gMCkge1xuICAgICAgc3RlcCA9IHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICAgIGlmIChzdGVwID09PSBwcmVzdGVwKSB7XG4gICAgICAgIGRbaTBdID0gc3RhcnRcbiAgICAgICAgZFtpMV0gPSBzdG9wXG4gICAgICAgIHJldHVybiBkb21haW4oZCk7XG4gICAgICB9IGVsc2UgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJlc3RlcCA9IHN0ZXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGluZWFyKCkge1xuICB2YXIgc2NhbGUgPSBjb250aW51b3VzKCk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuIiwiaW1wb3J0IHt0aWNrc30gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2Zvcm1hdH0gZnJvbSBcImQzLWZvcm1hdFwiO1xuaW1wb3J0IG5pY2UgZnJvbSBcIi4vbmljZS5qc1wiO1xuaW1wb3J0IHtjb3B5LCB0cmFuc2Zvcm1lcn0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTG9nKHgpIHtcbiAgcmV0dXJuIE1hdGgubG9nKHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1FeHAoeCkge1xuICByZXR1cm4gTWF0aC5leHAoeCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUxvZ24oeCkge1xuICByZXR1cm4gLU1hdGgubG9nKC14KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtRXhwbih4KSB7XG4gIHJldHVybiAtTWF0aC5leHAoLXgpO1xufVxuXG5mdW5jdGlvbiBwb3cxMCh4KSB7XG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/ICsoXCIxZVwiICsgeCkgOiB4IDwgMCA/IDAgOiB4O1xufVxuXG5mdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IDEwID8gcG93MTBcbiAgICAgIDogYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5leHBcbiAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XG59XG5cbmZ1bmN0aW9uIGxvZ3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5sb2dcbiAgICAgIDogYmFzZSA9PT0gMTAgJiYgTWF0aC5sb2cxMFxuICAgICAgfHwgYmFzZSA9PT0gMiAmJiBNYXRoLmxvZzJcbiAgICAgIHx8IChiYXNlID0gTWF0aC5sb2coYmFzZSksIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpIC8gYmFzZTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZmxlY3QoZikge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAtZigteCk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dnaXNoKHRyYW5zZm9ybSkge1xuICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluLFxuICAgICAgYmFzZSA9IDEwLFxuICAgICAgbG9ncyxcbiAgICAgIHBvd3M7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgaWYgKGRvbWFpbigpWzBdIDwgMCkge1xuICAgICAgbG9ncyA9IHJlZmxlY3QobG9ncyksIHBvd3MgPSByZWZsZWN0KHBvd3MpO1xuICAgICAgdHJhbnNmb3JtKHRyYW5zZm9ybUxvZ24sIHRyYW5zZm9ybUV4cG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm0odHJhbnNmb3JtTG9nLCB0cmFuc2Zvcm1FeHApO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGJhc2UgPSArXywgcmVzY2FsZSgpKSA6IGJhc2U7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB1ID0gZFswXSxcbiAgICAgICAgdiA9IGRbZC5sZW5ndGggLSAxXSxcbiAgICAgICAgcjtcblxuICAgIGlmIChyID0gdiA8IHUpIGkgPSB1LCB1ID0gdiwgdiA9IGk7XG5cbiAgICB2YXIgaSA9IGxvZ3ModSksXG4gICAgICAgIGogPSBsb2dzKHYpLFxuICAgICAgICBwLFxuICAgICAgICBrLFxuICAgICAgICB0LFxuICAgICAgICBuID0gY291bnQgPT0gbnVsbCA/IDEwIDogK2NvdW50LFxuICAgICAgICB6ID0gW107XG5cbiAgICBpZiAoIShiYXNlICUgMSkgJiYgaiAtIGkgPCBuKSB7XG4gICAgICBpID0gTWF0aC5mbG9vcihpKSwgaiA9IE1hdGguY2VpbChqKTtcbiAgICAgIGlmICh1ID4gMCkgZm9yICg7IGkgPD0gajsgKytpKSB7XG4gICAgICAgIGZvciAoayA9IDEsIHAgPSBwb3dzKGkpOyBrIDwgYmFzZTsgKytrKSB7XG4gICAgICAgICAgdCA9IHAgKiBrO1xuICAgICAgICAgIGlmICh0IDwgdSkgY29udGludWU7XG4gICAgICAgICAgaWYgKHQgPiB2KSBicmVhaztcbiAgICAgICAgICB6LnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBmb3IgKDsgaSA8PSBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoei5sZW5ndGggKiAyIDwgbikgeiA9IHRpY2tzKHUsIHYsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gdGlja3MoaSwgaiwgTWF0aC5taW4oaiAtIGksIG4pKS5tYXAocG93cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHIgPyB6LnJldmVyc2UoKSA6IHo7XG4gIH07XG5cbiAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICBpZiAoc3BlY2lmaWVyID09IG51bGwpIHNwZWNpZmllciA9IGJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiO1xuICAgIGlmICh0eXBlb2Ygc3BlY2lmaWVyICE9PSBcImZ1bmN0aW9uXCIpIHNwZWNpZmllciA9IGZvcm1hdChzcGVjaWZpZXIpO1xuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBzcGVjaWZpZXI7XG4gICAgaWYgKGNvdW50ID09IG51bGwpIGNvdW50ID0gMTA7XG4gICAgdmFyIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7IC8vIFRPRE8gZmFzdCBlc3RpbWF0ZT9cbiAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIGkgPSBkIC8gcG93cyhNYXRoLnJvdW5kKGxvZ3MoZCkpKTtcbiAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAwLjUpIGkgKj0gYmFzZTtcbiAgICAgIHJldHVybiBpIDw9IGsgPyBzcGVjaWZpZXIoZCkgOiBcIlwiO1xuICAgIH07XG4gIH07XG5cbiAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb21haW4obmljZShkb21haW4oKSwge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHBvd3MoTWF0aC5mbG9vcihsb2dzKHgpKSk7IH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguY2VpbChsb2dzKHgpKSk7IH1cbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsb2coKSB7XG4gIHZhciBzY2FsZSA9IGxvZ2dpc2godHJhbnNmb3JtZXIoKSkuZG9tYWluKFsxLCAxMF0pO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gIHZhciBpMCA9IDAsXG4gICAgICBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLFxuICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgdDtcblxuICBpZiAoeDEgPCB4MCkge1xuICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICB9XG5cbiAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xuICByZXR1cm4gZG9tYWluO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuIiwiaW1wb3J0IHtpbml0UmFuZ2V9IGZyb20gXCIuL2luaXQuanNcIjtcblxuZXhwb3J0IGNvbnN0IGltcGxpY2l0ID0gU3ltYm9sKFwiaW1wbGljaXRcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGluYWwoKSB7XG4gIHZhciBpbmRleCA9IG5ldyBNYXAoKSxcbiAgICAgIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHVua25vd24gPSBpbXBsaWNpdDtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlWyhpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIF8pIHtcbiAgICAgIGNvbnN0IGtleSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIGlmIChpbmRleC5oYXMoa2V5KSkgY29udGludWU7XG4gICAgICBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaCh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFuZ2UgPSBBcnJheS5mcm9tKF8pLCBzY2FsZSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBvcmRpbmFsKGRvbWFpbiwgcmFuZ2UpLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgaW5pdFJhbmdlLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xuXG4gIHJldHVybiBzY2FsZTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7Y29weSwgaWRlbnRpdHksIHRyYW5zZm9ybWVyfSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb3coZXhwb25lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3FydCh4KSB7XG4gIHJldHVybiB4IDwgMCA/IC1NYXRoLnNxcnQoLXgpIDogTWF0aC5zcXJ0KHgpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TcXVhcmUoeCkge1xuICByZXR1cm4geCA8IDAgPyAteCAqIHggOiB4ICogeDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvd2lzaCh0cmFuc2Zvcm0pIHtcbiAgdmFyIHNjYWxlID0gdHJhbnNmb3JtKGlkZW50aXR5LCBpZGVudGl0eSksXG4gICAgICBleHBvbmVudCA9IDE7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICByZXR1cm4gZXhwb25lbnQgPT09IDEgPyB0cmFuc2Zvcm0oaWRlbnRpdHksIGlkZW50aXR5KVxuICAgICAgICA6IGV4cG9uZW50ID09PSAwLjUgPyB0cmFuc2Zvcm0odHJhbnNmb3JtU3FydCwgdHJhbnNmb3JtU3F1YXJlKVxuICAgICAgICA6IHRyYW5zZm9ybSh0cmFuc2Zvcm1Qb3coZXhwb25lbnQpLCB0cmFuc2Zvcm1Qb3coMSAvIGV4cG9uZW50KSk7XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCByZXNjYWxlKCkpIDogZXhwb25lbnQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvdygpIHtcbiAgdmFyIHNjYWxlID0gcG93aXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KCkge1xuICByZXR1cm4gcG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7YXNjZW5kaW5nLCBiaXNlY3QsIHF1YW50aWxlU29ydGVkIGFzIHRocmVzaG9sZH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFudGlsZSgpIHtcbiAgdmFyIGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXSxcbiAgICAgIHRocmVzaG9sZHMgPSBbXSxcbiAgICAgIHVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IHRocmVzaG9sZChkb21haW4sIGkgLyBuKTtcbiAgICByZXR1cm4gc2NhbGU7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCBpc05hTih4ID0gK3gpID8gdW5rbm93biA6IHJhbmdlW2Jpc2VjdCh0aHJlc2hvbGRzLCB4KV07XG4gIH1cblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl0gOiBbXG4gICAgICBpID4gMCA/IHRocmVzaG9sZHNbaSAtIDFdIDogZG9tYWluWzBdLFxuICAgICAgaSA8IHRocmVzaG9sZHMubGVuZ3RoID8gdGhyZXNob2xkc1tpXSA6IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV1cbiAgICBdO1xuICB9O1xuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW4uc2xpY2UoKTtcbiAgICBkb21haW4gPSBbXTtcbiAgICBmb3IgKGxldCBkIG9mIF8pIGlmIChkICE9IG51bGwgJiYgIWlzTmFOKGQgPSArZCkpIGRvbWFpbi5wdXNoKGQpO1xuICAgIGRvbWFpbi5zb3J0KGFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIHJlc2NhbGUoKSkgOiByYW5nZS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnVua25vd24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodW5rbm93biA9IF8sIHNjYWxlKSA6IHVua25vd247XG4gIH07XG5cbiAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRocmVzaG9sZHMuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHF1YW50aWxlKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7YmlzZWN0fSBmcm9tIFwiZDMtYXJyYXlcIjtcbmltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHF1YW50aXplKCkge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgbiA9IDEsXG4gICAgICBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bjtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiB4IDw9IHggPyByYW5nZVtiaXNlY3QoZG9tYWluLCB4LCAwLCBuKV0gOiB1bmtub3duO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbeDAsIHgxXSA9IF8sIHgwID0gK3gwLCB4MSA9ICt4MSwgcmVzY2FsZSgpKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG4gPSAocmFuZ2UgPSBBcnJheS5mcm9tKF8pKS5sZW5ndGggLSAxLCByZXNjYWxlKCkpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBpIDwgMCA/IFtOYU4sIE5hTl1cbiAgICAgICAgOiBpIDwgMSA/IFt4MCwgZG9tYWluWzBdXVxuICAgICAgICA6IGkgPj0gbiA/IFtkb21haW5bbiAtIDFdLCB4MV1cbiAgICAgICAgOiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiBzY2FsZTtcbiAgfTtcblxuICBzY2FsZS50aHJlc2hvbGRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkobGluZWFyaXNoKHNjYWxlKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7aW50ZXJwb2xhdGUsIGludGVycG9sYXRlUm91bmR9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xuaW1wb3J0IHtpZGVudGl0eX0gZnJvbSBcIi4vY29udGludW91cy5qc1wiO1xuaW1wb3J0IHtpbml0SW50ZXJwb2xhdG9yfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5pbXBvcnQge2xpbmVhcmlzaH0gZnJvbSBcIi4vbGluZWFyLmpzXCI7XG5pbXBvcnQge2xvZ2dpc2h9IGZyb20gXCIuL2xvZy5qc1wiO1xuaW1wb3J0IHtzeW1sb2dpc2h9IGZyb20gXCIuL3N5bWxvZy5qc1wiO1xuaW1wb3J0IHtwb3dpc2h9IGZyb20gXCIuL3Bvdy5qc1wiO1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcigpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIHQwLFxuICAgICAgdDEsXG4gICAgICBrMTAsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBpbnRlcnBvbGF0b3IgPSBpZGVudGl0eSxcbiAgICAgIGNsYW1wID0gZmFsc2UsXG4gICAgICB1bmtub3duO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsIHx8IGlzTmFOKHggPSAreCkgPyB1bmtub3duIDogaW50ZXJwb2xhdG9yKGsxMCA9PT0gMCA/IDAuNSA6ICh4ID0gKHRyYW5zZm9ybSh4KSAtIHQwKSAqIGsxMCwgY2xhbXAgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB4KSkgOiB4KSk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoW3gwLCB4MV0gPSBfLCB0MCA9IHRyYW5zZm9ybSh4MCA9ICt4MCksIHQxID0gdHJhbnNmb3JtKHgxID0gK3gxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCksIHNjYWxlKSA6IFt4MCwgeDFdO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCBzY2FsZSkgOiBjbGFtcDtcbiAgfTtcblxuICBzY2FsZS5pbnRlcnBvbGF0b3IgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdG9yID0gXywgc2NhbGUpIDogaW50ZXJwb2xhdG9yO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJhbmdlKGludGVycG9sYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHtcbiAgICAgIHZhciByMCwgcjE7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChbcjAsIHIxXSA9IF8sIGludGVycG9sYXRvciA9IGludGVycG9sYXRlKHIwLCByMSksIHNjYWxlKSA6IFtpbnRlcnBvbGF0b3IoMCksIGludGVycG9sYXRvcigxKV07XG4gICAgfTtcbiAgfVxuXG4gIHNjYWxlLnJhbmdlID0gcmFuZ2UoaW50ZXJwb2xhdGUpO1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSByYW5nZShpbnRlcnBvbGF0ZVJvdW5kKTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdHJhbnNmb3JtID0gdCwgdDAgPSB0KHgwKSwgdDEgPSB0KHgxKSwgazEwID0gdDAgPT09IHQxID8gMCA6IDEgLyAodDEgLSB0MCk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShzb3VyY2UsIHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0XG4gICAgICAuZG9tYWluKHNvdXJjZS5kb21haW4oKSlcbiAgICAgIC5pbnRlcnBvbGF0b3Ioc291cmNlLmludGVycG9sYXRvcigpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKVxuICAgICAgLnVua25vd24oc291cmNlLnVua25vd24oKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlcXVlbnRpYWwoKSB7XG4gIHZhciBzY2FsZSA9IGxpbmVhcmlzaCh0cmFuc2Zvcm1lcigpKGlkZW50aXR5KSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsKCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbExvZygpIHtcbiAgdmFyIHNjYWxlID0gbG9nZ2lzaCh0cmFuc2Zvcm1lcigpKS5kb21haW4oWzEsIDEwXSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsTG9nKCkpLmJhc2Uoc2NhbGUuYmFzZSgpKTtcbiAgfTtcblxuICByZXR1cm4gaW5pdEludGVycG9sYXRvci5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbnRpYWxTeW1sb2coKSB7XG4gIHZhciBzY2FsZSA9IHN5bWxvZ2lzaCh0cmFuc2Zvcm1lcigpKTtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvcHkoc2NhbGUsIHNlcXVlbnRpYWxTeW1sb2coKSkuY29uc3RhbnQoc2NhbGUuY29uc3RhbnQoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRJbnRlcnBvbGF0b3IuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXF1ZW50aWFsUG93KCkge1xuICB2YXIgc2NhbGUgPSBwb3dpc2godHJhbnNmb3JtZXIoKSk7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBzZXF1ZW50aWFsUG93KCkpLmV4cG9uZW50KHNjYWxlLmV4cG9uZW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0SW50ZXJwb2xhdG9yLmFwcGx5KHNjYWxlLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VxdWVudGlhbFNxcnQoKSB7XG4gIHJldHVybiBzZXF1ZW50aWFsUG93LmFwcGx5KG51bGwsIGFyZ3VtZW50cykuZXhwb25lbnQoMC41KTtcbn1cbiIsImltcG9ydCB7bGluZWFyaXNofSBmcm9tIFwiLi9saW5lYXIuanNcIjtcbmltcG9ydCB7Y29weSwgdHJhbnNmb3JtZXJ9IGZyb20gXCIuL2NvbnRpbnVvdXMuanNcIjtcbmltcG9ydCB7aW5pdFJhbmdlfSBmcm9tIFwiLi9pbml0LmpzXCI7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN5bWxvZyhjKSB7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih4KSAqIE1hdGgubG9nMXAoTWF0aC5hYnMoeCAvIGMpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU3ltZXhwKGMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3ltbG9naXNoKHRyYW5zZm9ybSkge1xuICB2YXIgYyA9IDEsIHNjYWxlID0gdHJhbnNmb3JtKHRyYW5zZm9ybVN5bWxvZyhjKSwgdHJhbnNmb3JtU3ltZXhwKGMpKTtcblxuICBzY2FsZS5jb25zdGFudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyYW5zZm9ybSh0cmFuc2Zvcm1TeW1sb2coYyA9ICtfKSwgdHJhbnNmb3JtU3ltZXhwKGMpKSA6IGM7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWxvZygpIHtcbiAgdmFyIHNjYWxlID0gc3ltbG9naXNoKHRyYW5zZm9ybWVyKCkpO1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgc3ltbG9nKCkpLmNvbnN0YW50KHNjYWxlLmNvbnN0YW50KCkpO1xuICB9O1xuXG4gIHJldHVybiBpbml0UmFuZ2UuYXBwbHkoc2NhbGUsIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge2Jpc2VjdH0gZnJvbSBcImQzLWFycmF5XCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlID0gWzAsIDFdLFxuICAgICAgdW5rbm93bixcbiAgICAgIG4gPSAxO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHggPD0geCA/IHJhbmdlW2Jpc2VjdChkb21haW4sIHgsIDAsIG4pXSA6IHVua25vd247XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gQXJyYXkuZnJvbShfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiBkb21haW4uc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSA9IEFycmF5LmZyb20oXyksIG4gPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGggLSAxKSwgc2NhbGUpIDogcmFuZ2Uuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgdmFyIGkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgIHJldHVybiBbZG9tYWluW2kgLSAxXSwgZG9tYWluW2ldXTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSlcbiAgICAgICAgLnVua25vd24odW5rbm93bik7XG4gIH07XG5cbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShzY2FsZSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7dGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtmb3JtYXQsIGZvcm1hdFByZWZpeCwgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUHJlZml4LCBwcmVjaXNpb25Sb3VuZH0gZnJvbSBcImQzLWZvcm1hdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0aWNrRm9ybWF0KHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gIHZhciBzdGVwID0gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSxcbiAgICAgIHByZWNpc2lvbjtcbiAgc3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllciA9PSBudWxsID8gXCIsZlwiIDogc3BlY2lmaWVyKTtcbiAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgIGNhc2UgXCJzXCI6IHtcbiAgICAgIHZhciB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUHJlZml4KHN0ZXAsIHZhbHVlKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgIH1cbiAgICBjYXNlIFwiXCI6XG4gICAgY2FzZSBcImVcIjpcbiAgICBjYXNlIFwiZ1wiOlxuICAgIGNhc2UgXCJwXCI6XG4gICAgY2FzZSBcInJcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSkpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gXCJlXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJmXCI6XG4gICAgY2FzZSBcIiVcIjoge1xuICAgICAgaWYgKHNwZWNpZmllci5wcmVjaXNpb24gPT0gbnVsbCAmJiAhaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcIiVcIikgKiAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbn1cbiIsImltcG9ydCB7dGltZVllYXIsIHRpbWVNb250aCwgdGltZVdlZWssIHRpbWVEYXksIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lVGlja3MsIHRpbWVUaWNrSW50ZXJ2YWx9IGZyb20gXCJkMy10aW1lXCI7XG5pbXBvcnQge3RpbWVGb3JtYXR9IGZyb20gXCJkMy10aW1lLWZvcm1hdFwiO1xuaW1wb3J0IGNvbnRpbnVvdXMsIHtjb3B5fSBmcm9tIFwiLi9jb250aW51b3VzLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuaW1wb3J0IG5pY2UgZnJvbSBcIi4vbmljZS5qc1wiO1xuXG5mdW5jdGlvbiBkYXRlKHQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHQpO1xufVxuXG5mdW5jdGlvbiBudW1iZXIodCkge1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIERhdGUgPyArdCA6ICtuZXcgRGF0ZSgrdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxlbmRhcih0aWNrcywgdGlja0ludGVydmFsLCB5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgZm9ybWF0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoKSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdChcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdChcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQoXCIlWVwiKTtcblxuICBmdW5jdGlvbiB0aWNrRm9ybWF0KGRhdGUpIHtcbiAgICByZXR1cm4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBmb3JtYXRNaWxsaXNlY29uZFxuICAgICAgICA6IG1pbnV0ZShkYXRlKSA8IGRhdGUgPyBmb3JtYXRTZWNvbmRcbiAgICAgICAgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbnV0ZVxuICAgICAgICA6IGRheShkYXRlKSA8IGRhdGUgPyBmb3JtYXRIb3VyXG4gICAgICAgIDogbW9udGgoZGF0ZSkgPCBkYXRlID8gKHdlZWsoZGF0ZSkgPCBkYXRlID8gZm9ybWF0RGF5IDogZm9ybWF0V2VlaylcbiAgICAgICAgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1vbnRoXG4gICAgICAgIDogZm9ybWF0WWVhcikoZGF0ZSk7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih5KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGludmVydCh5KSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZG9tYWluKEFycmF5LmZyb20oXywgbnVtYmVyKSkgOiBkb21haW4oKS5tYXAoZGF0ZSk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgcmV0dXJuIHRpY2tzKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgaW50ZXJ2YWwgPT0gbnVsbCA/IDEwIDogaW50ZXJ2YWwpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gdGlja0Zvcm1hdCA6IGZvcm1hdChzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuICAgIHZhciBkID0gZG9tYWluKCk7XG4gICAgaWYgKCFpbnRlcnZhbCB8fCB0eXBlb2YgaW50ZXJ2YWwucmFuZ2UgIT09IFwiZnVuY3Rpb25cIikgaW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwoZFswXSwgZFtkLmxlbmd0aCAtIDFdLCBpbnRlcnZhbCA9PSBudWxsID8gMTAgOiBpbnRlcnZhbCk7XG4gICAgcmV0dXJuIGludGVydmFsID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKSA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIodGlja3MsIHRpY2tJbnRlcnZhbCwgeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIGZvcm1hdCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGltZSgpIHtcbiAgcmV0dXJuIGluaXRSYW5nZS5hcHBseShjYWxlbmRhcih0aW1lVGlja3MsIHRpbWVUaWNrSW50ZXJ2YWwsIHRpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVXZWVrLCB0aW1lRGF5LCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKSwgYXJndW1lbnRzKTtcbn1cbiIsImltcG9ydCB7dXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWx9IGZyb20gXCJkMy10aW1lXCI7XG5pbXBvcnQge3V0Y0Zvcm1hdH0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XG5pbXBvcnQge2NhbGVuZGFyfSBmcm9tIFwiLi90aW1lLmpzXCI7XG5pbXBvcnQge2luaXRSYW5nZX0gZnJvbSBcIi4vaW5pdC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1dGNUaW1lKCkge1xuICByZXR1cm4gaW5pdFJhbmdlLmFwcGx5KGNhbGVuZGFyKHV0Y1RpY2tzLCB1dGNUaWNrSW50ZXJ2YWwsIHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNXZWVrLCB1dGNEYXksIHV0Y0hvdXIsIHV0Y01pbnV0ZSwgdXRjU2Vjb25kLCB1dGNGb3JtYXQpLmRvbWFpbihbRGF0ZS5VVEMoMjAwMCwgMCwgMSksIERhdGUuVVRDKDIwMDAsIDAsIDIpXSksIGFyZ3VtZW50cyk7XG59XG4iLCJpbXBvcnQge3BhdGh9IGZyb20gXCJkMy1wYXRoXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCB7YWJzLCBhY29zLCBhc2luLCBhdGFuMiwgY29zLCBlcHNpbG9uLCBoYWxmUGksIG1heCwgbWluLCBwaSwgc2luLCBzcXJ0LCB0YXV9IGZyb20gXCIuL21hdGguanNcIjtcblxuZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5pbm5lclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICByZXR1cm4gZC5vdXRlclJhZGl1cztcbn1cblxuZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gIHJldHVybiBkLnN0YXJ0QW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQuZW5kQW5nbGU7XG59XG5cbmZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsXG4gICAgICB4MzIgPSB4MyAtIHgyLCB5MzIgPSB5MyAtIHkyLFxuICAgICAgdCA9IHkzMiAqIHgxMCAtIHgzMiAqIHkxMDtcbiAgaWYgKHQgKiB0IDwgZXBzaWxvbikgcmV0dXJuO1xuICB0ID0gKHgzMiAqICh5MCAtIHkyKSAtIHkzMiAqICh4MCAtIHgyKSkgLyB0O1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksXG4gICAgICBveCA9IGxvICogeTAxLFxuICAgICAgb3kgPSAtbG8gKiB4MDEsXG4gICAgICB4MTEgPSB4MCArIG94LFxuICAgICAgeTExID0geTAgKyBveSxcbiAgICAgIHgxMCA9IHgxICsgb3gsXG4gICAgICB5MTAgPSB5MSArIG95LFxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxuICAgICAgeTAwID0gKHkxMSArIHkxMCkgLyAyLFxuICAgICAgZHggPSB4MTAgLSB4MTEsXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICByID0gcjEgLSByYyxcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXG4gICAgICBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBpbm5lclJhZGl1cyA9IGFyY0lubmVyUmFkaXVzLFxuICAgICAgb3V0ZXJSYWRpdXMgPSBhcmNPdXRlclJhZGl1cyxcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLFxuICAgICAgcGFkUmFkaXVzID0gbnVsbCxcbiAgICAgIHN0YXJ0QW5nbGUgPSBhcmNTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSxcbiAgICAgIHBhZEFuZ2xlID0gYXJjUGFkQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgcixcbiAgICAgICAgcjAgPSAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgcjEgPSArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGExID0gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGZQaSxcbiAgICAgICAgZGEgPSBhYnMoYTEgLSBhMCksXG4gICAgICAgIGN3ID0gYTEgPiBhMDtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdXRlciByYWRpdXMgaXMgYWx3YXlzIGxhcmdlciB0aGFuIHRoZSBpbm5lciByYWRpdXMuXG4gICAgaWYgKHIxIDwgcjApIHIgPSByMSwgcjEgPSByMCwgcjAgPSByO1xuXG4gICAgLy8gSXMgaXQgYSBwb2ludD9cbiAgICBpZiAoIShyMSA+IGVwc2lsb24pKSBjb250ZXh0Lm1vdmVUbygwLCAwKTtcblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgZWxzZSBpZiAoZGEgPiB0YXUgLSBlcHNpbG9uKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAsIGExLCAhY3cpO1xuICAgICAgaWYgKHIwID4gZXBzaWxvbikge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMCAqIGNvcyhhMSksIHIwICogc2luKGExKSk7XG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMSwgYTAsIGN3KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPciBpcyBpdCBhIGNpcmN1bGFyIG9yIGFubnVsYXIgc2VjdG9yP1xuICAgIGVsc2Uge1xuICAgICAgdmFyIGEwMSA9IGEwLFxuICAgICAgICAgIGExMSA9IGExLFxuICAgICAgICAgIGEwMCA9IGEwLFxuICAgICAgICAgIGExMCA9IGExLFxuICAgICAgICAgIGRhMCA9IGRhLFxuICAgICAgICAgIGRhMSA9IGRhLFxuICAgICAgICAgIGFwID0gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAvIDIsXG4gICAgICAgICAgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLFxuICAgICAgICAgIHJjID0gbWluKGFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksXG4gICAgICAgICAgcmMwID0gcmMsXG4gICAgICAgICAgcmMxID0gcmMsXG4gICAgICAgICAgdDAsXG4gICAgICAgICAgdDE7XG5cbiAgICAgIC8vIEFwcGx5IHBhZGRpbmc/IE5vdGUgdGhhdCBzaW5jZSByMSDiiaUgcjAsIGRhMSDiiaUgZGEwLlxuICAgICAgaWYgKHJwID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgcDAgPSBhc2luKHJwIC8gcjAgKiBzaW4oYXApKSxcbiAgICAgICAgICAgIHAxID0gYXNpbihycCAvIHIxICogc2luKGFwKSk7XG4gICAgICAgIGlmICgoZGEwIC09IHAwICogMikgPiBlcHNpbG9uKSBwMCAqPSAoY3cgPyAxIDogLTEpLCBhMDAgKz0gcDAsIGExMCAtPSBwMDtcbiAgICAgICAgZWxzZSBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbikgcDEgKj0gKGN3ID8gMSA6IC0xKSwgYTAxICs9IHAxLCBhMTEgLT0gcDE7XG4gICAgICAgIGVsc2UgZGExID0gMCwgYTAxID0gYTExID0gKGEwICsgYTEpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHgwMSA9IHIxICogY29zKGEwMSksXG4gICAgICAgICAgeTAxID0gcjEgKiBzaW4oYTAxKSxcbiAgICAgICAgICB4MTAgPSByMCAqIGNvcyhhMTApLFxuICAgICAgICAgIHkxMCA9IHIwICogc2luKGExMCk7XG5cbiAgICAgIC8vIEFwcGx5IHJvdW5kZWQgY29ybmVycz9cbiAgICAgIGlmIChyYyA+IGVwc2lsb24pIHtcbiAgICAgICAgdmFyIHgxMSA9IHIxICogY29zKGExMSksXG4gICAgICAgICAgICB5MTEgPSByMSAqIHNpbihhMTEpLFxuICAgICAgICAgICAgeDAwID0gcjAgKiBjb3MoYTAwKSxcbiAgICAgICAgICAgIHkwMCA9IHIwICogc2luKGEwMCksXG4gICAgICAgICAgICBvYztcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkgJiYgKG9jID0gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSkpIHtcbiAgICAgICAgICB2YXIgYXggPSB4MDEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYXkgPSB5MDEgLSBvY1sxXSxcbiAgICAgICAgICAgICAgYnggPSB4MTEgLSBvY1swXSxcbiAgICAgICAgICAgICAgYnkgPSB5MTEgLSBvY1sxXSxcbiAgICAgICAgICAgICAga2MgPSAxIC8gc2luKGFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChzcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIHNxcnQoYnggKiBieCArIGJ5ICogYnkpKSkgLyAyKSxcbiAgICAgICAgICAgICAgbGMgPSBzcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBtaW4ocmMsIChyMSAtIGxjKSAvIChrYyArIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJcyB0aGUgc2VjdG9yIGNvbGxhcHNlZCB0byBhIGxpbmU/XG4gICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSkgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuXG4gICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIG91dGVyIHJpbmcgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5tb3ZlVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMSA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMSwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MS5jeCwgdDEuY3ksIHJjMSwgYXRhbjIodDEueTExLCB0MS54MTEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3IgaXMgdGhlIG91dGVyIHJpbmcganVzdCBhIGNpcmN1bGFyIGFyYz9cbiAgICAgIGVsc2UgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpLCBjb250ZXh0LmFyYygwLCAwLCByMSwgYTAxLCBhMTEsICFjdyk7XG5cbiAgICAgIC8vIElzIHRoZXJlIG5vIGlubmVyIHJpbmcsIGFuZCBpdOKAmXMgYSBjaXJjdWxhciBzZWN0b3I/XG4gICAgICAvLyBPciBwZXJoYXBzIGl04oCZcyBhbiBhbm51bGFyIHNlY3RvciBjb2xsYXBzZWQgZHVlIHRvIHBhZGRpbmc/XG4gICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBpbm5lciByaW5nIChvciBwb2ludCkgaGF2ZSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyh0MC5jeCArIHQwLngwMSwgdDAuY3kgKyB0MC55MDEpO1xuXG4gICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICBpZiAocmMwIDwgcmMpIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcblxuICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgdGhlIHR3byBjb3JuZXJzIGFuZCB0aGUgcmluZy5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCBjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzAsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBpbm5lciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQuYXJjKDAsIDAsIHIwLCBhMTAsIGEwMCwgY3cpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGFyYy5jZW50cm9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMixcbiAgICAgICAgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIHBpIC8gMjtcbiAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICB9O1xuXG4gIGFyYy5pbm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogaW5uZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG91dGVyUmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBvdXRlclJhZGl1cztcbiAgfTtcblxuICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5wYWRSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkUmFkaXVzID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogcGFkUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBhcmMpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJjO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmltcG9ydCBsaW5lIGZyb20gXCIuL2xpbmUuanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4MCwgeTAsIHkxKSB7XG4gIHZhciB4MSA9IG51bGwsXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIHgwID0gdHlwZW9mIHgwID09PSBcImZ1bmN0aW9uXCIgPyB4MCA6ICh4MCA9PT0gdW5kZWZpbmVkKSA/IHBvaW50WCA6IGNvbnN0YW50KCt4MCk7XG4gIHkwID0gdHlwZW9mIHkwID09PSBcImZ1bmN0aW9uXCIgPyB5MCA6ICh5MCA9PT0gdW5kZWZpbmVkKSA/IGNvbnN0YW50KDApIDogY29uc3RhbnQoK3kwKTtcbiAgeTEgPSB0eXBlb2YgeTEgPT09IFwiZnVuY3Rpb25cIiA/IHkxIDogKHkxID09PSB1bmRlZmluZWQpID8gcG9pbnRZIDogY29uc3RhbnQoK3kxKTtcblxuICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgbiA9IChkYXRhID0gYXJyYXkoZGF0YSkpLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHtcbiAgICAgICAgICBqID0gaTtcbiAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgIGZvciAoayA9IGkgLSAxOyBrID49IGo7IC0taykge1xuICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5lZDApIHtcbiAgICAgICAgeDB6W2ldID0gK3gwKGQsIGksIGRhdGEpLCB5MHpbaV0gPSAreTAoZCwgaSwgZGF0YSk7XG4gICAgICAgIG91dHB1dC5wb2ludCh4MSA/ICt4MShkLCBpLCBkYXRhKSA6IHgweltpXSwgeTEgPyAreTEoZCwgaSwgZGF0YSkgOiB5MHpbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChidWZmZXIpIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVhbGluZSgpIHtcbiAgICByZXR1cm4gbGluZSgpLmRlZmluZWQoZGVmaW5lZCkuY3VydmUoY3VydmUpLmNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeDEgPSBudWxsLCBhcmVhKSA6IHgwO1xuICB9O1xuXG4gIGFyZWEueDAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHgxO1xuICB9O1xuXG4gIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB5MSA9IG51bGwsIGFyZWEpIDogeTA7XG4gIH07XG5cbiAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTEgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTEgPSBfID09IG51bGwgPyBudWxsIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeTE7XG4gIH07XG5cbiAgYXJlYS5saW5lWDAgPVxuICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTApO1xuICB9O1xuXG4gIGFyZWEubGluZVkxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gIH07XG5cbiAgYXJlYS5saW5lWDEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgxKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgYXJlYSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGFyZWEuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBhcmVhLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGFyZWEpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gYXJlYTtcbn1cbiIsImV4cG9ydCB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm9iamVjdFwiICYmIFwibGVuZ3RoXCIgaW4geFxuICAgID8geCAvLyBBcnJheSwgVHlwZWRBcnJheSwgTm9kZUxpc3QsIGFycmF5LWxpa2VcbiAgICA6IEFycmF5LmZyb20oeCk7IC8vIE1hcCwgU2V0LCBpdGVyYWJsZSwgc3RyaW5nLCBvciBhbnl0aGluZyBlbHNlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbiBjb25zdGFudCgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICAoMiAqIHRoYXQuX3gwICsgdGhhdC5feDEpIC8gMyxcbiAgICAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyAyICogdGhhdC5feDEpIC8gMyxcbiAgICAodGhhdC5feTAgKyAyICogdGhhdC5feTEpIC8gMyxcbiAgICAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsXG4gICAgKHRoYXQuX3kwICsgNCAqIHRoYXQuX3kxICsgeSkgLyA2XG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2Jhc2lzLmpzXCI7XG5cbmZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbkJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oKHRoaXMuX3gyICsgMiAqIHRoaXMuX3gzKSAvIDMsICh0aGlzLl95MiArIDIgKiB0aGlzLl95MykgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oKHRoaXMuX3gzICsgMiAqIHRoaXMuX3gyKSAvIDMsICh0aGlzLl95MyArIDIgKiB0aGlzLl95MikgLyAzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MiA9IHgsIHRoaXMuX3kyID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5OyB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgQmFzaXNDbG9zZWQoY29udGV4dCk7XG59XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5mdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdmFyIHgwID0gKHRoaXMuX3gwICsgNCAqIHRoaXMuX3gxICsgeCkgLyA2LCB5MCA9ICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNjsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgwLCB5MCkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4MCwgeTApOyBicmVhaztcbiAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59XG4iLCJpbXBvcnQge0Jhc2lzfSBmcm9tIFwiLi9iYXNpcy5qc1wiO1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcblxuICBmdW5jdGlvbiBidW5kbGUoY29udGV4dCkge1xuICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgfVxuXG4gIGJ1bmRsZS5iZXRhID0gZnVuY3Rpb24oYmV0YSkge1xuICAgIHJldHVybiBjdXN0b20oK2JldGEpO1xuICB9O1xuXG4gIHJldHVybiBidW5kbGU7XG59KSgwLjg1KTtcbiIsImV4cG9ydCBmdW5jdGlvbiBwb2ludCh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHBvaW50KHRoaXMsIHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5feDEgPSB4LCB0aGlzLl95MSA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG5cbiAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhcmRpbmFsLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPSB0aGlzLl94NSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IHRoaXMuX3k1ID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkoMCk7XG4iLCJpbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXJkaW5hbC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2FyZGluYWxPcGVuKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxPcGVuLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcblxuICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gIH1cblxuICBjYXJkaW5hbC50ZW5zaW9uID0gZnVuY3Rpb24odGVuc2lvbikge1xuICAgIHJldHVybiBjdXN0b20oK3RlbnNpb24pO1xuICB9O1xuXG4gIHJldHVybiBjYXJkaW5hbDtcbn0pKDApO1xuIiwiaW1wb3J0IHtlcHNpbG9ufSBmcm9tIFwiLi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtDYXJkaW5hbH0gZnJvbSBcIi4vY2FyZGluYWwuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsQ2xvc2VkfSBmcm9tIFwiLi9jYXJkaW5hbENsb3NlZC5qc1wiO1xuaW1wb3J0IG5vb3AgZnJvbSBcIi4uL25vb3AuanNcIjtcbmltcG9ydCB7cG9pbnR9IGZyb20gXCIuL2NhdG11bGxSb20uanNcIjtcblxuZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogbm9vcCxcbiAgYXJlYUVuZDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuXG4gICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LFxuICAgICAgICAgIHkyMyA9IHRoaXMuX3kyIC0geTtcbiAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDUgPSB4LCB0aGlzLl95NSA9IHk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKDAuNSk7XG4iLCJpbXBvcnQge0NhcmRpbmFsT3Blbn0gZnJvbSBcIi4vY2FyZGluYWxPcGVuLmpzXCI7XG5pbXBvcnQge3BvaW50fSBmcm9tIFwiLi9jYXRtdWxsUm9tLmpzXCI7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21PcGVuKGNvbnRleHQsIGFscGhhKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9hbHBoYSA9IGFscGhhO1xufVxuXG5DYXRtdWxsUm9tT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDMpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMuX3BvaW50ID0gNDsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkgOiBuZXcgQ2FyZGluYWxPcGVuKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkoMC41KTtcbiIsImZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59XG4iLCJpbXBvcnQgbm9vcCBmcm9tIFwiLi4vbm9vcC5qc1wiO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBzbG9wZXMgb2YgdGhlIHRhbmdlbnRzIChIZXJtaXRlLXR5cGUgaW50ZXJwb2xhdGlvbikgYmFzZWQgb25cbi8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4vLyBJbnRlcnBvbGF0aW9uIGluIE9uZSBEaW1lbnNpb24uIEFzdHJvbm9teSBhbmQgQXN0cm9waHlzaWNzLCBWb2wuIDIzOSwgTk8uXG4vLyBOT1YoSUkpLCBQLiA0NDMsIDE5OTAuXG5mdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsXG4gICAgICBoMSA9IHgyIC0gdGhhdC5feDEsXG4gICAgICBzMCA9ICh0aGF0Ll95MSAtIHRoYXQuX3kwKSAvIChoMCB8fCBoMSA8IDAgJiYgLTApLFxuICAgICAgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSxcbiAgICAgIHAgPSAoczAgKiBoMSArIHMxICogaDApIC8gKGgwICsgaDEpO1xuICByZXR1cm4gKHNpZ24oczApICsgc2lnbihzMSkpICogTWF0aC5taW4oTWF0aC5hYnMoczApLCBNYXRoLmFicyhzMSksIDAuNSAqIE1hdGguYWJzKHApKSB8fCAwO1xufVxuXG4vLyBDYWxjdWxhdGUgYSBvbmUtc2lkZWQgc2xvcGUuXG5mdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbn1cblxuLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuLy8gXCJ5b3UgY2FuIGV4cHJlc3MgY3ViaWMgSGVybWl0ZSBpbnRlcnBvbGF0aW9uIGluIHRlcm1zIG9mIGN1YmljIELDqXppZXIgY3VydmVzXG4vLyB3aXRoIHJlc3BlY3QgdG8gdGhlIGZvdXIgdmFsdWVzIHAwLCBwMCArIG0wIC8gMywgcDEgLSBtMSAvIDMsIHAxXCIuXG5mdW5jdGlvbiBwb2ludCh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl90MCwgc2xvcGUyKHRoaXMsIHRoaXMuX3QwKSk7IGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciB0MSA9IE5hTjtcblxuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSkgcmV0dXJuOyAvLyBJZ25vcmUgY29pbmNpZGVudCBwb2ludHMuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyBwb2ludCh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcG9pbnQodGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIE1vbm90b25lWShjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBuZXcgUmVmbGVjdENvbnRleHQoY29udGV4dCk7XG59XG5cbihNb25vdG9uZVkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb25vdG9uZVgucHJvdG90eXBlKSkucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIE1vbm90b25lWC5wcm90b3R5cGUucG9pbnQuY2FsbCh0aGlzLCB5LCB4KTtcbn07XG5cbmZ1bmN0aW9uIFJlZmxlY3RDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cblJlZmxlY3RDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkgeyB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpOyB9LFxuICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5fY29udGV4dC5saW5lVG8oeSwgeCk7IH0sXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vbm90b25lWShjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgTW9ub3RvbmVZKGNvbnRleHQpO1xufVxuIiwiZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5OYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gW107XG4gICAgdGhpcy5feSA9IFtdO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHRoaXMuX3gsXG4gICAgICAgIHkgPSB0aGlzLl95LFxuICAgICAgICBuID0geC5sZW5ndGg7XG5cbiAgICBpZiAobikge1xuICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICBpZiAobiA9PT0gMikge1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzFdLCB5WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBweCA9IGNvbnRyb2xQb2ludHMoeCksXG4gICAgICAgICAgICBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8ocHhbMF1baTBdLCBweVswXVtpMF0sIHB4WzFdW2kwXSwgcHlbMV1baTBdLCB4W2kxXSwgeVtpMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgbiA9PT0gMSkpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLl94LnB1c2goK3gpO1xuICAgIHRoaXMuX3kucHVzaCgreSk7XG4gIH1cbn07XG5cbi8vIFNlZSBodHRwczovL3d3dy5wYXJ0aWNsZWluY2VsbC5jb20vMjAxMi9iZXppZXItc3BsaW5lcy8gZm9yIGRlcml2YXRpb24uXG5mdW5jdGlvbiBjb250cm9sUG9pbnRzKHgpIHtcbiAgdmFyIGksXG4gICAgICBuID0geC5sZW5ndGggLSAxLFxuICAgICAgbSxcbiAgICAgIGEgPSBuZXcgQXJyYXkobiksXG4gICAgICBiID0gbmV3IEFycmF5KG4pLFxuICAgICAgciA9IG5ldyBBcnJheShuKTtcbiAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSkgYVtpXSA9IDEsIGJbaV0gPSA0LCByW2ldID0gNCAqIHhbaV0gKyAyICogeFtpICsgMV07XG4gIGFbbiAtIDFdID0gMiwgYltuIC0gMV0gPSA3LCByW24gLSAxXSA9IDggKiB4W24gLSAxXSArIHhbbl07XG4gIGZvciAoaSA9IDE7IGkgPCBuOyArK2kpIG0gPSBhW2ldIC8gYltpIC0gMV0sIGJbaV0gLT0gbSwgcltpXSAtPSBtICogcltpIC0gMV07XG4gIGFbbiAtIDFdID0gcltuIC0gMV0gLyBiW24gLSAxXTtcbiAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgLS1pKSBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpIGJbaV0gPSAyICogeFtpICsgMV0gLSBhW2kgKyAxXTtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59XG4iLCJmdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGVwQmVmb3JlKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RlcEFmdGVyKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDEpO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGFycmF5IGZyb20gXCIuL2FycmF5LmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBjdXJ2ZUxpbmVhciBmcm9tIFwiLi9jdXJ2ZS9saW5lYXIuanNcIjtcbmltcG9ydCB7eCBhcyBwb2ludFgsIHkgYXMgcG9pbnRZfSBmcm9tIFwiLi9wb2ludC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIHggPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICh4ID09PSB1bmRlZmluZWQpID8gcG9pbnRYIDogY29uc3RhbnQoeCk7XG4gIHkgPSB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8geSA6ICh5ID09PSB1bmRlZmluZWQpID8gcG9pbnRZIDogY29uc3RhbnQoeSk7XG5cbiAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG4gPSAoZGF0YSA9IGFycmF5KGRhdGEpKS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IHBhdGgoKSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgZWxzZSBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSBvdXRwdXQucG9pbnQoK3goZCwgaSwgZGF0YSksICt5KGQsIGksIGRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluZSkgOiB4O1xuICB9O1xuXG4gIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeTtcbiAgfTtcblxuICBsaW5lLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVmaW5lZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgbGluZSkgOiBkZWZpbmVkO1xuICB9O1xuXG4gIGxpbmUuY3VydmUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgbGluZSkgOiBjdXJ2ZTtcbiAgfTtcblxuICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgfTtcblxuICByZXR1cm4gbGluZTtcbn1cbiIsImV4cG9ydCB2YXIgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcbmV4cG9ydCB2YXIgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbmV4cG9ydCB2YXIgZXBzaWxvbiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgdGF1ID0gMiAqIHBpO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHt9XG4iLCJleHBvcnQgZnVuY3Rpb24geChwKSB7XG4gIHJldHVybiBwWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24geShwKSB7XG4gIHJldHVybiBwWzFdO1xufVxuIiwiaW1wb3J0IHtwYXRofSBmcm9tIFwiZDMtcGF0aFwiO1xuaW1wb3J0IGNpcmNsZSBmcm9tIFwiLi9zeW1ib2wvY2lyY2xlLmpzXCI7XG5pbXBvcnQgY3Jvc3MgZnJvbSBcIi4vc3ltYm9sL2Nyb3NzLmpzXCI7XG5pbXBvcnQgZGlhbW9uZCBmcm9tIFwiLi9zeW1ib2wvZGlhbW9uZC5qc1wiO1xuaW1wb3J0IHN0YXIgZnJvbSBcIi4vc3ltYm9sL3N0YXIuanNcIjtcbmltcG9ydCBzcXVhcmUgZnJvbSBcIi4vc3ltYm9sL3NxdWFyZS5qc1wiO1xuaW1wb3J0IHRyaWFuZ2xlIGZyb20gXCIuL3N5bWJvbC90cmlhbmdsZS5qc1wiO1xuaW1wb3J0IHd5ZSBmcm9tIFwiLi9zeW1ib2wvd3llLmpzXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IHZhciBzeW1ib2xzID0gW1xuICBjaXJjbGUsXG4gIGNyb3NzLFxuICBkaWFtb25kLFxuICBzcXVhcmUsXG4gIHN0YXIsXG4gIHRyaWFuZ2xlLFxuICB3eWVcbl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgdmFyIGNvbnRleHQgPSBudWxsO1xuICB0eXBlID0gdHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IHR5cGUgOiBjb25zdGFudCh0eXBlIHx8IGNpcmNsZSk7XG4gIHNpemUgPSB0eXBlb2Ygc2l6ZSA9PT0gXCJmdW5jdGlvblwiID8gc2l6ZSA6IGNvbnN0YW50KHNpemUgPT09IHVuZGVmaW5lZCA/IDY0IDogK3NpemUpO1xuXG4gIGZ1bmN0aW9uIHN5bWJvbCgpIHtcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn1cbiIsImltcG9ydCB7cGksIHRhdX0gZnJvbSBcIi4uL21hdGguanNcIjtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuIiwiZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICBjb250ZXh0Lm1vdmVUbygtMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKDMgKiByLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKHIsIDMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtciwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICBjb250ZXh0LmxpbmVUbygtMyAqIHIsIHIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJ2YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLFxuICAgIHRhbjMwXzIgPSB0YW4zMCAqIDI7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcbiAgICAgICAgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG4iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSxcbiAgICAgICAgeCA9IC13IC8gMjtcbiAgICBjb250ZXh0LnJlY3QoeCwgeCwgdywgdyk7XG4gIH1cbn07XG4iLCJpbXBvcnQge3BpLCB0YXV9IGZyb20gXCIuLi9tYXRoLmpzXCI7XG5cbnZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTAsXG4gICAga3IgPSBNYXRoLnNpbihwaSAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSAvIDEwKSxcbiAgICBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyLFxuICAgIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplICoga2EpLFxuICAgICAgICB4ID0ga3ggKiByLFxuICAgICAgICB5ID0ga3kgKiByO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDU7ICsraSkge1xuICAgICAgdmFyIGEgPSB0YXUgKiBpIC8gNSxcbiAgICAgICAgICBjID0gTWF0aC5jb3MoYSksXG4gICAgICAgICAgcyA9IE1hdGguc2luKGEpO1xuICAgICAgY29udGV4dC5saW5lVG8ocyAqIHIsIC1jICogcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICB9XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcbiIsInZhciBzcXJ0MyA9IE1hdGguc3FydCgzKTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHkgPSAtTWF0aC5zcXJ0KHNpemUgLyAoc3FydDMgKiAzKSk7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgIGNvbnRleHQubGluZVRvKC1zcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmxpbmVUbyhzcXJ0MyAqIHksIC15KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwidmFyIGMgPSAtMC41LFxuICAgIHMgPSBNYXRoLnNxcnQoMykgLyAyLFxuICAgIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKSxcbiAgICBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gYSksXG4gICAgICAgIHgwID0gciAvIDIsXG4gICAgICAgIHkwID0gciAqIGssXG4gICAgICAgIHgxID0geDAsXG4gICAgICAgIHkxID0gciAqIGsgKyByLFxuICAgICAgICB4MiA9IC14MSxcbiAgICAgICAgeTIgPSB5MTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgY29udGV4dC5saW5lVG8oeDIsIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgLSBzICogeTAsIHMgKiB4MCArIGMgKiB5MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiAtIHMgKiB5MiwgcyAqIHgyICsgYyAqIHkyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDAgKyBzICogeTAsIGMgKiB5MCAtIHMgKiB4MCk7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MiArIHMgKiB5MiwgYyAqIHkyIC0gcyAqIHgyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuIiwiaW1wb3J0IGZvcm1hdExvY2FsZSBmcm9tIFwiLi9sb2NhbGUuanNcIjtcblxudmFyIGxvY2FsZTtcbmV4cG9ydCB2YXIgdGltZUZvcm1hdDtcbmV4cG9ydCB2YXIgdGltZVBhcnNlO1xuZXhwb3J0IHZhciB1dGNGb3JtYXQ7XG5leHBvcnQgdmFyIHV0Y1BhcnNlO1xuXG5kZWZhdWx0TG9jYWxlKHtcbiAgZGF0ZVRpbWU6IFwiJXgsICVYXCIsXG4gIGRhdGU6IFwiJS1tLyUtZC8lWVwiLFxuICB0aW1lOiBcIiUtSTolTTolUyAlcFwiLFxuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1wiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIl0sXG4gIHNob3J0TW9udGhzOiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgbG9jYWxlID0gZm9ybWF0TG9jYWxlKGRlZmluaXRpb24pO1xuICB0aW1lRm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgdGltZVBhcnNlID0gbG9jYWxlLnBhcnNlO1xuICB1dGNGb3JtYXQgPSBsb2NhbGUudXRjRm9ybWF0O1xuICB1dGNQYXJzZSA9IGxvY2FsZS51dGNQYXJzZTtcbiAgcmV0dXJuIGxvY2FsZTtcbn1cbiIsImltcG9ydCB7XG4gIHRpbWVEYXksXG4gIHRpbWVTdW5kYXksXG4gIHRpbWVNb25kYXksXG4gIHRpbWVUaHVyc2RheSxcbiAgdGltZVllYXIsXG4gIHV0Y0RheSxcbiAgdXRjU3VuZGF5LFxuICB1dGNNb25kYXksXG4gIHV0Y1RodXJzZGF5LFxuICB1dGNZZWFyXG59IGZyb20gXCJkMy10aW1lXCI7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld0RhdGUoeSwgbSwgZCkge1xuICByZXR1cm4ge3k6IHksIG06IG0sIGQ6IGQsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRNaWNyb3NlY29uZHMsXG4gICAgXCJnXCI6IGZvcm1hdFllYXJJU08sXG4gICAgXCJHXCI6IGZvcm1hdEZ1bGxZZWFySVNPLFxuICAgIFwiSFwiOiBmb3JtYXRIb3VyMjQsXG4gICAgXCJJXCI6IGZvcm1hdEhvdXIxMixcbiAgICBcImpcIjogZm9ybWF0RGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBmb3JtYXRNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IGZvcm1hdE1vbnRoTnVtYmVyLFxuICAgIFwiTVwiOiBmb3JtYXRNaW51dGVzLFxuICAgIFwicFwiOiBmb3JtYXRQZXJpb2QsXG4gICAgXCJxXCI6IGZvcm1hdFF1YXJ0ZXIsXG4gICAgXCJRXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXAsXG4gICAgXCJzXCI6IGZvcm1hdFVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBmb3JtYXRTZWNvbmRzLFxuICAgIFwidVwiOiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5LFxuICAgIFwiVVwiOiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBmb3JtYXRXZWVrTnVtYmVySVNPLFxuICAgIFwid1wiOiBmb3JtYXRXZWVrZGF5TnVtYmVyU3VuZGF5LFxuICAgIFwiV1wiOiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBudWxsLFxuICAgIFwiWFwiOiBudWxsLFxuICAgIFwieVwiOiBmb3JtYXRZZWFyLFxuICAgIFwiWVwiOiBmb3JtYXRGdWxsWWVhcixcbiAgICBcIlpcIjogZm9ybWF0Wm9uZSxcbiAgICBcIiVcIjogZm9ybWF0TGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICB2YXIgdXRjRm9ybWF0cyA9IHtcbiAgICBcImFcIjogZm9ybWF0VVRDU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBmb3JtYXRVVENXZWVrZGF5LFxuICAgIFwiYlwiOiBmb3JtYXRVVENTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBmb3JtYXRVVENNb250aCxcbiAgICBcImNcIjogbnVsbCxcbiAgICBcImRcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImVcIjogZm9ybWF0VVRDRGF5T2ZNb250aCxcbiAgICBcImZcIjogZm9ybWF0VVRDTWljcm9zZWNvbmRzLFxuICAgIFwiZ1wiOiBmb3JtYXRVVENZZWFySVNPLFxuICAgIFwiR1wiOiBmb3JtYXRVVENGdWxsWWVhcklTTyxcbiAgICBcIkhcIjogZm9ybWF0VVRDSG91cjI0LFxuICAgIFwiSVwiOiBmb3JtYXRVVENIb3VyMTIsXG4gICAgXCJqXCI6IGZvcm1hdFVUQ0RheU9mWWVhcixcbiAgICBcIkxcIjogZm9ybWF0VVRDTWlsbGlzZWNvbmRzLFxuICAgIFwibVwiOiBmb3JtYXRVVENNb250aE51bWJlcixcbiAgICBcIk1cIjogZm9ybWF0VVRDTWludXRlcyxcbiAgICBcInBcIjogZm9ybWF0VVRDUGVyaW9kLFxuICAgIFwicVwiOiBmb3JtYXRVVENRdWFydGVyLFxuICAgIFwiUVwiOiBmb3JtYXRVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBmb3JtYXRVbml4VGltZXN0YW1wU2Vjb25kcyxcbiAgICBcIlNcIjogZm9ybWF0VVRDU2Vjb25kcyxcbiAgICBcInVcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogZm9ybWF0VVRDV2Vla051bWJlclN1bmRheSxcbiAgICBcIlZcIjogZm9ybWF0VVRDV2Vla051bWJlcklTTyxcbiAgICBcIndcIjogZm9ybWF0VVRDV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogZm9ybWF0VVRDV2Vla051bWJlck1vbmRheSxcbiAgICBcInhcIjogbnVsbCxcbiAgICBcIlhcIjogbnVsbCxcbiAgICBcInlcIjogZm9ybWF0VVRDWWVhcixcbiAgICBcIllcIjogZm9ybWF0VVRDRnVsbFllYXIsXG4gICAgXCJaXCI6IGZvcm1hdFVUQ1pvbmUsXG4gICAgXCIlXCI6IGZvcm1hdExpdGVyYWxQZXJjZW50XG4gIH07XG5cbiAgdmFyIHBhcnNlcyA9IHtcbiAgICBcImFcIjogcGFyc2VTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IHBhcnNlV2Vla2RheSxcbiAgICBcImJcIjogcGFyc2VTaG9ydE1vbnRoLFxuICAgIFwiQlwiOiBwYXJzZU1vbnRoLFxuICAgIFwiY1wiOiBwYXJzZUxvY2FsZURhdGVUaW1lLFxuICAgIFwiZFwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJlXCI6IHBhcnNlRGF5T2ZNb250aCxcbiAgICBcImZcIjogcGFyc2VNaWNyb3NlY29uZHMsXG4gICAgXCJnXCI6IHBhcnNlWWVhcixcbiAgICBcIkdcIjogcGFyc2VGdWxsWWVhcixcbiAgICBcIkhcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJJXCI6IHBhcnNlSG91cjI0LFxuICAgIFwialwiOiBwYXJzZURheU9mWWVhcixcbiAgICBcIkxcIjogcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgXCJtXCI6IHBhcnNlTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IHBhcnNlTWludXRlcyxcbiAgICBcInBcIjogcGFyc2VQZXJpb2QsXG4gICAgXCJxXCI6IHBhcnNlUXVhcnRlcixcbiAgICBcIlFcIjogcGFyc2VVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJ1XCI6IHBhcnNlV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBwYXJzZVdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYWQsXG4gICAgICAgICAgZm9ybWF0O1xuXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcbiAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIFopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgZCA9IG5ld0RhdGUoMTkwMCwgdW5kZWZpbmVkLCAxKSxcbiAgICAgICAgICBpID0gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcgKz0gXCJcIiwgMCksXG4gICAgICAgICAgd2VlaywgZGF5O1xuICAgICAgaWYgKGkgIT0gc3RyaW5nLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIElmIGEgVU5JWCB0aW1lc3RhbXAgaXMgc3BlY2lmaWVkLCByZXR1cm4gaXQuXG4gICAgICBpZiAoXCJRXCIgaW4gZCkgcmV0dXJuIG5ldyBEYXRlKGQuUSk7XG4gICAgICBpZiAoXCJzXCIgaW4gZCkgcmV0dXJuIG5ldyBEYXRlKGQucyAqIDEwMDAgKyAoXCJMXCIgaW4gZCA/IGQuTCA6IDApKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyB1dGNQYXJzZSwgbmV2ZXIgdXNlIHRoZSBsb2NhbCB0aW1lem9uZS5cbiAgICAgIGlmIChaICYmICEoXCJaXCIgaW4gZCkpIGQuWiA9IDA7XG5cbiAgICAgIC8vIFRoZSBhbS1wbSBmbGFnIGlzIDAgZm9yIEFNLCBhbmQgMSBmb3IgUE0uXG4gICAgICBpZiAoXCJwXCIgaW4gZCkgZC5IID0gZC5IICUgMTIgKyBkLnAgKiAxMjtcblxuICAgICAgLy8gSWYgdGhlIG1vbnRoIHdhcyBub3Qgc3BlY2lmaWVkLCBpbmhlcml0IGZyb20gdGhlIHF1YXJ0ZXIuXG4gICAgICBpZiAoZC5tID09PSB1bmRlZmluZWQpIGQubSA9IFwicVwiIGluIGQgPyBkLnEgOiAwO1xuXG4gICAgICAvLyBDb252ZXJ0IGRheS1vZi13ZWVrIGFuZCB3ZWVrLW9mLXllYXIgdG8gZGF5LW9mLXllYXIuXG4gICAgICBpZiAoXCJWXCIgaW4gZCkge1xuICAgICAgICBpZiAoZC5WIDwgMSB8fCBkLlYgPiA1MykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSAxO1xuICAgICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICAgIHdlZWsgPSB1dGNEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSksIGRheSA9IHdlZWsuZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgd2VlayA9IGRheSA+IDQgfHwgZGF5ID09PSAwID8gdXRjTW9uZGF5LmNlaWwod2VlaykgOiB1dGNNb25kYXkod2Vlayk7XG4gICAgICAgICAgd2VlayA9IHV0Y0RheS5vZmZzZXQod2VlaywgKGQuViAtIDEpICogNyk7XG4gICAgICAgICAgZC55ID0gd2Vlay5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgIGQubSA9IHdlZWsuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICBkLmQgPSB3ZWVrLmdldFVUQ0RhdGUoKSArIChkLncgKyA2KSAlIDc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2VlayA9IGxvY2FsRGF0ZShuZXdEYXRlKGQueSwgMCwgMSkpLCBkYXkgPSB3ZWVrLmdldERheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IHRpbWVNb25kYXkuY2VpbCh3ZWVrKSA6IHRpbWVNb25kYXkod2Vlayk7XG4gICAgICAgICAgd2VlayA9IHRpbWVEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldE1vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXREYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJ1XCIgaW4gZCA/IGQudSAlIDcgOiBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIGRheSA9IFwiWlwiIGluIGQgPyB1dGNEYXRlKG5ld0RhdGUoZC55LCAwLCAxKSkuZ2V0VVRDRGF5KCkgOiBsb2NhbERhdGUobmV3RGF0ZShkLnksIDAsIDEpKS5nZXREYXkoKTtcbiAgICAgICAgZC5tID0gMDtcbiAgICAgICAgZC5kID0gXCJXXCIgaW4gZCA/IChkLncgKyA2KSAlIDcgKyBkLlcgKiA3IC0gKGRheSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF5ICsgNikgJSA3O1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIHRpbWUgem9uZSBpcyBzcGVjaWZpZWQsIGFsbCBmaWVsZHMgYXJlIGludGVycHJldGVkIGFzIFVUQyBhbmQgdGhlblxuICAgICAgLy8gb2Zmc2V0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIHRpbWUgem9uZS5cbiAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgIGQuSCArPSBkLlogLyAxMDAgfCAwO1xuICAgICAgICBkLk0gKz0gZC5aICUgMTAwO1xuICAgICAgICByZXR1cm4gdXRjRGF0ZShkKTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBhbGwgZmllbGRzIGFyZSBpbiBsb2NhbCB0aW1lLlxuICAgICAgcmV0dXJuIGxvY2FsRGF0ZShkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTcGVjaWZpZXIoZCwgc3BlY2lmaWVyLCBzdHJpbmcsIGopIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIG4gPSBzcGVjaWZpZXIubGVuZ3RoLFxuICAgICAgICBtID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgYyxcbiAgICAgICAgcGFyc2U7XG5cbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckNvZGVBdChpKyspO1xuICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgIGMgPSBzcGVjaWZpZXIuY2hhckF0KGkrKyk7XG4gICAgICAgIHBhcnNlID0gcGFyc2VzW2MgaW4gcGFkcyA/IHNwZWNpZmllci5jaGFyQXQoaSsrKSA6IGNdO1xuICAgICAgICBpZiAoIXBhcnNlIHx8ICgoaiA9IHBhcnNlKGQsIHN0cmluZywgaikpIDwgMCkpIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyaW9kKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gcGVyaW9kUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQucCA9IHBlcmlvZExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydFdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBzaG9ydFdlZWtkYXlSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC53ID0gc2hvcnRXZWVrZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IHNob3J0TW9udGhSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5tID0gc2hvcnRNb250aExvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgICB2YXIgbiA9IG1vbnRoUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQubSA9IG1vbnRoTG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFF1YXJ0ZXIoZCkge1xuICAgIHJldHVybiAxICsgfn4oZC5nZXRNb250aCgpIC8gMyk7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydFdlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRXZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtkYXkoZCkge1xuICAgIHJldHVybiBsb2NhbGVfd2Vla2RheXNbZC5nZXRVVENEYXkoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENTaG9ydE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3Nob3J0TW9udGhzW2QuZ2V0VVRDTW9udGgoKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENNb250aChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9tb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1BlcmlvZChkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9wZXJpb2RzWysoZC5nZXRVVENIb3VycygpID49IDEyKV07XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRVVENRdWFydGVyKGQpIHtcbiAgICByZXR1cm4gMSArIH5+KGQuZ2V0VVRDTW9udGgoKSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmb3JtYXQ6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIGYgPSBuZXdGb3JtYXQoc3BlY2lmaWVyICs9IFwiXCIsIGZvcm1hdHMpO1xuICAgICAgZi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgcCA9IG5ld1BhcnNlKHNwZWNpZmllciArPSBcIlwiLCBmYWxzZSk7XG4gICAgICBwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuICAgIHV0Y0Zvcm1hdDogZnVuY3Rpb24oc3BlY2lmaWVyKSB7XG4gICAgICB2YXIgZiA9IG5ld0Zvcm1hdChzcGVjaWZpZXIgKz0gXCJcIiwgdXRjRm9ybWF0cyk7XG4gICAgICBmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBzcGVjaWZpZXI7IH07XG4gICAgICByZXR1cm4gZjtcbiAgICB9LFxuICAgIHV0Y1BhcnNlOiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBwID0gbmV3UGFyc2Uoc3BlY2lmaWVyICs9IFwiXCIsIHRydWUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9LFxuICAgIG51bWJlclJlID0gL15cXHMqXFxkKy8sIC8vIG5vdGU6IGlnbm9yZXMgbmV4dCBkaXJlY3RpdmVcbiAgICBwZXJjZW50UmUgPSAvXiUvLFxuICAgIHJlcXVvdGVSZSA9IC9bXFxcXF4kKis/fFtcXF0oKS57fV0vZztcblxuZnVuY3Rpb24gcGFkKHZhbHVlLCBmaWxsLCB3aWR0aCkge1xuICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIixcbiAgICAgIHN0cmluZyA9IChzaWduID8gLXZhbHVlIDogdmFsdWUpICsgXCJcIixcbiAgICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG59XG5cbmZ1bmN0aW9uIHJlcXVvdGUocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHJlcXVvdGVSZSwgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJlKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKHJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TG9va3VwKG5hbWVzKSB7XG4gIHJldHVybiBuZXcgTWFwKG5hbWVzLm1hcCgobmFtZSwgaSkgPT4gW25hbWUudG9Mb3dlckNhc2UoKSwgaV0pKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5TnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQudyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLnUgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJTdW5kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5VID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVySVNPKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuViA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlck1vbmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlcgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ1bGxZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA0KSk7XG4gIHJldHVybiBuID8gKGQueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSArICgrblswXSA+IDY4ID8gMTkwMCA6IDIwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlWm9uZShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSAvXihaKXwoWystXVxcZFxcZCkoPzo6PyhcXGRcXGQpKT8vLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuWiA9IG5bMV0gPyAwIDogLShuWzJdICsgKG5bM10gfHwgXCIwMFwiKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWFydGVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gKGQucSA9IG5bMF0gKiAzIC0gMywgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoTnVtYmVyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQubSA9IG5bMF0gLSAxLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZNb250aChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZURheU9mWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICByZXR1cm4gbiA/IChkLm0gPSAwLCBkLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZUhvdXIyNChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLkggPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1pbnV0ZXMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuUyA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWlsbGlzZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQuTCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWljcm9zZWNvbmRzKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyA2KSk7XG4gIHJldHVybiBuID8gKGQuTCA9IE1hdGguZmxvb3IoblswXSAvIDEwMDApLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTGl0ZXJhbFBlcmNlbnQoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gIHJldHVybiBuID8gaSArIG5bMF0ubGVuZ3RoIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuUSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5peFRpbWVzdGFtcFNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICByZXR1cm4gbiA/IChkLnMgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREYXlPZk1vbnRoKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldERhdGUoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhvdXIyNChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjEyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoMSArIHRpbWVEYXkuY291bnQodGltZVllYXIoZCksIGQpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWlsbGlzZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWljcm9zZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSArIFwiMDAwXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoTnVtYmVyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TWludXRlcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaW51dGVzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWNvbmRzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXkoZCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgcmV0dXJuIGRheSA9PT0gMCA/IDcgOiBkYXk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJTdW5kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHRpbWVTdW5kYXkuY291bnQodGltZVllYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGRJU08oZCkge1xuICB2YXIgZGF5ID0gZC5nZXREYXkoKTtcbiAgcmV0dXJuIChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gdGltZVRodXJzZGF5KGQpIDogdGltZVRodXJzZGF5LmNlaWwoZCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtOdW1iZXJJU08oZCwgcCkge1xuICBkID0gZElTTyhkKTtcbiAgcmV0dXJuIHBhZCh0aW1lVGh1cnNkYXkuY291bnQodGltZVllYXIoZCksIGQpICsgKHRpbWVZZWFyKGQpLmdldERheSgpID09PSA0KSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXkoZCkge1xuICByZXR1cm4gZC5nZXREYXkoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlck1vbmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQodGltZU1vbmRheS5jb3VudCh0aW1lWWVhcihkKSAtIDEsIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcklTTyhkLCBwKSB7XG4gIGQgPSBkSVNPKGQpO1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEZ1bGxZZWFyKCkgJSAxMDAwMCwgcCwgNCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEZ1bGxZZWFySVNPKGQsIHApIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIGQgPSAoZGF5ID49IDQgfHwgZGF5ID09PSAwKSA/IHRpbWVUaHVyc2RheShkKSA6IHRpbWVUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyB1dGNEYXkuY291bnQodXRjWWVhcihkKSwgZCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIHAsIDMpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaWNyb3NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gZm9ybWF0VVRDTWlsbGlzZWNvbmRzKGQsIHApICsgXCIwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDTW9udGhOdW1iZXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNaW51dGVzKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ01pbnV0ZXMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1NlY29uZHMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDU2Vjb25kcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheU51bWJlck1vbmRheShkKSB7XG4gIHZhciBkb3cgPSBkLmdldFVUQ0RheSgpO1xuICByZXR1cm4gZG93ID09PSAwID8gNyA6IGRvdztcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDV2Vla051bWJlclN1bmRheShkLCBwKSB7XG4gIHJldHVybiBwYWQodXRjU3VuZGF5LmNvdW50KHV0Y1llYXIoZCkgLSAxLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIFVUQ2RJU08oZCkge1xuICB2YXIgZGF5ID0gZC5nZXRVVENEYXkoKTtcbiAgcmV0dXJuIChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gdXRjVGh1cnNkYXkoZCkgOiB1dGNUaHVyc2RheS5jZWlsKGQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVySVNPKGQsIHApIHtcbiAgZCA9IFVUQ2RJU08oZCk7XG4gIHJldHVybiBwYWQodXRjVGh1cnNkYXkuY291bnQodXRjWWVhcihkKSwgZCkgKyAodXRjWWVhcihkKS5nZXRVVENEYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKHV0Y01vbmRheS5jb3VudCh1dGNZZWFyKGQpIC0gMSwgZCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldFVUQ0Z1bGxZZWFyKCkgJSAxMDAsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENZZWFySVNPKGQsIHApIHtcbiAgZCA9IFVUQ2RJU08oZCk7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXRVVENEYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gdXRjVGh1cnNkYXkoZCkgOiB1dGNUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgcmV0dXJuIFwiKzAwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gIHJldHVybiBcIiVcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcChkKSB7XG4gIHJldHVybiArZDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMoZCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigrZCAvIDEwMDApO1xufVxuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uRGF5LCBkdXJhdGlvbk1pbnV0ZX0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIGRheSA9IGludGVydmFsKFxuICBkYXRlID0+IGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCksXG4gIChkYXRlLCBzdGVwKSA9PiBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyBzdGVwKSxcbiAgKHN0YXJ0LCBlbmQpID0+IChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25EYXksXG4gIGRhdGUgPT4gZGF0ZS5nZXREYXRlKCkgLSAxXG4pO1xuXG5leHBvcnQgZGVmYXVsdCBkYXk7XG5leHBvcnQgdmFyIGRheXMgPSBkYXkucmFuZ2U7XG4iLCJleHBvcnQgY29uc3QgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbmV4cG9ydCBjb25zdCBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG5leHBvcnQgY29uc3QgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uSG91ciwgZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uU2Vjb25kfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuXG52YXIgaG91ciA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRUaW1lKGRhdGUgLSBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC0gZGF0ZS5nZXRTZWNvbmRzKCkgKiBkdXJhdGlvblNlY29uZCAtIGRhdGUuZ2V0TWludXRlcygpICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25Ib3VyKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkhvdXI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaG91cjtcbmV4cG9ydCB2YXIgaG91cnMgPSBob3VyLnJhbmdlO1xuIiwidmFyIHQwID0gbmV3IERhdGUsXG4gICAgdDEgPSBuZXcgRGF0ZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbmV3SW50ZXJ2YWwoZmxvb3JpLCBvZmZzZXRpLCBjb3VudCwgZmllbGQpIHtcblxuICBmdW5jdGlvbiBpbnRlcnZhbChkYXRlKSB7XG4gICAgcmV0dXJuIGZsb29yaShkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCA/IG5ldyBEYXRlIDogbmV3IERhdGUoK2RhdGUpKSwgZGF0ZTtcbiAgfVxuXG4gIGludGVydmFsLmZsb29yID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwuY2VpbCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZShkYXRlIC0gMSkpLCBvZmZzZXRpKGRhdGUsIDEpLCBmbG9vcmkoZGF0ZSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucm91bmQgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgdmFyIGQwID0gaW50ZXJ2YWwoZGF0ZSksXG4gICAgICAgIGQxID0gaW50ZXJ2YWwuY2VpbChkYXRlKTtcbiAgICByZXR1cm4gZGF0ZSAtIGQwIDwgZDEgLSBkYXRlID8gZDAgOiBkMTtcbiAgfTtcblxuICBpbnRlcnZhbC5vZmZzZXQgPSBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgcmV0dXJuIG9mZnNldGkoZGF0ZSA9IG5ldyBEYXRlKCtkYXRlKSwgc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCkpLCBkYXRlO1xuICB9O1xuXG4gIGludGVydmFsLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICB2YXIgcmFuZ2UgPSBbXSwgcHJldmlvdXM7XG4gICAgc3RhcnQgPSBpbnRlcnZhbC5jZWlsKHN0YXJ0KTtcbiAgICBzdGVwID0gc3RlcCA9PSBudWxsID8gMSA6IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgaWYgKCEoc3RhcnQgPCBzdG9wKSB8fCAhKHN0ZXAgPiAwKSkgcmV0dXJuIHJhbmdlOyAvLyBhbHNvIGhhbmRsZXMgSW52YWxpZCBEYXRlXG4gICAgZG8gcmFuZ2UucHVzaChwcmV2aW91cyA9IG5ldyBEYXRlKCtzdGFydCkpLCBvZmZzZXRpKHN0YXJ0LCBzdGVwKSwgZmxvb3JpKHN0YXJ0KTtcbiAgICB3aGlsZSAocHJldmlvdXMgPCBzdGFydCAmJiBzdGFydCA8IHN0b3ApO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICBpbnRlcnZhbC5maWx0ZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG4gICAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHdoaWxlIChmbG9vcmkoZGF0ZSksICF0ZXN0KGRhdGUpKSBkYXRlLnNldFRpbWUoZGF0ZSAtIDEpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICAgIGlmIChkYXRlID49IGRhdGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKytzdGVwIDw9IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCAtMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gZWxzZSB3aGlsZSAoLS1zdGVwID49IDApIHtcbiAgICAgICAgICB3aGlsZSAob2Zmc2V0aShkYXRlLCArMSksICF0ZXN0KGRhdGUpKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBpZiAoY291bnQpIHtcbiAgICBpbnRlcnZhbC5jb3VudCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHQwLnNldFRpbWUoK3N0YXJ0KSwgdDEuc2V0VGltZSgrZW5kKTtcbiAgICAgIGZsb29yaSh0MCksIGZsb29yaSh0MSk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihjb3VudCh0MCwgdDEpKTtcbiAgICB9O1xuXG4gICAgaW50ZXJ2YWwuZXZlcnkgPSBmdW5jdGlvbihzdGVwKSB7XG4gICAgICBzdGVwID0gTWF0aC5mbG9vcihzdGVwKTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUoc3RlcCkgfHwgIShzdGVwID4gMCkgPyBudWxsXG4gICAgICAgICAgOiAhKHN0ZXAgPiAxKSA/IGludGVydmFsXG4gICAgICAgICAgOiBpbnRlcnZhbC5maWx0ZXIoZmllbGRcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbihkKSB7IHJldHVybiBmaWVsZChkKSAlIHN0ZXAgPT09IDA7IH1cbiAgICAgICAgICAgICAgOiBmdW5jdGlvbihkKSB7IHJldHVybiBpbnRlcnZhbC5jb3VudCgwLCBkKSAlIHN0ZXAgPT09IDA7IH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJ2YWw7XG59XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcblxudmFyIG1pbGxpc2Vjb25kID0gaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gIC8vIG5vb3Bcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG5taWxsaXNlY29uZC5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICBpZiAoIShrID4gMSkpIHJldHVybiBtaWxsaXNlY29uZDtcbiAgcmV0dXJuIGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBrKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gaztcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtaWxsaXNlY29uZDtcbmV4cG9ydCB2YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uU2Vjb25kfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuXG52YXIgbWludXRlID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoZGF0ZSAtIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLSBkYXRlLmdldFNlY29uZHMoKSAqIGR1cmF0aW9uU2Vjb25kKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uTWludXRlKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbk1pbnV0ZTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1pbnV0ZTtcbmV4cG9ydCB2YXIgbWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuXG52YXIgbW9udGggPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbW9udGg7XG5leHBvcnQgdmFyIG1vbnRocyA9IG1vbnRoLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uU2Vjb25kfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuXG52YXIgc2Vjb25kID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoZGF0ZSAtIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uU2Vjb25kO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2Vjb25kO1xuZXhwb3J0IHZhciBzZWNvbmRzID0gc2Vjb25kLnJhbmdlO1xuIiwiaW1wb3J0IHtiaXNlY3RvciwgdGlja1N0ZXB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtkdXJhdGlvbkRheSwgZHVyYXRpb25Ib3VyLCBkdXJhdGlvbk1pbnV0ZSwgZHVyYXRpb25Nb250aCwgZHVyYXRpb25TZWNvbmQsIGR1cmF0aW9uV2VlaywgZHVyYXRpb25ZZWFyfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IG1pbGxpc2Vjb25kIGZyb20gXCIuL21pbGxpc2Vjb25kLmpzXCI7XG5pbXBvcnQgc2Vjb25kIGZyb20gXCIuL3NlY29uZC5qc1wiO1xuaW1wb3J0IG1pbnV0ZSBmcm9tIFwiLi9taW51dGUuanNcIjtcbmltcG9ydCBob3VyIGZyb20gXCIuL2hvdXIuanNcIjtcbmltcG9ydCBkYXkgZnJvbSBcIi4vZGF5LmpzXCI7XG5pbXBvcnQge3N1bmRheSBhcyB3ZWVrfSBmcm9tIFwiLi93ZWVrLmpzXCI7XG5pbXBvcnQgbW9udGggZnJvbSBcIi4vbW9udGguanNcIjtcbmltcG9ydCB5ZWFyIGZyb20gXCIuL3llYXIuanNcIjtcbmltcG9ydCB1dGNNaW51dGUgZnJvbSBcIi4vdXRjTWludXRlLmpzXCI7XG5pbXBvcnQgdXRjSG91ciBmcm9tIFwiLi91dGNIb3VyLmpzXCI7XG5pbXBvcnQgdXRjRGF5IGZyb20gXCIuL3V0Y0RheS5qc1wiO1xuaW1wb3J0IHt1dGNTdW5kYXkgYXMgdXRjV2Vla30gZnJvbSBcIi4vdXRjV2Vlay5qc1wiO1xuaW1wb3J0IHV0Y01vbnRoIGZyb20gXCIuL3V0Y01vbnRoLmpzXCI7XG5pbXBvcnQgdXRjWWVhciBmcm9tIFwiLi91dGNZZWFyLmpzXCI7XG5cbmZ1bmN0aW9uIHRpY2tlcih5ZWFyLCBtb250aCwgd2VlaywgZGF5LCBob3VyLCBtaW51dGUpIHtcblxuICBjb25zdCB0aWNrSW50ZXJ2YWxzID0gW1xuICAgIFtzZWNvbmQsICAxLCAgICAgIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAgNSwgIDUgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDMwLCAzMCAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbbWludXRlLCAgMSwgICAgICBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgIDUsICA1ICogZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAzMCwgMzAgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgWyAgaG91ciwgIDEsICAgICAgZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsICAzLCAgMyAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgNiwgIDYgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgMTIsIDEyICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgICBkYXksICAxLCAgICAgIGR1cmF0aW9uRGF5ICAgXSxcbiAgICBbICAgZGF5LCAgMiwgIDIgKiBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgd2VlaywgIDEsICAgICAgZHVyYXRpb25XZWVrICBdLFxuICAgIFsgbW9udGgsICAxLCAgICAgIGR1cmF0aW9uTW9udGggXSxcbiAgICBbIG1vbnRoLCAgMywgIDMgKiBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyAgeWVhciwgIDEsICAgICAgZHVyYXRpb25ZZWFyICBdXG4gIF07XG5cbiAgZnVuY3Rpb24gdGlja3Moc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgY29uc3QgcmV2ZXJzZSA9IHN0b3AgPCBzdGFydDtcbiAgICBpZiAocmV2ZXJzZSkgW3N0YXJ0LCBzdG9wXSA9IFtzdG9wLCBzdGFydF07XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBjb3VudCAmJiB0eXBlb2YgY291bnQucmFuZ2UgPT09IFwiZnVuY3Rpb25cIiA/IGNvdW50IDogdGlja0ludGVydmFsKHN0YXJ0LCBzdG9wLCBjb3VudCk7XG4gICAgY29uc3QgdGlja3MgPSBpbnRlcnZhbCA/IGludGVydmFsLnJhbmdlKHN0YXJ0LCArc3RvcCArIDEpIDogW107IC8vIGluY2x1c2l2ZSBzdG9wXG4gICAgcmV0dXJuIHJldmVyc2UgPyB0aWNrcy5yZXZlcnNlKCkgOiB0aWNrcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBNYXRoLmFicyhzdG9wIC0gc3RhcnQpIC8gY291bnQ7XG4gICAgY29uc3QgaSA9IGJpc2VjdG9yKChbLCwgc3RlcF0pID0+IHN0ZXApLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgaWYgKGkgPT09IHRpY2tJbnRlcnZhbHMubGVuZ3RoKSByZXR1cm4geWVhci5ldmVyeSh0aWNrU3RlcChzdGFydCAvIGR1cmF0aW9uWWVhciwgc3RvcCAvIGR1cmF0aW9uWWVhciwgY291bnQpKTtcbiAgICBpZiAoaSA9PT0gMCkgcmV0dXJuIG1pbGxpc2Vjb25kLmV2ZXJ5KE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCksIDEpKTtcbiAgICBjb25zdCBbdCwgc3RlcF0gPSB0aWNrSW50ZXJ2YWxzW3RhcmdldCAvIHRpY2tJbnRlcnZhbHNbaSAtIDFdWzJdIDwgdGlja0ludGVydmFsc1tpXVsyXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgcmV0dXJuIHQuZXZlcnkoc3RlcCk7XG4gIH1cblxuICByZXR1cm4gW3RpY2tzLCB0aWNrSW50ZXJ2YWxdO1xufVxuXG5jb25zdCBbdXRjVGlja3MsIHV0Y1RpY2tJbnRlcnZhbF0gPSB0aWNrZXIodXRjWWVhciwgdXRjTW9udGgsIHV0Y1dlZWssIHV0Y0RheSwgdXRjSG91ciwgdXRjTWludXRlKTtcbmNvbnN0IFt0aW1lVGlja3MsIHRpbWVUaWNrSW50ZXJ2YWxdID0gdGlja2VyKHllYXIsIG1vbnRoLCB3ZWVrLCBkYXksIGhvdXIsIG1pbnV0ZSk7XG5cbmV4cG9ydCB7dXRjVGlja3MsIHV0Y1RpY2tJbnRlcnZhbCwgdGltZVRpY2tzLCB0aW1lVGlja0ludGVydmFsfTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbkRheX0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIHV0Y0RheSA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25EYXk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldFVUQ0RhdGUoKSAtIDE7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjRGF5O1xuZXhwb3J0IHZhciB1dGNEYXlzID0gdXRjRGF5LnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQge2R1cmF0aW9uSG91cn0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIHV0Y0hvdXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VVRDTWludXRlcygwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENIb3VycygpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHV0Y0hvdXI7XG5leHBvcnQgdmFyIHV0Y0hvdXJzID0gdXRjSG91ci5yYW5nZTtcbiIsImltcG9ydCBpbnRlcnZhbCBmcm9tIFwiLi9pbnRlcnZhbC5qc1wiO1xuaW1wb3J0IHtkdXJhdGlvbk1pbnV0ZX0gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxudmFyIHV0Y01pbnV0ZSA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdXRjTWludXRlO1xuZXhwb3J0IHZhciB1dGNNaW51dGVzID0gdXRjTWludXRlLnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciB1dGNNb250aCA9IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1dGNNb250aDtcbmV4cG9ydCB2YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25XZWVrfSBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuXG5mdW5jdGlvbiB1dGNXZWVrZGF5KGkpIHtcbiAgcmV0dXJuIGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgLSAoZGF0ZS5nZXRVVENEYXkoKSArIDcgLSBpKSAlIDcpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwICogNyk7XG4gIH0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uV2VlaztcbiAgfSk7XG59XG5cbmV4cG9ydCB2YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbmV4cG9ydCB2YXIgdXRjTW9uZGF5ID0gdXRjV2Vla2RheSgxKTtcbmV4cG9ydCB2YXIgdXRjVHVlc2RheSA9IHV0Y1dlZWtkYXkoMik7XG5leHBvcnQgdmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG5leHBvcnQgdmFyIHV0Y1RodXJzZGF5ID0gdXRjV2Vla2RheSg0KTtcbmV4cG9ydCB2YXIgdXRjRnJpZGF5ID0gdXRjV2Vla2RheSg1KTtcbmV4cG9ydCB2YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG5leHBvcnQgdmFyIHV0Y1N1bmRheXMgPSB1dGNTdW5kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y01vbmRheXMgPSB1dGNNb25kYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdXRjV2VkbmVzZGF5cyA9IHV0Y1dlZG5lc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgdXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG5leHBvcnQgdmFyIHV0Y1NhdHVyZGF5cyA9IHV0Y1NhdHVyZGF5LnJhbmdlO1xuIiwiaW1wb3J0IGludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5cbnZhciB1dGNZZWFyID0gaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnV0Y1llYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IGludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB1dGNZZWFyO1xuZXhwb3J0IHZhciB1dGNZZWFycyA9IHV0Y1llYXIucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcbmltcG9ydCB7ZHVyYXRpb25NaW51dGUsIGR1cmF0aW9uV2Vla30gZnJvbSBcIi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxuZXhwb3J0IHZhciBzdW5kYXkgPSB3ZWVrZGF5KDApO1xuZXhwb3J0IHZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xuZXhwb3J0IHZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbmV4cG9ydCB2YXIgd2VkbmVzZGF5ID0gd2Vla2RheSgzKTtcbmV4cG9ydCB2YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xuZXhwb3J0IHZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xuZXhwb3J0IHZhciBzYXR1cmRheSA9IHdlZWtkYXkoNik7XG5cbmV4cG9ydCB2YXIgc3VuZGF5cyA9IHN1bmRheS5yYW5nZTtcbmV4cG9ydCB2YXIgbW9uZGF5cyA9IG1vbmRheS5yYW5nZTtcbmV4cG9ydCB2YXIgdHVlc2RheXMgPSB0dWVzZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB3ZWRuZXNkYXlzID0gd2VkbmVzZGF5LnJhbmdlO1xuZXhwb3J0IHZhciB0aHVyc2RheXMgPSB0aHVyc2RheS5yYW5nZTtcbmV4cG9ydCB2YXIgZnJpZGF5cyA9IGZyaWRheS5yYW5nZTtcbmV4cG9ydCB2YXIgc2F0dXJkYXlzID0gc2F0dXJkYXkucmFuZ2U7XG4iLCJpbXBvcnQgaW50ZXJ2YWwgZnJvbSBcIi4vaW50ZXJ2YWwuanNcIjtcblxudmFyIHllYXIgPSBpbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCk7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCk7XG59KTtcblxuLy8gQW4gb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGZvciB0aGlzIHNpbXBsZSBjYXNlLlxueWVhci5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgcmV0dXJuICFpc0Zpbml0ZShrID0gTWF0aC5mbG9vcihrKSkgfHwgIShrID4gMCkgPyBudWxsIDogaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoTWF0aC5mbG9vcihkYXRlLmdldEZ1bGxZZWFyKCkgLyBrKSAqIGspO1xuICAgIGRhdGUuc2V0TW9udGgoMCwgMSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0RnVsbFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpICsgc3RlcCAqIGspO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHllYXI7XG5leHBvcnQgdmFyIHllYXJzID0geWVhci5yYW5nZTtcbiIsImltcG9ydCB7VGltZXIsIG5vd30gZnJvbSBcIi4vdGltZXIuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2ssIGRlbGF5LCB0aW1lKSB7XG4gIHZhciB0ID0gbmV3IFRpbWVyLCB0b3RhbCA9IGRlbGF5O1xuICBpZiAoZGVsYXkgPT0gbnVsbCkgcmV0dXJuIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpLCB0O1xuICB0Ll9yZXN0YXJ0ID0gdC5yZXN0YXJ0O1xuICB0LnJlc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBkZWxheSA9ICtkZWxheSwgdGltZSA9IHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWU7XG4gICAgdC5fcmVzdGFydChmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgICB0Ll9yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICAgIGNhbGxiYWNrKGVsYXBzZWQpO1xuICAgIH0sIGRlbGF5LCB0aW1lKTtcbiAgfVxuICB0LnJlc3RhcnQoY2FsbGJhY2ssIGRlbGF5LCB0aW1lKTtcbiAgcmV0dXJuIHQ7XG59XG4iLCJ2YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKG51bGwsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cbiIsIlxuY29uc3QgRVBTSUxPTiA9IE1hdGgucG93KDIsIC01Mik7XG5jb25zdCBFREdFX1NUQUNLID0gbmV3IFVpbnQzMkFycmF5KDUxMik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlbGF1bmF0b3Ige1xuXG4gICAgc3RhdGljIGZyb20ocG9pbnRzLCBnZXRYID0gZGVmYXVsdEdldFgsIGdldFkgPSBkZWZhdWx0R2V0WSkge1xuICAgICAgICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY29vcmRzID0gbmV3IEZsb2F0NjRBcnJheShuICogMik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb29yZHNbMiAqIGldID0gZ2V0WChwKTtcbiAgICAgICAgICAgIGNvb3Jkc1syICogaSArIDFdID0gZ2V0WShwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgRGVsYXVuYXRvcihjb29yZHMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKGNvb3Jkcykge1xuICAgICAgICBjb25zdCBuID0gY29vcmRzLmxlbmd0aCA+PiAxO1xuICAgICAgICBpZiAobiA+IDAgJiYgdHlwZW9mIGNvb3Jkc1swXSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgY29vcmRzIHRvIGNvbnRhaW4gbnVtYmVycy4nKTtcblxuICAgICAgICB0aGlzLmNvb3JkcyA9IGNvb3JkcztcblxuICAgICAgICAvLyBhcnJheXMgdGhhdCB3aWxsIHN0b3JlIHRoZSB0cmlhbmd1bGF0aW9uIGdyYXBoXG4gICAgICAgIGNvbnN0IG1heFRyaWFuZ2xlcyA9IE1hdGgubWF4KDIgKiBuIC0gNSwgMCk7XG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IG5ldyBVaW50MzJBcnJheShtYXhUcmlhbmdsZXMgKiAzKTtcbiAgICAgICAgdGhpcy5faGFsZmVkZ2VzID0gbmV3IEludDMyQXJyYXkobWF4VHJpYW5nbGVzICogMyk7XG5cbiAgICAgICAgLy8gdGVtcG9yYXJ5IGFycmF5cyBmb3IgdHJhY2tpbmcgdGhlIGVkZ2VzIG9mIHRoZSBhZHZhbmNpbmcgY29udmV4IGh1bGxcbiAgICAgICAgdGhpcy5faGFzaFNpemUgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKTtcbiAgICAgICAgdGhpcy5faHVsbFByZXYgPSBuZXcgVWludDMyQXJyYXkobik7IC8vIGVkZ2UgdG8gcHJldiBlZGdlXG4gICAgICAgIHRoaXMuX2h1bGxOZXh0ID0gbmV3IFVpbnQzMkFycmF5KG4pOyAvLyBlZGdlIHRvIG5leHQgZWRnZVxuICAgICAgICB0aGlzLl9odWxsVHJpID0gbmV3IFVpbnQzMkFycmF5KG4pOyAvLyBlZGdlIHRvIGFkamFjZW50IHRyaWFuZ2xlXG4gICAgICAgIHRoaXMuX2h1bGxIYXNoID0gbmV3IEludDMyQXJyYXkodGhpcy5faGFzaFNpemUpLmZpbGwoLTEpOyAvLyBhbmd1bGFyIGVkZ2UgaGFzaFxuXG4gICAgICAgIC8vIHRlbXBvcmFyeSBhcnJheXMgZm9yIHNvcnRpbmcgcG9pbnRzXG4gICAgICAgIHRoaXMuX2lkcyA9IG5ldyBVaW50MzJBcnJheShuKTtcbiAgICAgICAgdGhpcy5fZGlzdHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7Y29vcmRzLCBfaHVsbFByZXY6IGh1bGxQcmV2LCBfaHVsbE5leHQ6IGh1bGxOZXh0LCBfaHVsbFRyaTogaHVsbFRyaSwgX2h1bGxIYXNoOiBodWxsSGFzaH0gPSAgdGhpcztcbiAgICAgICAgY29uc3QgbiA9IGNvb3Jkcy5sZW5ndGggPj4gMTtcblxuICAgICAgICAvLyBwb3B1bGF0ZSBhbiBhcnJheSBvZiBwb2ludCBpbmRpY2VzOyBjYWxjdWxhdGUgaW5wdXQgZGF0YSBiYm94XG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGNvb3Jkc1syICogaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gY29vcmRzWzIgKiBpICsgMV07XG4gICAgICAgICAgICBpZiAoeCA8IG1pblgpIG1pblggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSBtaW5ZID0geTtcbiAgICAgICAgICAgIGlmICh4ID4gbWF4WCkgbWF4WCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA+IG1heFkpIG1heFkgPSB5O1xuICAgICAgICAgICAgdGhpcy5faWRzW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjeCA9IChtaW5YICsgbWF4WCkgLyAyO1xuICAgICAgICBjb25zdCBjeSA9IChtaW5ZICsgbWF4WSkgLyAyO1xuXG4gICAgICAgIGxldCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBpMCwgaTEsIGkyO1xuXG4gICAgICAgIC8vIHBpY2sgYSBzZWVkIHBvaW50IGNsb3NlIHRvIHRoZSBjZW50ZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkaXN0KGN4LCBjeSwgY29vcmRzWzIgKiBpXSwgY29vcmRzWzIgKiBpICsgMV0pO1xuICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgICAgaTAgPSBpO1xuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkweCA9IGNvb3Jkc1syICogaTBdO1xuICAgICAgICBjb25zdCBpMHkgPSBjb29yZHNbMiAqIGkwICsgMV07XG5cbiAgICAgICAgbWluRGlzdCA9IEluZmluaXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHNlZWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBpMCkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBkID0gZGlzdChpMHgsIGkweSwgY29vcmRzWzIgKiBpXSwgY29vcmRzWzIgKiBpICsgMV0pO1xuICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0ICYmIGQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaTEgPSBpO1xuICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpMXggPSBjb29yZHNbMiAqIGkxXTtcbiAgICAgICAgbGV0IGkxeSA9IGNvb3Jkc1syICogaTEgKyAxXTtcblxuICAgICAgICBsZXQgbWluUmFkaXVzID0gSW5maW5pdHk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgdGhpcmQgcG9pbnQgd2hpY2ggZm9ybXMgdGhlIHNtYWxsZXN0IGNpcmN1bWNpcmNsZSB3aXRoIHRoZSBmaXJzdCB0d29cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBpMCB8fCBpID09PSBpMSkgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCByID0gY2lyY3VtcmFkaXVzKGkweCwgaTB5LCBpMXgsIGkxeSwgY29vcmRzWzIgKiBpXSwgY29vcmRzWzIgKiBpICsgMV0pO1xuICAgICAgICAgICAgaWYgKHIgPCBtaW5SYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGk7XG4gICAgICAgICAgICAgICAgbWluUmFkaXVzID0gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaTJ4ID0gY29vcmRzWzIgKiBpMl07XG4gICAgICAgIGxldCBpMnkgPSBjb29yZHNbMiAqIGkyICsgMV07XG5cbiAgICAgICAgaWYgKG1pblJhZGl1cyA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8vIG9yZGVyIGNvbGxpbmVhciBwb2ludHMgYnkgZHggKG9yIGR5IGlmIGFsbCB4IGFyZSBpZGVudGljYWwpXG4gICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRoZSBsaXN0IGFzIGEgaHVsbFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXN0c1tpXSA9IChjb29yZHNbMiAqIGldIC0gY29vcmRzWzBdKSB8fCAoY29vcmRzWzIgKiBpICsgMV0gLSBjb29yZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVpY2tzb3J0KHRoaXMuX2lkcywgdGhpcy5fZGlzdHMsIDAsIG4gLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGh1bGwgPSBuZXcgVWludDMyQXJyYXkobik7XG4gICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgZDAgPSAtSW5maW5pdHk7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2lkc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGlzdHNbaWRdID4gZDApIHtcbiAgICAgICAgICAgICAgICAgICAgaHVsbFtqKytdID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIGQwID0gdGhpcy5fZGlzdHNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaHVsbCA9IGh1bGwuc3ViYXJyYXkoMCwgaik7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlcyA9IG5ldyBVaW50MzJBcnJheSgwKTtcbiAgICAgICAgICAgIHRoaXMuaGFsZmVkZ2VzID0gbmV3IFVpbnQzMkFycmF5KDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3dhcCB0aGUgb3JkZXIgb2YgdGhlIHNlZWQgcG9pbnRzIGZvciBjb3VudGVyLWNsb2Nrd2lzZSBvcmllbnRhdGlvblxuICAgICAgICBpZiAob3JpZW50KGkweCwgaTB5LCBpMXgsIGkxeSwgaTJ4LCBpMnkpKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gaTE7XG4gICAgICAgICAgICBjb25zdCB4ID0gaTF4O1xuICAgICAgICAgICAgY29uc3QgeSA9IGkxeTtcbiAgICAgICAgICAgIGkxID0gaTI7XG4gICAgICAgICAgICBpMXggPSBpMng7XG4gICAgICAgICAgICBpMXkgPSBpMnk7XG4gICAgICAgICAgICBpMiA9IGk7XG4gICAgICAgICAgICBpMnggPSB4O1xuICAgICAgICAgICAgaTJ5ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IGNpcmN1bWNlbnRlcihpMHgsIGkweSwgaTF4LCBpMXksIGkyeCwgaTJ5KTtcbiAgICAgICAgdGhpcy5fY3ggPSBjZW50ZXIueDtcbiAgICAgICAgdGhpcy5fY3kgPSBjZW50ZXIueTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fZGlzdHNbaV0gPSBkaXN0KGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdLCBjZW50ZXIueCwgY2VudGVyLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc29ydCB0aGUgcG9pbnRzIGJ5IGRpc3RhbmNlIGZyb20gdGhlIHNlZWQgdHJpYW5nbGUgY2lyY3VtY2VudGVyXG4gICAgICAgIHF1aWNrc29ydCh0aGlzLl9pZHMsIHRoaXMuX2Rpc3RzLCAwLCBuIC0gMSk7XG5cbiAgICAgICAgLy8gc2V0IHVwIHRoZSBzZWVkIHRyaWFuZ2xlIGFzIHRoZSBzdGFydGluZyBodWxsXG4gICAgICAgIHRoaXMuX2h1bGxTdGFydCA9IGkwO1xuICAgICAgICBsZXQgaHVsbFNpemUgPSAzO1xuXG4gICAgICAgIGh1bGxOZXh0W2kwXSA9IGh1bGxQcmV2W2kyXSA9IGkxO1xuICAgICAgICBodWxsTmV4dFtpMV0gPSBodWxsUHJldltpMF0gPSBpMjtcbiAgICAgICAgaHVsbE5leHRbaTJdID0gaHVsbFByZXZbaTFdID0gaTA7XG5cbiAgICAgICAgaHVsbFRyaVtpMF0gPSAwO1xuICAgICAgICBodWxsVHJpW2kxXSA9IDE7XG4gICAgICAgIGh1bGxUcmlbaTJdID0gMjtcblxuICAgICAgICBodWxsSGFzaC5maWxsKC0xKTtcbiAgICAgICAgaHVsbEhhc2hbdGhpcy5faGFzaEtleShpMHgsIGkweSldID0gaTA7XG4gICAgICAgIGh1bGxIYXNoW3RoaXMuX2hhc2hLZXkoaTF4LCBpMXkpXSA9IGkxO1xuICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KGkyeCwgaTJ5KV0gPSBpMjtcblxuICAgICAgICB0aGlzLnRyaWFuZ2xlc0xlbiA9IDA7XG4gICAgICAgIHRoaXMuX2FkZFRyaWFuZ2xlKGkwLCBpMSwgaTIsIC0xLCAtMSwgLTEpO1xuXG4gICAgICAgIGZvciAobGV0IGsgPSAwLCB4cCwgeXA7IGsgPCB0aGlzLl9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLl9pZHNba107XG4gICAgICAgICAgICBjb25zdCB4ID0gY29vcmRzWzIgKiBpXTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBjb29yZHNbMiAqIGkgKyAxXTtcblxuICAgICAgICAgICAgLy8gc2tpcCBuZWFyLWR1cGxpY2F0ZSBwb2ludHNcbiAgICAgICAgICAgIGlmIChrID4gMCAmJiBNYXRoLmFicyh4IC0geHApIDw9IEVQU0lMT04gJiYgTWF0aC5hYnMoeSAtIHlwKSA8PSBFUFNJTE9OKSBjb250aW51ZTtcbiAgICAgICAgICAgIHhwID0geDtcbiAgICAgICAgICAgIHlwID0geTtcblxuICAgICAgICAgICAgLy8gc2tpcCBzZWVkIHRyaWFuZ2xlIHBvaW50c1xuICAgICAgICAgICAgaWYgKGkgPT09IGkwIHx8IGkgPT09IGkxIHx8IGkgPT09IGkyKSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gZmluZCBhIHZpc2libGUgZWRnZSBvbiB0aGUgY29udmV4IGh1bGwgdXNpbmcgZWRnZSBoYXNoXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGtleSA9IHRoaXMuX2hhc2hLZXkoeCwgeSk7IGogPCB0aGlzLl9oYXNoU2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBodWxsSGFzaFsoa2V5ICsgaikgJSB0aGlzLl9oYXNoU2l6ZV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSAtMSAmJiBzdGFydCAhPT0gaHVsbE5leHRbc3RhcnRdKSBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhcnQgPSBodWxsUHJldltzdGFydF07XG4gICAgICAgICAgICBsZXQgZSA9IHN0YXJ0LCBxO1xuICAgICAgICAgICAgd2hpbGUgKHEgPSBodWxsTmV4dFtlXSwgIW9yaWVudCh4LCB5LCBjb29yZHNbMiAqIGVdLCBjb29yZHNbMiAqIGUgKyAxXSwgY29vcmRzWzIgKiBxXSwgY29vcmRzWzIgKiBxICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgaWYgKGUgPT09IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgPT09IC0xKSBjb250aW51ZTsgLy8gbGlrZWx5IGEgbmVhci1kdXBsaWNhdGUgcG9pbnQ7IHNraXAgaXRcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBmaXJzdCB0cmlhbmdsZSBmcm9tIHRoZSBwb2ludFxuICAgICAgICAgICAgbGV0IHQgPSB0aGlzLl9hZGRUcmlhbmdsZShlLCBpLCBodWxsTmV4dFtlXSwgLTEsIC0xLCBodWxsVHJpW2VdKTtcblxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgZmxpcCB0cmlhbmdsZXMgZnJvbSB0aGUgcG9pbnQgdW50aWwgdGhleSBzYXRpc2Z5IHRoZSBEZWxhdW5heSBjb25kaXRpb25cbiAgICAgICAgICAgIGh1bGxUcmlbaV0gPSB0aGlzLl9sZWdhbGl6ZSh0ICsgMik7XG4gICAgICAgICAgICBodWxsVHJpW2VdID0gdDsgLy8ga2VlcCB0cmFjayBvZiBib3VuZGFyeSB0cmlhbmdsZXMgb24gdGhlIGh1bGxcbiAgICAgICAgICAgIGh1bGxTaXplKys7XG5cbiAgICAgICAgICAgIC8vIHdhbGsgZm9yd2FyZCB0aHJvdWdoIHRoZSBodWxsLCBhZGRpbmcgbW9yZSB0cmlhbmdsZXMgYW5kIGZsaXBwaW5nIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICBsZXQgbiA9IGh1bGxOZXh0W2VdO1xuICAgICAgICAgICAgd2hpbGUgKHEgPSBodWxsTmV4dFtuXSwgb3JpZW50KHgsIHksIGNvb3Jkc1syICogbl0sIGNvb3Jkc1syICogbiArIDFdLCBjb29yZHNbMiAqIHFdLCBjb29yZHNbMiAqIHEgKyAxXSkpIHtcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5fYWRkVHJpYW5nbGUobiwgaSwgcSwgaHVsbFRyaVtpXSwgLTEsIGh1bGxUcmlbbl0pO1xuICAgICAgICAgICAgICAgIGh1bGxUcmlbaV0gPSB0aGlzLl9sZWdhbGl6ZSh0ICsgMik7XG4gICAgICAgICAgICAgICAgaHVsbE5leHRbbl0gPSBuOyAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBodWxsU2l6ZS0tO1xuICAgICAgICAgICAgICAgIG4gPSBxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3YWxrIGJhY2t3YXJkIGZyb20gdGhlIG90aGVyIHNpZGUsIGFkZGluZyBtb3JlIHRyaWFuZ2xlcyBhbmQgZmxpcHBpbmdcbiAgICAgICAgICAgIGlmIChlID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHdoaWxlIChxID0gaHVsbFByZXZbZV0sIG9yaWVudCh4LCB5LCBjb29yZHNbMiAqIHFdLCBjb29yZHNbMiAqIHEgKyAxXSwgY29vcmRzWzIgKiBlXSwgY29vcmRzWzIgKiBlICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHQgPSB0aGlzLl9hZGRUcmlhbmdsZShxLCBpLCBlLCAtMSwgaHVsbFRyaVtlXSwgaHVsbFRyaVtxXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FsaXplKHQgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaHVsbFRyaVtxXSA9IHQ7XG4gICAgICAgICAgICAgICAgICAgIGh1bGxOZXh0W2VdID0gZTsgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGh1bGxTaXplLS07XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBodWxsIGluZGljZXNcbiAgICAgICAgICAgIHRoaXMuX2h1bGxTdGFydCA9IGh1bGxQcmV2W2ldID0gZTtcbiAgICAgICAgICAgIGh1bGxOZXh0W2VdID0gaHVsbFByZXZbbl0gPSBpO1xuICAgICAgICAgICAgaHVsbE5leHRbaV0gPSBuO1xuXG4gICAgICAgICAgICAvLyBzYXZlIHRoZSB0d28gbmV3IGVkZ2VzIGluIHRoZSBoYXNoIHRhYmxlXG4gICAgICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KHgsIHkpXSA9IGk7XG4gICAgICAgICAgICBodWxsSGFzaFt0aGlzLl9oYXNoS2V5KGNvb3Jkc1syICogZV0sIGNvb3Jkc1syICogZSArIDFdKV0gPSBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5odWxsID0gbmV3IFVpbnQzMkFycmF5KGh1bGxTaXplKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGUgPSB0aGlzLl9odWxsU3RhcnQ7IGkgPCBodWxsU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmh1bGxbaV0gPSBlO1xuICAgICAgICAgICAgZSA9IGh1bGxOZXh0W2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpbSB0eXBlZCB0cmlhbmdsZSBtZXNoIGFycmF5c1xuICAgICAgICB0aGlzLnRyaWFuZ2xlcyA9IHRoaXMuX3RyaWFuZ2xlcy5zdWJhcnJheSgwLCB0aGlzLnRyaWFuZ2xlc0xlbik7XG4gICAgICAgIHRoaXMuaGFsZmVkZ2VzID0gdGhpcy5faGFsZmVkZ2VzLnN1YmFycmF5KDAsIHRoaXMudHJpYW5nbGVzTGVuKTtcbiAgICB9XG5cbiAgICBfaGFzaEtleSh4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHBzZXVkb0FuZ2xlKHggLSB0aGlzLl9jeCwgeSAtIHRoaXMuX2N5KSAqIHRoaXMuX2hhc2hTaXplKSAlIHRoaXMuX2hhc2hTaXplO1xuICAgIH1cblxuICAgIF9sZWdhbGl6ZShhKSB7XG4gICAgICAgIGNvbnN0IHtfdHJpYW5nbGVzOiB0cmlhbmdsZXMsIF9oYWxmZWRnZXM6IGhhbGZlZGdlcywgY29vcmRzfSA9IHRoaXM7XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgYXIgPSAwO1xuXG4gICAgICAgIC8vIHJlY3Vyc2lvbiBlbGltaW5hdGVkIHdpdGggYSBmaXhlZC1zaXplIHN0YWNrXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBiID0gaGFsZmVkZ2VzW2FdO1xuXG4gICAgICAgICAgICAvKiBpZiB0aGUgcGFpciBvZiB0cmlhbmdsZXMgZG9lc24ndCBzYXRpc2Z5IHRoZSBEZWxhdW5heSBjb25kaXRpb25cbiAgICAgICAgICAgICAqIChwMSBpcyBpbnNpZGUgdGhlIGNpcmN1bWNpcmNsZSBvZiBbcDAsIHBsLCBwcl0pLCBmbGlwIHRoZW0sXG4gICAgICAgICAgICAgKiB0aGVuIGRvIHRoZSBzYW1lIGNoZWNrL2ZsaXAgcmVjdXJzaXZlbHkgZm9yIHRoZSBuZXcgcGFpciBvZiB0cmlhbmdsZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgICAgcGwgICAgICAgICAgICAgICAgICAgIHBsXG4gICAgICAgICAgICAgKiAgICAgICAgICAvfHxcXCAgICAgICAgICAgICAgICAgIC8gIFxcXG4gICAgICAgICAgICAgKiAgICAgICBhbC8gfHwgXFxibCAgICAgICAgICAgIGFsLyAgICBcXGFcbiAgICAgICAgICAgICAqICAgICAgICAvICB8fCAgXFwgICAgICAgICAgICAgIC8gICAgICBcXFxuICAgICAgICAgICAgICogICAgICAgLyAgYXx8YiAgXFwgICAgZmxpcCAgICAvX19fYXJfX19cXFxuICAgICAgICAgICAgICogICAgIHAwXFwgICB8fCAgIC9wMSAgID0+ICAgcDBcXC0tLWJsLS0tL3AxXG4gICAgICAgICAgICAgKiAgICAgICAgXFwgIHx8ICAvICAgICAgICAgICAgICBcXCAgICAgIC9cbiAgICAgICAgICAgICAqICAgICAgIGFyXFwgfHwgL2JyICAgICAgICAgICAgIGJcXCAgICAvYnJcbiAgICAgICAgICAgICAqICAgICAgICAgIFxcfHwvICAgICAgICAgICAgICAgICAgXFwgIC9cbiAgICAgICAgICAgICAqICAgICAgICAgICBwciAgICAgICAgICAgICAgICAgICAgcHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYTAgPSBhIC0gYSAlIDM7XG4gICAgICAgICAgICBhciA9IGEwICsgKGEgKyAyKSAlIDM7XG5cbiAgICAgICAgICAgIGlmIChiID09PSAtMSkgeyAvLyBjb252ZXggaHVsbCBlZGdlXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xuICAgICAgICAgICAgICAgIGEgPSBFREdFX1NUQUNLWy0taV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGIwID0gYiAtIGIgJSAzO1xuICAgICAgICAgICAgY29uc3QgYWwgPSBhMCArIChhICsgMSkgJSAzO1xuICAgICAgICAgICAgY29uc3QgYmwgPSBiMCArIChiICsgMikgJSAzO1xuXG4gICAgICAgICAgICBjb25zdCBwMCA9IHRyaWFuZ2xlc1thcl07XG4gICAgICAgICAgICBjb25zdCBwciA9IHRyaWFuZ2xlc1thXTtcbiAgICAgICAgICAgIGNvbnN0IHBsID0gdHJpYW5nbGVzW2FsXTtcbiAgICAgICAgICAgIGNvbnN0IHAxID0gdHJpYW5nbGVzW2JsXTtcblxuICAgICAgICAgICAgY29uc3QgaWxsZWdhbCA9IGluQ2lyY2xlKFxuICAgICAgICAgICAgICAgIGNvb3Jkc1syICogcDBdLCBjb29yZHNbMiAqIHAwICsgMV0sXG4gICAgICAgICAgICAgICAgY29vcmRzWzIgKiBwcl0sIGNvb3Jkc1syICogcHIgKyAxXSxcbiAgICAgICAgICAgICAgICBjb29yZHNbMiAqIHBsXSwgY29vcmRzWzIgKiBwbCArIDFdLFxuICAgICAgICAgICAgICAgIGNvb3Jkc1syICogcDFdLCBjb29yZHNbMiAqIHAxICsgMV0pO1xuXG4gICAgICAgICAgICBpZiAoaWxsZWdhbCkge1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1thXSA9IHAxO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlc1tiXSA9IHAwO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaGJsID0gaGFsZmVkZ2VzW2JsXTtcblxuICAgICAgICAgICAgICAgIC8vIGVkZ2Ugc3dhcHBlZCBvbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgaHVsbCAocmFyZSk7IGZpeCB0aGUgaGFsZmVkZ2UgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgaWYgKGhibCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGUgPSB0aGlzLl9odWxsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9odWxsVHJpW2VdID09PSBibCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2h1bGxUcmlbZV0gPSBhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHRoaXMuX2h1bGxQcmV2W2VdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChlICE9PSB0aGlzLl9odWxsU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rKGEsIGhibCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluayhiLCBoYWxmZWRnZXNbYXJdKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5rKGFyLCBibCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBiciA9IGIwICsgKGIgKyAxKSAlIDM7XG5cbiAgICAgICAgICAgICAgICAvLyBkb24ndCB3b3JyeSBhYm91dCBoaXR0aW5nIHRoZSBjYXA6IGl0IGNhbiBvbmx5IGhhcHBlbiBvbiBleHRyZW1lbHkgZGVnZW5lcmF0ZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmIChpIDwgRURHRV9TVEFDSy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgRURHRV9TVEFDS1tpKytdID0gYnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XG4gICAgICAgICAgICAgICAgYSA9IEVER0VfU1RBQ0tbLS1pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcjtcbiAgICB9XG5cbiAgICBfbGluayhhLCBiKSB7XG4gICAgICAgIHRoaXMuX2hhbGZlZGdlc1thXSA9IGI7XG4gICAgICAgIGlmIChiICE9PSAtMSkgdGhpcy5faGFsZmVkZ2VzW2JdID0gYTtcbiAgICB9XG5cbiAgICAvLyBhZGQgYSBuZXcgdHJpYW5nbGUgZ2l2ZW4gdmVydGV4IGluZGljZXMgYW5kIGFkamFjZW50IGhhbGYtZWRnZSBpZHNcbiAgICBfYWRkVHJpYW5nbGUoaTAsIGkxLCBpMiwgYSwgYiwgYykge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy50cmlhbmdsZXNMZW47XG5cbiAgICAgICAgdGhpcy5fdHJpYW5nbGVzW3RdID0gaTA7XG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlc1t0ICsgMV0gPSBpMTtcbiAgICAgICAgdGhpcy5fdHJpYW5nbGVzW3QgKyAyXSA9IGkyO1xuXG4gICAgICAgIHRoaXMuX2xpbmsodCwgYSk7XG4gICAgICAgIHRoaXMuX2xpbmsodCArIDEsIGIpO1xuICAgICAgICB0aGlzLl9saW5rKHQgKyAyLCBjKTtcblxuICAgICAgICB0aGlzLnRyaWFuZ2xlc0xlbiArPSAzO1xuXG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbn1cblxuLy8gbW9ub3RvbmljYWxseSBpbmNyZWFzZXMgd2l0aCByZWFsIGFuZ2xlLCBidXQgZG9lc24ndCBuZWVkIGV4cGVuc2l2ZSB0cmlnb25vbWV0cnlcbmZ1bmN0aW9uIHBzZXVkb0FuZ2xlKGR4LCBkeSkge1xuICAgIGNvbnN0IHAgPSBkeCAvIChNYXRoLmFicyhkeCkgKyBNYXRoLmFicyhkeSkpO1xuICAgIHJldHVybiAoZHkgPiAwID8gMyAtIHAgOiAxICsgcCkgLyA0OyAvLyBbMC4uMV1cbn1cblxuZnVuY3Rpb24gZGlzdChheCwgYXksIGJ4LCBieSkge1xuICAgIGNvbnN0IGR4ID0gYXggLSBieDtcbiAgICBjb25zdCBkeSA9IGF5IC0gYnk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyByZXR1cm4gMmQgb3JpZW50YXRpb24gc2lnbiBpZiB3ZSdyZSBjb25maWRlbnQgaW4gaXQgdGhyb3VnaCBKLiBTaGV3Y2h1aydzIGVycm9yIGJvdW5kIGNoZWNrXG5mdW5jdGlvbiBvcmllbnRJZlN1cmUocHgsIHB5LCByeCwgcnksIHF4LCBxeSkge1xuICAgIGNvbnN0IGwgPSAocnkgLSBweSkgKiAocXggLSBweCk7XG4gICAgY29uc3QgciA9IChyeCAtIHB4KSAqIChxeSAtIHB5KTtcbiAgICByZXR1cm4gTWF0aC5hYnMobCAtIHIpID49IDMuMzMwNjY5MDczODc1NDcxNmUtMTYgKiBNYXRoLmFicyhsICsgcikgPyBsIC0gciA6IDA7XG59XG5cbi8vIGEgbW9yZSByb2J1c3Qgb3JpZW50YXRpb24gdGVzdCB0aGF0J3Mgc3RhYmxlIGluIGEgZ2l2ZW4gdHJpYW5nbGUgKHRvIGZpeCByb2J1c3RuZXNzIGlzc3VlcylcbmZ1bmN0aW9uIG9yaWVudChyeCwgcnksIHF4LCBxeSwgcHgsIHB5KSB7XG4gICAgY29uc3Qgc2lnbiA9IG9yaWVudElmU3VyZShweCwgcHksIHJ4LCByeSwgcXgsIHF5KSB8fFxuICAgIG9yaWVudElmU3VyZShyeCwgcnksIHF4LCBxeSwgcHgsIHB5KSB8fFxuICAgIG9yaWVudElmU3VyZShxeCwgcXksIHB4LCBweSwgcngsIHJ5KTtcbiAgICByZXR1cm4gc2lnbiA8IDA7XG59XG5cbmZ1bmN0aW9uIGluQ2lyY2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIGNvbnN0IGR4ID0gYXggLSBweDtcbiAgICBjb25zdCBkeSA9IGF5IC0gcHk7XG4gICAgY29uc3QgZXggPSBieCAtIHB4O1xuICAgIGNvbnN0IGV5ID0gYnkgLSBweTtcbiAgICBjb25zdCBmeCA9IGN4IC0gcHg7XG4gICAgY29uc3QgZnkgPSBjeSAtIHB5O1xuXG4gICAgY29uc3QgYXAgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBjb25zdCBicCA9IGV4ICogZXggKyBleSAqIGV5O1xuICAgIGNvbnN0IGNwID0gZnggKiBmeCArIGZ5ICogZnk7XG5cbiAgICByZXR1cm4gZHggKiAoZXkgKiBjcCAtIGJwICogZnkpIC1cbiAgICAgICAgICAgZHkgKiAoZXggKiBjcCAtIGJwICogZngpICtcbiAgICAgICAgICAgYXAgKiAoZXggKiBmeSAtIGV5ICogZngpIDwgMDtcbn1cblxuZnVuY3Rpb24gY2lyY3VtcmFkaXVzKGF4LCBheSwgYngsIGJ5LCBjeCwgY3kpIHtcbiAgICBjb25zdCBkeCA9IGJ4IC0gYXg7XG4gICAgY29uc3QgZHkgPSBieSAtIGF5O1xuICAgIGNvbnN0IGV4ID0gY3ggLSBheDtcbiAgICBjb25zdCBleSA9IGN5IC0gYXk7XG5cbiAgICBjb25zdCBibCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGNvbnN0IGNsID0gZXggKiBleCArIGV5ICogZXk7XG4gICAgY29uc3QgZCA9IDAuNSAvIChkeCAqIGV5IC0gZHkgKiBleCk7XG5cbiAgICBjb25zdCB4ID0gKGV5ICogYmwgLSBkeSAqIGNsKSAqIGQ7XG4gICAgY29uc3QgeSA9IChkeCAqIGNsIC0gZXggKiBibCkgKiBkO1xuXG4gICAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG5cbmZ1bmN0aW9uIGNpcmN1bWNlbnRlcihheCwgYXksIGJ4LCBieSwgY3gsIGN5KSB7XG4gICAgY29uc3QgZHggPSBieCAtIGF4O1xuICAgIGNvbnN0IGR5ID0gYnkgLSBheTtcbiAgICBjb25zdCBleCA9IGN4IC0gYXg7XG4gICAgY29uc3QgZXkgPSBjeSAtIGF5O1xuXG4gICAgY29uc3QgYmwgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBjb25zdCBjbCA9IGV4ICogZXggKyBleSAqIGV5O1xuICAgIGNvbnN0IGQgPSAwLjUgLyAoZHggKiBleSAtIGR5ICogZXgpO1xuXG4gICAgY29uc3QgeCA9IGF4ICsgKGV5ICogYmwgLSBkeSAqIGNsKSAqIGQ7XG4gICAgY29uc3QgeSA9IGF5ICsgKGR4ICogY2wgLSBleCAqIGJsKSAqIGQ7XG5cbiAgICByZXR1cm4ge3gsIHl9O1xufVxuXG5mdW5jdGlvbiBxdWlja3NvcnQoaWRzLCBkaXN0cywgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IDIwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBsZWZ0ICsgMTsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gaWRzW2ldO1xuICAgICAgICAgICAgY29uc3QgdGVtcERpc3QgPSBkaXN0c1t0ZW1wXTtcbiAgICAgICAgICAgIGxldCBqID0gaSAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaiA+PSBsZWZ0ICYmIGRpc3RzW2lkc1tqXV0gPiB0ZW1wRGlzdCkgaWRzW2ogKyAxXSA9IGlkc1tqLS1dO1xuICAgICAgICAgICAgaWRzW2ogKyAxXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtZWRpYW4gPSAobGVmdCArIHJpZ2h0KSA+PiAxO1xuICAgICAgICBsZXQgaSA9IGxlZnQgKyAxO1xuICAgICAgICBsZXQgaiA9IHJpZ2h0O1xuICAgICAgICBzd2FwKGlkcywgbWVkaWFuLCBpKTtcbiAgICAgICAgaWYgKGRpc3RzW2lkc1tsZWZ0XV0gPiBkaXN0c1tpZHNbcmlnaHRdXSkgc3dhcChpZHMsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgaWYgKGRpc3RzW2lkc1tpXV0gPiBkaXN0c1tpZHNbcmlnaHRdXSkgc3dhcChpZHMsIGksIHJpZ2h0KTtcbiAgICAgICAgaWYgKGRpc3RzW2lkc1tsZWZ0XV0gPiBkaXN0c1tpZHNbaV1dKSBzd2FwKGlkcywgbGVmdCwgaSk7XG5cbiAgICAgICAgY29uc3QgdGVtcCA9IGlkc1tpXTtcbiAgICAgICAgY29uc3QgdGVtcERpc3QgPSBkaXN0c1t0ZW1wXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGRvIGkrKzsgd2hpbGUgKGRpc3RzW2lkc1tpXV0gPCB0ZW1wRGlzdCk7XG4gICAgICAgICAgICBkbyBqLS07IHdoaWxlIChkaXN0c1tpZHNbal1dID4gdGVtcERpc3QpO1xuICAgICAgICAgICAgaWYgKGogPCBpKSBicmVhaztcbiAgICAgICAgICAgIHN3YXAoaWRzLCBpLCBqKTtcbiAgICAgICAgfVxuICAgICAgICBpZHNbbGVmdCArIDFdID0gaWRzW2pdO1xuICAgICAgICBpZHNbal0gPSB0ZW1wO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGkgKyAxID49IGogLSBsZWZ0KSB7XG4gICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgaSwgcmlnaHQpO1xuICAgICAgICAgICAgcXVpY2tzb3J0KGlkcywgZGlzdHMsIGxlZnQsIGogLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1aWNrc29ydChpZHMsIGRpc3RzLCBsZWZ0LCBqIC0gMSk7XG4gICAgICAgICAgICBxdWlja3NvcnQoaWRzLCBkaXN0cywgaSwgcmlnaHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIGNvbnN0IHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0R2V0WChwKSB7XG4gICAgcmV0dXJuIHBbMF07XG59XG5mdW5jdGlvbiBkZWZhdWx0R2V0WShwKSB7XG4gICAgcmV0dXJuIHBbMV07XG59XG4iLCJpbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLCBrZXksXG4gICAgICB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSAteDA7XG5cbiAgZnVuY3Rpb24gYmJveFBvaW50KHApIHtcbiAgICBwID0gdChwKTtcbiAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gIH1cblxuICBmdW5jdGlvbiBiYm94R2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJib3hHZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGJib3hQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2goYmJveFBvaW50KTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcmMubGVuZ3RoLCBwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gdChhcmNbaV0sIGkpO1xuICAgICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChrZXkgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCB4KSB7XG4gIHZhciBsbyA9IDAsIGhpID0gYS5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKGFbbWlkXSA8IHgpIGxvID0gbWlkICsgMTtcbiAgICBlbHNlIGhpID0gbWlkO1xuICB9XG4gIHJldHVybiBsbztcbn1cbiIsImltcG9ydCByZXZlcnNlIGZyb20gXCIuL3JldmVyc2UuanNcIjtcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgbyA9IHRvcG9sb2d5Lm9iamVjdHNbb107XG4gIHJldHVybiBvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCJcbiAgICAgID8ge3R5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSh0b3BvbG9neSwgbyk7IH0pfVxuICAgICAgOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICB2YXIgaWQgPSBvLmlkLFxuICAgICAgYmJveCA9IG8uYmJveCxcbiAgICAgIHByb3BlcnRpZXMgPSBvLnByb3BlcnRpZXMgPT0gbnVsbCA/IHt9IDogby5wcm9wZXJ0aWVzLFxuICAgICAgZ2VvbWV0cnkgPSBvYmplY3QodG9wb2xvZ3ksIG8pO1xuICByZXR1cm4gaWQgPT0gbnVsbCAmJiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDogYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDoge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIGJib3g6IGJib3gsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIHRyYW5zZm9ybVBvaW50ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGg7IGsgPCBuOyArK2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRyYW5zZm9ybVBvaW50KGFba10sIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHApO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0pOyAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYW4gYXJjIGhhcyBvbmx5IHR3byBwb2ludHMuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmJveH0gZnJvbSBcIi4vYmJveC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZlYXR1cmV9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXNoLCBtZXNoQXJjc30gZnJvbSBcIi4vbWVzaC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlLCBtZXJnZUFyY3N9IGZyb20gXCIuL21lcmdlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmVpZ2hib3JzfSBmcm9tIFwiLi9uZWlnaGJvcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFudGl6ZX0gZnJvbSBcIi4vcXVhbnRpemUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHVudHJhbnNmb3JtfSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmZ1bmN0aW9uIHBsYW5hclJpbmdBcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKTsgLy8gTm90ZTogZG91YmxlZCBhcmVhIVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubGVuZ3RoID4gMDtcbiAgICB9KVxuICB9O1xufVxuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzLCBpLCBuO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGFyY3MgPSBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpO1xuICBlbHNlIGZvciAoaSA9IDAsIGFyY3MgPSBuZXcgQXJyYXkobiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoKTsgaSA8IG47ICsraSkgYXJjc1tpXSA9IGk7XG4gIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcyA9IFtdLFxuICAgICAgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgZ2VvbTtcblxuICBmdW5jdGlvbiBleHRyYWN0MChpKSB7XG4gICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDEoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MihhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QzKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoZ2VvbSA9IG8sIG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogZXh0cmFjdDEoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6IGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3QyKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBleHRyYWN0MyhvLmFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZW9tZXRyeShvYmplY3QpO1xuXG4gIGdlb21zQnlBcmMuZm9yRWFjaChmaWx0ZXIgPT0gbnVsbFxuICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcblxuICByZXR1cm4gYXJjcztcbn1cbiIsImltcG9ydCBiaXNlY3QgZnJvbSBcIi4vYmlzZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICB9O1xuXG4gIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuIiwiaW1wb3J0IGJib3ggZnJvbSBcIi4vYmJveC5qc1wiO1xuaW1wb3J0IHVudHJhbnNmb3JtIGZyb20gXCIuL3VudHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBxdWFudGl6ZWRcIik7XG5cbiAgaWYgKCF0cmFuc2Zvcm0gfHwgIXRyYW5zZm9ybS5zY2FsZSkge1xuICAgIGlmICghKChuID0gTWF0aC5mbG9vcih0cmFuc2Zvcm0pKSA+PSAyKSkgdGhyb3cgbmV3IEVycm9yKFwibiBtdXN0IGJlIOKJpTJcIik7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveCB8fCBiYm94KHRvcG9sb2d5KTtcbiAgICB2YXIgeDAgPSBib3hbMF0sIHkwID0gYm94WzFdLCB4MSA9IGJveFsyXSwgeTEgPSBib3hbM10sIG47XG4gICAgdHJhbnNmb3JtID0ge3NjYWxlOiBbeDEgLSB4MCA/ICh4MSAtIHgwKSAvIChuIC0gMSkgOiAxLCB5MSAtIHkwID8gKHkxIC0geTApIC8gKG4gLSAxKSA6IDFdLCB0cmFuc2xhdGU6IFt4MCwgeTBdfTtcbiAgfSBlbHNlIHtcbiAgICBib3ggPSB0b3BvbG9neS5iYm94O1xuICB9XG5cbiAgdmFyIHQgPSB1bnRyYW5zZm9ybSh0cmFuc2Zvcm0pLCBib3gsIGtleSwgaW5wdXRzID0gdG9wb2xvZ3kub2JqZWN0cywgb3V0cHV0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHF1YW50aXplUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gdChwb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KGlucHV0KSB7XG4gICAgdmFyIG91dHB1dDtcbiAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogb3V0cHV0ID0ge3R5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsIGdlb21ldHJpZXM6IGlucHV0Lmdlb21ldHJpZXMubWFwKHF1YW50aXplR2VvbWV0cnkpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9pbnQoaW5wdXQuY29vcmRpbmF0ZXMpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvdXRwdXQgPSB7dHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAocXVhbnRpemVQb2ludCl9OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlucHV0LmlkICE9IG51bGwpIG91dHB1dC5pZCA9IGlucHV0LmlkO1xuICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICBpZiAoaW5wdXQucHJvcGVydGllcyAhPSBudWxsKSBvdXRwdXQucHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplQXJjKGlucHV0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMSwgbiA9IGlucHV0Lmxlbmd0aCwgcCwgb3V0cHV0ID0gbmV3IEFycmF5KG4pOyAvLyBwZXNzaW1pc3RpY1xuICAgIG91dHB1dFswXSA9IHQoaW5wdXRbMF0sIDApO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHAgPSB0KGlucHV0W2ldLCBpKSlbMF0gfHwgcFsxXSkgb3V0cHV0W2orK10gPSBwOyAvLyBub24tY29pbmNpZGVudCBwb2ludHNcbiAgICBpZiAoaiA9PT0gMSkgb3V0cHV0W2orK10gPSBbMCwgMF07IC8vIGFuIGFyYyBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgIG91dHB1dC5sZW5ndGggPSBqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmb3IgKGtleSBpbiBpbnB1dHMpIG91dHB1dHNba2V5XSA9IHF1YW50aXplR2VvbWV0cnkoaW5wdXRzW2tleV0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BvbG9neVwiLFxuICAgIGJib3g6IGJveCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBvYmplY3RzOiBvdXRwdXRzLFxuICAgIGFyY3M6IHRvcG9sb2d5LmFyY3MubWFwKHF1YW50aXplQXJjKVxuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIG4pIHtcbiAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjtcbiAgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgYXJjcykge1xuICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgfVxuICB9KTtcblxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICBmLCBnO1xuXG4gICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgZi5wdXNoKGkpO1xuICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSBbaV07XG4gICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgcmV0dXJuIGZyYWdtZW50cztcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsIG4gPSBpbnB1dC5sZW5ndGgsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICBvdXRwdXRbMF0gPSAoeDAgKz0gaW5wdXRbMF0pICoga3ggKyBkeDtcbiAgICBvdXRwdXRbMV0gPSAoeTAgKz0gaW5wdXRbMV0pICoga3kgKyBkeTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsXG4gICAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeDEgPSBNYXRoLnJvdW5kKChpbnB1dFswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTEgPSBNYXRoLnJvdW5kKChpbnB1dFsxXSAtIGR5KSAvIGt5KTtcbiAgICBvdXRwdXRbMF0gPSB4MSAtIHgwLCB4MCA9IHgxO1xuICAgIG91dHB1dFsxXSA9IHkxIC0geTAsIHkwID0geTE7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJleHBvcnQge1xuICBkb21DYW52YXMgYXMgZG9tQ2FudmFzLFxuICBkb21DYW52YXMgYXMgY2FudmFzLFxuICBkb21JbWFnZSBhcyBpbWFnZVxufSBmcm9tICcuL3NyYy9kb21DYW52YXMnO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGRvbUNhbnZhcyh3LCBoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpIHtcbiAgICBjb25zdCBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgaWYgKGMgJiYgYy5nZXRDb250ZXh0KSB7XG4gICAgICBjLndpZHRoID0gdztcbiAgICAgIGMuaGVpZ2h0ID0gaDtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IGRvbUltYWdlID0gKCkgPT5cbiAgdHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJyA/IEltYWdlIDogbnVsbDtcbiIsImltcG9ydCB7IHBlcm11dGUsIGJpc2VjdExlZnQsIGJpc2VjdFJpZ2h0IH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cyB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmNvbnN0IGFycmF5OCA9IG4gPT4gbmV3IFVpbnQ4QXJyYXkobik7XG5jb25zdCBhcnJheTE2ID0gbiA9PiBuZXcgVWludDE2QXJyYXkobik7XG5jb25zdCBhcnJheTMyID0gbiA9PiBuZXcgVWludDMyQXJyYXkobik7XG5cbi8qKlxuICogTWFpbnRhaW5zIENyb3NzRmlsdGVyIHN0YXRlLlxuICovXG5cbmZ1bmN0aW9uIEJpdG1hcHMoKSB7XG4gIGxldCB3aWR0aCA9IDgsXG4gICAgICBkYXRhID0gW10sXG4gICAgICBzZWVuID0gYXJyYXkzMigwKSxcbiAgICAgIGN1cnIgPSBhcnJheSgwLCB3aWR0aCksXG4gICAgICBwcmV2ID0gYXJyYXkoMCwgd2lkdGgpO1xuICByZXR1cm4ge1xuICAgIGRhdGE6ICgpID0+IGRhdGEsXG4gICAgc2VlbjogKCkgPT4gc2VlbiA9IGxlbmd0aGVuKHNlZW4sIGRhdGEubGVuZ3RoKSxcblxuICAgIGFkZChhcnJheSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBkYXRhLmxlbmd0aCwgbiA9IGFycmF5Lmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gYXJyYXlbaV07XG4gICAgICAgIHQuX2luZGV4ID0gaisrO1xuICAgICAgICBkYXRhLnB1c2godCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZShudW0sIG1hcCkge1xuICAgICAgLy8gbWFwOiBpbmRleCAtPiBib29sZWFuICh0cnVlID0+IHJlbW92ZSlcbiAgICAgIGNvbnN0IG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGNvcHkgPSBBcnJheShuIC0gbnVtKSxcbiAgICAgICAgICAgIHJlaW5kZXggPSBkYXRhOyAvLyByZXVzZSBvbGQgZGF0YSBhcnJheSBmb3IgaW5kZXggbWFwXG5cbiAgICAgIGxldCB0LCBpLCBqOyAvLyBzZWVrIGZvcndhcmQgdG8gZmlyc3QgcmVtb3ZhbFxuXG4gICAgICBmb3IgKGkgPSAwOyAhbWFwW2ldICYmIGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29weVtpXSA9IGRhdGFbaV07XG4gICAgICAgIHJlaW5kZXhbaV0gPSBpO1xuICAgICAgfSAvLyBjb25kZW5zZSBhcnJheXNcblxuXG4gICAgICBmb3IgKGogPSBpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHQgPSBkYXRhW2ldO1xuXG4gICAgICAgIGlmICghbWFwW2ldKSB7XG4gICAgICAgICAgcmVpbmRleFtpXSA9IGo7XG4gICAgICAgICAgY3VycltqXSA9IGN1cnJbaV07XG4gICAgICAgICAgcHJldltqXSA9IHByZXZbaV07XG4gICAgICAgICAgY29weVtqXSA9IHQ7XG4gICAgICAgICAgdC5faW5kZXggPSBqKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVpbmRleFtpXSA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycltpXSA9IDA7IC8vIGNsZWFyIHVudXNlZCBiaXRzXG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBjb3B5O1xuICAgICAgcmV0dXJuIHJlaW5kZXg7XG4gICAgfSxcblxuICAgIHNpemU6ICgpID0+IGRhdGEubGVuZ3RoLFxuICAgIGN1cnI6ICgpID0+IGN1cnIsXG4gICAgcHJldjogKCkgPT4gcHJldixcbiAgICByZXNldDogayA9PiBwcmV2W2tdID0gY3VycltrXSxcbiAgICBhbGw6ICgpID0+IHdpZHRoIDwgMHgxMDEgPyAweGZmIDogd2lkdGggPCAweDEwMDAxID8gMHhmZmZmIDogMHhmZmZmZmZmZixcblxuICAgIHNldChrLCBvbmUpIHtcbiAgICAgIGN1cnJba10gfD0gb25lO1xuICAgIH0sXG5cbiAgICBjbGVhcihrLCBvbmUpIHtcbiAgICAgIGN1cnJba10gJj0gfm9uZTtcbiAgICB9LFxuXG4gICAgcmVzaXplKG4sIG0pIHtcbiAgICAgIGNvbnN0IGsgPSBjdXJyLmxlbmd0aDtcblxuICAgICAgaWYgKG4gPiBrIHx8IG0gPiB3aWR0aCkge1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KG0sIHdpZHRoKTtcbiAgICAgICAgY3VyciA9IGFycmF5KG4sIHdpZHRoLCBjdXJyKTtcbiAgICAgICAgcHJldiA9IGFycmF5KG4sIHdpZHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoZW4oYXJyYXksIGxlbmd0aCwgY29weSkge1xuICBpZiAoYXJyYXkubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGFycmF5O1xuICBjb3B5ID0gY29weSB8fCBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcbiAgY29weS5zZXQoYXJyYXkpO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gYXJyYXkobiwgbSwgYXJyYXkpIHtcbiAgY29uc3QgY29weSA9IChtIDwgMHgxMDEgPyBhcnJheTggOiBtIDwgMHgxMDAwMSA/IGFycmF5MTYgOiBhcnJheTMyKShuKTtcbiAgaWYgKGFycmF5KSBjb3B5LnNldChhcnJheSk7XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBEaW1lbnNpb24gKGluZGV4LCBpLCBxdWVyeSkge1xuICBjb25zdCBiaXQgPSAxIDw8IGk7XG4gIHJldHVybiB7XG4gICAgb25lOiBiaXQsXG4gICAgemVybzogfmJpdCxcbiAgICByYW5nZTogcXVlcnkuc2xpY2UoKSxcbiAgICBiaXNlY3Q6IGluZGV4LmJpc2VjdCxcbiAgICBpbmRleDogaW5kZXguaW5kZXgsXG4gICAgc2l6ZTogaW5kZXguc2l6ZSxcblxuICAgIG9uQWRkKGFkZGVkLCBjdXJyKSB7XG4gICAgICBjb25zdCBkaW0gPSB0aGlzLFxuICAgICAgICAgICAgcmFuZ2UgPSBkaW0uYmlzZWN0KGRpbS5yYW5nZSwgYWRkZWQudmFsdWUpLFxuICAgICAgICAgICAgaWR4ID0gYWRkZWQuaW5kZXgsXG4gICAgICAgICAgICBsbyA9IHJhbmdlWzBdLFxuICAgICAgICAgICAgaGkgPSByYW5nZVsxXSxcbiAgICAgICAgICAgIG4xID0gaWR4Lmxlbmd0aDtcbiAgICAgIGxldCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbG87ICsraSkgY3VycltpZHhbaV1dIHw9IGJpdDtcblxuICAgICAgZm9yIChpID0gaGk7IGkgPCBuMTsgKytpKSBjdXJyW2lkeFtpXV0gfD0gYml0O1xuXG4gICAgICByZXR1cm4gZGltO1xuICAgIH1cblxuICB9O1xufVxuXG4vKipcbiAqIE1haW50YWlucyBhIGxpc3Qgb2YgdmFsdWVzLCBzb3J0ZWQgYnkga2V5LlxuICovXG5cbmZ1bmN0aW9uIFNvcnRlZEluZGV4KCkge1xuICBsZXQgaW5kZXggPSBhcnJheTMyKDApLFxuICAgICAgdmFsdWUgPSBbXSxcbiAgICAgIHNpemUgPSAwO1xuXG4gIGZ1bmN0aW9uIGluc2VydChrZXksIGRhdGEsIGJhc2UpIHtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgY29uc3QgbjAgPSBzaXplLFxuICAgICAgICAgIG4xID0gZGF0YS5sZW5ndGgsXG4gICAgICAgICAgYWRkaSA9IGFycmF5MzIobjEpO1xuICAgIGxldCBhZGR2ID0gQXJyYXkobjEpLFxuICAgICAgICBvbGR2LFxuICAgICAgICBvbGRpLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG4xOyArK2kpIHtcbiAgICAgIGFkZHZbaV0gPSBrZXkoZGF0YVtpXSk7XG4gICAgICBhZGRpW2ldID0gaTtcbiAgICB9XG5cbiAgICBhZGR2ID0gc29ydChhZGR2LCBhZGRpKTtcblxuICAgIGlmIChuMCkge1xuICAgICAgb2xkdiA9IHZhbHVlO1xuICAgICAgb2xkaSA9IGluZGV4O1xuICAgICAgdmFsdWUgPSBBcnJheShuMCArIG4xKTtcbiAgICAgIGluZGV4ID0gYXJyYXkzMihuMCArIG4xKTtcbiAgICAgIG1lcmdlKGJhc2UsIG9sZHYsIG9sZGksIG4wLCBhZGR2LCBhZGRpLCBuMSwgdmFsdWUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJhc2UgPiAwKSBmb3IgKGkgPSAwOyBpIDwgbjE7ICsraSkge1xuICAgICAgICBhZGRpW2ldICs9IGJhc2U7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGFkZHY7XG4gICAgICBpbmRleCA9IGFkZGk7XG4gICAgfVxuXG4gICAgc2l6ZSA9IG4wICsgbjE7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluZGV4OiBhZGRpLFxuICAgICAgdmFsdWU6IGFkZHZcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlKG51bSwgbWFwKSB7XG4gICAgLy8gbWFwOiBpbmRleCAtPiByZW1vdmVcbiAgICBjb25zdCBuID0gc2l6ZTtcbiAgICBsZXQgaWR4LCBpLCBqOyAvLyBzZWVrIGZvcndhcmQgdG8gZmlyc3QgcmVtb3ZhbFxuXG4gICAgZm9yIChpID0gMDsgIW1hcFtpbmRleFtpXV0gJiYgaSA8IG47ICsraSk7IC8vIGNvbmRlbnNlIGluZGV4IGFuZCB2YWx1ZSBhcnJheXNcblxuXG4gICAgZm9yIChqID0gaTsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCFtYXBbaWR4ID0gaW5kZXhbaV1dKSB7XG4gICAgICAgIGluZGV4W2pdID0gaWR4O1xuICAgICAgICB2YWx1ZVtqXSA9IHZhbHVlW2ldO1xuICAgICAgICArK2o7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2l6ZSA9IG4gLSBudW07XG4gIH1cblxuICBmdW5jdGlvbiByZWluZGV4KG1hcCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gc2l6ZTsgaSA8IG47ICsraSkge1xuICAgICAgaW5kZXhbaV0gPSBtYXBbaW5kZXhbaV1dO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJpc2VjdChyYW5nZSwgYXJyYXkpIHtcbiAgICBsZXQgbjtcblxuICAgIGlmIChhcnJheSkge1xuICAgICAgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSB2YWx1ZTtcbiAgICAgIG4gPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiBbYmlzZWN0TGVmdChhcnJheSwgcmFuZ2VbMF0sIDAsIG4pLCBiaXNlY3RSaWdodChhcnJheSwgcmFuZ2VbMV0sIDAsIG4pXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaW5zZXJ0OiBpbnNlcnQsXG4gICAgcmVtb3ZlOiByZW1vdmUsXG4gICAgYmlzZWN0OiBiaXNlY3QsXG4gICAgcmVpbmRleDogcmVpbmRleCxcbiAgICBpbmRleDogKCkgPT4gaW5kZXgsXG4gICAgc2l6ZTogKCkgPT4gc2l6ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBzb3J0KHZhbHVlcywgaW5kZXgpIHtcbiAgdmFsdWVzLnNvcnQuY2FsbChpbmRleCwgKGEsIGIpID0+IHtcbiAgICBjb25zdCB4ID0gdmFsdWVzW2FdLFxuICAgICAgICAgIHkgPSB2YWx1ZXNbYl07XG4gICAgcmV0dXJuIHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xuICB9KTtcbiAgcmV0dXJuIHBlcm11dGUodmFsdWVzLCBpbmRleCk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKGJhc2UsIHZhbHVlMCwgaW5kZXgwLCBuMCwgdmFsdWUxLCBpbmRleDEsIG4xLCB2YWx1ZSwgaW5kZXgpIHtcbiAgbGV0IGkwID0gMCxcbiAgICAgIGkxID0gMCxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaTAgPCBuMCAmJiBpMSA8IG4xOyArK2kpIHtcbiAgICBpZiAodmFsdWUwW2kwXSA8IHZhbHVlMVtpMV0pIHtcbiAgICAgIHZhbHVlW2ldID0gdmFsdWUwW2kwXTtcbiAgICAgIGluZGV4W2ldID0gaW5kZXgwW2kwKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVtpXSA9IHZhbHVlMVtpMV07XG4gICAgICBpbmRleFtpXSA9IGluZGV4MVtpMSsrXSArIGJhc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IGkwIDwgbjA7ICsraTAsICsraSkge1xuICAgIHZhbHVlW2ldID0gdmFsdWUwW2kwXTtcbiAgICBpbmRleFtpXSA9IGluZGV4MFtpMF07XG4gIH1cblxuICBmb3IgKDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgdmFsdWVbaV0gPSB2YWx1ZTFbaTFdO1xuICAgIGluZGV4W2ldID0gaW5kZXgxW2kxXSArIGJhc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbmRleGVkIG11bHRpLWRpbWVuc2lvbmFsIGZpbHRlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gcGFyYW1zLmZpZWxkcyAtIEFuIGFycmF5IG9mIGRpbWVuc2lvbiBhY2Nlc3NvcnMgdG8gZmlsdGVyLlxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLnF1ZXJ5IC0gQW4gYXJyYXkgb2YgcGVyLWRpbWVuc2lvbiByYW5nZSBxdWVyaWVzLlxuICovXG5cbmZ1bmN0aW9uIENyb3NzRmlsdGVyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBCaXRtYXBzKCksIHBhcmFtcyk7XG4gIHRoaXMuX2luZGljZXMgPSBudWxsO1xuICB0aGlzLl9kaW1zID0gbnVsbDtcbn1cbkNyb3NzRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0Nyb3NzRmlsdGVyJyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncXVlcnknLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWUsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9XVxufTtcbmluaGVyaXRzKENyb3NzRmlsdGVyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCF0aGlzLl9kaW1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0KF8sIHB1bHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluaXQgPSBfLm1vZGlmaWVkKCdmaWVsZHMnKSB8fCBfLmZpZWxkcy5zb21lKGYgPT4gcHVsc2UubW9kaWZpZWQoZi5maWVsZHMpKTtcblxuICAgICAgcmV0dXJuIGluaXQgPyB0aGlzLnJlaW5pdChfLCBwdWxzZSkgOiB0aGlzLmV2YWwoXywgcHVsc2UpO1xuICAgIH1cbiAgfSxcblxuICBpbml0KF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICAgICAgcXVlcnkgPSBfLnF1ZXJ5LFxuICAgICAgICAgIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzID0ge30sXG4gICAgICAgICAgZGltcyA9IHRoaXMuX2RpbXMgPSBbXSxcbiAgICAgICAgICBtID0gcXVlcnkubGVuZ3RoO1xuICAgIGxldCBpID0gMCxcbiAgICAgICAga2V5LFxuICAgICAgICBpbmRleDsgLy8gaW5zdGFudGlhdGUgaW5kaWNlcyBhbmQgZGltZW5zaW9uc1xuXG4gICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgIGtleSA9IGZpZWxkc1tpXS5mbmFtZTtcbiAgICAgIGluZGV4ID0gaW5kaWNlc1trZXldIHx8IChpbmRpY2VzW2tleV0gPSBTb3J0ZWRJbmRleCgpKTtcbiAgICAgIGRpbXMucHVzaChEaW1lbnNpb24oaW5kZXgsIGksIHF1ZXJ5W2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXZhbChfLCBwdWxzZSk7XG4gIH0sXG5cbiAgcmVpbml0KF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gcHVsc2UubWF0ZXJpYWxpemUoKS5mb3JrKCksXG4gICAgICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICAgICAgcXVlcnkgPSBfLnF1ZXJ5LFxuICAgICAgICAgIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzLFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgICAgIGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBwcmV2ID0gYml0cy5wcmV2KCksXG4gICAgICAgICAgYWxsID0gYml0cy5hbGwoKSxcbiAgICAgICAgICBvdXQgPSBvdXRwdXQucmVtID0gb3V0cHV0LmFkZCxcbiAgICAgICAgICBtb2QgPSBvdXRwdXQubW9kLFxuICAgICAgICAgIG0gPSBxdWVyeS5sZW5ndGgsXG4gICAgICAgICAgYWRkcyA9IHt9O1xuICAgIGxldCBhZGQsIGluZGV4LCBrZXksIG1vZHMsIHJlbU1hcCwgbW9kTWFwLCBpLCBuLCBmOyAvLyBzZXQgcHJldiB0byBjdXJyZW50IHN0YXRlXG5cbiAgICBwcmV2LnNldChjdXJyKTsgLy8gaWYgcHVsc2UgaGFzIHJlbW92ZSB0dXBsZXMsIHByb2Nlc3MgdGhlbSBmaXJzdFxuXG4gICAgaWYgKHB1bHNlLnJlbS5sZW5ndGgpIHtcbiAgICAgIHJlbU1hcCA9IHRoaXMucmVtb3ZlKF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgIH0gLy8gaWYgcHVsc2UgaGFzIGFkZGVkIHR1cGxlcywgYWRkIHRoZW0gdG8gc3RhdGVcblxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGgpIHtcbiAgICAgIGJpdHMuYWRkKHB1bHNlLmFkZCk7XG4gICAgfSAvLyBpZiBwdWxzZSBoYXMgbW9kaWZpZWQgdHVwbGVzLCBjcmVhdGUgYW4gaW5kZXggbWFwXG5cblxuICAgIGlmIChwdWxzZS5tb2QubGVuZ3RoKSB7XG4gICAgICBtb2RNYXAgPSB7fTtcblxuICAgICAgZm9yIChtb2RzID0gcHVsc2UubW9kLCBpID0gMCwgbiA9IG1vZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1vZE1hcFttb2RzW2ldLl9pbmRleF0gPSAxO1xuICAgICAgfVxuICAgIH0gLy8gcmUtaW5pdGlhbGl6ZSBpbmRpY2VzIGFzIG5lZWRlZCwgdXBkYXRlIGN1cnIgYml0bWFwXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgIGYgPSBmaWVsZHNbaV07XG5cbiAgICAgIGlmICghZGltc1tpXSB8fCBfLm1vZGlmaWVkKCdmaWVsZHMnLCBpKSB8fCBwdWxzZS5tb2RpZmllZChmLmZpZWxkcykpIHtcbiAgICAgICAga2V5ID0gZi5mbmFtZTtcblxuICAgICAgICBpZiAoIShhZGQgPSBhZGRzW2tleV0pKSB7XG4gICAgICAgICAgaW5kaWNlc1trZXldID0gaW5kZXggPSBTb3J0ZWRJbmRleCgpO1xuICAgICAgICAgIGFkZHNba2V5XSA9IGFkZCA9IGluZGV4Lmluc2VydChmLCBwdWxzZS5zb3VyY2UsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGltc1tpXSA9IERpbWVuc2lvbihpbmRleCwgaSwgcXVlcnlbaV0pLm9uQWRkKGFkZCwgY3Vycik7XG4gICAgICB9XG4gICAgfSAvLyB2aXNpdCBlYWNoIHR1cGxlXG4gICAgLy8gaWYgZmlsdGVyIHN0YXRlIGNoYW5nZWQsIHB1c2ggaW5kZXggdG8gYWRkL3JlbVxuICAgIC8vIGVsc2UgaWYgaW4gbW9kIGFuZCBwYXNzZXMgYSBmaWx0ZXIsIHB1c2ggaW5kZXggdG8gbW9kXG5cblxuICAgIGZvciAoaSA9IDAsIG4gPSBiaXRzLmRhdGEoKS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChyZW1NYXBbaV0pIHtcbiAgICAgICAgLy8gc2tpcCBpZiByZW1vdmVkIHR1cGxlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2W2ldICE9PSBjdXJyW2ldKSB7XG4gICAgICAgIC8vIGFkZCBpZiBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgIG91dC5wdXNoKGkpO1xuICAgICAgfSBlbHNlIGlmIChtb2RNYXBbaV0gJiYgY3VycltpXSAhPT0gYWxsKSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgcGFzcyBtb2RzIHRocm91Z2hcbiAgICAgICAgbW9kLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYml0cy5tYXNrID0gKDEgPDwgbSkgLSAxO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG5cbiAgZXZhbChfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yaygpLFxuICAgICAgICAgIG0gPSB0aGlzLl9kaW1zLmxlbmd0aDtcbiAgICBsZXQgbWFzayA9IDA7XG5cbiAgICBpZiAocHVsc2UucmVtLmxlbmd0aCkge1xuICAgICAgdGhpcy5yZW1vdmUoXywgcHVsc2UsIG91dHB1dCk7XG4gICAgICBtYXNrIHw9ICgxIDw8IG0pIC0gMTtcbiAgICB9XG5cbiAgICBpZiAoXy5tb2RpZmllZCgncXVlcnknKSAmJiAhXy5tb2RpZmllZCgnZmllbGRzJykpIHtcbiAgICAgIG1hc2sgfD0gdGhpcy51cGRhdGUoXywgcHVsc2UsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaW5zZXJ0KF8sIHB1bHNlLCBvdXRwdXQpO1xuICAgICAgbWFzayB8PSAoMSA8PCBtKSAtIDE7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLm1vZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMubW9kaWZ5KHB1bHNlLCBvdXRwdXQpO1xuICAgICAgbWFzayB8PSAoMSA8PCBtKSAtIDE7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZS5tYXNrID0gbWFzaztcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGluc2VydChfLCBwdWxzZSwgb3V0cHV0KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcHVsc2UuYWRkLFxuICAgICAgICAgIGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgICAgIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIGFkZHMgPSB7fSxcbiAgICAgICAgICBvdXQgPSBvdXRwdXQuYWRkLFxuICAgICAgICAgIG4gPSBiaXRzLnNpemUoKSArIHR1cGxlcy5sZW5ndGgsXG4gICAgICAgICAgbSA9IGRpbXMubGVuZ3RoO1xuICAgIGxldCBrID0gYml0cy5zaXplKCksXG4gICAgICAgIGosXG4gICAgICAgIGtleSxcbiAgICAgICAgYWRkOyAvLyByZXNpemUgYml0bWFwcyBhbmQgYWRkIHR1cGxlcyBhcyBuZWVkZWRcblxuICAgIGJpdHMucmVzaXplKG4sIG0pO1xuICAgIGJpdHMuYWRkKHR1cGxlcyk7XG4gICAgY29uc3QgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIHByZXYgPSBiaXRzLnByZXYoKSxcbiAgICAgICAgICBhbGwgPSBiaXRzLmFsbCgpOyAvLyBhZGQgdG8gZGltZW5zaW9uYWwgaW5kaWNlc1xuXG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAga2V5ID0gZmllbGRzW2pdLmZuYW1lO1xuICAgICAgYWRkID0gYWRkc1trZXldIHx8IChhZGRzW2tleV0gPSBpbmRpY2VzW2tleV0uaW5zZXJ0KGZpZWxkc1tqXSwgdHVwbGVzLCBrKSk7XG4gICAgICBkaW1zW2pdLm9uQWRkKGFkZCwgY3Vycik7XG4gICAgfSAvLyBzZXQgcHJldmlvdXMgZmlsdGVycywgb3V0cHV0IGlmIHBhc3NlcyBhdCBsZWFzdCBvbmUgZmlsdGVyXG5cblxuICAgIGZvciAoOyBrIDwgbjsgKytrKSB7XG4gICAgICBwcmV2W2tdID0gYWxsO1xuICAgICAgaWYgKGN1cnJba10gIT09IGFsbCkgb3V0LnB1c2goayk7XG4gICAgfVxuICB9LFxuXG4gIG1vZGlmeShwdWxzZSwgb3V0cHV0KSB7XG4gICAgY29uc3Qgb3V0ID0gb3V0cHV0Lm1vZCxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgYWxsID0gYml0cy5hbGwoKSxcbiAgICAgICAgICB0dXBsZXMgPSBwdWxzZS5tb2Q7XG4gICAgbGV0IGksIG4sIGs7XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgayA9IHR1cGxlc1tpXS5faW5kZXg7XG4gICAgICBpZiAoY3VycltrXSAhPT0gYWxsKSBvdXQucHVzaChrKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVtb3ZlKF8sIHB1bHNlLCBvdXRwdXQpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgICAgIGFsbCA9IGJpdHMuYWxsKCksXG4gICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgb3V0ID0gb3V0cHV0LnJlbSxcbiAgICAgICAgICB0dXBsZXMgPSBwdWxzZS5yZW07XG4gICAgbGV0IGksIG4sIGssIGY7IC8vIHByb2Nlc3MgdHVwbGVzLCBvdXRwdXQgaWYgcGFzc2VzIGF0IGxlYXN0IG9uZSBmaWx0ZXJcblxuICAgIGZvciAoaSA9IDAsIG4gPSB0dXBsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBrID0gdHVwbGVzW2ldLl9pbmRleDtcbiAgICAgIG1hcFtrXSA9IDE7IC8vIGJ1aWxkIGluZGV4IG1hcFxuXG4gICAgICBwcmV2W2tdID0gZiA9IGN1cnJba107XG4gICAgICBjdXJyW2tdID0gYWxsO1xuICAgICAgaWYgKGYgIT09IGFsbCkgb3V0LnB1c2goayk7XG4gICAgfSAvLyByZW1vdmUgZnJvbSBkaW1lbnNpb25hbCBpbmRpY2VzXG5cblxuICAgIGZvciAoayBpbiBpbmRpY2VzKSB7XG4gICAgICBpbmRpY2VzW2tdLnJlbW92ZShuLCBtYXApO1xuICAgIH1cblxuICAgIHRoaXMucmVpbmRleChwdWxzZSwgbiwgbWFwKTtcbiAgICByZXR1cm4gbWFwO1xuICB9LFxuXG4gIC8vIHJlaW5kZXggZmlsdGVycyBhbmQgaW5kaWNlcyBhZnRlciBwcm9wYWdhdGlvbiBjb21wbGV0ZXNcbiAgcmVpbmRleChwdWxzZSwgbnVtLCBtYXApIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgICAgICBiaXRzID0gdGhpcy52YWx1ZTtcbiAgICBwdWxzZS5ydW5BZnRlcigoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleE1hcCA9IGJpdHMucmVtb3ZlKG51bSwgbWFwKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5kaWNlcykgaW5kaWNlc1trZXldLnJlaW5kZXgoaW5kZXhNYXApO1xuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZShfLCBwdWxzZSwgb3V0cHV0KSB7XG4gICAgY29uc3QgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICAgICAgcXVlcnkgPSBfLnF1ZXJ5LFxuICAgICAgICAgIHN0YW1wID0gcHVsc2Uuc3RhbXAsXG4gICAgICAgICAgbSA9IGRpbXMubGVuZ3RoO1xuICAgIGxldCBtYXNrID0gMCxcbiAgICAgICAgaSxcbiAgICAgICAgcTsgLy8gc3VydmV5IGhvdyBtYW55IHF1ZXJpZXMgaGF2ZSBjaGFuZ2VkXG5cbiAgICBvdXRwdXQuZmlsdGVycyA9IDA7XG5cbiAgICBmb3IgKHEgPSAwOyBxIDwgbTsgKytxKSB7XG4gICAgICBpZiAoXy5tb2RpZmllZCgncXVlcnknLCBxKSkge1xuICAgICAgICBpID0gcTtcbiAgICAgICAgKyttYXNrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXNrID09PSAxKSB7XG4gICAgICAvLyBvbmx5IG9uZSBxdWVyeSBjaGFuZ2VkLCB1c2UgbW9yZSBlZmZpY2llbnQgdXBkYXRlXG4gICAgICBtYXNrID0gZGltc1tpXS5vbmU7XG4gICAgICB0aGlzLmluY3JlbWVudE9uZShkaW1zW2ldLCBxdWVyeVtpXSwgb3V0cHV0LmFkZCwgb3V0cHV0LnJlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG11bHRpcGxlIHF1ZXJpZXMgY2hhbmdlZCwgcGVyZm9ybSBmdWxsIHJlY29yZCBrZWVwaW5nXG4gICAgICBmb3IgKHEgPSAwLCBtYXNrID0gMDsgcSA8IG07ICsrcSkge1xuICAgICAgICBpZiAoIV8ubW9kaWZpZWQoJ3F1ZXJ5JywgcSkpIGNvbnRpbnVlO1xuICAgICAgICBtYXNrIHw9IGRpbXNbcV0ub25lO1xuICAgICAgICB0aGlzLmluY3JlbWVudEFsbChkaW1zW3FdLCBxdWVyeVtxXSwgc3RhbXAsIG91dHB1dC5hZGQpO1xuICAgICAgICBvdXRwdXQucmVtID0gb3V0cHV0LmFkZDsgLy8gZHVwbGljYXRlIGFkZC9yZW0gZm9yIGRvd25zdHJlYW0gcmVzb2x2ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXNrO1xuICB9LFxuXG4gIGluY3JlbWVudEFsbChkaW0sIHF1ZXJ5LCBzdGFtcCwgb3V0KSB7XG4gICAgY29uc3QgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgc2VlbiA9IGJpdHMuc2VlbigpLFxuICAgICAgICAgIGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgICAgICBwcmV2ID0gYml0cy5wcmV2KCksXG4gICAgICAgICAgaW5kZXggPSBkaW0uaW5kZXgoKSxcbiAgICAgICAgICBvbGQgPSBkaW0uYmlzZWN0KGRpbS5yYW5nZSksXG4gICAgICAgICAgcmFuZ2UgPSBkaW0uYmlzZWN0KHF1ZXJ5KSxcbiAgICAgICAgICBsbzEgPSByYW5nZVswXSxcbiAgICAgICAgICBoaTEgPSByYW5nZVsxXSxcbiAgICAgICAgICBsbzAgPSBvbGRbMF0sXG4gICAgICAgICAgaGkwID0gb2xkWzFdLFxuICAgICAgICAgIG9uZSA9IGRpbS5vbmU7XG4gICAgbGV0IGksIGosIGs7IC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGxvIGluZGV4LlxuXG4gICAgaWYgKGxvMSA8IGxvMCkge1xuICAgICAgZm9yIChpID0gbG8xLCBqID0gTWF0aC5taW4obG8wLCBoaTEpOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvMSA+IGxvMCkge1xuICAgICAgZm9yIChpID0gbG8wLCBqID0gTWF0aC5taW4obG8xLCBoaTApOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcblxuICAgICAgICBpZiAoc2VlbltrXSAhPT0gc3RhbXApIHtcbiAgICAgICAgICBwcmV2W2tdID0gY3VycltrXTtcbiAgICAgICAgICBzZWVuW2tdID0gc3RhbXA7XG4gICAgICAgICAgb3V0LnB1c2goayk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGhpIGluZGV4LlxuXG5cbiAgICBpZiAoaGkxID4gaGkwKSB7XG4gICAgICBmb3IgKGkgPSBNYXRoLm1heChsbzEsIGhpMCksIGogPSBoaTE7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuXG4gICAgICAgIGlmIChzZWVuW2tdICE9PSBzdGFtcCkge1xuICAgICAgICAgIHByZXZba10gPSBjdXJyW2tdO1xuICAgICAgICAgIHNlZW5ba10gPSBzdGFtcDtcbiAgICAgICAgICBvdXQucHVzaChrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGkxIDwgaGkwKSB7XG4gICAgICBmb3IgKGkgPSBNYXRoLm1heChsbzAsIGhpMSksIGogPSBoaTA7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuXG4gICAgICAgIGlmIChzZWVuW2tdICE9PSBzdGFtcCkge1xuICAgICAgICAgIHByZXZba10gPSBjdXJyW2tdO1xuICAgICAgICAgIHNlZW5ba10gPSBzdGFtcDtcbiAgICAgICAgICBvdXQucHVzaChrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpbS5yYW5nZSA9IHF1ZXJ5LnNsaWNlKCk7XG4gIH0sXG5cbiAgaW5jcmVtZW50T25lKGRpbSwgcXVlcnksIGFkZCwgcmVtKSB7XG4gICAgY29uc3QgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgICAgIGluZGV4ID0gZGltLmluZGV4KCksXG4gICAgICAgICAgb2xkID0gZGltLmJpc2VjdChkaW0ucmFuZ2UpLFxuICAgICAgICAgIHJhbmdlID0gZGltLmJpc2VjdChxdWVyeSksXG4gICAgICAgICAgbG8xID0gcmFuZ2VbMF0sXG4gICAgICAgICAgaGkxID0gcmFuZ2VbMV0sXG4gICAgICAgICAgbG8wID0gb2xkWzBdLFxuICAgICAgICAgIGhpMCA9IG9sZFsxXSxcbiAgICAgICAgICBvbmUgPSBkaW0ub25lO1xuICAgIGxldCBpLCBqLCBrOyAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cblxuICAgIGlmIChsbzEgPCBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMSwgaiA9IE1hdGgubWluKGxvMCwgaGkxKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICBhZGQucHVzaChrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvMSA+IGxvMCkge1xuICAgICAgZm9yIChpID0gbG8wLCBqID0gTWF0aC5taW4obG8xLCBoaTApOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICAgIHJlbS5wdXNoKGspO1xuICAgICAgfVxuICAgIH0gLy8gRmFzdCBpbmNyZW1lbnRhbCB1cGRhdGUgYmFzZWQgb24gcHJldmlvdXMgaGkgaW5kZXguXG5cblxuICAgIGlmIChoaTEgPiBoaTApIHtcbiAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMSwgaGkwKSwgaiA9IGhpMTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICBhZGQucHVzaChrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhpMSA8IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8wLCBoaTEpLCBqID0gaGkwOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcbiAgICAgICAgY3VycltrXSBePSBvbmU7XG4gICAgICAgIHJlbS5wdXNoKGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpbS5yYW5nZSA9IHF1ZXJ5LnNsaWNlKCk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogU2VsZWN0aXZlbHkgZmlsdGVycyB0dXBsZXMgYnkgcmVzb2x2aW5nIGFnYWluc3QgYSBmaWx0ZXIgYml0bWFwLlxuICogVXNlZnVsIGZvciBwcm9jZXNzaW5nIHRoZSBvdXRwdXQgb2YgYSBjcm9zcy1maWx0ZXIgdHJhbnNmb3JtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmlnbm9yZSAtIEEgYml0IG1hc2sgaW5kaWNhdGluZyB3aGljaCBmaWx0ZXJzIHRvIGlnbm9yZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuZmlsdGVyIC0gVGhlIHBlci10dXBsZSBmaWx0ZXIgYml0bWFwcy4gVHlwaWNhbGx5IHRoaXNcbiAqICAgcGFyYW1ldGVyIHZhbHVlIGlzIGEgcmVmZXJlbmNlIHRvIGEge0BsaW5rIENyb3NzRmlsdGVyfSB0cmFuc2Zvcm0uXG4gKi9cblxuZnVuY3Rpb24gUmVzb2x2ZUZpbHRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblJlc29sdmVGaWx0ZXIuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUmVzb2x2ZUZpbHRlcicsXG4gICdtZXRhZGF0YSc6IHt9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdpZ25vcmUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnZGVzY3JpcHRpb24nOiAnQSBiaXQgbWFzayBpbmRpY2F0aW5nIHdoaWNoIGZpbHRlcnMgdG8gaWdub3JlLidcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpbHRlcicsXG4gICAgJ3R5cGUnOiAnb2JqZWN0JyxcbiAgICAncmVxdWlyZWQnOiB0cnVlLFxuICAgICdkZXNjcmlwdGlvbic6ICdQZXItdHVwbGUgZmlsdGVyIGJpdG1hcHMgZnJvbSBhIENyb3NzRmlsdGVyIHRyYW5zZm9ybS4nXG4gIH1dXG59O1xuaW5oZXJpdHMoUmVzb2x2ZUZpbHRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGlnbm9yZSA9IH4oXy5pZ25vcmUgfHwgMCksXG4gICAgICAgICAgLy8gYml0IG1hc2sgd2hlcmUgemVyb3MgLT4gZGltcyB0byBpZ25vcmVcbiAgICBiaXRtYXAgPSBfLmZpbHRlcixcbiAgICAgICAgICBtYXNrID0gYml0bWFwLm1hc2s7IC8vIGV4aXQgZWFybHkgaWYgbm8gcmVsZXZhbnQgZmlsdGVyIGNoYW5nZXNcblxuICAgIGlmICgobWFzayAmIGlnbm9yZSkgPT09IDApIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG5cbiAgICBjb25zdCBvdXRwdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgICAgZGF0YSA9IGJpdG1hcC5kYXRhKCksXG4gICAgICAgICAgY3VyciA9IGJpdG1hcC5jdXJyKCksXG4gICAgICAgICAgcHJldiA9IGJpdG1hcC5wcmV2KCksXG4gICAgICAgICAgcGFzcyA9IGsgPT4gIShjdXJyW2tdICYgaWdub3JlKSA/IGRhdGFba10gOiBudWxsOyAvLyBwcm9wYWdhdGUgYWxsIG1vZCB0dXBsZXMgdGhhdCBwYXNzIHRoZSBmaWx0ZXJcblxuXG4gICAgb3V0cHV0LmZpbHRlcihvdXRwdXQuTU9ELCBwYXNzKTsgLy8gZGV0ZXJtaW5lIGFkZCAmIHJlbSB0dXBsZXMgdmlhIGZpbHRlciBmdW5jdGlvbnNcbiAgICAvLyBmb3IgZWZmaWNpZW5jeSwgd2UgZG8gKm5vdCogcG9wdWxhdGUgbmV3IGFycmF5cyxcbiAgICAvLyBpbnN0ZWFkIHdlIGFkZCBmaWx0ZXIgZnVuY3Rpb25zIGFwcGxpZWQgZG93bnN0cmVhbVxuXG4gICAgaWYgKCEobWFzayAmIG1hc2sgLSAxKSkge1xuICAgICAgLy8gb25seSBvbmUgZmlsdGVyIGNoYW5nZWRcbiAgICAgIG91dHB1dC5maWx0ZXIob3V0cHV0LkFERCwgcGFzcyk7XG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5SRU0sIGsgPT4gKGN1cnJba10gJiBpZ25vcmUpID09PSBtYXNrID8gZGF0YVtrXSA6IG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtdWx0aXBsZSBmaWx0ZXJzIGNoYW5nZWRcbiAgICAgIG91dHB1dC5maWx0ZXIob3V0cHV0LkFERCwgayA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjdXJyW2tdICYgaWdub3JlLFxuICAgICAgICAgICAgICBmID0gIWMgJiYgYyBeIHByZXZba10gJiBpZ25vcmU7XG4gICAgICAgIHJldHVybiBmID8gZGF0YVtrXSA6IG51bGw7XG4gICAgICB9KTtcbiAgICAgIG91dHB1dC5maWx0ZXIob3V0cHV0LlJFTSwgayA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjdXJyW2tdICYgaWdub3JlLFxuICAgICAgICAgICAgICBmID0gYyAmJiAhKGMgXiAoYyBeIHByZXZba10gJiBpZ25vcmUpKTtcbiAgICAgICAgcmV0dXJuIGYgPyBkYXRhW2tdIDogbnVsbDtcbiAgICAgIH0pO1xuICAgIH0gLy8gYWRkIGZpbHRlciB0byBzb3VyY2UgZGF0YSBpbiBjYXNlIG9mIHJlZmxvdy4uLlxuXG5cbiAgICByZXR1cm4gb3V0cHV0LmZpbHRlcihvdXRwdXQuU09VUkNFLCB0ID0+IHBhc3ModC5faW5kZXgpKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0IHsgQ3Jvc3NGaWx0ZXIgYXMgY3Jvc3NmaWx0ZXIsIFJlc29sdmVGaWx0ZXIgYXMgcmVzb2x2ZWZpbHRlciB9O1xuIiwiaW1wb3J0IHsgaWRlbnRpdHksIGFycmF5LCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgaXNBcnJheSwgaWQsIGVycm9yLCB0cnV0aHksIGRlYm91bmNlLCBleHRlbmQsIHZpc2l0QXJyYXksIGluaGVyaXRzLCBsb2dnZXIsIEVycm9yLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyByZWFkLCByZXNwb25zZVR5cGUsIGxvYWRlciB9IGZyb20gJ3ZlZ2EtbG9hZGVyJztcbmltcG9ydCB7IGRlZmF1bHRMb2NhbGUgfSBmcm9tICd2ZWdhLWZvcm1hdCc7XG5cbmZ1bmN0aW9uIFVuaXF1ZUxpc3QoaWRGdW5jKSB7XG4gIGNvbnN0ICQgPSBpZEZ1bmMgfHwgaWRlbnRpdHksXG4gICAgICAgIGxpc3QgPSBbXSxcbiAgICAgICAgaWRzID0ge307XG5cbiAgbGlzdC5hZGQgPSBfID0+IHtcbiAgICBjb25zdCBpZCA9ICQoXyk7XG5cbiAgICBpZiAoIWlkc1tpZF0pIHtcbiAgICAgIGlkc1tpZF0gPSAxO1xuICAgICAgbGlzdC5wdXNoKF8pO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9O1xuXG4gIGxpc3QucmVtb3ZlID0gXyA9PiB7XG4gICAgY29uc3QgaWQgPSAkKF8pO1xuXG4gICAgaWYgKGlkc1tpZF0pIHtcbiAgICAgIGlkc1tpZF0gPSAwO1xuICAgICAgY29uc3QgaWR4ID0gbGlzdC5pbmRleE9mKF8pO1xuICAgICAgaWYgKGlkeCA+PSAwKSBsaXN0LnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIEludm9rZSBhbmQgYXdhaXQgYSBwb3RlbnRpYWxseSBhc3luYyBjYWxsYmFjayBmdW5jdGlvbi4gSWZcbiAqIGFuIGVycm9yIG9jY3VycywgdHJhcCBpdCBhbmQgcm91dGUgdG8gRGF0YWZsb3cuZXJyb3IuXG4gKiBAcGFyYW0ge0RhdGFmbG93fSBkZiAtIFRoZSBkYXRhZmxvdyBpbnN0YW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBhbmQgdGhlbiBhd2FpdC4gVGhlIGRhdGFmbG93IHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBzaW5nbGVcbiAqICAgYXJndW1lbnQgdG8gdGhlIGZ1bmN0aW9uLlxuICovXG5hc3luYyBmdW5jdGlvbiBhc3luY0NhbGxiYWNrIChkZiwgY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBjYWxsYmFjayhkZik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRmLmVycm9yKGVycik7XG4gIH1cbn1cblxuY29uc3QgVFVQTEVfSURfS0VZID0gU3ltYm9sKCd2ZWdhX2lkJyk7XG5sZXQgVFVQTEVfSUQgPSAxO1xuLyoqXG4gKiBDaGVja3MgaWYgYW4gaW5wdXQgdmFsdWUgaXMgYSByZWdpc3RlcmVkIHR1cGxlLlxuICogQHBhcmFtIHsqfSB0IC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgYSB0dXBsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cbmZ1bmN0aW9uIGlzVHVwbGUodCkge1xuICByZXR1cm4gISEodCAmJiB0dXBsZWlkKHQpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgaWQgb2YgYSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIGlucHV0IHR1cGxlLlxuICogQHJldHVybiB7Kn0gdGhlIHR1cGxlIGlkLlxuICovXG5cbmZ1bmN0aW9uIHR1cGxlaWQodCkge1xuICByZXR1cm4gdFtUVVBMRV9JRF9LRVldO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBpZCBvZiBhIHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IHQgLSBUaGUgaW5wdXQgdHVwbGUuXG4gKiBAcGFyYW0geyp9IGlkIC0gVGhlIGlkIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm4ge29iamVjdH0gdGhlIGlucHV0IHR1cGxlLlxuICovXG5cbmZ1bmN0aW9uIHNldGlkKHQsIGlkKSB7XG4gIHRbVFVQTEVfSURfS0VZXSA9IGlkO1xuICByZXR1cm4gdDtcbn1cbi8qKlxuICogSW5nZXN0IGFuIG9iamVjdCBvciB2YWx1ZSBhcyBhIGRhdGEgdHVwbGUuXG4gKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LCBhbiBpZCBmaWVsZCB3aWxsIGJlIGFkZGVkIHRvIGl0LiBGb3JcbiAqIGVmZmljaWVuY3ksIHRoZSBpbnB1dCBvYmplY3QgaXMgbW9kaWZpZWQgZGlyZWN0bHkuIEEgY29weSBpcyBub3QgbWFkZS5cbiAqIElmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGxpdGVyYWwsIGl0IHdpbGwgYmUgd3JhcHBlZCBpbiBhIG5ldyBvYmplY3RcbiAqIGluc3RhbmNlLCB3aXRoIHRoZSB2YWx1ZSBhY2Nlc3NpYmxlIGFzIHRoZSAnZGF0YScgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGF0dW0gLSBUaGUgdmFsdWUgdG8gaW5nZXN0LlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgaW5nZXN0ZWQgZGF0YSB0dXBsZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluZ2VzdCQxKGRhdHVtKSB7XG4gIGNvbnN0IHQgPSBkYXR1bSA9PT0gT2JqZWN0KGRhdHVtKSA/IGRhdHVtIDoge1xuICAgIGRhdGE6IGRhdHVtXG4gIH07XG4gIHJldHVybiB0dXBsZWlkKHQpID8gdCA6IHNldGlkKHQsIFRVUExFX0lEKyspO1xufVxuLyoqXG4gKiBHaXZlbiBhIHNvdXJjZSB0dXBsZSwgcmV0dXJuIGEgZGVyaXZlZCBjb3B5LlxuICogQHBhcmFtIHtvYmplY3R9IHQgLSBUaGUgc291cmNlIHR1cGxlLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgZGVyaXZlZCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiBkZXJpdmUodCkge1xuICByZXR1cm4gcmVkZXJpdmUodCwgaW5nZXN0JDEoe30pKTtcbn1cbi8qKlxuICogUmVkZXJpdmUgYSBkZXJpdmVkIHR1cGxlIGJ5IGNvcHlpbmcgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIHNvdXJjZSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkIC0gVGhlIGRlcml2ZWQgdHVwbGUuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBkZXJpdmVkIHR1cGxlLlxuICovXG5cbmZ1bmN0aW9uIHJlZGVyaXZlKHQsIGQpIHtcbiAgZm9yIChjb25zdCBrIGluIHQpIGRba10gPSB0W2tdO1xuXG4gIHJldHVybiBkO1xufVxuLyoqXG4gKiBSZXBsYWNlIGFuIGV4aXN0aW5nIHR1cGxlIHdpdGggYSBuZXcgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBleGlzdGluZyBkYXRhIHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IGQgLSBUaGUgbmV3IHR1cGxlIHRoYXQgcmVwbGFjZXMgdGhlIG9sZC5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG5ldyB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiByZXBsYWNlKHQsIGQpIHtcbiAgcmV0dXJuIHNldGlkKGQsIHR1cGxlaWQodCkpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhdWdtZW50ZWQgY29tcGFyYXRvciBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHN0YWJsZVxuICogc29ydGluZyBieSB0dXBsZSBpZCB3aGVuIHRoZSBnaXZlbiBjb21wYXJhdG9yIHByb2R1Y2VzIHRpZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjbXAgLSBUaGUgY29tcGFyYXRvciB0byBhdWdtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZdIC0gT3B0aW9uYWwgdHVwbGUgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gQW4gYXVnbWVudGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gc3RhYmxlQ29tcGFyZShjbXAsIGYpIHtcbiAgcmV0dXJuICFjbXAgPyBudWxsIDogZiA/IChhLCBiKSA9PiBjbXAoYSwgYikgfHwgdHVwbGVpZChmKGEpKSAtIHR1cGxlaWQoZihiKSkgOiAoYSwgYikgPT4gY21wKGEsIGIpIHx8IHR1cGxlaWQoYSkgLSB0dXBsZWlkKGIpO1xufVxuXG5mdW5jdGlvbiBpc0NoYW5nZVNldCh2KSB7XG4gIHJldHVybiB2ICYmIHYuY29uc3RydWN0b3IgPT09IGNoYW5nZXNldDtcbn1cbmZ1bmN0aW9uIGNoYW5nZXNldCgpIHtcbiAgY29uc3QgYWRkID0gW10sXG4gICAgICAgIC8vIGluc2VydCB0dXBsZXNcbiAgcmVtID0gW10sXG4gICAgICAgIC8vIHJlbW92ZSB0dXBsZXNcbiAgbW9kID0gW10sXG4gICAgICAgIC8vIG1vZGlmeSB0dXBsZXNcbiAgcmVtcCA9IFtdLFxuICAgICAgICAvLyByZW1vdmUgYnkgcHJlZGljYXRlXG4gIG1vZHAgPSBbXTsgLy8gbW9kaWZ5IGJ5IHByZWRpY2F0ZVxuXG4gIGxldCBjbGVhbiA9IG51bGwsXG4gICAgICByZWZsb3cgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBjb25zdHJ1Y3RvcjogY2hhbmdlc2V0LFxuXG4gICAgaW5zZXJ0KHQpIHtcbiAgICAgIGNvbnN0IGQgPSBhcnJheSh0KSxcbiAgICAgICAgICAgIG4gPSBkLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGFkZC5wdXNoKGRbaV0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlKHQpIHtcbiAgICAgIGNvbnN0IGEgPSBpc0Z1bmN0aW9uKHQpID8gcmVtcCA6IHJlbSxcbiAgICAgICAgICAgIGQgPSBhcnJheSh0KSxcbiAgICAgICAgICAgIG4gPSBkLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGEucHVzaChkW2ldKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1vZGlmeSh0LCBmaWVsZCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IG0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgdmFsdWU6IGNvbnN0YW50KHZhbHVlKVxuICAgICAgfTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odCkpIHtcbiAgICAgICAgbS5maWx0ZXIgPSB0O1xuICAgICAgICBtb2RwLnB1c2gobSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLnR1cGxlID0gdDtcbiAgICAgICAgbW9kLnB1c2gobSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlbmNvZGUodCwgc2V0KSB7XG4gICAgICBpZiAoaXNGdW5jdGlvbih0KSkgbW9kcC5wdXNoKHtcbiAgICAgICAgZmlsdGVyOiB0LFxuICAgICAgICBmaWVsZDogc2V0XG4gICAgICB9KTtlbHNlIG1vZC5wdXNoKHtcbiAgICAgICAgdHVwbGU6IHQsXG4gICAgICAgIGZpZWxkOiBzZXRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFuKHZhbHVlKSB7XG4gICAgICBjbGVhbiA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlZmxvdygpIHtcbiAgICAgIHJlZmxvdyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHVsc2UocHVsc2UsIHR1cGxlcykge1xuICAgICAgY29uc3QgY3VyID0ge30sXG4gICAgICAgICAgICBvdXQgPSB7fTtcbiAgICAgIGxldCBpLCBuLCBtLCBmLCB0LCBpZDsgLy8gYnVpbGQgbG9va3VwIHRhYmxlIG9mIGN1cnJlbnQgdHVwbGVzXG5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSB0dXBsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGN1clt0dXBsZWlkKHR1cGxlc1tpXSldID0gMTtcbiAgICAgIH0gLy8gcHJvY2VzcyBpbmRpdmlkdWFsIHR1cGxlcyB0byByZW1vdmVcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gcmVtLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gcmVtW2ldO1xuICAgICAgICBjdXJbdHVwbGVpZCh0KV0gPSAtMTtcbiAgICAgIH0gLy8gcHJvY2VzcyBwcmVkaWNhdGUtYmFzZWQgcmVtb3ZhbHNcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gcmVtcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZiA9IHJlbXBbaV07XG4gICAgICAgIHR1cGxlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmIChmKHQpKSBjdXJbdHVwbGVpZCh0KV0gPSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHByb2Nlc3MgYWxsIGFkZCB0dXBsZXNcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gYWRkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gYWRkW2ldO1xuICAgICAgICBpZCA9IHR1cGxlaWQodCk7XG5cbiAgICAgICAgaWYgKGN1cltpZF0pIHtcbiAgICAgICAgICAvLyB0dXBsZSBhbHJlYWR5IHJlc2lkZXMgaW4gZGF0YXNldFxuICAgICAgICAgIC8vIGlmIGZsYWdnZWQgZm9yIGJvdGggYWRkIGFuZCByZW1vdmUsIGNhbmNlbFxuICAgICAgICAgIGN1cltpZF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHR1cGxlIGRvZXMgbm90IHJlc2lkZSBpbiBkYXRhc2V0LCBhZGRcbiAgICAgICAgICBwdWxzZS5hZGQucHVzaChpbmdlc3QkMShhZGRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBwb3B1bGF0ZSBwdWxzZSByZW0gbGlzdFxuXG5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSB0dXBsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHQgPSB0dXBsZXNbaV07XG4gICAgICAgIGlmIChjdXJbdHVwbGVpZCh0KV0gPCAwKSBwdWxzZS5yZW0ucHVzaCh0KTtcbiAgICAgIH0gLy8gbW9kaWZ5IGhlbHBlciBtZXRob2RcblxuXG4gICAgICBmdW5jdGlvbiBtb2RpZnkodCwgZiwgdikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHRbZl0gPSB2KHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1bHNlLmVuY29kZSA9IGY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZmxvdykgb3V0W3R1cGxlaWQodCldID0gdDtcbiAgICAgIH0gLy8gcHJvY2VzcyBpbmRpdmlkdWFsIHR1cGxlcyB0byBtb2RpZnlcblxuXG4gICAgICBmb3IgKGkgPSAwLCBuID0gbW9kLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBtID0gbW9kW2ldO1xuICAgICAgICB0ID0gbS50dXBsZTtcbiAgICAgICAgZiA9IG0uZmllbGQ7XG4gICAgICAgIGlkID0gY3VyW3R1cGxlaWQodCldO1xuXG4gICAgICAgIGlmIChpZCA+IDApIHtcbiAgICAgICAgICBtb2RpZnkodCwgZiwgbS52YWx1ZSk7XG4gICAgICAgICAgcHVsc2UubW9kaWZpZXMoZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcHJvY2VzcyBwcmVkaWNhdGUtYmFzZWQgbW9kaWZpY2F0aW9uc1xuXG5cbiAgICAgIGZvciAoaSA9IDAsIG4gPSBtb2RwLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBtID0gbW9kcFtpXTtcbiAgICAgICAgZiA9IG0uZmlsdGVyO1xuICAgICAgICB0dXBsZXMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICBpZiAoZih0KSAmJiBjdXJbdHVwbGVpZCh0KV0gPiAwKSB7XG4gICAgICAgICAgICBtb2RpZnkodCwgbS5maWVsZCwgbS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHVsc2UubW9kaWZpZXMobS5maWVsZCk7XG4gICAgICB9IC8vIHVwb24gcmVmbG93IHJlcXVlc3QsIHBvcHVsYXRlIG1vZCB3aXRoIGFsbCBub24tcmVtb3ZlZCB0dXBsZXNcbiAgICAgIC8vIG90aGVyd2lzZSwgcG9wdWxhdGUgbW9kIHdpdGggbW9kaWZpZWQgdHVwbGVzIG9ubHlcblxuXG4gICAgICBpZiAocmVmbG93KSB7XG4gICAgICAgIHB1bHNlLm1vZCA9IHJlbS5sZW5ndGggfHwgcmVtcC5sZW5ndGggPyB0dXBsZXMuZmlsdGVyKHQgPT4gY3VyW3R1cGxlaWQodCldID4gMCkgOiB0dXBsZXMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaWQgaW4gb3V0KSBwdWxzZS5tb2QucHVzaChvdXRbaWRdKTtcbiAgICAgIH0gLy8gc2V0IHB1bHNlIGdhcmJhZ2UgY29sbGVjdGlvbiByZXF1ZXN0XG5cblxuICAgICAgaWYgKGNsZWFuIHx8IGNsZWFuID09IG51bGwgJiYgKHJlbS5sZW5ndGggfHwgcmVtcC5sZW5ndGgpKSB7XG4gICAgICAgIHB1bHNlLmNsZWFuKHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHVsc2U7XG4gICAgfVxuXG4gIH07XG59XG5cbmNvbnN0IENBQ0hFID0gJ186bW9kOl8nO1xuLyoqXG4gKiBIYXNoIHRoYXQgdHJhY2tzIG1vZGlmaWNhdGlvbnMgdG8gYXNzaWduZWQgdmFsdWVzLlxuICogQ2FsbGVycyAqbXVzdCogdXNlIHRoZSBzZXQgbWV0aG9kIHRvIHVwZGF0ZSB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gUGFyYW1ldGVycygpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIENBQ0hFLCB7XG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHt9XG4gIH0pO1xufVxuUGFyYW1ldGVycy5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBTZXQgYSBwYXJhbWV0ZXIgdmFsdWUuIElmIHRoZSBwYXJhbWV0ZXIgdmFsdWUgY2hhbmdlcywgdGhlIHBhcmFtZXRlclxuICAgKiB3aWxsIGJlIHJlY29yZGVkIGFzIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IGludG8gYW4gYXJyYXktdmFsdWUgcGFyYW1ldGVyLiBJZ25vcmVkIGlmXG4gICAqICAgdGhlIGFyZ3VtZW50IGlzIHVuZGVmaW5lZCwgbnVsbCBvciBsZXNzIHRoYW4gemVyby5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSBwYXJhbWV0ZXIgdmFsdWUgdG8gc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSBJZiB0cnVlLCByZWNvcmRzIHRoZSBwYXJhbWV0ZXIgYXMgbW9kaWZpZWRcbiAgICogICBldmVuIGlmIHRoZSB2YWx1ZSBpcyB1bmNoYW5nZWQuXG4gICAqIEByZXR1cm4ge1BhcmFtZXRlcnN9IC0gVGhpcyBwYXJhbWV0ZXIgb2JqZWN0LlxuICAgKi9cbiAgc2V0KG5hbWUsIGluZGV4LCB2YWx1ZSwgZm9yY2UpIHtcbiAgICBjb25zdCBvID0gdGhpcyxcbiAgICAgICAgICB2ID0gb1tuYW1lXSxcbiAgICAgICAgICBtb2QgPSBvW0NBQ0hFXTtcblxuICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgIGlmICh2W2luZGV4XSAhPT0gdmFsdWUgfHwgZm9yY2UpIHtcbiAgICAgICAgdltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgbW9kW2luZGV4ICsgJzonICsgbmFtZV0gPSAtMTtcbiAgICAgICAgbW9kW25hbWVdID0gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2ICE9PSB2YWx1ZSB8fCBmb3JjZSkge1xuICAgICAgb1tuYW1lXSA9IHZhbHVlO1xuICAgICAgbW9kW25hbWVdID0gaXNBcnJheSh2YWx1ZSkgPyAxICsgdmFsdWUubGVuZ3RoIDogLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG87XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIG9uZSBvciBtb3JlIHBhcmFtZXRlcnMgaGFzIGJlZW4gbW9kaWZpZWQuIElmIGludm9rZWQgd2l0aCBub1xuICAgKiBhcmd1bWVudHMsIHJldHVybnMgdHJ1ZSBpZiBhbnkgcGFyYW1ldGVyIHZhbHVlIGhhcyBjaGFuZ2VkLiBJZiB0aGUgZmlyc3RcbiAgICogYXJndW1lbnQgaXMgYXJyYXksIHJldHVybnMgdHJ1ZXMgaWYgYW55IHBhcmFtZXRlciBuYW1lIGluIHRoZSBhcnJheSBoYXNcbiAgICogY2hhbmdlZC4gT3RoZXJ3aXNlLCB0ZXN0cyBpZiB0aGUgZ2l2ZW4gbmFtZSBhbmQgb3B0aW9uYWwgYXJyYXkgaW5kZXggaGFzXG4gICAqIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lIHRvIHRlc3QuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9dW5kZWZpbmVkXSAtIFRoZSBwYXJhbWV0ZXIgYXJyYXkgaW5kZXggdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgYSBxdWVyaWVkIHBhcmFtZXRlciB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBtb2RpZmllZChuYW1lLCBpbmRleCkge1xuICAgIGNvbnN0IG1vZCA9IHRoaXNbQ0FDSEVdO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gbW9kKSB7XG4gICAgICAgIGlmIChtb2Rba10pIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG5hbWUpKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG5hbWUubGVuZ3RoOyArK2spIHtcbiAgICAgICAgaWYgKG1vZFtuYW1lW2tdXSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwID8gaW5kZXggKyAxIDwgbW9kW25hbWVdIHx8ICEhbW9kW2luZGV4ICsgJzonICsgbmFtZV0gOiAhIW1vZFtuYW1lXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBtb2RpZmljYXRpb24gcmVjb3Jkcy4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAgICogYWxsIHBhcmFtZXRlcnMgYXJlIGNvbnNpZGVyZWQgdW5tb2RpZmllZC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXNbQ0FDSEVdID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxufTtcblxubGV0IE9QX0lEID0gMDtcbmNvbnN0IFBVTFNFID0gJ3B1bHNlJyxcbiAgICAgIE5PX1BBUkFNUyA9IG5ldyBQYXJhbWV0ZXJzKCk7IC8vIEJvb2xlYW4gRmxhZ3NcblxuY29uc3QgU0tJUCQxID0gMSxcbiAgICAgIE1PRElGSUVEID0gMjtcbi8qKlxuICogQW4gT3BlcmF0b3IgaXMgYSBwcm9jZXNzaW5nIG5vZGUgaW4gYSBkYXRhZmxvdyBncmFwaC5cbiAqIEVhY2ggb3BlcmF0b3Igc3RvcmVzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHZhbHVlIHVwZGF0ZSBmdW5jdGlvbi5cbiAqIE9wZXJhdG9ycyBjYW4gYWNjZXB0IGEgaGFzaCBvZiBuYW1lZCBwYXJhbWV0ZXJzLiBQYXJhbWV0ZXIgdmFsdWVzIGNhblxuICogZWl0aGVyIGJlIGRpcmVjdCAoSmF2YVNjcmlwdCBsaXRlcmFscywgYXJyYXlzLCBvYmplY3RzKSBvciBpbmRpcmVjdFxuICogKG90aGVyIG9wZXJhdG9ycyB3aG9zZSB2YWx1ZXMgd2lsbCBiZSBwdWxsZWQgZHluYW1pY2FsbHkpLiBPcGVyYXRvcnNcbiAqIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoaXMgb3BlcmF0b3IgYWRkZWQgYXMgYSBkZXBlbmRlbmN5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IFtpbml0XSAtIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIFB1bHNlKX0gW3VwZGF0ZV0gLSBBbiB1cGRhdGUgZnVuY3Rpb24uIFVwb25cbiAqICAgZXZhbHVhdGlvbiBvZiB0aGlzIG9wZXJhdG9yLCB0aGUgdXBkYXRlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhbmQgdGhlXG4gKiAgIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWFjdD10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICogICBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMuXG4gKiBAc2VlIHBhcmFtZXRlcnNcbiAqL1xuXG5mdW5jdGlvbiBPcGVyYXRvcihpbml0LCB1cGRhdGUsIHBhcmFtcywgcmVhY3QpIHtcbiAgdGhpcy5pZCA9ICsrT1BfSUQ7XG4gIHRoaXMudmFsdWUgPSBpbml0O1xuICB0aGlzLnN0YW1wID0gLTE7XG4gIHRoaXMucmFuayA9IC0xO1xuICB0aGlzLnFyYW5rID0gLTE7XG4gIHRoaXMuZmxhZ3MgPSAwO1xuXG4gIGlmICh1cGRhdGUpIHtcbiAgICB0aGlzLl91cGRhdGUgPSB1cGRhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zKSB0aGlzLnBhcmFtZXRlcnMocGFyYW1zLCByZWFjdCk7XG59XG5cbmZ1bmN0aW9uIGZsYWcoYml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICBjb25zdCBmID0gdGhpcy5mbGFncztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICEhKGYgJiBiaXQpO1xuICAgIHRoaXMuZmxhZ3MgPSBzdGF0ZSA/IGYgfCBiaXQgOiBmICYgfmJpdDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuT3BlcmF0b3IucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdGFyZ2V0IG9wZXJhdG9ycyBkZXBlbmRlbnQgb24gdGhpcyBvcGVyYXRvci5cbiAgICogSWYgdGhpcyBsaXN0IGRvZXMgbm90IGV4aXN0LCBpdCBpcyBjcmVhdGVkIGFuZCB0aGVuIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtVbmlxdWVMaXN0fVxuICAgKi9cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cyB8fCAodGhpcy5fdGFyZ2V0cyA9IFVuaXF1ZUxpc3QoaWQpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyAxIGlmIHRoZSBvcGVyYXRvciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiAgIGFjY29yZGluZyB0byBzdHJpY3QgZXF1YWxpdHksIHJldHVybnMgMCBvdGhlcndpc2UuXG4gICAqL1xuICBzZXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB0aGF0IG9wZXJhdG9yIGV2YWx1YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgb24gdGhlIG5leHQgcHVsc2UuXG4gICAqIFRoaXMgb3BlcmF0b3Igd2lsbCBzdGlsbCBwcm9wYWdhdGUgaW5jb21pbmcgcHVsc2VzLCBidXQgaXRzIHVwZGF0ZSBmdW5jdGlvblxuICAgKiB3aWxsIG5vdCBiZSBpbnZva2VkLiBUaGUgc2tpcCBmbGFnIGlzIHJlc2V0IGFmdGVyIGV2ZXJ5IHB1bHNlLCBzbyBjYWxsaW5nXG4gICAqIHRoaXMgbWV0aG9kIHdpbGwgYWZmZWN0IHByb2Nlc3Npbmcgb2YgdGhlIG5leHQgcHVsc2Ugb25seS5cbiAgICovXG4gIHNraXA6IGZsYWcoU0tJUCQxKSxcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhpcyBvcGVyYXRvcidzIHZhbHVlIGhhcyBiZWVuIG1vZGlmaWVkIG9uIGl0cyBtb3N0IHJlY2VudFxuICAgKiBwdWxzZS4gTm9ybWFsbHkgbW9kaWZpY2F0aW9uIGlzIGNoZWNrZWQgdmlhIHN0cmljdCBlcXVhbGl0eTsgaG93ZXZlciwgaW5cbiAgICogc29tZSBjYXNlcyBpdCBpcyBtb3JlIGVmZmljaWVudCB0byB1cGRhdGUgdGhlIGludGVybmFsIHN0YXRlIG9mIGFuIG9iamVjdC5cbiAgICogSW4gdGhvc2UgY2FzZXMsIHRoZSBtb2RpZmllZCBmbGFnIGNhbiBiZSB1c2VkIHRvIHRyaWdnZXIgcHJvcGFnYXRpb24uIE9uY2VcbiAgICogc2V0LCB0aGUgbW9kaWZpY2F0aW9uIGZsYWcgcGVyc2lzdHMgYWNyb3NzIHB1bHNlcyB1bnRpbCB1bnNldC4gVGhlIGZsYWcgY2FuXG4gICAqIGJlIHVzZWQgd2l0aCB0aGUgbGFzdCB0aW1lc3RhbXAgdG8gdGVzdCBpZiBhIG1vZGlmaWNhdGlvbiBpcyByZWNlbnQuXG4gICAqL1xuICBtb2RpZmllZDogZmxhZyhNT0RJRklFRCksXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBhbmFseXplZCBmb3JcbiAgICogb3BlcmF0b3IgaW5zdGFuY2VzLiBJZiBmb3VuZCwgdGhpcyBvcGVyYXRvciB3aWxsIGJlIGFkZGVkIGFzIGEgZGVwZW5kZW5jeVxuICAgKiBvZiB0aGUgcGFyYW1ldGVyaXppbmcgb3BlcmF0b3IuIE9wZXJhdG9yIHZhbHVlcyBhcmUgZHluYW1pY2FsbHkgbWFyc2hhbGxlZFxuICAgKiBmcm9tIGVhY2ggb3BlcmF0b3IgcGFyYW1ldGVyIHByaW9yIHRvIGV2YWx1YXRpb24uIElmIGEgcGFyYW1ldGVyIHZhbHVlIGlzXG4gICAqIGFuIGFycmF5LCB0aGUgYXJyYXkgd2lsbCBhbHNvIGJlIHNlYXJjaGVkIGZvciBPcGVyYXRvciBpbnN0YW5jZXMuIEhvd2V2ZXIsXG4gICAqIHRoZSBzZWFyY2ggZG9lcyBub3QgcmVjdXJzZSBpbnRvIHN1Yi1hcnJheXMgb3Igb2JqZWN0IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBBIGhhc2ggb2Ygb3BlcmF0b3IgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVhY3Q9dHJ1ZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICAgKiAgIGF1dG9tYXRpY2FsbHkgdXBkYXRlIChyZWFjdCkgd2hlbiBwYXJhbWV0ZXIgdmFsdWVzIGNoYW5nZS4gSW4gb3RoZXIgd29yZHMsXG4gICAqICAgdGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG9wZXJhdG9yIHJlZ2lzdGVycyBpdHNlbGYgYXMgYSBsaXN0ZW5lciBvblxuICAgKiAgIGFueSB1cHN0cmVhbSBvcGVyYXRvcnMgaW5jbHVkZWQgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRvbmx5PWZhbHNlXSAtIEEgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgb3BlcmF0b3JcbiAgICogICBzaG91bGQgY2FsY3VsYXRlIGFuIHVwZGF0ZSBvbmx5IHVwb24gaXRzIGluaXRpYXRhbCBldmFsdWF0aW9uLCB0aGVuXG4gICAqICAgZGVyZWdpc3RlciBkZXBlbmRlbmNpZXMgYW5kIHN1cHByZXNzIGFsbCBmdXR1cmUgdXBkYXRlIGludm9jYXRpb25zLlxuICAgKiBAcmV0dXJuIHtPcGVyYXRvcltdfSAtIEFuIGFycmF5IG9mIHVwc3RyZWFtIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIHBhcmFtZXRlcnMocGFyYW1zLCByZWFjdCwgaW5pdG9ubHkpIHtcbiAgICByZWFjdCA9IHJlYWN0ICE9PSBmYWxzZTtcbiAgICBjb25zdCBhcmd2YWwgPSB0aGlzLl9hcmd2YWwgPSB0aGlzLl9hcmd2YWwgfHwgbmV3IFBhcmFtZXRlcnMoKSxcbiAgICAgICAgICBhcmdvcHMgPSB0aGlzLl9hcmdvcHMgPSB0aGlzLl9hcmdvcHMgfHwgW10sXG4gICAgICAgICAgZGVwcyA9IFtdO1xuICAgIGxldCBuYW1lLCB2YWx1ZSwgbiwgaTtcblxuICAgIGNvbnN0IGFkZCA9IChuYW1lLCBpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9wZXJhdG9yKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcykge1xuICAgICAgICAgIGlmIChyZWFjdCkgdmFsdWUudGFyZ2V0cygpLmFkZCh0aGlzKTtcbiAgICAgICAgICBkZXBzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJnb3BzLnB1c2goe1xuICAgICAgICAgIG9wOiB2YWx1ZSxcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3ZhbC5zZXQobmFtZSwgaW5kZXgsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChuYW1lIGluIHBhcmFtcykge1xuICAgICAgdmFsdWUgPSBwYXJhbXNbbmFtZV07XG5cbiAgICAgIGlmIChuYW1lID09PSBQVUxTRSkge1xuICAgICAgICBhcnJheSh2YWx1ZSkuZm9yRWFjaChvcCA9PiB7XG4gICAgICAgICAgaWYgKCEob3AgaW5zdGFuY2VvZiBPcGVyYXRvcikpIHtcbiAgICAgICAgICAgIGVycm9yKCdQdWxzZSBwYXJhbWV0ZXJzIG11c3QgYmUgb3BlcmF0b3IgaW5zdGFuY2VzLicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3AgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIG9wLnRhcmdldHMoKS5hZGQodGhpcyk7XG4gICAgICAgICAgICBkZXBzLnB1c2gob3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyZ3ZhbC5zZXQobmFtZSwgLTEsIEFycmF5KG4gPSB2YWx1ZS5sZW5ndGgpKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBhZGQobmFtZSwgaSwgdmFsdWVbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkKG5hbWUsIC0xLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5tYXJzaGFsbCgpLmNsZWFyKCk7IC8vIGluaXRpYWxpemUgdmFsdWVzXG5cbiAgICBpZiAoaW5pdG9ubHkpIGFyZ29wcy5pbml0b25seSA9IHRydWU7XG4gICAgcmV0dXJuIGRlcHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgbWFyc2hhbGxpbmcgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICogVmlzaXRzIGVhY2ggb3BlcmF0b3IgZGVwZW5kZW5jeSB0byBwdWxsIHRoZSBsYXRlc3QgdmFsdWUuXG4gICAqIEByZXR1cm4ge1BhcmFtZXRlcnN9IEEgUGFyYW1ldGVycyBvYmplY3QgdG8gcGFzcyB0byB0aGUgdXBkYXRlIGZ1bmN0aW9uLlxuICAgKi9cbiAgbWFyc2hhbGwoc3RhbXApIHtcbiAgICBjb25zdCBhcmd2YWwgPSB0aGlzLl9hcmd2YWwgfHwgTk9fUEFSQU1TLFxuICAgICAgICAgIGFyZ29wcyA9IHRoaXMuX2FyZ29wcztcbiAgICBsZXQgaXRlbSwgaSwgb3AsIG1vZDtcblxuICAgIGlmIChhcmdvcHMpIHtcbiAgICAgIGNvbnN0IG4gPSBhcmdvcHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGl0ZW0gPSBhcmdvcHNbaV07XG4gICAgICAgIG9wID0gaXRlbS5vcDtcbiAgICAgICAgbW9kID0gb3AubW9kaWZpZWQoKSAmJiBvcC5zdGFtcCA9PT0gc3RhbXA7XG4gICAgICAgIGFyZ3ZhbC5zZXQoaXRlbS5uYW1lLCBpdGVtLmluZGV4LCBvcC52YWx1ZSwgbW9kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ29wcy5pbml0b25seSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgICBpdGVtLm9wLnRhcmdldHMoKS5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hcmdvcHMgPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcmd2YWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaCB0aGlzIG9wZXJhdG9yIGZyb20gdGhlIGRhdGFmbG93LlxuICAgKiBVbnJlZ2lzdGVycyBsaXN0ZW5lcnMgb24gdXBzdHJlYW0gZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIGNvbnN0IGFyZ29wcyA9IHRoaXMuX2FyZ29wcztcbiAgICBsZXQgaSwgbiwgaXRlbSwgb3A7XG5cbiAgICBpZiAoYXJnb3BzKSB7XG4gICAgICBmb3IgKGkgPSAwLCBuID0gYXJnb3BzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpdGVtID0gYXJnb3BzW2ldO1xuICAgICAgICBvcCA9IGl0ZW0ub3A7XG5cbiAgICAgICAgaWYgKG9wLl90YXJnZXRzKSB7XG4gICAgICAgICAgb3AuX3RhcmdldHMucmVtb3ZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGUgc291cmNlIGFuZCBwdWxzZSBvYmplY3QsXG4gICAgLy8gaWYgcHJlc2VudCwgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgb2Ygb2xkIGRhdGEuXG5cblxuICAgIHRoaXMucHVsc2UgPSBudWxsO1xuICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZWdhdGUgbWV0aG9kIHRvIHBlcmZvcm0gb3BlcmF0b3IgcHJvY2Vzc2luZy5cbiAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjdXN0b20gcHJvY2Vzc2luZy5cbiAgICogQnkgZGVmYXVsdCwgaXQgbWFyc2hhbGxzIHBhcmFtZXRlcnMgYW5kIGNhbGxzIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAgICogaWYgdGhhdCBmdW5jdGlvbiBpcyBkZWZpbmVkLiBJZiB0aGUgdXBkYXRlIGZ1bmN0aW9uIGRvZXMgbm90XG4gICAqIGNoYW5nZSB0aGUgb3BlcmF0b3IgdmFsdWUgdGhlbiBTdG9wUHJvcGFnYXRpb24gaXMgcmV0dXJuZWQuXG4gICAqIElmIG5vIHVwZGF0ZSBmdW5jdGlvbiBpcyBkZWZpbmVkLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4gVGhlIG91dHB1dCBwdWxzZSBvciBTdG9wUHJvcGFnYXRpb24uIEEgZmFsc3kgcmV0dXJuIHZhbHVlXG4gICAqICAgKGluY2x1ZGluZyB1bmRlZmluZWQpIHdpbGwgbGV0IHRoZSBpbnB1dCBwdWxzZSBwYXNzIHRocm91Z2guXG4gICAqL1xuICBldmFsdWF0ZShwdWxzZSkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMubWFyc2hhbGwocHVsc2Uuc3RhbXApLFxuICAgICAgICAgICAgdiA9IHVwZGF0ZS5jYWxsKHRoaXMsIHBhcmFtcywgcHVsc2UpO1xuICAgICAgcGFyYW1zLmNsZWFyKCk7XG5cbiAgICAgIGlmICh2ICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2O1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5tb2RpZmllZCgpKSB7XG4gICAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSdW4gdGhpcyBvcGVyYXRvciBmb3IgdGhlIGN1cnJlbnQgcHVsc2UuIElmIHRoaXMgb3BlcmF0b3IgaGFzIGFscmVhZHlcbiAgICogYmVlbiBydW4gYXQgKG9yIGFmdGVyKSB0aGUgcHVsc2UgdGltZXN0YW1wLCByZXR1cm5zIFN0b3BQcm9wYWdhdGlvbi5cbiAgICogSW50ZXJuYWxseSwgdGhpcyBtZXRob2QgY2FsbHMge0BsaW5rIGV2YWx1YXRlfSB0byBwZXJmb3JtIHByb2Nlc3NpbmcuXG4gICAqIElmIHtAbGluayBldmFsdWF0ZX0gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCB0aGUgaW5wdXQgcHVsc2UgaXMgcmV0dXJuZWQuXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBOT1QgYmUgb3ZlcnJpZGRlbiwgaW5zdGVhZCBvdmVycnJpZGUge0BsaW5rIGV2YWx1YXRlfS5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSB0aGUgY3VycmVudCBkYXRhZmxvdyBwdWxzZS5cbiAgICogQHJldHVybiB0aGUgb3V0cHV0IHB1bHNlIGZvciB0aGlzIG9wZXJhdG9yIChvciBTdG9wUHJvcGFnYXRpb24pXG4gICAqL1xuICBydW4ocHVsc2UpIHtcbiAgICBpZiAocHVsc2Uuc3RhbXAgPCB0aGlzLnN0YW1wKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIGxldCBydjtcblxuICAgIGlmICh0aGlzLnNraXAoKSkge1xuICAgICAgdGhpcy5za2lwKGZhbHNlKTtcbiAgICAgIHJ2ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnYgPSB0aGlzLmV2YWx1YXRlKHB1bHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wdWxzZSA9IHJ2IHx8IHB1bHNlO1xuICB9XG5cbn07XG5cbi8qKlxuICogQWRkIGFuIG9wZXJhdG9yIHRvIHRoZSBkYXRhZmxvdyBncmFwaC4gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFcbiAqIHZhcmlldHkgb2YgaW5wdXQgYXJndW1lbnQgdHlwZXMuIFRoZSBiYXNpYyBzaWduYXR1cmUgc3VwcG9ydHMgYW5cbiAqIGluaXRpYWwgdmFsdWUsIHVwZGF0ZSBmdW5jdGlvbiBhbmQgcGFyYW1ldGVycy4gSWYgdGhlIGZpcnN0IHBhcmFtZXRlclxuICogaXMgYW4gT3BlcmF0b3IgaW5zdGFuY2UsIGl0IHdpbGwgYmUgYWRkZWQgZGlyZWN0bHkuIElmIGl0IGlzIGFcbiAqIGNvbnN0cnVjdG9yIGZvciBhbiBPcGVyYXRvciBzdWJjbGFzcywgYSBuZXcgaW5zdGFuY2Ugd2lsbCBiZSBpbnN0YW50aWF0ZWQuXG4gKiBPdGhlcndpc2UsIGlmIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiBpbnN0YW5jZSwgaXQgd2lsbCBiZSB1c2VkXG4gKiBhcyB0aGUgdXBkYXRlIGZ1bmN0aW9uIGFuZCBhIG51bGwgaW5pdGlhbCB2YWx1ZSBpcyBhc3N1bWVkLlxuICogQHBhcmFtIHsqfSBpbml0IC0gT25lIG9mOiB0aGUgb3BlcmF0b3IgdG8gYWRkLCB0aGUgaW5pdGlhbCB2YWx1ZSBvZlxuICogICB0aGUgb3BlcmF0b3IsIGFuIG9wZXJhdG9yIGNsYXNzIHRvIGluc3RhbnRpYXRlLCBvciBhbiB1cGRhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbdXBkYXRlXSAtIFRoZSBvcGVyYXRvciB1cGRhdGUgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gLSBUaGUgb3BlcmF0b3IgcGFyYW1ldGVycy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlYWN0PXRydWVdIC0gRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgb3BlcmF0b3Igc2hvdWxkXG4gKiAgIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB1cHN0cmVhbSBvcGVyYXRvcnMgaW5jbHVkZWQgYXMgcGFyYW1ldGVycy5cbiAqIEByZXR1cm4ge09wZXJhdG9yfSAtIFRoZSBhZGRlZCBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBhZGQgKGluaXQsIHVwZGF0ZSwgcGFyYW1zLCByZWFjdCkge1xuICBsZXQgc2hpZnQgPSAxLFxuICAgICAgb3A7XG5cbiAgaWYgKGluaXQgaW5zdGFuY2VvZiBPcGVyYXRvcikge1xuICAgIG9wID0gaW5pdDtcbiAgfSBlbHNlIGlmIChpbml0ICYmIGluaXQucHJvdG90eXBlIGluc3RhbmNlb2YgT3BlcmF0b3IpIHtcbiAgICBvcCA9IG5ldyBpbml0KCk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihpbml0KSkge1xuICAgIG9wID0gbmV3IE9wZXJhdG9yKG51bGwsIGluaXQpO1xuICB9IGVsc2Uge1xuICAgIHNoaWZ0ID0gMDtcbiAgICBvcCA9IG5ldyBPcGVyYXRvcihpbml0LCB1cGRhdGUpO1xuICB9XG5cbiAgdGhpcy5yYW5rKG9wKTtcblxuICBpZiAoc2hpZnQpIHtcbiAgICByZWFjdCA9IHBhcmFtcztcbiAgICBwYXJhbXMgPSB1cGRhdGU7XG4gIH1cblxuICBpZiAocGFyYW1zKSB0aGlzLmNvbm5lY3Qob3AsIG9wLnBhcmFtZXRlcnMocGFyYW1zLCByZWFjdCkpO1xuICB0aGlzLnRvdWNoKG9wKTtcbiAgcmV0dXJuIG9wO1xufVxuXG4vKipcbiAqIENvbm5lY3QgYSB0YXJnZXQgb3BlcmF0b3IgYXMgYSBkZXBlbmRlbnQgb2Ygc291cmNlIG9wZXJhdG9ycy5cbiAqIElmIG5lY2Vzc2FyeSwgdGhpcyBtZXRob2Qgd2lsbCByZXJhbmsgdGhlIHRhcmdldCBvcGVyYXRvciBhbmQgaXRzXG4gKiBkZXBlbmRlbnRzIHRvIGVuc3VyZSBwcm9wYWdhdGlvbiBwcm9jZWVkcyBpbiBhIHRvcG9sb2dpY2FsbHkgc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8T3BlcmF0b3I+fSAtIFRoZSBzb3VyY2Ugb3BlcmF0b3JzIHRoYXQgc2hvdWxkIHByb3BhZ2F0ZVxuICogICB0byB0aGUgdGFyZ2V0IG9wZXJhdG9yLlxuICovXG5mdW5jdGlvbiBjb25uZWN0ICh0YXJnZXQsIHNvdXJjZXMpIHtcbiAgY29uc3QgdGFyZ2V0UmFuayA9IHRhcmdldC5yYW5rLFxuICAgICAgICBuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodGFyZ2V0UmFuayA8IHNvdXJjZXNbaV0ucmFuaykge1xuICAgICAgdGhpcy5yZXJhbmsodGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxubGV0IFNUUkVBTV9JRCA9IDA7XG4vKipcbiAqIE1vZGVscyBhbiBldmVudCBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0LCBudW1iZXIpOiBib29sZWFufSBbZmlsdGVyXSAtIEZpbHRlciBwcmVkaWNhdGUuXG4gKiAgIEV2ZW50cyBwYXNzIHRocm91Z2ggd2hlbiB0cnV0aHksIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCB3aGVuIGZhbHN5LlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpOiAqfSBbYXBwbHldIC0gQXBwbGllZCB0byBpbnB1dCBldmVudHMgdG8gcHJvZHVjZVxuICogICBuZXcgZXZlbnQgdmFsdWVzLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBbcmVjZWl2ZV0gLSBFdmVudCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgdXBvbiByZWNlaXB0IG9mIGEgbmV3IGV2ZW50LiBVc2UgdG8gb3ZlcnJpZGUgc3RhbmRhcmQgZXZlbnQgcHJvY2Vzc2luZy5cbiAqL1xuXG5mdW5jdGlvbiBFdmVudFN0cmVhbShmaWx0ZXIsIGFwcGx5LCByZWNlaXZlKSB7XG4gIHRoaXMuaWQgPSArK1NUUkVBTV9JRDtcbiAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIGlmIChyZWNlaXZlKSB0aGlzLnJlY2VpdmUgPSByZWNlaXZlO1xuICBpZiAoZmlsdGVyKSB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XG4gIGlmIChhcHBseSkgdGhpcy5fYXBwbHkgPSBhcHBseTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBldmVudCBzdHJlYW0gaW5zdGFuY2Ugd2l0aCB0aGUgcHJvdmlkZWRcbiAqIChvcHRpb25hbCkgZmlsdGVyLCBhcHBseSBhbmQgcmVjZWl2ZSBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCwgbnVtYmVyKTogYm9vbGVhbn0gW2ZpbHRlcl0gLSBGaWx0ZXIgcHJlZGljYXRlLlxuICogICBFdmVudHMgcGFzcyB0aHJvdWdoIHdoZW4gdHJ1dGh5LCBldmVudHMgYXJlIHN1cHByZXNzZWQgd2hlbiBmYWxzeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogKn0gW2FwcGx5XSAtIEFwcGxpZWQgdG8gaW5wdXQgZXZlbnRzIHRvIHByb2R1Y2VcbiAqICAgbmV3IGV2ZW50IHZhbHVlcy5cbiAqIEBzZWUgRXZlbnRTdHJlYW1cbiAqL1xuXG5mdW5jdGlvbiBzdHJlYW0oZmlsdGVyLCBhcHBseSwgcmVjZWl2ZSkge1xuICByZXR1cm4gbmV3IEV2ZW50U3RyZWFtKGZpbHRlciwgYXBwbHksIHJlY2VpdmUpO1xufVxuRXZlbnRTdHJlYW0ucHJvdG90eXBlID0ge1xuICBfZmlsdGVyOiB0cnV0aHksXG4gIF9hcHBseTogaWRlbnRpdHksXG5cbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cyB8fCAodGhpcy5fdGFyZ2V0cyA9IFVuaXF1ZUxpc3QoaWQpKTtcbiAgfSxcblxuICBjb25zdW1lKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAhIXRoaXMuX2NvbnN1bWU7XG4gICAgdGhpcy5fY29uc3VtZSA9ICEhXztcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICByZWNlaXZlKGV2dCkge1xuICAgIGlmICh0aGlzLl9maWx0ZXIoZXZ0KSkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy52YWx1ZSA9IHRoaXMuX2FwcGx5KGV2dCksXG4gICAgICAgICAgICB0cmcgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICAgICAgbiA9IHRyZyA/IHRyZy5sZW5ndGggOiAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgdHJnW2ldLnJlY2VpdmUodmFsKTtcblxuICAgICAgaWYgKHRoaXMuX2NvbnN1bWUpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZmlsdGVyKGZpbHRlcikge1xuICAgIGNvbnN0IHMgPSBzdHJlYW0oZmlsdGVyKTtcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQocyk7XG4gICAgcmV0dXJuIHM7XG4gIH0sXG5cbiAgYXBwbHkoYXBwbHkpIHtcbiAgICBjb25zdCBzID0gc3RyZWFtKG51bGwsIGFwcGx5KTtcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQocyk7XG4gICAgcmV0dXJuIHM7XG4gIH0sXG5cbiAgbWVyZ2UoKSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbSgpO1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZChzKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgYXJndW1lbnRzW2ldLnRhcmdldHMoKS5hZGQocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG4gIH0sXG5cbiAgdGhyb3R0bGUocGF1c2UpIHtcbiAgICBsZXQgdCA9IC0xO1xuICAgIHJldHVybiB0aGlzLmZpbHRlcigoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiAobm93IC0gdCA+IHBhdXNlKSB7XG4gICAgICAgIHQgPSBub3c7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVib3VuY2UoZGVsYXkpIHtcbiAgICBjb25zdCBzID0gc3RyZWFtKCk7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHN0cmVhbShudWxsLCBudWxsLCBkZWJvdW5jZShkZWxheSwgZSA9PiB7XG4gICAgICBjb25zdCBkZiA9IGUuZGF0YWZsb3c7XG4gICAgICBzLnJlY2VpdmUoZSk7XG4gICAgICBpZiAoZGYgJiYgZGYucnVuKSBkZi5ydW4oKTtcbiAgICB9KSkpO1xuICAgIHJldHVybiBzO1xuICB9LFxuXG4gIGJldHdlZW4oYSwgYikge1xuICAgIGxldCBhY3RpdmUgPSBmYWxzZTtcbiAgICBhLnRhcmdldHMoKS5hZGQoc3RyZWFtKG51bGwsIG51bGwsICgpID0+IGFjdGl2ZSA9IHRydWUpKTtcbiAgICBiLnRhcmdldHMoKS5hZGQoc3RyZWFtKG51bGwsIG51bGwsICgpID0+IGFjdGl2ZSA9IGZhbHNlKSk7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKCgpID0+IGFjdGl2ZSk7XG4gIH0sXG5cbiAgZGV0YWNoKCkge1xuICAgIC8vIGVuc3VyZXMgY29tcGF0aWJpbGl0eSB3aXRoIG9wZXJhdG9ycyAoIzI3NTMpXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gb3RoZXIgc3RyZWFtcyBhbmQgZmlsdGVyIGZ1bmN0aW9ucyB0aGF0IG1heVxuICAgIC8vIGJlIGJvdW5kIHRvIHN1YmNvbnRleHRzIHRoYXQgbmVlZCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICB0aGlzLl9maWx0ZXIgPSB0cnV0aHk7XG4gICAgdGhpcy5fdGFyZ2V0cyA9IG51bGw7XG4gIH1cblxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXZlbnQgc3RyZWFtIGZyb20gYW4gZXZlbnQgc291cmNlLlxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSAtIFRoZSBldmVudCBzb3VyY2UgdG8gbW9uaXRvci4gVGhlIGlucHV0IG11c3RcbiAqICBzdXBwb3J0IHRoZSBhZGRFdmVudExpc3RlbmVyIG1ldGhvZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IGJvb2xlYW59IFtmaWx0ZXJdIC0gRXZlbnQgZmlsdGVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbYXBwbHldIC0gRXZlbnQgYXBwbGljYXRpb24gZnVuY3Rpb24uXG4gKiAgIElmIHByb3ZpZGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhbmQgdGhlIHJlc3VsdCB3aWxsIGJlXG4gKiAgIHVzZWQgYXMgdGhlIGRvd25zdHJlYW0gZXZlbnQgdmFsdWUuXG4gKiBAcmV0dXJuIHtFdmVudFN0cmVhbX1cbiAqL1xuXG5mdW5jdGlvbiBldmVudHMgKHNvdXJjZSwgdHlwZSwgZmlsdGVyLCBhcHBseSkge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgICAgIHMgPSBzdHJlYW0oZmlsdGVyLCBhcHBseSksXG4gICAgICAgIHNlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGUuZGF0YWZsb3cgPSBkZjtcblxuICAgIHRyeSB7XG4gICAgICBzLnJlY2VpdmUoZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRmLmVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGYucnVuKCk7XG4gICAgfVxuICB9O1xuXG4gIGxldCBzb3VyY2VzO1xuXG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc291cmNlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2VzID0gYXJyYXkoc291cmNlKTtcbiAgfVxuXG4gIGNvbnN0IG4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHNvdXJjZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kKTtcbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCBmb3JtYXQpIHtcbiAgY29uc3QgbG9jYWxlID0gdGhpcy5sb2NhbGUoKTtcbiAgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0LCBsb2NhbGUudGltZVBhcnNlLCBsb2NhbGUudXRjUGFyc2UpO1xufVxuLyoqXG4gKiBJbmdlc3RzIG5ldyBkYXRhIGludG8gdGhlIGRhdGFmbG93LiBGaXJzdCBwYXJzZXMgdGhlIGRhdGEgdXNpbmcgdGhlXG4gKiB2ZWdhLWxvYWRlciByZWFkIG1ldGhvZCwgdGhlbiBwdWxzZXMgYSBjaGFuZ2VzZXQgdG8gdGhlIHRhcmdldCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IHRhcmdldCAtIFRoZSBPcGVyYXRvciB0byB0YXJnZXQgd2l0aCBpbmdlc3RlZCBkYXRhLFxuICogICB0eXBpY2FsbHkgYSBDb2xsZWN0IHRyYW5zZm9ybSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Kn0gZGF0YSAtIFRoZSBpbnB1dCBkYXRhLCBwcmlvciB0byBwYXJzaW5nLiBGb3IgSlNPTiB0aGlzIG1heVxuICogICBiZSBhIHN0cmluZyBvciBhbiBvYmplY3QuIEZvciBDU1YsIFRTViwgZXRjIHNob3VsZCBiZSBhIHN0cmluZy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmb3JtYXQgLSBUaGUgZGF0YSBmb3JtYXQgZGVzY3JpcHRpb24gZm9yIHBhcnNpbmdcbiAqICAgbG9hZGVkIGRhdGEuIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byB0aGUgdmVnYS1sb2FkZXIgcmVhZCBtZXRob2QuXG4gKiBAcmV0dXJucyB7RGF0YWZsb3d9XG4gKi9cblxuZnVuY3Rpb24gaW5nZXN0KHRhcmdldCwgZGF0YSwgZm9ybWF0KSB7XG4gIGRhdGEgPSB0aGlzLnBhcnNlKGRhdGEsIGZvcm1hdCk7XG4gIHJldHVybiB0aGlzLnB1bHNlKHRhcmdldCwgdGhpcy5jaGFuZ2VzZXQoKS5pbnNlcnQoZGF0YSkpO1xufVxuLyoqXG4gKiBSZXF1ZXN0IGRhdGEgZnJvbSBhbiBleHRlcm5hbCBzb3VyY2UsIHBhcnNlIGl0LCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIGZyb20gd2hpY2ggdG8gbG9hZCB0aGUgZGF0YS4gVGhpcyBzdHJpbmdcbiAqICAgaXMgcGFzc2VkIHRvIHRoZSB2ZWdhLWxvYWRlciBsb2FkIG1ldGhvZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbZm9ybWF0XSAtIFRoZSBkYXRhIGZvcm1hdCBkZXNjcmlwdGlvbiBmb3IgcGFyc2luZ1xuICogICBsb2FkZWQgZGF0YS4gVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSB2ZWdhLWxvYWRlciByZWFkIG1ldGhvZC5cbiAqIEByZXR1cm4ge1Byb21pc2V9IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHVwb24gY29tcGxldGlvbiBvZiB0aGUgcmVxdWVzdC5cbiAqICAgVGhlIHJlc29sdmVkIG9iamVjdCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgIC0gZGF0YTogYW4gYXJyYXkgb2YgcGFyc2VkIGRhdGEgKG9yIG51bGwgdXBvbiBlcnJvcilcbiAqICAgLSBzdGF0dXM6IGEgY29kZSBmb3Igc3VjY2VzcyAoMCksIGxvYWQgZmFpbCAoLTEpLCBvciBwYXJzZSBmYWlsICgtMilcbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgZm9ybWF0KSB7XG4gIGNvbnN0IGRmID0gdGhpcztcbiAgbGV0IHN0YXR1cyA9IDAsXG4gICAgICBkYXRhO1xuXG4gIHRyeSB7XG4gICAgZGF0YSA9IGF3YWl0IGRmLmxvYWRlcigpLmxvYWQodXJsLCB7XG4gICAgICBjb250ZXh0OiAnZGF0YWZsb3cnLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlVHlwZShmb3JtYXQgJiYgZm9ybWF0LnR5cGUpXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgZGF0YSA9IGRmLnBhcnNlKGRhdGEsIGZvcm1hdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdGF0dXMgPSAtMjtcbiAgICAgIGRmLndhcm4oJ0RhdGEgaW5nZXN0aW9uIGZhaWxlZCcsIHVybCwgZXJyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN0YXR1cyA9IC0xO1xuICAgIGRmLndhcm4oJ0xvYWRpbmcgZmFpbGVkJywgdXJsLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhLFxuICAgIHN0YXR1c1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcHJlbG9hZCh0YXJnZXQsIHVybCwgZm9ybWF0KSB7XG4gIGNvbnN0IGRmID0gdGhpcyxcbiAgICAgICAgcGVuZGluZyA9IGRmLl9wZW5kaW5nIHx8IGxvYWRQZW5kaW5nKGRmKTtcbiAgcGVuZGluZy5yZXF1ZXN0cyArPSAxO1xuICBjb25zdCByZXMgPSBhd2FpdCBkZi5yZXF1ZXN0KHVybCwgZm9ybWF0KTtcbiAgZGYucHVsc2UodGFyZ2V0LCBkZi5jaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQocmVzLmRhdGEgfHwgW10pKTtcbiAgcGVuZGluZy5kb25lKCk7XG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGxvYWRQZW5kaW5nKGRmKSB7XG4gIGxldCBhY2NlcHQ7XG4gIGNvbnN0IHBlbmRpbmcgPSBuZXcgUHJvbWlzZShhID0+IGFjY2VwdCA9IGEpO1xuICBwZW5kaW5nLnJlcXVlc3RzID0gMDtcblxuICBwZW5kaW5nLmRvbmUgPSAoKSA9PiB7XG4gICAgaWYgKC0tcGVuZGluZy5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgZGYuX3BlbmRpbmcgPSBudWxsO1xuICAgICAgYWNjZXB0KGRmKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRmLl9wZW5kaW5nID0gcGVuZGluZztcbn1cblxuY29uc3QgU0tJUCA9IHtcbiAgc2tpcDogdHJ1ZVxufTtcbi8qKlxuICogUGVyZm9ybSBvcGVyYXRvciB1cGRhdGVzIGluIHJlc3BvbnNlIHRvIGV2ZW50cy4gQXBwbGllcyBhblxuICogdXBkYXRlIGZ1bmN0aW9uIHRvIGNvbXB1dGUgYSBuZXcgb3BlcmF0b3IgdmFsdWUuIElmIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAqIHJldHVybnMgYSB7QGxpbmsgQ2hhbmdlU2V0fSwgdGhlIG9wZXJhdG9yIHdpbGwgYmUgcHVsc2VkIHdpdGggdGhvc2UgdHVwbGVcbiAqIGNoYW5nZXMuIE90aGVyd2lzZSwgdGhlIG9wZXJhdG9yIHZhbHVlIHdpbGwgYmUgdXBkYXRlZCB0byB0aGUgcmV0dXJuIHZhbHVlLlxuICogQHBhcmFtIHtFdmVudFN0cmVhbXxPcGVyYXRvcn0gc291cmNlIC0gVGhlIGV2ZW50IHNvdXJjZSB0byByZWFjdCB0by5cbiAqICAgVGhpcyBhcmd1bWVudCBjYW4gYmUgZWl0aGVyIGFuIEV2ZW50U3RyZWFtIG9yIGFuIE9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcnxmdW5jdGlvbihvYmplY3QpOk9wZXJhdG9yfSB0YXJnZXQgLSBUaGUgb3BlcmF0b3IgdG8gdXBkYXRlLlxuICogICBUaGlzIGFyZ3VtZW50IGNhbiBlaXRoZXIgYmUgYW4gT3BlcmF0b3IgaW5zdGFuY2Ugb3IgKGlmIHRoZSBzb3VyY2VcbiAqICAgYXJndW1lbnQgaXMgYW4gRXZlbnRTdHJlYW0pLCBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBldmVudCBvYmplY3QgYXNcbiAqICAgaW5wdXQgYW5kIHJldHVybnMgYW4gT3BlcmF0b3IgdG8gdGFyZ2V0LlxuICogQHBhcmFtIHtmdW5jdGlvbihQYXJhbWV0ZXJzLEV2ZW50KTogKn0gW3VwZGF0ZV0gLSBPcHRpb25hbCB1cGRhdGUgZnVuY3Rpb25cbiAqICAgdG8gY29tcHV0ZSB0aGUgbmV3IG9wZXJhdG9yIHZhbHVlLCBvciBhIGxpdGVyYWwgdmFsdWUgdG8gc2V0LiBVcGRhdGVcbiAqICAgZnVuY3Rpb25zIGV4cGVjdCB0byByZWNlaXZlIGEgcGFyYW1ldGVyIG9iamVjdCBhbmQgZXZlbnQgYXMgYXJndW1lbnRzLlxuICogICBUaGlzIGZ1bmN0aW9uIGNhbiBlaXRoZXIgcmV0dXJuIGEgbmV3IG9wZXJhdG9yIHZhbHVlIG9yIChpZiB0aGUgc291cmNlXG4gKiAgIGFyZ3VtZW50IGlzIGFuIEV2ZW50U3RyZWFtKSBhIHtAbGluayBDaGFuZ2VTZXR9IGluc3RhbmNlIHRvIHB1bHNlXG4gKiAgIHRoZSB0YXJnZXQgb3BlcmF0b3Igd2l0aCB0dXBsZSBjaGFuZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIHVwZGF0ZSBmdW5jdGlvbiBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLiBJZiBub3Qgb3ZlcnJpZGRlbixcbiAqICAgdXBkYXRlZCBvcGVyYXRvcnMgd2lsbCBiZSBza2lwcGVkIGJ5IGRlZmF1bHQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBdIC0gSWYgdHJ1ZSwgdGhlIG9wZXJhdG9yIHdpbGxcbiAqICBiZSBza2lwcGVkOiBpdCB3aWxsIG5vdCBiZSBldmFsdWF0ZWQsIGJ1dCBpdHMgZGVwZW5kZW50cyB3aWxsIGJlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZV0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSByZS1ldmFsdWF0ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuICogQHJldHVybiB7RGF0YWZsb3d9XG4gKi9cblxuZnVuY3Rpb24gb24gKHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCBmbiA9IHNvdXJjZSBpbnN0YW5jZW9mIE9wZXJhdG9yID8gb25PcGVyYXRvciA6IG9uU3RyZWFtO1xuICBmbih0aGlzLCBzb3VyY2UsIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gb25TdHJlYW0oZGYsIHN0cmVhbSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBleHRlbmQoe30sIG9wdGlvbnMsIFNLSVApO1xuICBsZXQgZnVuYywgb3A7XG4gIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB0YXJnZXQgPSBjb25zdGFudCh0YXJnZXQpO1xuXG4gIGlmICh1cGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGZ1bmMgPSBlID0+IGRmLnRvdWNoKHRhcmdldChlKSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih1cGRhdGUpKSB7XG4gICAgb3AgPSBuZXcgT3BlcmF0b3IobnVsbCwgdXBkYXRlLCBwYXJhbXMsIGZhbHNlKTtcblxuICAgIGZ1bmMgPSBlID0+IHtcbiAgICAgIG9wLmV2YWx1YXRlKGUpO1xuICAgICAgY29uc3QgdCA9IHRhcmdldChlKSxcbiAgICAgICAgICAgIHYgPSBvcC52YWx1ZTtcbiAgICAgIGlzQ2hhbmdlU2V0KHYpID8gZGYucHVsc2UodCwgdiwgb3B0aW9ucykgOiBkZi51cGRhdGUodCwgdiwgb3B0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZ1bmMgPSBlID0+IGRmLnVwZGF0ZSh0YXJnZXQoZSksIHVwZGF0ZSwgb3B0KTtcbiAgfVxuXG4gIHN0cmVhbS5hcHBseShmdW5jKTtcbn1cblxuZnVuY3Rpb24gb25PcGVyYXRvcihkZiwgc291cmNlLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmICh1cGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZS50YXJnZXRzKCkuYWRkKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3B0ID0gb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgICBvcCA9IG5ldyBPcGVyYXRvcihudWxsLCB1cGRhdGVyKHRhcmdldCwgdXBkYXRlKSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgb3AubW9kaWZpZWQob3B0LmZvcmNlKTtcbiAgICBvcC5yYW5rID0gc291cmNlLnJhbms7IC8vIGltbWVkaWF0ZWx5IGZvbGxvdyBzb3VyY2VcblxuICAgIHNvdXJjZS50YXJnZXRzKCkuYWRkKG9wKTsgLy8gYWRkIGRlcGVuZGVuY3lcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIG9wLnNraXAodHJ1ZSk7IC8vIHNraXAgZmlyc3QgaW52b2NhdGlvblxuXG4gICAgICBvcC52YWx1ZSA9IHRhcmdldC52YWx1ZTsgLy8gaW5pdGlhbGl6ZSB2YWx1ZVxuXG4gICAgICBvcC50YXJnZXRzKCkuYWRkKHRhcmdldCk7IC8vIGNoYWluIGRlcGVuZGVuY2llc1xuXG4gICAgICBkZi5jb25uZWN0KHRhcmdldCwgW29wXSk7IC8vIHJlcmFuayBhcyBuZWVkZWQsICMxNjcyXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZXIodGFyZ2V0LCB1cGRhdGUpIHtcbiAgdXBkYXRlID0gaXNGdW5jdGlvbih1cGRhdGUpID8gdXBkYXRlIDogY29uc3RhbnQodXBkYXRlKTtcbiAgcmV0dXJuIHRhcmdldCA/IGZ1bmN0aW9uIChfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlKF8sIHB1bHNlKTtcblxuICAgIGlmICghdGFyZ2V0LnNraXAoKSkge1xuICAgICAgdGFyZ2V0LnNraXAodmFsdWUgIT09IHRoaXMudmFsdWUpLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IDogdXBkYXRlO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgYSByYW5rIHRvIGFuIG9wZXJhdG9yLiBSYW5rcyBhcmUgYXNzaWduZWQgaW4gaW5jcmVhc2luZyBvcmRlclxuICogYnkgaW5jcmVtZW50aW5nIGFuIGludGVybmFsIHJhbmsgY291bnRlci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIGFzc2lnbiBhIHJhbmsuXG4gKi9cblxuZnVuY3Rpb24gcmFuayhvcCkge1xuICBvcC5yYW5rID0gKyt0aGlzLl9yYW5rO1xufVxuLyoqXG4gKiBSZS1yYW5rcyBhbiBvcGVyYXRvciBhbmQgYWxsIGRvd25zdHJlYW0gdGFyZ2V0IGRlcGVuZGVuY2llcy4gVGhpc1xuICogaXMgbmVjZXNzYXJ5IHdoZW4gdXBzdHJlYW0gZGVwZW5kZW5jaWVzIG9mIGhpZ2hlciByYW5rIGFyZSBhZGRlZCB0b1xuICogYSB0YXJnZXQgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byByZS1yYW5rLlxuICovXG5cbmZ1bmN0aW9uIHJlcmFuayhvcCkge1xuICBjb25zdCBxdWV1ZSA9IFtvcF07XG4gIGxldCBjdXIsIGxpc3QsIGk7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIHRoaXMucmFuayhjdXIgPSBxdWV1ZS5wb3AoKSk7XG5cbiAgICBpZiAobGlzdCA9IGN1ci5fdGFyZ2V0cykge1xuICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgICBxdWV1ZS5wdXNoKGN1ciA9IGxpc3RbaV0pO1xuICAgICAgICBpZiAoY3VyID09PSBvcCkgZXJyb3IoJ0N5Y2xlIGRldGVjdGVkIGluIGRhdGFmbG93IGdyYXBoLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNlbnRpbmVsIHZhbHVlIGluZGljYXRpbmcgcHVsc2UgcHJvcGFnYXRpb24gc2hvdWxkIHN0b3AuXG4gKi9cblxuY29uc3QgU3RvcFByb3BhZ2F0aW9uID0ge307IC8vIFB1bHNlIHZpc2l0IHR5cGUgZmxhZ3NcblxuY29uc3QgQUREID0gMSA8PCAwLFxuICAgICAgUkVNID0gMSA8PCAxLFxuICAgICAgTU9EID0gMSA8PCAyLFxuICAgICAgQUREX1JFTSA9IEFERCB8IFJFTSxcbiAgICAgIEFERF9NT0QgPSBBREQgfCBNT0QsXG4gICAgICBBTEwgPSBBREQgfCBSRU0gfCBNT0QsXG4gICAgICBSRUZMT1cgPSAxIDw8IDMsXG4gICAgICBTT1VSQ0UgPSAxIDw8IDQsXG4gICAgICBOT19TT1VSQ0UgPSAxIDw8IDUsXG4gICAgICBOT19GSUVMRFMgPSAxIDw8IDY7XG4vKipcbiAqIEEgUHVsc2UgZW5hYmxlcyBpbnRlci1vcGVyYXRvciBjb21tdW5pY2F0aW9uIGR1cmluZyBhIHJ1biBvZiB0aGVcbiAqIGRhdGFmbG93IGdyYXBoLiBJbiBhZGRpdGlvbiB0byB0aGUgY3VycmVudCB0aW1lc3RhbXAsIGEgcHVsc2UgbWF5IGFsc29cbiAqIGNvbnRhaW4gYSBjaGFuZ2Utc2V0IG9mIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkIGRhdGEgdHVwbGVzLCBhcyB3ZWxsIGFzXG4gKiBhIHBvaW50ZXIgdG8gYSBmdWxsIGJhY2tpbmcgZGF0YSBzb3VyY2UuIFR1cGxlIGNoYW5nZSBzZXRzIG1heSBub3RcbiAqIGJlIGZ1bGx5IG1hdGVyaWFsaXplZDsgZm9yIGV4YW1wbGUsIHRvIHByZXZlbnQgbmVlZGxlc3MgYXJyYXkgY3JlYXRpb25cbiAqIGEgY2hhbmdlIHNldCBtYXkgaW5jbHVkZSBsYXJnZXIgYXJyYXlzIGFuZCBjb3JyZXNwb25kaW5nIGZpbHRlciBmdW5jdGlvbnMuXG4gKiBUaGUgcHVsc2UgcHJvdmlkZXMgYSB7QGxpbmsgdmlzaXR9IG1ldGhvZCB0byBlbmFibGUgcHJvcGVyIGFuZCBlZmZpY2llbnRcbiAqIGl0ZXJhdGlvbiBvdmVyIHJlcXVlc3RlZCBkYXRhIHR1cGxlcy5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgZWFjaCBwdWxzZSBjYW4gdHJhY2sgbW9kaWZpY2F0aW9uIGZsYWdzIGZvciBkYXRhIHR1cGxlIGZpZWxkcy5cbiAqIFJlc3BvbnNpYmxlIHRyYW5zZm9ybSBvcGVyYXRvcnMgc2hvdWxkIGNhbGwgdGhlIHtAbGluayBtb2RpZmllc30gbWV0aG9kIHRvXG4gKiBpbmRpY2F0ZSBjaGFuZ2VzIHRvIGRhdGEgZmllbGRzLiBUaGUge0BsaW5rIG1vZGlmaWVkfSBtZXRob2QgZW5hYmxlc1xuICogcXVlcnlpbmcgb2YgdGhpcyBtb2RpZmljYXRpb24gc3RhdGUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0RhdGFmbG93fSBkYXRhZmxvdyAtIFRoZSBiYWNraW5nIGRhdGFmbG93IGluc3RhbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0YW1wIC0gVGhlIGN1cnJlbnQgcHJvcGFnYXRpb24gdGltZXN0YW1wLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gQW4gb3B0aW9uYWwgZW5jb2Rpbmcgc2V0IG5hbWUsIHdoaWNoIGlzIHRoZW5cbiAqICAgYWNjZXNzaWJsZSBhcyBQdWxzZS5lbmNvZGUuIE9wZXJhdG9ycyBjYW4gcmVzcG9uZCB0byAob3IgaWdub3JlKSB0aGlzXG4gKiAgIHNldHRpbmcgYXMgYXBwcm9wcmlhdGUuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGhcbiAqICAgdGhlIEVuY29kZSB0cmFuc2Zvcm0gaW4gdGhlIHZlZ2EtZW5jb2RlIG1vZHVsZS5cbiAqL1xuXG5mdW5jdGlvbiBQdWxzZShkYXRhZmxvdywgc3RhbXAsIGVuY29kZSkge1xuICB0aGlzLmRhdGFmbG93ID0gZGF0YWZsb3c7XG4gIHRoaXMuc3RhbXAgPSBzdGFtcCA9PSBudWxsID8gLTEgOiBzdGFtcDtcbiAgdGhpcy5hZGQgPSBbXTtcbiAgdGhpcy5yZW0gPSBbXTtcbiAgdGhpcy5tb2QgPSBbXTtcbiAgdGhpcy5maWVsZHMgPSBudWxsO1xuICB0aGlzLmVuY29kZSA9IGVuY29kZSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShkYXRhLCBmaWx0ZXIpIHtcbiAgY29uc3Qgb3V0ID0gW107XG4gIHZpc2l0QXJyYXkoZGF0YSwgZmlsdGVyLCBfID0+IG91dC5wdXNoKF8pKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZmlsdGVyKHB1bHNlLCBmbGFncykge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgcHVsc2UudmlzaXQoZmxhZ3MsIHQgPT4ge1xuICAgIG1hcFt0dXBsZWlkKHQpXSA9IDE7XG4gIH0pO1xuICByZXR1cm4gdCA9PiBtYXBbdHVwbGVpZCh0KV0gPyBudWxsIDogdDtcbn1cblxuZnVuY3Rpb24gYWRkRmlsdGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyAodCwgaSkgPT4gYSh0LCBpKSAmJiBiKHQsIGkpIDogYjtcbn1cblxuUHVsc2UucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogU2VudGluZWwgdmFsdWUgaW5kaWNhdGluZyBwdWxzZSBwcm9wYWdhdGlvbiBzaG91bGQgc3RvcC5cbiAgICovXG4gIFN0b3BQcm9wYWdhdGlvbixcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQUREIChhZGRlZCkgdHVwbGVzLlxuICAgKi9cbiAgQURELFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBSRU0gKHJlbW92ZWQpIHR1cGxlcy5cbiAgICovXG4gIFJFTSxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgTU9EIChtb2RpZmllZCkgdHVwbGVzLlxuICAgKi9cbiAgTU9ELFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBBREQgKGFkZGVkKSBhbmQgUkVNIChyZW1vdmVkKSB0dXBsZXMuXG4gICAqL1xuICBBRERfUkVNLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBBREQgKGFkZGVkKSBhbmQgTU9EIChtb2RpZmllZCkgdHVwbGVzLlxuICAgKi9cbiAgQUREX01PRCxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgQURELCBSRU0gYW5kIE1PRCB0dXBsZXMuXG4gICAqL1xuICBBTEwsXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGFsbCB0dXBsZXMgaW4gYSBkYXRhIHNvdXJjZVxuICAgKiBleGNlcHQgZm9yIHRoZSBBREQsIFJFTSBhbmQgTU9EIHR1cGxlcy5cbiAgICovXG4gIFJFRkxPVyxcblxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgYSAncGFzcy10aHJvdWdoJyB0byBhXG4gICAqIGJhY2tpbmcgZGF0YSBzb3VyY2UsIGlnbm9yaW5nIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgU09VUkNFLFxuXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGF0IHNvdXJjZSBkYXRhIHNob3VsZCBiZVxuICAgKiBzdXBwcmVzc2VkIHdoZW4gY3JlYXRpbmcgYSBmb3JrZWQgcHVsc2UuXG4gICAqL1xuICBOT19TT1VSQ0UsXG5cbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIHRoYXQgZmllbGQgbW9kaWZpY2F0aW9ucyBzaG91bGQgYmVcbiAgICogc3VwcHJlc3NlZCB3aGVuIGNyZWF0aW5nIGEgZm9ya2VkIHB1bHNlLlxuICAgKi9cbiAgTk9fRklFTERTLFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHB1bHNlIGJhc2VkIG9uIHRoZSB2YWx1ZXMgb2YgdGhpcyBwdWxzZS5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQnkgZGVmYXVsdCwgbmV3IGVtcHR5IEFERCwgUkVNIGFuZCBNT0QgYXJyYXlzIGFyZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBJbnRlZ2VyIG9mIGJvb2xlYW4gZmxhZ3MgaW5kaWNhdGluZyB3aGljaCAoaWYgYW55KVxuICAgKiAgIHR1cGxlIGFycmF5cyBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBuZXcgcHVsc2UuIFRoZSBzdXBwb3J0ZWQgZmxhZyB2YWx1ZXNcbiAgICogICBhcmUgQURELCBSRU0gYW5kIE1PRC4gQXJyYXkgcmVmZXJlbmNlcyBhcmUgY29waWVkIGRpcmVjdGx5OiBuZXcgYXJyYXlcbiAgICogICBpbnN0YW5jZXMgYXJlIG5vdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBUaGUgZm9ya2VkIHB1bHNlIGluc3RhbmNlLlxuICAgKiBAc2VlIGluaXRcbiAgICovXG4gIGZvcmsoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFB1bHNlKHRoaXMuZGF0YWZsb3cpLmluaXQodGhpcywgZmxhZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHB1bHNlIHdpdGggbmV3IG1hdGVyaWFsaXplZCBhcnJheVxuICAgKiBpbnN0YW5jZXMgZm9yIHRoZSBBREQsIFJFTSwgTU9ELCBhbmQgU09VUkNFIGFycmF5cy5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gVGhlIGNsb25lZCBwdWxzZSBpbnN0YW5jZS5cbiAgICogQHNlZSBpbml0XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5mb3JrKEFMTCk7XG4gICAgcC5hZGQgPSBwLmFkZC5zbGljZSgpO1xuICAgIHAucmVtID0gcC5yZW0uc2xpY2UoKTtcbiAgICBwLm1vZCA9IHAubW9kLnNsaWNlKCk7XG4gICAgaWYgKHAuc291cmNlKSBwLnNvdXJjZSA9IHAuc291cmNlLnNsaWNlKCk7XG4gICAgcmV0dXJuIHAubWF0ZXJpYWxpemUoQUxMIHwgU09VUkNFKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHB1bHNlIHRoYXQgYWRkcyBhbGwgdHVwbGVzIGZyb20gYSBiYWNraW5nIHNvdXJjZS4gVGhpcyBpc1xuICAgKiB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIG9wZXJhdG9ycyBhcmUgYWRkZWQgdG8gYSBkYXRhZmxvdyBhZnRlciBhblxuICAgKiB1cHN0cmVhbSBkYXRhIHBpcGVsaW5lIGhhcyBhbHJlYWR5IGJlZW4gcHJvY2Vzc2VkLCBlbnN1cmluZyB0aGF0XG4gICAqIG5ldyBvcGVyYXRvcnMgY2FuIG9ic2VydmUgYWxsIHR1cGxlcyB3aXRoaW4gYSBzdHJlYW0uXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIEEgcHVsc2UgaW5zdGFuY2Ugd2l0aCBhbGwgc291cmNlIHR1cGxlcyBpbmNsdWRlZFxuICAgKiAgIGluIHRoZSBhZGQgYXJyYXkuIElmIHRoZSBjdXJyZW50IHB1bHNlIGFscmVhZHkgaGFzIGFsbCBzb3VyY2VcbiAgICogICB0dXBsZXMgaW4gaXRzIGFkZCBhcnJheSwgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuIElmIHRoZSBjdXJyZW50XG4gICAqICAgcHVsc2UgZG9lcyBub3QgaGF2ZSBhIGJhY2tpbmcgc291cmNlLCBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAgICovXG4gIGFkZEFsbCgpIHtcbiAgICBsZXQgcCA9IHRoaXM7XG4gICAgY29uc3QgcmV1c2UgPSAhcC5zb3VyY2UgfHwgcC5hZGQgPT09IHAucmVtIC8vIHNwZWNpYWwgY2FzZSBmb3IgaW5kZXhlZCBzZXQgKGUuZy4sIGNyb3NzZmlsdGVyKVxuICAgIHx8ICFwLnJlbS5sZW5ndGggJiYgcC5zb3VyY2UubGVuZ3RoID09PSBwLmFkZC5sZW5ndGg7XG5cbiAgICBpZiAocmV1c2UpIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gbmV3IFB1bHNlKHRoaXMuZGF0YWZsb3cpLmluaXQodGhpcyk7XG4gICAgICBwLmFkZCA9IHAuc291cmNlO1xuICAgICAgcC5yZW0gPSBbXTsgLy8gbmV3IG9wZXJhdG9ycyBjYW4gaWdub3JlIHJlbSAjMjc2OVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhpcyBwdWxzZSBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIGFub3RoZXIgcHVsc2UuIFRoaXMgbWV0aG9kXG4gICAqIGlzIHVzZWQgaW50ZXJuYWxseSBieSB7QGxpbmsgZm9ya30gdG8gaW5pdGlhbGl6ZSBhIG5ldyBmb3JrZWQgdHVwbGUuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEJ5IGRlZmF1bHQsIG5ldyBlbXB0eSBBREQsIFJFTSBhbmQgTU9EIGFycmF5cyBhcmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtQdWxzZX0gc3JjIC0gVGhlIHNvdXJjZSBwdWxzZSB0byBjb3B5IGZyb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyAtIEludGVnZXIgb2YgYm9vbGVhbiBmbGFncyBpbmRpY2F0aW5nIHdoaWNoIChpZiBhbnkpXG4gICAqICAgdHVwbGUgYXJyYXlzIHNob3VsZCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBwdWxzZS4gVGhlIHN1cHBvcnRlZCBmbGFnIHZhbHVlc1xuICAgKiAgIGFyZSBBREQsIFJFTSBhbmQgTU9ELiBBcnJheSByZWZlcmVuY2VzIGFyZSBjb3BpZWQgZGlyZWN0bHk6IG5ldyBhcnJheVxuICAgKiAgIGluc3RhbmNlcyBhcmUgbm90IGNyZWF0ZWQuIEJ5IGRlZmF1bHQsIHNvdXJjZSBkYXRhIGFycmF5cyBhcmUgY29waWVkXG4gICAqICAgdG8gdGhlIG5ldyBwdWxzZS4gVXNlIHRoZSBOT19TT1VSQ0UgZmxhZyB0byBlbmZvcmNlIGEgbnVsbCBzb3VyY2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFJldHVybnMgdGhpcyBQdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIGluaXQoc3JjLCBmbGFncykge1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuICAgIHAuc3RhbXAgPSBzcmMuc3RhbXA7XG4gICAgcC5lbmNvZGUgPSBzcmMuZW5jb2RlO1xuXG4gICAgaWYgKHNyYy5maWVsZHMgJiYgIShmbGFncyAmIE5PX0ZJRUxEUykpIHtcbiAgICAgIHAuZmllbGRzID0gc3JjLmZpZWxkcztcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBBREQpIHtcbiAgICAgIHAuYWRkRiA9IHNyYy5hZGRGO1xuICAgICAgcC5hZGQgPSBzcmMuYWRkO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLmFkZEYgPSBudWxsO1xuICAgICAgcC5hZGQgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBSRU0pIHtcbiAgICAgIHAucmVtRiA9IHNyYy5yZW1GO1xuICAgICAgcC5yZW0gPSBzcmMucmVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnJlbUYgPSBudWxsO1xuICAgICAgcC5yZW0gPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBNT0QpIHtcbiAgICAgIHAubW9kRiA9IHNyYy5tb2RGO1xuICAgICAgcC5tb2QgPSBzcmMubW9kO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm1vZEYgPSBudWxsO1xuICAgICAgcC5tb2QgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBOT19TT1VSQ0UpIHtcbiAgICAgIHAuc3JjRiA9IG51bGw7XG4gICAgICBwLnNvdXJjZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuc3JjRiA9IHNyYy5zcmNGO1xuICAgICAgcC5zb3VyY2UgPSBzcmMuc291cmNlO1xuICAgICAgaWYgKHNyYy5jbGVhbnMpIHAuY2xlYW5zID0gc3JjLmNsZWFucztcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHB1bHNlIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBydW4uXG4gICAqL1xuICBydW5BZnRlcihmdW5jKSB7XG4gICAgdGhpcy5kYXRhZmxvdy5ydW5BZnRlcihmdW5jKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHR1cGxlcyBoYXZlIGJlZW4gYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZmxhZ3NdIC0gVGhlIHR1cGxlIHR5cGVzIChBREQsIFJFTSBvciBNT0QpIHRvIHF1ZXJ5LlxuICAgKiAgIERlZmF1bHRzIHRvIEFMTCwgcmV0dXJuaW5nIHRydWUgaWYgYW55IHR1cGxlIHR5cGUgaGFzIGNoYW5nZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIG9uZSBvciBtb3JlIHF1ZXJpZWQgdHVwbGUgdHlwZXMgaGF2ZVxuICAgKiAgIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNoYW5nZWQoZmxhZ3MpIHtcbiAgICBjb25zdCBmID0gZmxhZ3MgfHwgQUxMO1xuICAgIHJldHVybiBmICYgQUREICYmIHRoaXMuYWRkLmxlbmd0aCB8fCBmICYgUkVNICYmIHRoaXMucmVtLmxlbmd0aCB8fCBmICYgTU9EICYmIHRoaXMubW9kLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGEgXCJyZWZsb3dcIiBvZiB0dXBsZSB2YWx1ZXMsIHN1Y2ggdGhhdCBhbGwgdHVwbGVzIGluIHRoZSBiYWNraW5nXG4gICAqIHNvdXJjZSBhcmUgYWRkZWQgdG8gdGhlIE1PRCBzZXQsIHVubGVzcyBhbHJlYWR5IHByZXNlbnQgaW4gdGhlIEFERCBzZXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zvcms9ZmFsc2VdIC0gSWYgdHJ1ZSwgcmV0dXJucyBhIGZvcmtlZCBjb3B5IG9mIHRoaXNcbiAgICogICBwdWxzZSwgYW5kIGludm9rZXMgcmVmbG93IG9uIHRoYXQgZGVyaXZlZCBwdWxzZS5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gVGhlIHJlZmxvd2VkIHB1bHNlIGluc3RhbmNlLlxuICAgKi9cbiAgcmVmbG93KGZvcmspIHtcbiAgICBpZiAoZm9yaykgcmV0dXJuIHRoaXMuZm9yayhBTEwpLnJlZmxvdygpO1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYWRkLmxlbmd0aCxcbiAgICAgICAgICBzcmMgPSB0aGlzLnNvdXJjZSAmJiB0aGlzLnNvdXJjZS5sZW5ndGg7XG5cbiAgICBpZiAoc3JjICYmIHNyYyAhPT0gbGVuKSB7XG4gICAgICB0aGlzLm1vZCA9IHRoaXMuc291cmNlO1xuICAgICAgaWYgKGxlbikgdGhpcy5maWx0ZXIoTU9ELCBmaWx0ZXIodGhpcywgQUREKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldC9zZXQgbWV0YWRhdGEgdG8gcHVsc2UgcmVxdWVzdGluZyBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICogdG8gcmVjbGFpbSBjdXJyZW50bHkgdW51c2VkIHJlc291cmNlcy5cbiAgICovXG4gIGNsZWFuKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2xlYW5zID0gISF2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jbGVhbnM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrcyBvbmUgb3IgbW9yZSBkYXRhIGZpZWxkIG5hbWVzIGFzIG1vZGlmaWVkIHRvIGFzc2lzdCBkZXBlbmRlbmN5XG4gICAqIHRyYWNraW5nIGFuZCBpbmNyZW1lbnRhbCBwcm9jZXNzaW5nIGJ5IHRyYW5zZm9ybSBvcGVyYXRvcnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IF8gLSBUaGUgZmllbGQocykgdG8gbWFyayBhcyBtb2RpZmllZC5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gVGhpcyBwdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIG1vZGlmaWVzKF8pIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5maWVsZHMgfHwgKHRoaXMuZmllbGRzID0ge30pO1xuXG4gICAgaWYgKGlzQXJyYXkoXykpIHtcbiAgICAgIF8uZm9yRWFjaChmID0+IGhhc2hbZl0gPSB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzaFtfXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvbmUgb3IgbW9yZSBkYXRhIGZpZWxkcyBoYXZlIGJlZW4gbW9kaWZpZWQgZHVyaW5nIHRoaXMgcHVsc2VcbiAgICogcHJvcGFnYXRpb24gdGltZXN0YW1wLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBfIC0gVGhlIGZpZWxkKHMpIHRvIGNoZWNrIGZvciBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBub21vZCAtIElmIHRydWUsIHdpbGwgY2hlY2sgdGhlIG1vZGlmaWVkIGZsYWcgZXZlbiBpZlxuICAgKiAgIG5vIG1vZCB0dXBsZXMgZXhpc3QuIElmIGZhbHNlIChkZWZhdWx0KSwgbW9kIHR1cGxlcyBtdXN0IGJlIHByZXNlbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgcHJvdmlkZWQgZmllbGRzIGhhcyBiZWVuXG4gICAqICAgbWFya2VkIGFzIG1vZGlmaWVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBtb2RpZmllZChfLCBub21vZCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZmllbGRzO1xuICAgIHJldHVybiAhKChub21vZCB8fCB0aGlzLm1vZC5sZW5ndGgpICYmIGZpZWxkcykgPyBmYWxzZSA6ICFhcmd1bWVudHMubGVuZ3RoID8gISFmaWVsZHMgOiBpc0FycmF5KF8pID8gXy5zb21lKGYgPT4gZmllbGRzW2ZdKSA6IGZpZWxkc1tfXTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGZpbHRlciBmdW5jdGlvbiB0byBvbmUgbW9yZSB0dXBsZSBzZXRzLiBGaWx0ZXJzIGFyZSBhcHBsaWVkIHRvXG4gICAqIGJhY2tpbmcgdHVwbGUgYXJyYXlzLCB0byBkZXRlcm1pbmUgdGhlIGFjdHVhbCBzZXQgb2YgdHVwbGVzIGNvbnNpZGVyZWRcbiAgICogYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQuIFRoZXkgY2FuIGJlIHVzZWQgdG8gZGVsYXkgbWF0ZXJpYWxpemF0aW9uIG9mXG4gICAqIGEgdHVwbGUgc2V0IGluIG9yZGVyIHRvIGF2b2lkIGV4cGVuc2l2ZSBhcnJheSBjb3BpZXMuIEluIGFkZGl0aW9uLCB0aGVcbiAgICogZmlsdGVyIGZ1bmN0aW9ucyBjYW4gc2VydmUgYXMgdmFsdWUgdHJhbnNmb3JtZXJzOiB1bmxpa2Ugc3RhbmRhcmQgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uICh3aGljaCByZXR1cm4gYm9vbGVhbiB2YWx1ZXMpLCBQdWxzZSBmaWx0ZXJzIHNob3VsZCByZXR1cm4gdGhlXG4gICAqIGFjdHVhbCB0dXBsZSB2YWx1ZSB0byBwcm9jZXNzLiBJZiBhIHR1cGxlIHNldCBpcyBhbHJlYWR5IGZpbHRlcmVkLCB0aGVcbiAgICogbmV3IGZpbHRlciBmdW5jdGlvbiB3aWxsIGJlIGFwcGVuZGVkIGludG8gYSBjb25qdW50aXZlICgnYW5kJykgcXVlcnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyAtIEZsYWdzIGluZGljYXRpbmcgdGhlIHR1cGxlIHNldChzKSB0byBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6b2JqZWN0fSBmaWx0ZXIgLSBGaWx0ZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICogICB0byB0aGUgdHVwbGUgc2V0IGFycmF5LCBhbmQgc2hvdWxkIHJldHVybiBhIGRhdGEgdHVwbGUgaWYgdGhlIHZhbHVlXG4gICAqICAgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB0dXBsZSBzZXQsIGFuZCBmYWxzeSAob3IgbnVsbCkgb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXIoZmxhZ3MsIGZpbHRlcikge1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuICAgIGlmIChmbGFncyAmIEFERCkgcC5hZGRGID0gYWRkRmlsdGVyKHAuYWRkRiwgZmlsdGVyKTtcbiAgICBpZiAoZmxhZ3MgJiBSRU0pIHAucmVtRiA9IGFkZEZpbHRlcihwLnJlbUYsIGZpbHRlcik7XG4gICAgaWYgKGZsYWdzICYgTU9EKSBwLm1vZEYgPSBhZGRGaWx0ZXIocC5tb2RGLCBmaWx0ZXIpO1xuICAgIGlmIChmbGFncyAmIFNPVVJDRSkgcC5zcmNGID0gYWRkRmlsdGVyKHAuc3JjRiwgZmlsdGVyKTtcbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcbiAgICogTWF0ZXJpYWxpemUgb25lIG9yIG1vcmUgdHVwbGUgc2V0cyBpbiB0aGlzIHB1bHNlLiBJZiB0aGUgdHVwbGUgc2V0KHMpIGhhdmVcbiAgICogYSByZWdpc3RlcmVkIGZpbHRlciBmdW5jdGlvbiwgaXQgd2lsbCBiZSBhcHBsaWVkIGFuZCB0aGUgdHVwbGUgc2V0KHMpIHdpbGxcbiAgICogYmUgcmVwbGFjZWQgd2l0aCBtYXRlcmlhbGl6ZWQgdHVwbGUgYXJyYXlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBGbGFncyBpbmRpY2F0aW5nIHRoZSB0dXBsZSBzZXQocykgdG8gbWF0ZXJpYWxpemUuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFJldHVybnMgdGhpcyBwdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIG1hdGVyaWFsaXplKGZsYWdzKSB7XG4gICAgZmxhZ3MgPSBmbGFncyB8fCBBTEw7XG4gICAgY29uc3QgcCA9IHRoaXM7XG5cbiAgICBpZiAoZmxhZ3MgJiBBREQgJiYgcC5hZGRGKSB7XG4gICAgICBwLmFkZCA9IG1hdGVyaWFsaXplKHAuYWRkLCBwLmFkZEYpO1xuICAgICAgcC5hZGRGID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBSRU0gJiYgcC5yZW1GKSB7XG4gICAgICBwLnJlbSA9IG1hdGVyaWFsaXplKHAucmVtLCBwLnJlbUYpO1xuICAgICAgcC5yZW1GID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBNT0QgJiYgcC5tb2RGKSB7XG4gICAgICBwLm1vZCA9IG1hdGVyaWFsaXplKHAubW9kLCBwLm1vZEYpO1xuICAgICAgcC5tb2RGID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBTT1VSQ0UgJiYgcC5zcmNGKSB7XG4gICAgICBwLnNvdXJjZSA9IHAuc291cmNlLmZpbHRlcihwLnNyY0YpO1xuICAgICAgcC5zcmNGID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfSxcblxuICAvKipcbiAgICogVmlzaXQgb25lIG9yIG1vcmUgdHVwbGUgc2V0cyBpbiB0aGlzIHB1bHNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBGbGFncyBpbmRpY2F0aW5nIHRoZSB0dXBsZSBzZXQocykgdG8gdmlzaXQuXG4gICAqICAgTGVnYWwgdmFsdWVzIGFyZSBBREQsIFJFTSwgTU9EIGFuZCBTT1VSQ0UgKGlmIGEgYmFja2luZyBkYXRhIHNvdXJjZVxuICAgKiAgIGhhcyBiZWVuIHNldCkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KToqfSAtIFZpc2l0b3IgZnVuY3Rpb24gaW52b2tlZCBwZXItdHVwbGUuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFJldHVybnMgdGhpcyBwdWxzZSBpbnN0YW5jZS5cbiAgICovXG4gIHZpc2l0KGZsYWdzLCB2aXNpdG9yKSB7XG4gICAgY29uc3QgcCA9IHRoaXMsXG4gICAgICAgICAgdiA9IHZpc2l0b3I7XG5cbiAgICBpZiAoZmxhZ3MgJiBTT1VSQ0UpIHtcbiAgICAgIHZpc2l0QXJyYXkocC5zb3VyY2UsIHAuc3JjRiwgdik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MgJiBBREQpIHZpc2l0QXJyYXkocC5hZGQsIHAuYWRkRiwgdik7XG4gICAgaWYgKGZsYWdzICYgUkVNKSB2aXNpdEFycmF5KHAucmVtLCBwLnJlbUYsIHYpO1xuICAgIGlmIChmbGFncyAmIE1PRCkgdmlzaXRBcnJheShwLm1vZCwgcC5tb2RGLCB2KTtcbiAgICBjb25zdCBzcmMgPSBwLnNvdXJjZTtcblxuICAgIGlmIChmbGFncyAmIFJFRkxPVyAmJiBzcmMpIHtcbiAgICAgIGNvbnN0IHN1bSA9IHAuYWRkLmxlbmd0aCArIHAubW9kLmxlbmd0aDtcblxuICAgICAgaWYgKHN1bSA9PT0gc3JjLmxlbmd0aCkgOyBlbHNlIGlmIChzdW0pIHtcbiAgICAgICAgdmlzaXRBcnJheShzcmMsIGZpbHRlcihwLCBBRERfTU9EKSwgdik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBubyBhZGQvcmVtL21vZCB0dXBsZXMsIHZpc2l0IHNvdXJjZVxuICAgICAgICB2aXNpdEFycmF5KHNyYywgcC5zcmNGLCB2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZXQgb2YgbXVsdGlwbGUgcHVsc2VzLiBVc2VkIGFzIGlucHV0IGZvciBvcGVyYXRvcnNcbiAqIHRoYXQgYWNjZXB0IG11bHRpcGxlIHB1bHNlcyBhdCBhIHRpbWUuIENvbnRhaW5lZCBwdWxzZXMgYXJlXG4gKiBhY2Nlc3NpYmxlIHZpYSB0aGUgcHVibGljIFwicHVsc2VzXCIgYXJyYXkgcHJvcGVydHkuIFRoaXMgcHVsc2UgZG9lXG4gKiBub3QgY2FycnkgYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQgdHVwbGVzIGRpcmVjdGx5LiBIb3dldmVyLFxuICogdGhlIHZpc2l0IG1ldGhvZCBjYW4gYmUgdXNlZCB0byB0cmF2ZXJzZSBhbGwgc3VjaCB0dXBsZXMgY29udGFpbmVkXG4gKiBpbiBzdWItcHVsc2VzIHdpdGggYSB0aW1lc3RhbXAgbWF0Y2hpbmcgdGhpcyBwYXJlbnQgbXVsdGktcHVsc2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YWZsb3d9IGRhdGFmbG93IC0gVGhlIGJhY2tpbmcgZGF0YWZsb3cgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhbXAgLSBUaGUgdGltZXN0YW1wLlxuICogQHBhcmFtIHtBcnJheTxQdWxzZT59IHB1bHNlcyAtIFRoZSBzdWItcHVsc2VzIGZvciB0aGlzIG11bHRpLXB1bHNlLlxuICovXG5cbmZ1bmN0aW9uIE11bHRpUHVsc2UoZGF0YWZsb3csIHN0YW1wLCBwdWxzZXMsIGVuY29kZSkge1xuICBjb25zdCBwID0gdGhpcyxcbiAgICAgICAgbiA9IHB1bHNlcy5sZW5ndGg7XG4gIGxldCBjID0gMDtcbiAgdGhpcy5kYXRhZmxvdyA9IGRhdGFmbG93O1xuICB0aGlzLnN0YW1wID0gc3RhbXA7XG4gIHRoaXMuZmllbGRzID0gbnVsbDtcbiAgdGhpcy5lbmNvZGUgPSBlbmNvZGUgfHwgbnVsbDtcbiAgdGhpcy5wdWxzZXMgPSBwdWxzZXM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBwdWxzZSA9IHB1bHNlc1tpXTtcbiAgICBpZiAocHVsc2Uuc3RhbXAgIT09IHN0YW1wKSBjb250aW51ZTtcblxuICAgIGlmIChwdWxzZS5maWVsZHMpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBwLmZpZWxkcyB8fCAocC5maWVsZHMgPSB7fSk7XG5cbiAgICAgIGZvciAoY29uc3QgZiBpbiBwdWxzZS5maWVsZHMpIHtcbiAgICAgICAgaGFzaFtmXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocC5BREQpKSBjIHw9IHAuQUREO1xuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHAuUkVNKSkgYyB8PSBwLlJFTTtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwLk1PRCkpIGMgfD0gcC5NT0Q7XG4gIH1cblxuICB0aGlzLmNoYW5nZXMgPSBjO1xufVxuaW5oZXJpdHMoTXVsdGlQdWxzZSwgUHVsc2UsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcHVsc2UgYmFzZWQgb24gdGhlIHZhbHVlcyBvZiB0aGlzIHB1bHNlLlxuICAgKiBUaGUgZGF0YWZsb3csIHRpbWUgc3RhbXAgYW5kIGZpZWxkIG1vZGlmaWNhdGlvbiB2YWx1ZXMgYXJlIGNvcGllZCBvdmVyLlxuICAgKiBAcmV0dXJuIHtQdWxzZX1cbiAgICovXG4gIGZvcmsoZmxhZ3MpIHtcbiAgICBjb25zdCBwID0gbmV3IFB1bHNlKHRoaXMuZGF0YWZsb3cpLmluaXQodGhpcywgZmxhZ3MgJiB0aGlzLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoZmxhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZsYWdzICYgcC5BREQpIHRoaXMudmlzaXQocC5BREQsIHQgPT4gcC5hZGQucHVzaCh0KSk7XG4gICAgICBpZiAoZmxhZ3MgJiBwLlJFTSkgdGhpcy52aXNpdChwLlJFTSwgdCA9PiBwLnJlbS5wdXNoKHQpKTtcbiAgICAgIGlmIChmbGFncyAmIHAuTU9EKSB0aGlzLnZpc2l0KHAuTU9ELCB0ID0+IHAubW9kLnB1c2godCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIGNoYW5nZWQoZmxhZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2VzICYgZmxhZ3M7XG4gIH0sXG5cbiAgbW9kaWZpZWQoXykge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgICAgIGZpZWxkcyA9IHAuZmllbGRzO1xuICAgIHJldHVybiAhKGZpZWxkcyAmJiBwLmNoYW5nZXMgJiBwLk1PRCkgPyAwIDogaXNBcnJheShfKSA/IF8uc29tZShmID0+IGZpZWxkc1tmXSkgOiBmaWVsZHNbX107XG4gIH0sXG5cbiAgZmlsdGVyKCkge1xuICAgIGVycm9yKCdNdWx0aVB1bHNlIGRvZXMgbm90IHN1cHBvcnQgZmlsdGVyaW5nLicpO1xuICB9LFxuXG4gIG1hdGVyaWFsaXplKCkge1xuICAgIGVycm9yKCdNdWx0aVB1bHNlIGRvZXMgbm90IHN1cHBvcnQgbWF0ZXJpYWxpemF0aW9uLicpO1xuICB9LFxuXG4gIHZpc2l0KGZsYWdzLCB2aXNpdG9yKSB7XG4gICAgY29uc3QgcCA9IHRoaXMsXG4gICAgICAgICAgcHVsc2VzID0gcC5wdWxzZXMsXG4gICAgICAgICAgbiA9IHB1bHNlcy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgaWYgKGZsYWdzICYgcC5TT1VSQ0UpIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHB1bHNlc1tpXS52aXNpdChmbGFncywgdmlzaXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChwdWxzZXNbaV0uc3RhbXAgPT09IHAuc3RhbXApIHtcbiAgICAgICAgICBwdWxzZXNbaV0udmlzaXQoZmxhZ3MsIHZpc2l0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cblxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXMgKi9cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBkYXRhZmxvdyBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHB1bHNlXG4gKiBwcm9wYWdhdGlvbiBjb21wbGV0ZXMuIFRoaXMgbWV0aG9kIHdpbGwgaW5jcmVtZW50IHRoZSBjdXJyZW50IHRpbWVzdGFtcFxuICogYW5kIHByb2Nlc3MgYWxsIHVwZGF0ZWQsIHB1bHNlZCBhbmQgdG91Y2hlZCBvcGVyYXRvcnMuIFdoZW4gaW52b2tlZCBmb3JcbiAqIHRoZSBmaXJzdCB0aW1lLCBhbGwgcmVnaXN0ZXJlZCBvcGVyYXRvcnMgd2lsbCBiZSBwcm9jZXNzZWQuIFRoaXMgbWV0aG9kXG4gKiBzaG91bGQgbm90IGJlIGludm9rZWQgYnkgdGhpcmQtcGFydHkgY2xpZW50cywgdXNlIHtAbGluayBydW5Bc3luY30gb3JcbiAqIHtAbGluayBydW59IGluc3RlYWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kZV0gLSBUaGUgbmFtZSBvZiBhbiBlbmNvZGluZyBzZXQgdG8gaW52b2tlIGR1cmluZ1xuICogICBwcm9wYWdhdGlvbi4gVGhpcyB2YWx1ZSBpcyBhZGRlZCB0byBnZW5lcmF0ZWQgUHVsc2UgaW5zdGFuY2VzO1xuICogICBvcGVyYXRvcnMgY2FuIHRoZW4gcmVzcG9uZCB0byAob3IgaWdub3JlKSB0aGlzIHNldHRpbmcgYXMgYXBwcm9wcmlhdGUuXG4gKiAgIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIEVuY29kZSB0cmFuc2Zvcm0gaW5cbiAqICAgdGhlIHZlZ2EtZW5jb2RlIHBhY2thZ2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJlcnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBpbW1lZGlhdGVseSBiZWZvcmUgZGF0YWZsb3cgZXZhbHVhdGlvbiBjb21tZW5jZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcG9zdHJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgYWZ0ZXIgZGF0YWZsb3cgZXZhbHVhdGlvbiBjb21wbGV0ZXMuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqICAgYWZ0ZXIgdGhvc2UgcmVnaXN0ZXJlZCB2aWEge0BsaW5rIHJ1bkFmdGVyfS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhpcyBkYXRhZmxvdyBhZnRlclxuICogICBldmFsdWF0aW9uIGNvbXBsZXRlcy5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgICAgIGFzeW5jID0gW107IC8vIGlmIHRoZSBwdWxzZSB2YWx1ZSBpcyBzZXQsIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGxcblxuICBpZiAoZGYuX3B1bHNlKSByZXR1cm4gcmVlbnRyYW50KGRmKTsgLy8gd2FpdCBmb3IgcGVuZGluZyBkYXRhc2V0cyB0byBsb2FkXG5cbiAgaWYgKGRmLl9wZW5kaW5nKSBhd2FpdCBkZi5fcGVuZGluZzsgLy8gaW52b2tlIHByZXJ1biBmdW5jdGlvbiwgaWYgcHJvdmlkZWRcblxuICBpZiAocHJlcnVuKSBhd2FpdCBhc3luY0NhbGxiYWNrKGRmLCBwcmVydW4pOyAvLyBleGl0IGVhcmx5IGlmIHRoZXJlIGFyZSBubyB1cGRhdGVzXG5cbiAgaWYgKCFkZi5fdG91Y2hlZC5sZW5ndGgpIHtcbiAgICBkZi5kZWJ1ZygnRGF0YWZsb3cgaW52b2tlZCwgYnV0IG5vdGhpbmcgdG8gZG8uJyk7XG4gICAgcmV0dXJuIGRmO1xuICB9IC8vIGluY3JlbWVudCB0aW1lc3RhbXAgY2xvY2tcblxuXG4gIGNvbnN0IHN0YW1wID0gKytkZi5fY2xvY2s7IC8vIHNldCB0aGUgY3VycmVudCBwdWxzZVxuXG4gIGRmLl9wdWxzZSA9IG5ldyBQdWxzZShkZiwgc3RhbXAsIGVuY29kZSk7IC8vIGluaXRpYWxpemUgcHJpb3JpdHkgcXVldWUsIHJlc2V0IHRvdWNoZWQgb3BlcmF0b3JzXG5cbiAgZGYuX3RvdWNoZWQuZm9yRWFjaChvcCA9PiBkZi5fZW5xdWV1ZShvcCwgdHJ1ZSkpO1xuXG4gIGRmLl90b3VjaGVkID0gVW5pcXVlTGlzdChpZCk7XG4gIGxldCBjb3VudCA9IDAsXG4gICAgICBvcCxcbiAgICAgIG5leHQsXG4gICAgICBlcnJvcjtcblxuICB0cnkge1xuICAgIHdoaWxlIChkZi5faGVhcC5zaXplKCkgPiAwKSB7XG4gICAgICAvLyBkZXF1ZXVlIG9wZXJhdG9yIHdpdGggaGlnaGVzdCBwcmlvcml0eVxuICAgICAgb3AgPSBkZi5faGVhcC5wb3AoKTsgLy8gcmUtcXVldWUgaWYgcmFuayBjaGFuZ2VkXG5cbiAgICAgIGlmIChvcC5yYW5rICE9PSBvcC5xcmFuaykge1xuICAgICAgICBkZi5fZW5xdWV1ZShvcCwgdHJ1ZSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIG90aGVyd2lzZSwgZXZhbHVhdGUgdGhlIG9wZXJhdG9yXG5cblxuICAgICAgbmV4dCA9IG9wLnJ1bihkZi5fZ2V0UHVsc2Uob3AsIGVuY29kZSkpO1xuXG4gICAgICBpZiAobmV4dC50aGVuKSB7XG4gICAgICAgIC8vIGF3YWl0IGlmIG9wZXJhdG9yIHJldHVybnMgYSBwcm9taXNlIGRpcmVjdGx5XG4gICAgICAgIG5leHQgPSBhd2FpdCBuZXh0O1xuICAgICAgfSBlbHNlIGlmIChuZXh0LmFzeW5jKSB7XG4gICAgICAgIC8vIHF1ZXVlIHBhcmFsbGVsIGFzeW5jaHJvbm91cyBleGVjdXRpb25cbiAgICAgICAgYXN5bmMucHVzaChuZXh0LmFzeW5jKTtcbiAgICAgICAgbmV4dCA9IFN0b3BQcm9wYWdhdGlvbjtcbiAgICAgIH0gLy8gcHJvcGFnYXRlIGV2YWx1YXRpb24sIGVucXVldWUgZGVwZW5kZW50IG9wZXJhdG9yc1xuXG5cbiAgICAgIGlmIChuZXh0ICE9PSBTdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgaWYgKG9wLl90YXJnZXRzKSBvcC5fdGFyZ2V0cy5mb3JFYWNoKG9wID0+IGRmLl9lbnF1ZXVlKG9wKSk7XG4gICAgICB9IC8vIGluY3JlbWVudCB2aXNpdCBjb3VudGVyXG5cblxuICAgICAgKytjb3VudDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRmLl9oZWFwLmNsZWFyKCk7XG5cbiAgICBlcnJvciA9IGVycjtcbiAgfSAvLyByZXNldCBwdWxzZSBtYXBcblxuXG4gIGRmLl9pbnB1dCA9IHt9O1xuICBkZi5fcHVsc2UgPSBudWxsO1xuICBkZi5kZWJ1ZyhgUHVsc2UgJHtzdGFtcH06ICR7Y291bnR9IG9wZXJhdG9yc2ApO1xuXG4gIGlmIChlcnJvcikge1xuICAgIGRmLl9wb3N0cnVuID0gW107XG4gICAgZGYuZXJyb3IoZXJyb3IpO1xuICB9IC8vIGludm9rZSBjYWxsYmFja3MgcXVldWVkIHZpYSBydW5BZnRlclxuXG5cbiAgaWYgKGRmLl9wb3N0cnVuLmxlbmd0aCkge1xuICAgIGNvbnN0IHByID0gZGYuX3Bvc3RydW4uc29ydCgoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuXG4gICAgZGYuX3Bvc3RydW4gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHIubGVuZ3RoOyArK2kpIHtcbiAgICAgIGF3YWl0IGFzeW5jQ2FsbGJhY2soZGYsIHByW2ldLmNhbGxiYWNrKTtcbiAgICB9XG4gIH0gLy8gaW52b2tlIHBvc3RydW4gZnVuY3Rpb24sIGlmIHByb3ZpZGVkXG5cblxuICBpZiAocG9zdHJ1bikgYXdhaXQgYXN5bmNDYWxsYmFjayhkZiwgcG9zdHJ1bik7IC8vIGhhbmRsZSBub24tYmxvY2tpbmcgYXN5bmNocm9ub3VzIGNhbGxiYWNrc1xuXG4gIGlmIChhc3luYy5sZW5ndGgpIHtcbiAgICBQcm9taXNlLmFsbChhc3luYykudGhlbihjYiA9PiBkZi5ydW5Bc3luYyhudWxsLCAoKSA9PiB7XG4gICAgICBjYi5mb3JFYWNoKGYgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGYoZGYpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkZi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZGY7XG59XG4vKipcbiAqIFF1ZXVlcyBkYXRhZmxvdyBldmFsdWF0aW9uIHRvIHJ1biBvbmNlIGFueSBvdGhlciBxdWV1ZWQgZXZhbHVhdGlvbnMgaGF2ZVxuICogY29tcGxldGVkIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHF1ZXVlZCBwdWxzZVxuICogcHJvcGFnYXRpb24gY29tcGxldGVzLiBJZiBwcm92aWRlZCwgYSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWRcbiAqIGltbWVkaWF0ZWx5IGJlZm9yZSBldmFsdWF0aW9uIGNvbW1lbmNlcy4gVGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgYVxuICogc2VwYXJhdGUgZXZhbHVhdGlvbiBpcyBpbnZva2VkIGZvciBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gVGhlIG5hbWUgb2YgYW4gZW5jb2Rpbmcgc2V0IHRvIGludm9rZSBkdXJpbmdcbiAqICAgcHJvcGFnYXRpb24uIFRoaXMgdmFsdWUgaXMgYWRkZWQgdG8gZ2VuZXJhdGVkIFB1bHNlIGluc3RhbmNlcztcbiAqICAgb3BlcmF0b3JzIGNhbiB0aGVuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpcyBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLlxuICogICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluXG4gKiAgIHRoZSB2ZWdhLWVuY29kZSBwYWNrYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoaXMgZGF0YWZsb3cgYWZ0ZXJcbiAqICAgZXZhbHVhdGlvbiBjb21wbGV0ZXMuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcnVuQXN5bmMoZW5jb2RlLCBwcmVydW4sIHBvc3RydW4pIHtcbiAgLy8gYXdhaXQgcHJldmlvdXNseSBxdWV1ZWQgZnVuY3Rpb25zXG4gIHdoaWxlICh0aGlzLl9ydW5uaW5nKSBhd2FpdCB0aGlzLl9ydW5uaW5nOyAvLyBydW4gZGF0YWZsb3csIG1hbmFnZSBydW5uaW5nIHByb21pc2VcblxuXG4gIGNvbnN0IGNsZWFyID0gKCkgPT4gdGhpcy5fcnVubmluZyA9IG51bGw7XG5cbiAgKHRoaXMuX3J1bm5pbmcgPSB0aGlzLmV2YWx1YXRlKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSkudGhlbihjbGVhciwgY2xlYXIpO1xuICByZXR1cm4gdGhpcy5fcnVubmluZztcbn1cbi8qKlxuICogUmVxdWVzdHMgZGF0YWZsb3cgZXZhbHVhdGlvbiBhbmQgdGhlIGltbWVkaWF0ZWx5IHJldHVybnMgdGhpcyBkYXRhZmxvd1xuICogaW5zdGFuY2UuIElmIHRoZXJlIGFyZSBwZW5kaW5nIGRhdGEgbG9hZGluZyBvciBvdGhlciBhc3luY2hyb25vdXNcbiAqIG9wZXJhdGlvbnMsIHRoZSBkYXRhZmxvdyB3aWxsIGV2YWx1YXRlIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoaXMgbWV0aG9kXG4gKiBoYXMgYmVlbiBpbnZva2VkLiBUbyB0cmFjayB3aGVuIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLCB1c2UgdGhlXG4gKiB7QGxpbmsgcnVuQXN5bmN9IG1ldGhvZCBpbnN0ZWFkLiBUaGlzIG1ldGhvZCB3aWxsIHJhaXNlIGFuIGVycm9yIGlmXG4gKiBpbnZva2VkIHdoaWxlIHRoZSBkYXRhZmxvdyBpcyBhbHJlYWR5IGluIHRoZSBtaWRzdCBvZiBldmFsdWF0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gVGhlIG5hbWUgb2YgYW4gZW5jb2Rpbmcgc2V0IHRvIGludm9rZSBkdXJpbmdcbiAqICAgcHJvcGFnYXRpb24uIFRoaXMgdmFsdWUgaXMgYWRkZWQgdG8gZ2VuZXJhdGVkIFB1bHNlIGluc3RhbmNlcztcbiAqICAgb3BlcmF0b3JzIGNhbiB0aGVuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpcyBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLlxuICogICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluXG4gKiAgIHRoZSB2ZWdhLWVuY29kZSBtb2R1bGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJlcnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBpbW1lZGlhdGVseSBiZWZvcmUgZGF0YWZsb3cgZXZhbHVhdGlvbiBjb21tZW5jZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcG9zdHJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgYWZ0ZXIgZGF0YWZsb3cgZXZhbHVhdGlvbiBjb21wbGV0ZXMuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWRcbiAqICAgYWZ0ZXIgdGhvc2UgcmVnaXN0ZXJlZCB2aWEge0BsaW5rIHJ1bkFmdGVyfS5cbiAqIEByZXR1cm4ge0RhdGFmbG93fSAtIFRoaXMgZGF0YWZsb3cgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gcnVuKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gIHJldHVybiB0aGlzLl9wdWxzZSA/IHJlZW50cmFudCh0aGlzKSA6ICh0aGlzLmV2YWx1YXRlKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSwgdGhpcyk7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgcHVsc2VcbiAqIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy4gSWYgbm8gcHJvcGFnYXRpb24gaXMgY3VycmVudGx5IG9jY3VycmluZyxcbiAqIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIGltbWVkaWF0ZWx5LiBDYWxsYmFja3Mgc2NoZWR1bGVkIHZpYSBydW5BZnRlclxuICogYXJlIGludm9rZWQgaW1tZWRpYXRlbHkgdXBvbiBjb21wbGV0aW9uIG9mIHRoZSBjdXJyZW50IGN5Y2xlLCBiZWZvcmVcbiAqIGFueSByZXF1ZXN0IHF1ZXVlZCB2aWEgcnVuQXN5bmMuIFRoaXMgbWV0aG9kIGlzIHByaW1hcmlseSBpbnRlbmRlZCBmb3JcbiAqIGludGVybmFsIHVzZS4gVGhpcmQtcGFydHkgY2FsbGVycyB1c2luZyBydW5BZnRlciB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gKiB0aGF0IGludm9rZXMge0BsaW5rIHJ1bn0gb3Ige0BsaW5rIHJ1bkFzeW5jfSBzaG91bGQgbm90IHVzZSB0aGlzIG1ldGhvZCxcbiAqIGJ1dCBpbnN0ZWFkIHVzZSB7QGxpbmsgcnVuQXN5bmN9IHdpdGggcHJlcnVuIG9yIHBvc3RydW4gYXJndW1lbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhZmxvdyl9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1bi5cbiAqICAgVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aXRoIHRoaXMgRGF0YWZsb3cgaW5zdGFuY2UgYXMgaXRzXG4gKiAgIHNvbGUgYXJndW1lbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVucXVldWUgLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gKiAgIGNhbGxiYWNrIHNob3VsZCBiZSBxdWV1ZWQgdXAgdG8gcnVuIGFmdGVyIHRoZSBuZXh0IHByb3BhZ2F0aW9uXG4gKiAgIGN5Y2xlLCBzdXBwcmVzc2luZyBpbW1lZGlhdGUgaW52b2NhdGlvbiB3aGVuIHByb3BhZ2F0aW9uIGlzIG5vdFxuICogICBjdXJyZW50bHkgb2NjdXJyaW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eV0gLSBBIHByaW9yaXR5IHZhbHVlIHVzZWQgdG8gc29ydCByZWdpc3RlcmVkXG4gKiAgIGNhbGxiYWNrcyB0byBkZXRlcm1pbmUgZXhlY3V0aW9uIG9yZGVyLiBUaGlzIGFyZ3VtZW50IGlzIGludGVuZGVkXG4gKiAgIGZvciBpbnRlcm5hbCBWZWdhIHVzZSBvbmx5LlxuICovXG5cbmZ1bmN0aW9uIHJ1bkFmdGVyKGNhbGxiYWNrLCBlbnF1ZXVlLCBwcmlvcml0eSkge1xuICBpZiAodGhpcy5fcHVsc2UgfHwgZW5xdWV1ZSkge1xuICAgIC8vIHB1bHNlIHByb3BhZ2F0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLCBxdWV1ZSB0byBydW4gYWZ0ZXJcbiAgICB0aGlzLl9wb3N0cnVuLnB1c2goe1xuICAgICAgcHJpb3JpdHk6IHByaW9yaXR5IHx8IDAsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwdWxzZSBwcm9wYWdhdGlvbiBhbHJlYWR5IGNvbXBsZXRlLCBpbnZva2UgaW1tZWRpYXRlbHlcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFJhaXNlIGFuIGVycm9yIGZvciByZS1lbnRyYW50IGRhdGFmbG93IGV2YWx1YXRpb24uXG4gKi9cblxuZnVuY3Rpb24gcmVlbnRyYW50KGRmKSB7XG4gIGRmLmVycm9yKCdEYXRhZmxvdyBhbHJlYWR5IHJ1bm5pbmcuIFVzZSBydW5Bc3luYygpIHRvIGNoYWluIGludm9jYXRpb25zLicpO1xuICByZXR1cm4gZGY7XG59XG4vKipcbiAqIEVucXVldWUgYW4gb3BlcmF0b3IgaW50byB0aGUgcHJpb3JpdHkgcXVldWUgZm9yIGV2YWx1YXRpb24uIFRoZSBvcGVyYXRvclxuICogd2lsbCBiZSBlbnF1ZXVlZCBpZiBpdCBoYXMgbm8gcmVnaXN0ZXJlZCBwdWxzZSBmb3IgdGhlIGN1cnJlbnQgY3ljbGUsIG9yIGlmXG4gKiB0aGUgZm9yY2UgYXJndW1lbnQgaXMgdHJ1ZS4gVXBvbiBlbnF1ZXVlLCB0aGlzIG1ldGhvZCBhbHNvIHNldHMgdGhlXG4gKiBvcGVyYXRvcidzIHFyYW5rIHRvIHRoZSBjdXJyZW50IHJhbmsgdmFsdWUuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byBlbnF1ZXVlLlxuICogQHBhcmFtIHtib29sZWFufSBbZm9yY2VdIC0gQSBmbGFnIGluZGljYXRpbmcgaWYgdGhlIG9wZXJhdG9yIHNob3VsZCBiZVxuICogICBmb3JjZWFibHkgYWRkZWQgdG8gdGhlIHF1ZXVlLCBldmVuIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gcHJldmlvdXNseVxuICogICBlbnF1ZXVlZCBkdXJpbmcgdGhlIGN1cnJlbnQgcHVsc2UgcHJvcGFnYXRpb24uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXG4gKiAgIGRhdGFmbG93IGdyYXBoIGlzIGR5bmFtaWNhbGx5IG1vZGlmaWVkIGFuZCB0aGUgb3BlcmF0b3IgcmFuayBjaGFuZ2VzLlxuICovXG5cblxuZnVuY3Rpb24gZW5xdWV1ZShvcCwgZm9yY2UpIHtcbiAgY29uc3QgcSA9IG9wLnN0YW1wIDwgdGhpcy5fY2xvY2s7XG4gIGlmIChxKSBvcC5zdGFtcCA9IHRoaXMuX2Nsb2NrO1xuXG4gIGlmIChxIHx8IGZvcmNlKSB7XG4gICAgb3AucXJhbmsgPSBvcC5yYW5rO1xuXG4gICAgdGhpcy5faGVhcC5wdXNoKG9wKTtcbiAgfVxufVxuLyoqXG4gKiBQcm92aWRlIGEgY29ycmVjdCBwdWxzZSBmb3IgZXZhbHVhdGluZyBhbiBvcGVyYXRvci4gSWYgdGhlIG9wZXJhdG9yIGhhcyBhblxuICogZXhwbGljaXQgc291cmNlIG9wZXJhdG9yLCB3ZSB3aWxsIHRyeSB0byBwdWxsIHRoZSBwdWxzZShzKSBmcm9tIGl0LlxuICogSWYgdGhlcmUgaXMgYW4gYXJyYXkgb2Ygc291cmNlIG9wZXJhdG9ycywgd2UgYnVpbGQgYSBtdWx0aS1wdWxzZS5cbiAqIE90aGVyd2lzZSwgd2UgcmV0dXJuIGEgY3VycmVudCBwdWxzZSB3aXRoIGNvcnJlY3Qgc291cmNlIGRhdGEuXG4gKiBJZiB0aGUgcHVsc2UgaXMgdGhlIHB1bHNlIG1hcCBoYXMgYW4gZXhwbGljaXQgdGFyZ2V0IHNldCwgd2UgdXNlIHRoYXQuXG4gKiBFbHNlIGlmIHRoZSBwdWxzZSBvbiB0aGUgdXBzdHJlYW0gc291cmNlIG9wZXJhdG9yIGlzIGN1cnJlbnQsIHdlIHVzZSB0aGF0LlxuICogRWxzZSB3ZSB1c2UgdGhlIHB1bHNlIGZyb20gdGhlIHB1bHNlIG1hcCwgYnV0IGNvcHkgdGhlIHNvdXJjZSB0dXBsZSBhcnJheS5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIGZvciB3aGljaCB0byBnZXQgYW4gaW5wdXQgcHVsc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kZV0gLSBBbiAob3B0aW9uYWwpIGVuY29kaW5nIHNldCBuYW1lIHdpdGggd2hpY2ggdG9cbiAqICAgYW5ub3RhdGUgdGhlIHJldHVybmVkIHB1bHNlLiBTZWUge0BsaW5rIHJ1bn0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gZ2V0UHVsc2Uob3AsIGVuY29kZSkge1xuICBjb25zdCBzID0gb3Auc291cmNlLFxuICAgICAgICBzdGFtcCA9IHRoaXMuX2Nsb2NrO1xuICByZXR1cm4gcyAmJiBpc0FycmF5KHMpID8gbmV3IE11bHRpUHVsc2UodGhpcywgc3RhbXAsIHMubWFwKF8gPT4gXy5wdWxzZSksIGVuY29kZSkgOiB0aGlzLl9pbnB1dFtvcC5pZF0gfHwgc2luZ2xlUHVsc2UodGhpcy5fcHVsc2UsIHMgJiYgcy5wdWxzZSk7XG59XG5cbmZ1bmN0aW9uIHNpbmdsZVB1bHNlKHAsIHMpIHtcbiAgaWYgKHMgJiYgcy5zdGFtcCA9PT0gcC5zdGFtcCkge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgcCA9IHAuZm9yaygpO1xuXG4gIGlmIChzICYmIHMgIT09IFN0b3BQcm9wYWdhdGlvbikge1xuICAgIHAuc291cmNlID0gcy5zb3VyY2U7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuY29uc3QgTk9fT1BUID0ge1xuICBza2lwOiBmYWxzZSxcbiAgZm9yY2U6IGZhbHNlXG59O1xuLyoqXG4gKiBUb3VjaGVzIGFuIG9wZXJhdG9yLCBzY2hlZHVsaW5nIGl0IHRvIGJlIGV2YWx1YXRlZC4gSWYgaW52b2tlZCBvdXRzaWRlIG9mXG4gKiBhIHB1bHNlIHByb3BhZ2F0aW9uLCB0aGUgb3BlcmF0b3Igd2lsbCBiZSBldmFsdWF0ZWQgdGhlIG5leHQgdGltZSB0aGlzXG4gKiBkYXRhZmxvdyBpcyBydW4uIElmIGludm9rZWQgaW4gdGhlIG1pZHN0IG9mIHB1bHNlIHByb3BhZ2F0aW9uLCB0aGUgb3BlcmF0b3JcbiAqIHdpbGwgYmUgcXVldWVkIGZvciBldmFsdWF0aW9uIGlmIGFuZCBvbmx5IGlmIHRoZSBvcGVyYXRvciBoYXMgbm90IHlldCBiZWVuXG4gKiBldmFsdWF0ZWQgb24gdGhlIGN1cnJlbnQgcHJvcGFnYXRpb24gdGltZXN0YW1wLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gdG91Y2guXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGhhc2guXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBdIC0gSWYgdHJ1ZSwgdGhlIG9wZXJhdG9yIHdpbGxcbiAqICAgYmUgc2tpcHBlZDogaXQgd2lsbCBub3QgYmUgZXZhbHVhdGVkLCBidXQgaXRzIGRlcGVuZGVudHMgd2lsbCBiZS5cbiAqIEByZXR1cm4ge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIHRvdWNoKG9wLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwgTk9fT1BUO1xuXG4gIGlmICh0aGlzLl9wdWxzZSkge1xuICAgIC8vIGlmIGluIG1pZHN0IG9mIHByb3BhZ2F0aW9uLCBhZGQgdG8gcHJpb3JpdHkgcXVldWVcbiAgICB0aGlzLl9lbnF1ZXVlKG9wKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHF1ZXVlIGZvciBuZXh0IHByb3BhZ2F0aW9uXG4gICAgdGhpcy5fdG91Y2hlZC5hZGQob3ApO1xuICB9XG5cbiAgaWYgKG9wdC5za2lwKSBvcC5za2lwKHRydWUpO1xuICByZXR1cm4gdGhpcztcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGhhc2guXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHJlLWV2YWx1YXRlZCBldmVuIGlmIGl0cyB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNraXBdIC0gSWYgdHJ1ZSwgdGhlIG9wZXJhdG9yIHdpbGxcbiAqICAgYmUgc2tpcHBlZDogaXQgd2lsbCBub3QgYmUgZXZhbHVhdGVkLCBidXQgaXRzIGRlcGVuZGVudHMgd2lsbCBiZS5cbiAqIEByZXR1cm4ge0RhdGFmbG93fVxuICovXG5cbmZ1bmN0aW9uIHVwZGF0ZShvcCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0ID0gb3B0aW9ucyB8fCBOT19PUFQ7XG5cbiAgaWYgKG9wLnNldCh2YWx1ZSkgfHwgb3B0LmZvcmNlKSB7XG4gICAgdGhpcy50b3VjaChvcCwgb3B0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuLyoqXG4gKiBQdWxzZXMgYW4gb3BlcmF0b3Igd2l0aCBhIGNoYW5nZXNldCBvZiB0dXBsZXMuIElmIGludm9rZWQgb3V0c2lkZSBvZlxuICogYSBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIHB1bHNlIHdpbGwgYmUgYXBwbGllZCB0aGUgbmV4dCB0aW1lIHRoaXNcbiAqIGRhdGFmbG93IGlzIHJ1bi4gSWYgaW52b2tlZCBpbiB0aGUgbWlkc3Qgb2YgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBwdWxzZVxuICogd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIGFjdGl2ZSBwdWxzZXMgYW5kIHdpbGwgYmUgYXBwbGllZCBpZiBhbmRcbiAqIG9ubHkgaWYgdGhlIHRhcmdldCBvcGVyYXRvciBoYXMgbm90IHlldCBiZWVuIGV2YWx1YXRlZCBvbiB0aGUgY3VycmVudFxuICogcHJvcGFnYXRpb24gdGltZXN0YW1wLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gcHVsc2UuXG4gKiBAcGFyYW0ge0NoYW5nZVNldH0gdmFsdWUgLSBUaGUgdHVwbGUgY2hhbmdlc2V0IHRvIGFwcGx5LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuXG5mdW5jdGlvbiBwdWxzZShvcCwgY2hhbmdlc2V0LCBvcHRpb25zKSB7XG4gIHRoaXMudG91Y2gob3AsIG9wdGlvbnMgfHwgTk9fT1BUKTtcbiAgY29uc3QgcCA9IG5ldyBQdWxzZSh0aGlzLCB0aGlzLl9jbG9jayArICh0aGlzLl9wdWxzZSA/IDAgOiAxKSksXG4gICAgICAgIHQgPSBvcC5wdWxzZSAmJiBvcC5wdWxzZS5zb3VyY2UgfHwgW107XG4gIHAudGFyZ2V0ID0gb3A7XG4gIHRoaXMuX2lucHV0W29wLmlkXSA9IGNoYW5nZXNldC5wdWxzZShwLCB0KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gIGxldCBub2RlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIGNsZWFyOiAoKSA9PiBub2RlcyA9IFtdLFxuICAgIHNpemU6ICgpID0+IG5vZGVzLmxlbmd0aCxcbiAgICBwZWVrOiAoKSA9PiBub2Rlc1swXSxcbiAgICBwdXNoOiB4ID0+IHtcbiAgICAgIG5vZGVzLnB1c2goeCk7XG4gICAgICByZXR1cm4gc2lmdGRvd24obm9kZXMsIDAsIG5vZGVzLmxlbmd0aCAtIDEsIGNtcCk7XG4gICAgfSxcbiAgICBwb3A6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxhc3QgPSBub2Rlcy5wb3AoKTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBub2Rlc1swXTtcbiAgICAgICAgbm9kZXNbMF0gPSBsYXN0O1xuICAgICAgICBzaWZ0dXAobm9kZXMsIDAsIGNtcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtID0gbGFzdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaWZ0ZG93bihhcnJheSwgc3RhcnQsIGlkeCwgY21wKSB7XG4gIGxldCBwYXJlbnQsIHBpZHg7XG4gIGNvbnN0IGl0ZW0gPSBhcnJheVtpZHhdO1xuXG4gIHdoaWxlIChpZHggPiBzdGFydCkge1xuICAgIHBpZHggPSBpZHggLSAxID4+IDE7XG4gICAgcGFyZW50ID0gYXJyYXlbcGlkeF07XG5cbiAgICBpZiAoY21wKGl0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICBhcnJheVtpZHhdID0gcGFyZW50O1xuICAgICAgaWR4ID0gcGlkeDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5W2lkeF0gPSBpdGVtO1xufVxuXG5mdW5jdGlvbiBzaWZ0dXAoYXJyYXksIGlkeCwgY21wKSB7XG4gIGNvbnN0IHN0YXJ0ID0gaWR4LFxuICAgICAgICBlbmQgPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGl0ZW0gPSBhcnJheVtpZHhdO1xuICBsZXQgY2lkeCA9IChpZHggPDwgMSkgKyAxLFxuICAgICAgcmlkeDtcblxuICB3aGlsZSAoY2lkeCA8IGVuZCkge1xuICAgIHJpZHggPSBjaWR4ICsgMTtcblxuICAgIGlmIChyaWR4IDwgZW5kICYmIGNtcChhcnJheVtjaWR4XSwgYXJyYXlbcmlkeF0pID49IDApIHtcbiAgICAgIGNpZHggPSByaWR4O1xuICAgIH1cblxuICAgIGFycmF5W2lkeF0gPSBhcnJheVtjaWR4XTtcbiAgICBpZHggPSBjaWR4O1xuICAgIGNpZHggPSAoaWR4IDw8IDEpICsgMTtcbiAgfVxuXG4gIGFycmF5W2lkeF0gPSBpdGVtO1xuICByZXR1cm4gc2lmdGRvd24oYXJyYXksIHN0YXJ0LCBpZHgsIGNtcCk7XG59XG5cbi8qKlxuICogQSBkYXRhZmxvdyBncmFwaCBmb3IgcmVhY3RpdmUgcHJvY2Vzc2luZyBvZiBkYXRhIHN0cmVhbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBEYXRhZmxvdygpIHtcbiAgdGhpcy5sb2dnZXIobG9nZ2VyKCkpO1xuICB0aGlzLmxvZ0xldmVsKEVycm9yKTtcbiAgdGhpcy5fY2xvY2sgPSAwO1xuICB0aGlzLl9yYW5rID0gMDtcbiAgdGhpcy5fbG9jYWxlID0gZGVmYXVsdExvY2FsZSgpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyKCk7XG4gIH0gY2F0Y2ggKGUpIHsvLyBkbyBub3RoaW5nIGlmIGxvYWRlciBtb2R1bGUgaXMgdW5hdmFpbGFibGVcbiAgfVxuXG4gIHRoaXMuX3RvdWNoZWQgPSBVbmlxdWVMaXN0KGlkKTtcbiAgdGhpcy5faW5wdXQgPSB7fTtcbiAgdGhpcy5fcHVsc2UgPSBudWxsO1xuICB0aGlzLl9oZWFwID0gSGVhcCgoYSwgYikgPT4gYS5xcmFuayAtIGIucXJhbmspO1xuICB0aGlzLl9wb3N0cnVuID0gW107XG59XG5cbmZ1bmN0aW9uIGxvZ01ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuRGF0YWZsb3cucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdGltZXN0YW1wIG9mIHRoaXMgZGF0YWZsb3cuIFRoaXMgdmFsdWUgcmVmbGVjdHMgdGhlXG4gICAqIHRpbWVzdGFtcCBvZiB0aGUgcHJldmlvdXMgZGF0YWZsb3cgcnVuLiBUaGUgZGF0YWZsb3cgaXMgaW5pdGlhbGl6ZWRcbiAgICogd2l0aCBhIHN0YW1wIHZhbHVlIG9mIDAuIFRoZSBpbml0aWFsIHJ1biBvZiB0aGUgZGF0YWZsb3cgd2lsbCBoYXZlXG4gICAqIGEgdGltZXN0YXAgb2YgMSwgYW5kIHNvIG9uLiBUaGlzIHZhbHVlIHdpbGwgbWF0Y2ggdGhlXG4gICAqIHtAbGluayBQdWxzZS5zdGFtcH0gcHJvcGVydHkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgY3VycmVudCB0aW1lc3RhbXAgdmFsdWUuXG4gICAqL1xuICBzdGFtcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvY2s7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbG9hZGVyIGluc3RhbmNlIHRvIHVzZSBmb3IgZGF0YSBmaWxlIGxvYWRpbmcuIEFcbiAgICogbG9hZGVyIG9iamVjdCBtdXN0IHByb3ZpZGUgYSBcImxvYWRcIiBtZXRob2QgZm9yIGxvYWRpbmcgZmlsZXMgYW5kIGFcbiAgICogXCJzYW5pdGl6ZVwiIG1ldGhvZCBmb3IgY2hlY2tpbmcgVVJML2ZpbGVuYW1lIHZhbGlkaXR5LiBCb3RoIG1ldGhvZHNcbiAgICogc2hvdWxkIGFjY2VwdCBhIFVSSSBhbmQgb3B0aW9ucyBoYXNoIGFzIGFyZ3VtZW50cywgYW5kIHJldHVybiBhIFByb21pc2VcbiAgICogdGhhdCByZXNvbHZlcyB0byB0aGUgbG9hZGVkIGZpbGUgY29udGVudHMgKGxvYWQpIG9yIGEgaGFzaCBjb250YWluaW5nXG4gICAqIHNhbml0aXplZCBVUkkgZGF0YSB3aXRoIHRoZSBzYW5pdGl6ZWQgdXJsIGFzc2lnbmVkIHRvIHRoZSBcImhyZWZcIiBwcm9wZXJ0eVxuICAgKiAoc2FuaXRpemUpLlxuICAgKiBAcGFyYW0ge29iamVjdH0gXyAtIFRoZSBsb2FkZXIgaW5zdGFuY2UgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtvYmplY3R8RGF0YWZsb3d9IC0gSWYgbm8gYXJndW1lbnRzIGFyZSBwcm92aWRlZCwgcmV0dXJuc1xuICAgKiAgIHRoZSBjdXJyZW50IGxvYWRlciBpbnN0YW5jZS4gT3RoZXJ3aXNlIHJldHVybnMgdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS5cbiAgICovXG4gIGxvYWRlcihfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvYWRlciA9IF87XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbG9jYWxlIGluc3RhbmNlIHRvIHVzZSBmb3IgZm9ybWF0dGluZyBhbmQgcGFyc2luZ1xuICAgKiBzdHJpbmcgdmFsdWVzLiBUaGUgbG9jYWxlIG9iamVjdCBzaG91bGQgYmUgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHZlZ2EtZm9ybWF0IGxpYnJhcnksIGFuZCBpbmNsdWRlIG1ldGhvZHMgc3VjaCBhcyBmb3JtYXQsIHRpbWVGb3JtYXQsXG4gICAqIHV0Y0Zvcm1hdCwgdGltZVBhcnNlLCBhbmQgdXRjUGFyc2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBfIC0gVGhlIGxvY2FsZSBpbnN0YW5jZSB0byB1c2UuXG4gICAqIEByZXR1cm4ge29iamVjdHxEYXRhZmxvd30gLSBJZiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCByZXR1cm5zXG4gICAqICAgdGhlIGN1cnJlbnQgbG9jYWxlIGluc3RhbmNlLiBPdGhlcndpc2UgcmV0dXJucyB0aGlzIERhdGFmbG93IGluc3RhbmNlLlxuICAgKi9cbiAgbG9jYWxlKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbG9jYWxlID0gXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgbG9nZ2VyIGluc3RhbmNlIHVzZWQgdG8gbG9nIG1lc3NhZ2VzLiBJZiBubyBhcmd1bWVudHMgYXJlXG4gICAqIHByb3ZpZGVkLCByZXR1cm5zIHRoZSBjdXJyZW50IGxvZ2dlciBpbnN0YW5jZS4gT3RoZXJ3aXNlLCBzZXRzIHRoZSBsb2dnZXJcbiAgICogYW5kIHJldHVybiB0aGlzIERhdGFmbG93IGluc3RhbmNlLiBQcm92aWRlZCBsb2dnZXJzIG11c3Qgc3VwcG9ydCB0aGUgZnVsbFxuICAgKiBBUEkgb2YgbG9nZ2VyIG9iamVjdHMgZ2VuZXJhdGVkIGJ5IHRoZSB2ZWdhLXV0aWwgbG9nZ2VyIG1ldGhvZC4gTm90ZSB0aGF0XG4gICAqIGJ5IGRlZmF1bHQgdGhlIGxvZyBsZXZlbCBvZiB0aGUgbmV3IGxvZ2dlciB3aWxsIGJlIHVzZWQ7IHVzZSB0aGUgbG9nTGV2ZWxcbiAgICogbWV0aG9kIHRvIGFkanVzdCB0aGUgbG9nIGxldmVsIGFzIG5lZWRlZC5cbiAgICovXG4gIGxvZ2dlcihsb2dnZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbG9nID0gbG9nZ2VyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2c7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb2dzIGFuIGVycm9yIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0byBjb25zb2xlXG4gICAqIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXMgaGlnaFxuICAgKiBlbm91Z2ggdG8gcGVybWl0IGVycm9yIG1lc3NhZ2VzLlxuICAgKi9cbiAgZXJyb3I6IGxvZ01ldGhvZCgnZXJyb3InKSxcblxuICAvKipcbiAgICogTG9ncyBhIHdhcm5pbmcgbWVzc2FnZS4gQnkgZGVmYXVsdCwgbG9nZ2VkIG1lc3NhZ2VzIGFyZSB3cml0dGVuIHRvIGNvbnNvbGVcbiAgICogb3V0cHV0LiBUaGUgbWVzc2FnZSB3aWxsIG9ubHkgYmUgbG9nZ2VkIGlmIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBpcyBoaWdoXG4gICAqIGVub3VnaCB0byBwZXJtaXQgd2FybmluZyBtZXNzYWdlcy5cbiAgICovXG4gIHdhcm46IGxvZ01ldGhvZCgnd2FybicpLFxuXG4gIC8qKlxuICAgKiBMb2dzIGEgaW5mb3JtYXRpb24gbWVzc2FnZS4gQnkgZGVmYXVsdCwgbG9nZ2VkIG1lc3NhZ2VzIGFyZSB3cml0dGVuIHRvXG4gICAqIGNvbnNvbGUgb3V0cHV0LiBUaGUgbWVzc2FnZSB3aWxsIG9ubHkgYmUgbG9nZ2VkIGlmIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBpc1xuICAgKiBoaWdoIGVub3VnaCB0byBwZXJtaXQgaW5mb3JtYXRpb24gbWVzc2FnZXMuXG4gICAqL1xuICBpbmZvOiBsb2dNZXRob2QoJ2luZm8nKSxcblxuICAvKipcbiAgICogTG9ncyBhIGRlYnVnIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0byBjb25zb2xlXG4gICAqIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXMgaGlnaFxuICAgKiBlbm91Z2ggdG8gcGVybWl0IGRlYnVnIG1lc3NhZ2VzLlxuICAgKi9cbiAgZGVidWc6IGxvZ01ldGhvZCgnZGVidWcnKSxcblxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2cgbGV2ZWwuIElmIGFuIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdFxuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyBsb2cgbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWxdIC0gU2hvdWxkIGJlIG9uZSBvZiBOb25lLCBXYXJuLCBJbmZvXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAqL1xuICBsb2dMZXZlbDogbG9nTWV0aG9kKCdsZXZlbCcpLFxuXG4gIC8qKlxuICAgKiBFbXB0eSBlbnRyeSB0aHJlc2hvbGQgZm9yIGdhcmJhZ2UgY2xlYW5pbmcuIE1hcCBkYXRhIHN0cnVjdHVyZXMgd2lsbFxuICAgKiBwZXJmb3JtIGNsZWFuaW5nIG9uY2UgdGhlIG51bWJlciBvZiBlbXB0eSBlbnRyaWVzIGV4Y2VlZHMgdGhpcyB2YWx1ZS5cbiAgICovXG4gIGNsZWFuVGhyZXNob2xkOiAxZTQsXG4gIC8vIE9QRVJBVE9SIFJFR0lTVFJBVElPTlxuICBhZGQsXG4gIGNvbm5lY3QsXG4gIHJhbmssXG4gIHJlcmFuayxcbiAgLy8gT1BFUkFUT1IgVVBEQVRFU1xuICBwdWxzZSxcbiAgdG91Y2gsXG4gIHVwZGF0ZSxcbiAgY2hhbmdlc2V0LFxuICAvLyBEQVRBIExPQURJTkdcbiAgaW5nZXN0LFxuICBwYXJzZSxcbiAgcHJlbG9hZCxcbiAgcmVxdWVzdCxcbiAgLy8gRVZFTlQgSEFORExJTkdcbiAgZXZlbnRzLFxuICBvbixcbiAgLy8gUFVMU0UgUFJPUEFHQVRJT05cbiAgZXZhbHVhdGUsXG4gIHJ1bixcbiAgcnVuQXN5bmMsXG4gIHJ1bkFmdGVyLFxuICBfZW5xdWV1ZTogZW5xdWV1ZSxcbiAgX2dldFB1bHNlOiBnZXRQdWxzZVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3Igb3BlcmF0b3JzIHRoYXQgcHJvY2VzcyBkYXRhIHR1cGxlcy5cbiAqIFN1YmNsYXNzZXMgbXVzdCBwcm92aWRlIGEge0BsaW5rIHRyYW5zZm9ybX0gbWV0aG9kIGZvciBvcGVyYXRvciBwcm9jZXNzaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IFtpbml0XSAtIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBbc291cmNlXSAtIFRoZSBvcGVyYXRvciBmcm9tIHdoaWNoIHRvIHJlY2VpdmUgcHVsc2VzLlxuICovXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShpbml0LCBwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBpbml0LCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVHJhbnNmb3JtLCBPcGVyYXRvciwge1xuICAvKipcbiAgICogT3ZlcnJpZGVzIHtAbGluayBPcGVyYXRvci5ldmFsdWF0ZX0gZm9yIHRyYW5zZm9ybSBvcGVyYXRvcnMuXG4gICAqIEludGVybmFsbHksIHRoaXMgbWV0aG9kIGNhbGxzIHtAbGluayBldmFsdWF0ZX0gdG8gcGVyZm9ybSBwcm9jZXNzaW5nLlxuICAgKiBJZiB7QGxpbmsgZXZhbHVhdGV9IHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgdGhlIGlucHV0IHB1bHNlIGlzIHJldHVybmVkLlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgTk9UIGJlIG92ZXJyaWRkZW4sIGluc3RlYWQgb3ZlcnJyaWRlIHtAbGluayBldmFsdWF0ZX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4gdGhlIG91dHB1dCBwdWxzZSBmb3IgdGhpcyBvcGVyYXRvciAob3IgU3RvcFByb3BhZ2F0aW9uKVxuICAgKi9cbiAgcnVuKHB1bHNlKSB7XG4gICAgaWYgKHB1bHNlLnN0YW1wIDwgdGhpcy5zdGFtcCkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICBsZXQgcnY7XG5cbiAgICBpZiAodGhpcy5za2lwKCkpIHtcbiAgICAgIHRoaXMuc2tpcChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2ID0gdGhpcy5ldmFsdWF0ZShwdWxzZSk7XG4gICAgfVxuXG4gICAgcnYgPSBydiB8fCBwdWxzZTtcblxuICAgIGlmIChydi50aGVuKSB7XG4gICAgICBydiA9IHJ2LnRoZW4oXyA9PiB0aGlzLnB1bHNlID0gXyk7XG4gICAgfSBlbHNlIGlmIChydiAhPT0gcHVsc2UuU3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICB0aGlzLnB1bHNlID0gcnY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ2O1xuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMge0BsaW5rIE9wZXJhdG9yLmV2YWx1YXRlfSBmb3IgdHJhbnNmb3JtIG9wZXJhdG9ycy5cbiAgICogTWFyc2hhbGxzIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRoZW4gaW52b2tlcyB7QGxpbmsgdHJhbnNmb3JtfS5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSB0aGUgY3VycmVudCBkYXRhZmxvdyBwdWxzZS5cbiAgICogQHJldHVybiB7UHVsc2V9IFRoZSBvdXRwdXQgcHVsc2UgKG9yIFN0b3BQcm9wYWdhdGlvbikuIEEgZmFsc3kgcmV0dXJuXG4gICAgICAgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQpIHdpbGwgbGV0IHRoZSBpbnB1dCBwdWxzZSBwYXNzIHRocm91Z2guXG4gICovXG4gIGV2YWx1YXRlKHB1bHNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5tYXJzaGFsbChwdWxzZS5zdGFtcCksXG4gICAgICAgICAgb3V0ID0gdGhpcy50cmFuc2Zvcm0ocGFyYW1zLCBwdWxzZSk7XG4gICAgcGFyYW1zLmNsZWFyKCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogUHJvY2VzcyBpbmNvbWluZyBwdWxzZXMuXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCB0cmFuc2Zvcm1zLlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnN9IF8gLSBUaGUgb3BlcmF0b3IgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBUaGUgY3VycmVudCBkYXRhZmxvdyBwdWxzZS5cbiAgICogQHJldHVybiB7UHVsc2V9IFRoZSBvdXRwdXQgcHVsc2UgKG9yIFN0b3BQcm9wYWdhdGlvbikuIEEgZmFsc3kgcmV0dXJuXG4gICAqICAgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQpIHdpbGwgbGV0IHRoZSBpbnB1dCBwdWxzZSBwYXNzIHRocm91Z2guXG4gICAqL1xuICB0cmFuc2Zvcm0oKSB7fVxuXG59KTtcblxuY29uc3QgdHJhbnNmb3JtcyA9IHt9O1xuZnVuY3Rpb24gZGVmaW5pdGlvbih0eXBlKSB7XG4gIGNvbnN0IHQgPSB0cmFuc2Zvcm0odHlwZSk7XG4gIHJldHVybiB0ICYmIHQuRGVmaW5pdGlvbiB8fCBudWxsO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKHR5cGUpIHtcbiAgdHlwZSA9IHR5cGUgJiYgdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodHJhbnNmb3JtcywgdHlwZSkgPyB0cmFuc2Zvcm1zW3R5cGVdIDogbnVsbDtcbn1cblxuZXhwb3J0IHsgRGF0YWZsb3csIEV2ZW50U3RyZWFtLCBNdWx0aVB1bHNlLCBPcGVyYXRvciwgUGFyYW1ldGVycywgUHVsc2UsIFRyYW5zZm9ybSwgVW5pcXVlTGlzdCwgYXN5bmNDYWxsYmFjaywgY2hhbmdlc2V0LCBkZWZpbml0aW9uLCBkZXJpdmUsIGluZ2VzdCQxIGFzIGluZ2VzdCwgaXNDaGFuZ2VTZXQsIGlzVHVwbGUsIHJlZGVyaXZlLCByZXBsYWNlLCBzdGFibGVDb21wYXJlLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybXMsIHR1cGxlaWQgfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSwgaW5nZXN0LCB0dXBsZWlkLCBzdGFibGVDb21wYXJlIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyB0aWNrQ291bnQsIHRpY2tGb3JtYXQsIHZhbGlkVGlja3MsIHRpY2tWYWx1ZXMsIFN5bWJvbExlZ2VuZCwgbGFiZWxGb3JtYXQsIGxhYmVsVmFsdWVzLCBHcmFkaWVudExlZ2VuZCwgc2NhbGVGcmFjdGlvbiwgbGFiZWxGcmFjdGlvbiwgc2NhbGUsIGlzQ29udGludW91cywgU2VxdWVudGlhbCwgTGluZWFyLCBUaW1lLCBVVEMsIFBvdywgU3FydCwgT3JkaW5hbCwgc2NhbGVJbXBsaWNpdCwgTG9nLCBTeW1sb2csIGlzTG9nYXJpdGhtaWMsIEJpbk9yZGluYWwsIGJhbmRTcGFjZSwgaXNJbnRlcnBvbGF0aW5nLCBpbnRlcnBvbGF0ZVJhbmdlLCBxdWFudGl6ZUludGVycG9sYXRvciwgaW50ZXJwb2xhdGVDb2xvcnMsIGludGVycG9sYXRlLCBCYW5kLCBQb2ludCwgc2NoZW1lLCBUaHJlc2hvbGQsIFF1YW50aWxlLCBRdWFudGl6ZSwgRGl2ZXJnaW5nIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyBpbmhlcml0cywgaXNBcnJheSwgZXJyb3IsIGZhc3RtYXAsIGZhbHN5LCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgcGVlaywgb25lLCB0b1NldCwgaXNTdHJpbmcsIHpvb21Mb2csIHpvb21Qb3csIHpvb21TeW1sb2csIHpvb21MaW5lYXIsIHN0cmluZ1ZhbHVlIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHN1bSwgcmFuZ2UgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZVJvdW5kLCBpbnRlcnBvbGF0ZSBhcyBpbnRlcnBvbGF0ZSQxIH0gZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBheGlzIHRpY2tzIGZvciB2aXN1YWxpemluZyBhIHNwYXRpYWwgc2NhbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7U2NhbGV9IHBhcmFtcy5zY2FsZSAtIFRoZSBzY2FsZSB0byBnZW5lcmF0ZSB0aWNrcyBmb3IuXG4gKiBAcGFyYW0geyp9IFtwYXJhbXMuY291bnQ9MTBdIC0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiB0aWNrcywgb3JcbiAqICAgZGVzaXJlZCB0aWNrIGludGVydmFsLCB0byB1c2UuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBbcGFyYW1zLnZhbHVlc10gLSBUaGUgZXhhY3QgdGljayB2YWx1ZXMgdG8gdXNlLlxuICogICBUaGVzZSBtdXN0IGJlIGxlZ2FsIGRvbWFpbiB2YWx1ZXMgZm9yIHRoZSBwcm92aWRlZCBzY2FsZS5cbiAqICAgSWYgcHJvdmlkZWQsIHRoZSBjb3VudCBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqKTpzdHJpbmd9IFtwYXJhbXMuZm9ybWF0U3BlY2lmaWVyXSAtIEEgZm9ybWF0IHNwZWNpZmllclxuICogICB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCBzY2FsZS50aWNrRm9ybWF0LiBMZWdhbCB2YWx1ZXMgYXJlXG4gKiAgIGFueSB2YWxpZCBkMyA0LjAgZm9ybWF0IHNwZWNpZmllci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6c3RyaW5nfSBbcGFyYW1zLmZvcm1hdF0gLSBUaGUgZm9ybWF0IGZ1bmN0aW9uIHRvIHVzZS5cbiAqICAgSWYgcHJvdmlkZWQsIHRoZSBmb3JtYXRTcGVjaWZpZXIgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqL1xuXG5mdW5jdGlvbiBBeGlzVGlja3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhBeGlzVGlja3MsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSBwdWxzZS5kYXRhZmxvdy5sb2NhbGUoKSxcbiAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICB0aWNrcyA9IHRoaXMudmFsdWUsXG4gICAgICAgIHNjYWxlID0gXy5zY2FsZSxcbiAgICAgICAgdGFsbHkgPSBfLmNvdW50ID09IG51bGwgPyBfLnZhbHVlcyA/IF8udmFsdWVzLmxlbmd0aCA6IDEwIDogXy5jb3VudCxcbiAgICAgICAgY291bnQgPSB0aWNrQ291bnQoc2NhbGUsIHRhbGx5LCBfLm1pbnN0ZXApLFxuICAgICAgICBmb3JtYXQgPSBfLmZvcm1hdCB8fCB0aWNrRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCBfLmZvcm1hdFNwZWNpZmllciwgXy5mb3JtYXRUeXBlLCAhIV8udmFsdWVzKSxcbiAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMgPyB2YWxpZFRpY2tzKHNjYWxlLCBfLnZhbHVlcywgY291bnQpIDogdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpO1xuICAgIGlmICh0aWNrcykgb3V0LnJlbSA9IHRpY2tzO1xuICAgIHRpY2tzID0gdmFsdWVzLm1hcCgodmFsdWUsIGkpID0+IGluZ2VzdCh7XG4gICAgICBpbmRleDogaSAvICh2YWx1ZXMubGVuZ3RoIC0gMSB8fCAxKSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxhYmVsOiBmb3JtYXQodmFsdWUpXG4gICAgfSkpO1xuXG4gICAgaWYgKF8uZXh0cmEgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgYW4gZXh0cmEgdGljayBwZWdnZWQgdG8gdGhlIGluaXRpYWwgZG9tYWluIHZhbHVlXG4gICAgICAvLyB0aGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGUgYXhlcyB3aXRoICdiaW5uZWQnIGRvbWFpbnNcbiAgICAgIHRpY2tzLnB1c2goaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgIHZhbHVlOiB0aWNrc1swXS52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJydcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBvdXQuc291cmNlID0gdGlja3M7XG4gICAgb3V0LmFkZCA9IHRpY2tzO1xuICAgIHRoaXMudmFsdWUgPSB0aWNrcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEpvaW5zIGEgc2V0IG9mIGRhdGEgZWxlbWVudHMgYWdhaW5zdCBhIHNldCBvZiB2aXN1YWwgaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogb2JqZWN0fSBbcGFyYW1zLml0ZW1dIC0gQW4gaXRlbSBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMua2V5XSAtIFRoZSBrZXkgZmllbGQgYXNzb2NpYXRpbmcgZGF0YSBhbmQgdmlzdWFsIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIERhdGFKb2luKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0SXRlbUNyZWF0ZSgpIHtcbiAgcmV0dXJuIGluZ2VzdCh7fSk7XG59XG5cbmZ1bmN0aW9uIG5ld01hcChrZXkpIHtcbiAgY29uc3QgbWFwID0gZmFzdG1hcCgpLnRlc3QodCA9PiB0LmV4aXQpO1xuXG4gIG1hcC5sb29rdXAgPSB0ID0+IG1hcC5nZXQoa2V5KHQpKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG5pbmhlcml0cyhEYXRhSm9pbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICAgIGl0ZW0gPSBfLml0ZW0gfHwgZGVmYXVsdEl0ZW1DcmVhdGUsXG4gICAgICAgIGtleSA9IF8ua2V5IHx8IHR1cGxlaWQsXG4gICAgICAgIG1hcCA9IHRoaXMudmFsdWU7IC8vIHByZXZlbnQgdHJhbnNpZW50IChlLmcuLCBob3ZlcikgcmVxdWVzdHMgZnJvbVxuICAgIC8vIGNhc2NhZGluZyBhY3Jvc3MgbWFya3MgZGVyaXZlZCBmcm9tIG1hcmtzXG5cbiAgICBpZiAoaXNBcnJheShvdXQuZW5jb2RlKSkge1xuICAgICAgb3V0LmVuY29kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1hcCAmJiAoXy5tb2RpZmllZCgna2V5JykgfHwgcHVsc2UubW9kaWZpZWQoa2V5KSkpIHtcbiAgICAgIGVycm9yKCdEYXRhSm9pbiBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVkIGtleSBmdW5jdGlvbiBvciBmaWVsZHMuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFtYXApIHtcbiAgICAgIHB1bHNlID0gcHVsc2UuYWRkQWxsKCk7XG4gICAgICB0aGlzLnZhbHVlID0gbWFwID0gbmV3TWFwKGtleSk7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGNvbnN0IGsgPSBrZXkodCk7XG4gICAgICBsZXQgeCA9IG1hcC5nZXQoayk7XG5cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIGlmICh4LmV4aXQpIHtcbiAgICAgICAgICBtYXAuZW1wdHktLTtcbiAgICAgICAgICBvdXQuYWRkLnB1c2goeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0Lm1vZC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gaXRlbSh0KTtcbiAgICAgICAgbWFwLnNldChrLCB4KTtcbiAgICAgICAgb3V0LmFkZC5wdXNoKHgpO1xuICAgICAgfVxuXG4gICAgICB4LmRhdHVtID0gdDtcbiAgICAgIHguZXhpdCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpLFxuICAgICAgICAgICAgeCA9IG1hcC5nZXQoayk7XG5cbiAgICAgIGlmICh4KSB7XG4gICAgICAgIHguZGF0dW0gPSB0O1xuICAgICAgICBvdXQubW9kLnB1c2goeCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgIGNvbnN0IGsgPSBrZXkodCksXG4gICAgICAgICAgICB4ID0gbWFwLmdldChrKTtcblxuICAgICAgaWYgKHQgPT09IHguZGF0dW0gJiYgIXguZXhpdCkge1xuICAgICAgICBvdXQucmVtLnB1c2goeCk7XG4gICAgICAgIHguZXhpdCA9IHRydWU7XG4gICAgICAgICsrbWFwLmVtcHR5O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9NT0QpKSBvdXQubW9kaWZpZXMoJ2RhdHVtJyk7XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSB8fCBfLmNsZWFuICYmIG1hcC5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSB7XG4gICAgICBkZi5ydW5BZnRlcihtYXAuY2xlYW4pO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogSW52b2tlcyBlbmNvZGluZyBmdW5jdGlvbnMgZm9yIHZpc3VhbCBpdGVtcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIHRvIHRoZSBlbmNvZGluZyBmdW5jdGlvbnMuIFRoaXNcbiAqICAgcGFyYW1ldGVyIG9iamVjdCB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGFsbCBpbnZva2VkIGVuY29kaW5nIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLm1vZD1mYWxzZV0gLSBGbGFnIGluZGljYXRpbmcgaWYgdHVwbGVzIGluIHRoZSBpbnB1dFxuICogICBtb2Qgc2V0IHRoYXQgYXJlIHVubW9kaWZpZWQgYnkgZW5jb2RlcnMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW0uZW5jb2RlcnMgLSBUaGUgZW5jb2RpbmcgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCwgb2JqZWN0KTogYm9vbGVhbn0gW3BhcmFtLmVuY29kZXJzLnVwZGF0ZV0gLSBVcGRhdGUgZW5jb2Rpbmcgc2V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCwgb2JqZWN0KTogYm9vbGVhbn0gW3BhcmFtLmVuY29kZXJzLmVudGVyXSAtIEVudGVyIGVuY29kaW5nIHNldFxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy5leGl0XSAtIEV4aXQgZW5jb2Rpbmcgc2V0XG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoRW5jb2RlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUREX1JFTSksXG4gICAgICAgIGZtb2QgPSBfLm1vZCB8fCBmYWxzZSxcbiAgICAgICAgZW5jb2RlcnMgPSBfLmVuY29kZXJzLFxuICAgICAgICBlbmNvZGUgPSBwdWxzZS5lbmNvZGU7IC8vIGlmIGFuIGFycmF5LCB0aGUgZW5jb2RlIGRpcmVjdGl2ZSBpbmNsdWRlcyBhZGRpdGlvbmFsIHNldHNcbiAgICAvLyB0aGF0IG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciBmb3IgdGhlIHByaW1hcnkgc2V0IHRvIGJlIGludm9rZWRcbiAgICAvLyBlLmcuLCBvbmx5IHJ1biB0aGUgdXBkYXRlIHNldCBpZiB0aGUgaG92ZXIgc2V0IGlzIGRlZmluZWRcblxuICAgIGlmIChpc0FycmF5KGVuY29kZSkpIHtcbiAgICAgIGlmIChvdXQuY2hhbmdlZCgpIHx8IGVuY29kZS5ldmVyeShlID0+IGVuY29kZXJzW2VdKSkge1xuICAgICAgICBlbmNvZGUgPSBlbmNvZGVbMF07XG4gICAgICAgIG91dC5lbmNvZGUgPSBudWxsOyAvLyBjb25zdW1lIHRhcmdldGVkIGVuY29kZSBkaXJlY3RpdmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgICB9XG4gICAgfSAvLyBtYXJzaGFsbCBlbmNvZGVyIGZ1bmN0aW9uc1xuXG5cbiAgICB2YXIgcmVlbnRlciA9IGVuY29kZSA9PT0gJ2VudGVyJyxcbiAgICAgICAgdXBkYXRlID0gZW5jb2RlcnMudXBkYXRlIHx8IGZhbHN5LFxuICAgICAgICBlbnRlciA9IGVuY29kZXJzLmVudGVyIHx8IGZhbHN5LFxuICAgICAgICBleGl0ID0gZW5jb2RlcnMuZXhpdCB8fCBmYWxzeSxcbiAgICAgICAgc2V0ID0gKGVuY29kZSAmJiAhcmVlbnRlciA/IGVuY29kZXJzW2VuY29kZV0gOiB1cGRhdGUpIHx8IGZhbHN5O1xuXG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuQUREKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgZW50ZXIodCwgXyk7XG4gICAgICAgIHVwZGF0ZSh0LCBfKTtcbiAgICAgIH0pO1xuICAgICAgb3V0Lm1vZGlmaWVzKGVudGVyLm91dHB1dCk7XG4gICAgICBvdXQubW9kaWZpZXModXBkYXRlLm91dHB1dCk7XG5cbiAgICAgIGlmIChzZXQgIT09IGZhbHN5ICYmIHNldCAhPT0gdXBkYXRlKSB7XG4gICAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICAgICAgc2V0KHQsIF8pO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0Lm1vZGlmaWVzKHNldC5vdXRwdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLlJFTSkgJiYgZXhpdCAhPT0gZmFsc3kpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICAgIGV4aXQodCwgXyk7XG4gICAgICB9KTtcbiAgICAgIG91dC5tb2RpZmllcyhleGl0Lm91dHB1dCk7XG4gICAgfVxuXG4gICAgaWYgKHJlZW50ZXIgfHwgc2V0ICE9PSBmYWxzeSkge1xuICAgICAgY29uc3QgZmxhZyA9IHB1bHNlLk1PRCB8IChfLm1vZGlmaWVkKCkgPyBwdWxzZS5SRUZMT1cgOiAwKTtcblxuICAgICAgaWYgKHJlZW50ZXIpIHtcbiAgICAgICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICAgICAgY29uc3QgbW9kID0gZW50ZXIodCwgXykgfHwgZm1vZDtcbiAgICAgICAgICBpZiAoc2V0KHQsIF8pIHx8IG1vZCkgb3V0Lm1vZC5wdXNoKHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG91dC5tb2QubGVuZ3RoKSBvdXQubW9kaWZpZXMoZW50ZXIub3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4ge1xuICAgICAgICAgIGlmIChzZXQodCwgXykgfHwgZm1vZCkgb3V0Lm1vZC5wdXNoKHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG91dC5tb2QubGVuZ3RoKSBvdXQubW9kaWZpZXMoc2V0Lm91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5jaGFuZ2VkKCkgPyBvdXQgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGxlZ2VuZCBlbnRyaWVzIGZvciB2aXN1YWxpemluZyBhIHNjYWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge1NjYWxlfSBwYXJhbXMuc2NhbGUgLSBUaGUgc2NhbGUgdG8gZ2VuZXJhdGUgaXRlbXMgZm9yLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmNvdW50PTVdIC0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiBpdGVtcywgb3JcbiAqICAgZGVzaXJlZCB0aWNrIGludGVydmFsLCB0byB1c2UuXG4gKiBAcGFyYW0geyp9IFtwYXJhbXMubGltaXRdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG9cbiAqICAgaW5jbHVkZSBpbiBhIHN5bWJvbCBsZWdlbmQuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBbcGFyYW1zLnZhbHVlc10gLSBUaGUgZXhhY3QgdGljayB2YWx1ZXMgdG8gdXNlLlxuICogICBUaGVzZSBtdXN0IGJlIGxlZ2FsIGRvbWFpbiB2YWx1ZXMgZm9yIHRoZSBwcm92aWRlZCBzY2FsZS5cbiAqICAgSWYgcHJvdmlkZWQsIHRoZSBjb3VudCBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuZm9ybWF0U3BlY2lmaWVyXSAtIEEgZm9ybWF0IHNwZWNpZmllclxuICogICB0byB1c2UgaW4gY29uanVuY3Rpb24gd2l0aCBzY2FsZS50aWNrRm9ybWF0LiBMZWdhbCB2YWx1ZXMgYXJlXG4gKiAgIGFueSB2YWxpZCBEMyBmb3JtYXQgc3BlY2lmaWVyIHN0cmluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6c3RyaW5nfSBbcGFyYW1zLmZvcm1hdF0gLSBUaGUgZm9ybWF0IGZ1bmN0aW9uIHRvIHVzZS5cbiAqICAgSWYgcHJvdmlkZWQsIHRoZSBmb3JtYXRTcGVjaWZpZXIgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqL1xuXG5mdW5jdGlvbiBMZWdlbmRFbnRyaWVzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKExlZ2VuZEVudHJpZXMsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPSBudWxsICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHB1bHNlLmRhdGFmbG93LmxvY2FsZSgpLFxuICAgICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICAgIGl0ZW1zID0gdGhpcy52YWx1ZSxcbiAgICAgICAgdHlwZSA9IF8udHlwZSB8fCBTeW1ib2xMZWdlbmQsXG4gICAgICAgIHNjYWxlID0gXy5zY2FsZSxcbiAgICAgICAgbGltaXQgPSArXy5saW1pdCxcbiAgICAgICAgY291bnQgPSB0aWNrQ291bnQoc2NhbGUsIF8uY291bnQgPT0gbnVsbCA/IDUgOiBfLmNvdW50LCBfLm1pbnN0ZXApLFxuICAgICAgICBsc2tpcCA9ICEhXy52YWx1ZXMgfHwgdHlwZSA9PT0gU3ltYm9sTGVnZW5kLFxuICAgICAgICBmb3JtYXQgPSBfLmZvcm1hdCB8fCBsYWJlbEZvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgdHlwZSwgXy5mb3JtYXRTcGVjaWZpZXIsIF8uZm9ybWF0VHlwZSwgbHNraXApLFxuICAgICAgICB2YWx1ZXMgPSBfLnZhbHVlcyB8fCBsYWJlbFZhbHVlcyhzY2FsZSwgY291bnQpLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIGZyYWN0aW9uLFxuICAgICAgICBzaXplLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVsbGlwc2lzO1xuICAgIGlmIChpdGVtcykgb3V0LnJlbSA9IGl0ZW1zO1xuXG4gICAgaWYgKHR5cGUgPT09IFN5bWJvbExlZ2VuZCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHZhbHVlcy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKCdTeW1ib2wgbGVnZW5kIGNvdW50IGV4Y2VlZHMgbGltaXQsIGZpbHRlcmluZyBpdGVtcy4nKTtcbiAgICAgICAgaXRlbXMgPSB2YWx1ZXMuc2xpY2UoMCwgbGltaXQgLSAxKTtcbiAgICAgICAgZWxsaXBzaXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXMgPSB2YWx1ZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNpemUgPSBfLnNpemUpKSB7XG4gICAgICAgIC8vIGlmIGZpcnN0IHZhbHVlIG1hcHMgdG8gc2l6ZSB6ZXJvLCByZW1vdmUgZnJvbSBsaXN0ICh2ZWdhIzcxNylcbiAgICAgICAgaWYgKCFfLnZhbHVlcyAmJiBzY2FsZShpdGVtc1swXSkgPT09IDApIHtcbiAgICAgICAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDEpO1xuICAgICAgICB9IC8vIGNvbXB1dGUgc2l6ZSBvZmZzZXQgZm9yIGxlZ2VuZCBlbnRyaWVzXG5cblxuICAgICAgICBvZmZzZXQgPSBpdGVtcy5yZWR1Y2UoKG1heCwgdmFsdWUpID0+IE1hdGgubWF4KG1heCwgc2l6ZSh2YWx1ZSwgXykpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBjb25zdGFudChvZmZzZXQgPSBzaXplIHx8IDgpO1xuICAgICAgfVxuXG4gICAgICBpdGVtcyA9IGl0ZW1zLm1hcCgodmFsdWUsIGluZGV4KSA9PiBpbmdlc3Qoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGxhYmVsOiBmb3JtYXQodmFsdWUsIGluZGV4LCBpdGVtcyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIHNpemU6IHNpemUodmFsdWUsIF8pXG4gICAgICB9KSk7XG5cbiAgICAgIGlmIChlbGxpcHNpcykge1xuICAgICAgICBlbGxpcHNpcyA9IHZhbHVlc1tpdGVtcy5sZW5ndGhdO1xuICAgICAgICBpdGVtcy5wdXNoKGluZ2VzdCh7XG4gICAgICAgICAgaW5kZXg6IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICBsYWJlbDogXCJcXHUyMDI2XCIuY29uY2F0KHZhbHVlcy5sZW5ndGggLSBpdGVtcy5sZW5ndGgsIFwiIGVudHJpZXNcIiksXG4gICAgICAgICAgdmFsdWU6IGVsbGlwc2lzLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHNpemU6IHNpemUoZWxsaXBzaXMsIF8pXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdyYWRpZW50TGVnZW5kKSB7XG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4oKSwgZnJhY3Rpb24gPSBzY2FsZUZyYWN0aW9uKHNjYWxlLCBkb21haW5bMF0sIHBlZWsoZG9tYWluKSk7IC8vIGlmIGF1dG9tYXRpYyBsYWJlbCBnZW5lcmF0aW9uIHByb2R1Y2VzIDIgb3IgZmV3ZXIgdmFsdWVzLFxuICAgICAgLy8gdXNlIHRoZSBkb21haW4gZW5kIHBvaW50cyBpbnN0ZWFkIChmaXhlcyB2ZWdhL3ZlZ2EjMTM2NClcblxuICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPCAzICYmICFfLnZhbHVlcyAmJiBkb21haW5bMF0gIT09IHBlZWsoZG9tYWluKSkge1xuICAgICAgICB2YWx1ZXMgPSBbZG9tYWluWzBdLCBwZWVrKGRvbWFpbildO1xuICAgICAgfVxuXG4gICAgICBpdGVtcyA9IHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgdmFsdWVzKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwZXJjOiBmcmFjdGlvbih2YWx1ZSlcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgZnJhY3Rpb24gPSBsYWJlbEZyYWN0aW9uKHNjYWxlKTtcbiAgICAgIGl0ZW1zID0gdmFsdWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiBpbmdlc3Qoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGxhYmVsOiBmb3JtYXQodmFsdWUsIGluZGV4LCB2YWx1ZXMpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHBlcmM6IGluZGV4ID8gZnJhY3Rpb24odmFsdWUpIDogMCxcbiAgICAgICAgcGVyYzI6IGluZGV4ID09PSBzaXplID8gMSA6IGZyYWN0aW9uKHZhbHVlc1tpbmRleCArIDFdKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2UgPSBpdGVtcztcbiAgICBvdXQuYWRkID0gaXRlbXM7XG4gICAgdGhpcy52YWx1ZSA9IGl0ZW1zO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmNvbnN0IHNvdXJjZVggPSB0ID0+IHQuc291cmNlLng7XG5cbmNvbnN0IHNvdXJjZVkgPSB0ID0+IHQuc291cmNlLnk7XG5cbmNvbnN0IHRhcmdldFggPSB0ID0+IHQudGFyZ2V0Lng7XG5cbmNvbnN0IHRhcmdldFkgPSB0ID0+IHQudGFyZ2V0Lnk7XG4vKipcbiAqIExheW91dCBwYXRocyBsaW5raW5nIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuXG5mdW5jdGlvbiBMaW5rUGF0aChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge30sIHBhcmFtcyk7XG59XG5MaW5rUGF0aC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMaW5rUGF0aCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NvdXJjZVgnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnZGVmYXVsdCc6ICdzb3VyY2UueCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NvdXJjZVknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnZGVmYXVsdCc6ICdzb3VyY2UueSdcbiAgfSwge1xuICAgICduYW1lJzogJ3RhcmdldFgnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnZGVmYXVsdCc6ICd0YXJnZXQueCdcbiAgfSwge1xuICAgICduYW1lJzogJ3RhcmdldFknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnZGVmYXVsdCc6ICd0YXJnZXQueSdcbiAgfSwge1xuICAgICduYW1lJzogJ29yaWVudCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAndmVydGljYWwnLFxuICAgICd2YWx1ZXMnOiBbJ2hvcml6b250YWwnLCAndmVydGljYWwnLCAncmFkaWFsJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3NoYXBlJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICdsaW5lJyxcbiAgICAndmFsdWVzJzogWydsaW5lJywgJ2FyYycsICdjdXJ2ZScsICdkaWFnb25hbCcsICdvcnRob2dvbmFsJ11cbiAgfSwge1xuICAgICduYW1lJzogJ3JlcXVpcmUnLFxuICAgICd0eXBlJzogJ3NpZ25hbCdcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BhdGgnXG4gIH1dXG59O1xuaW5oZXJpdHMoTGlua1BhdGgsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgc3ggPSBfLnNvdXJjZVggfHwgc291cmNlWCxcbiAgICAgICAgc3kgPSBfLnNvdXJjZVkgfHwgc291cmNlWSxcbiAgICAgICAgdHggPSBfLnRhcmdldFggfHwgdGFyZ2V0WCxcbiAgICAgICAgdHkgPSBfLnRhcmdldFkgfHwgdGFyZ2V0WSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdwYXRoJyxcbiAgICAgICAgb3JpZW50ID0gXy5vcmllbnQgfHwgJ3ZlcnRpY2FsJyxcbiAgICAgICAgc2hhcGUgPSBfLnNoYXBlIHx8ICdsaW5lJyxcbiAgICAgICAgcGF0aCA9IFBhdGhzLmdldChzaGFwZSArICctJyArIG9yaWVudCkgfHwgUGF0aHMuZ2V0KHNoYXBlKTtcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgZXJyb3IoJ0xpbmtQYXRoIHVuc3VwcG9ydGVkIHR5cGU6ICcgKyBfLnNoYXBlICsgKF8ub3JpZW50ID8gJy0nICsgXy5vcmllbnQgOiAnJykpO1xuICAgIH1cblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgICB0W2FzXSA9IHBhdGgoc3godCksIHN5KHQpLCB0eCh0KSwgdHkodCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbmNvbnN0IGxpbmUgPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnTCcgKyB0eCArICcsJyArIHR5O1xuXG5jb25zdCBsaW5lUiA9IChzYSwgc3IsIHRhLCB0cikgPT4gbGluZShzciAqIE1hdGguY29zKHNhKSwgc3IgKiBNYXRoLnNpbihzYSksIHRyICogTWF0aC5jb3ModGEpLCB0ciAqIE1hdGguc2luKHRhKSk7XG5cbmNvbnN0IGFyYyA9IChzeCwgc3ksIHR4LCB0eSkgPT4ge1xuICB2YXIgZHggPSB0eCAtIHN4LFxuICAgICAgZHkgPSB0eSAtIHN5LFxuICAgICAgcnIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpIC8gMixcbiAgICAgIHJhID0gMTgwICogTWF0aC5hdGFuMihkeSwgZHgpIC8gTWF0aC5QSTtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgKyAnQScgKyByciArICcsJyArIHJyICsgJyAnICsgcmEgKyAnIDAgMScgKyAnICcgKyB0eCArICcsJyArIHR5O1xufTtcblxuY29uc3QgYXJjUiA9IChzYSwgc3IsIHRhLCB0cikgPT4gYXJjKHNyICogTWF0aC5jb3Moc2EpLCBzciAqIE1hdGguc2luKHNhKSwgdHIgKiBNYXRoLmNvcyh0YSksIHRyICogTWF0aC5zaW4odGEpKTtcblxuY29uc3QgY3VydmUgPSAoc3gsIHN5LCB0eCwgdHkpID0+IHtcbiAgY29uc3QgZHggPSB0eCAtIHN4LFxuICAgICAgICBkeSA9IHR5IC0gc3ksXG4gICAgICAgIGl4ID0gMC4yICogKGR4ICsgZHkpLFxuICAgICAgICBpeSA9IDAuMiAqIChkeSAtIGR4KTtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgKyAnQycgKyAoc3ggKyBpeCkgKyAnLCcgKyAoc3kgKyBpeSkgKyAnICcgKyAodHggKyBpeSkgKyAnLCcgKyAodHkgLSBpeCkgKyAnICcgKyB0eCArICcsJyArIHR5O1xufTtcblxuY29uc3QgY3VydmVSID0gKHNhLCBzciwgdGEsIHRyKSA9PiBjdXJ2ZShzciAqIE1hdGguY29zKHNhKSwgc3IgKiBNYXRoLnNpbihzYSksIHRyICogTWF0aC5jb3ModGEpLCB0ciAqIE1hdGguc2luKHRhKSk7XG5cbmNvbnN0IG9ydGhvWCA9IChzeCwgc3ksIHR4LCB0eSkgPT4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdWJyArIHR5ICsgJ0gnICsgdHg7XG5cbmNvbnN0IG9ydGhvWSA9IChzeCwgc3ksIHR4LCB0eSkgPT4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdIJyArIHR4ICsgJ1YnICsgdHk7XG5cbmNvbnN0IG9ydGhvUiA9IChzYSwgc3IsIHRhLCB0cikgPT4ge1xuICBjb25zdCBzYyA9IE1hdGguY29zKHNhKSxcbiAgICAgICAgc3MgPSBNYXRoLnNpbihzYSksXG4gICAgICAgIHRjID0gTWF0aC5jb3ModGEpLFxuICAgICAgICB0cyA9IE1hdGguc2luKHRhKSxcbiAgICAgICAgc2YgPSBNYXRoLmFicyh0YSAtIHNhKSA+IE1hdGguUEkgPyB0YSA8PSBzYSA6IHRhID4gc2E7XG4gIHJldHVybiAnTScgKyBzciAqIHNjICsgJywnICsgc3IgKiBzcyArICdBJyArIHNyICsgJywnICsgc3IgKyAnIDAgMCwnICsgKHNmID8gMSA6IDApICsgJyAnICsgc3IgKiB0YyArICcsJyArIHNyICogdHMgKyAnTCcgKyB0ciAqIHRjICsgJywnICsgdHIgKiB0cztcbn07XG5cbmNvbnN0IGRpYWdvbmFsWCA9IChzeCwgc3ksIHR4LCB0eSkgPT4ge1xuICBjb25zdCBtID0gKHN4ICsgdHgpIC8gMjtcbiAgcmV0dXJuICdNJyArIHN4ICsgJywnICsgc3kgKyAnQycgKyBtICsgJywnICsgc3kgKyAnICcgKyBtICsgJywnICsgdHkgKyAnICcgKyB0eCArICcsJyArIHR5O1xufTtcblxuY29uc3QgZGlhZ29uYWxZID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IG0gPSAoc3kgKyB0eSkgLyAyO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdDJyArIHN4ICsgJywnICsgbSArICcgJyArIHR4ICsgJywnICsgbSArICcgJyArIHR4ICsgJywnICsgdHk7XG59O1xuXG5jb25zdCBkaWFnb25hbFIgPSAoc2EsIHNyLCB0YSwgdHIpID0+IHtcbiAgY29uc3Qgc2MgPSBNYXRoLmNvcyhzYSksXG4gICAgICAgIHNzID0gTWF0aC5zaW4oc2EpLFxuICAgICAgICB0YyA9IE1hdGguY29zKHRhKSxcbiAgICAgICAgdHMgPSBNYXRoLnNpbih0YSksXG4gICAgICAgIG1yID0gKHNyICsgdHIpIC8gMjtcbiAgcmV0dXJuICdNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ0MnICsgbXIgKiBzYyArICcsJyArIG1yICogc3MgKyAnICcgKyBtciAqIHRjICsgJywnICsgbXIgKiB0cyArICcgJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzO1xufTtcblxuY29uc3QgUGF0aHMgPSBmYXN0bWFwKHtcbiAgJ2xpbmUnOiBsaW5lLFxuICAnbGluZS1yYWRpYWwnOiBsaW5lUixcbiAgJ2FyYyc6IGFyYyxcbiAgJ2FyYy1yYWRpYWwnOiBhcmNSLFxuICAnY3VydmUnOiBjdXJ2ZSxcbiAgJ2N1cnZlLXJhZGlhbCc6IGN1cnZlUixcbiAgJ29ydGhvZ29uYWwtaG9yaXpvbnRhbCc6IG9ydGhvWCxcbiAgJ29ydGhvZ29uYWwtdmVydGljYWwnOiBvcnRob1ksXG4gICdvcnRob2dvbmFsLXJhZGlhbCc6IG9ydGhvUixcbiAgJ2RpYWdvbmFsLWhvcml6b250YWwnOiBkaWFnb25hbFgsXG4gICdkaWFnb25hbC12ZXJ0aWNhbCc6IGRpYWdvbmFsWSxcbiAgJ2RpYWdvbmFsLXJhZGlhbCc6IGRpYWdvbmFsUlxufSk7XG5cbi8qKlxuICogUGllIGFuZCBkb251dCBjaGFydCBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgcGllIHNlZ21lbnRzLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuc3RhcnRBbmdsZT0wXSAtIFRoZSBzdGFydCBhbmdsZSAoaW4gcmFkaWFucykgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmVuZEFuZ2xlPTLPgF0gLSBUaGUgZW5kIGFuZ2xlIChpbiByYWRpYW5zKSBvZiB0aGUgbGF5b3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNvcnRdIC0gQm9vbGVhbiBmbGFnIGZvciBzb3J0aW5nIHNlY3RvcnMgYnkgdmFsdWUuXG4gKi9cblxuZnVuY3Rpb24gUGllKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuUGllLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1BpZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3N0YXJ0QW5nbGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdlbmRBbmdsZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDYuMjgzMTg1MzA3MTc5NTg2XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ11cbiAgfV1cbn07XG5pbmhlcml0cyhQaWUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgYXMgPSBfLmFzIHx8IFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLFxuICAgICAgICBzdGFydEFuZ2xlID0gYXNbMF0sXG4gICAgICAgIGVuZEFuZ2xlID0gYXNbMV0sXG4gICAgICAgIGZpZWxkID0gXy5maWVsZCB8fCBvbmUsXG4gICAgICAgIHN0YXJ0ID0gXy5zdGFydEFuZ2xlIHx8IDAsXG4gICAgICAgIHN0b3AgPSBfLmVuZEFuZ2xlICE9IG51bGwgPyBfLmVuZEFuZ2xlIDogMiAqIE1hdGguUEksXG4gICAgICAgIGRhdGEgPSBwdWxzZS5zb3VyY2UsXG4gICAgICAgIHZhbHVlcyA9IGRhdGEubWFwKGZpZWxkKSxcbiAgICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIGEgPSBzdGFydCxcbiAgICAgICAgayA9IChzdG9wIC0gc3RhcnQpIC8gc3VtKHZhbHVlcyksXG4gICAgICAgIGluZGV4ID0gcmFuZ2UobiksXG4gICAgICAgIGksXG4gICAgICAgIHQsXG4gICAgICAgIHY7XG5cbiAgICBpZiAoXy5zb3J0KSB7XG4gICAgICBpbmRleC5zb3J0KChhLCBiKSA9PiB2YWx1ZXNbYV0gLSB2YWx1ZXNbYl0pO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaW5kZXhbaV1dO1xuICAgICAgdCA9IGRhdGFbaW5kZXhbaV1dO1xuICAgICAgdFtzdGFydEFuZ2xlXSA9IGE7XG4gICAgICB0W2VuZEFuZ2xlXSA9IGEgKz0gdiAqIGs7XG4gICAgfVxuXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlcztcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5jb25zdCBERUZBVUxUX0NPVU5UID0gNTtcblxuZnVuY3Rpb24gaW5jbHVkZVplcm8oc2NhbGUpIHtcbiAgY29uc3QgdHlwZSA9IHNjYWxlLnR5cGU7XG4gIHJldHVybiAhc2NhbGUuYmlucyAmJiAodHlwZSA9PT0gTGluZWFyIHx8IHR5cGUgPT09IFBvdyB8fCB0eXBlID09PSBTcXJ0KTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZVBhZCh0eXBlKSB7XG4gIHJldHVybiBpc0NvbnRpbnVvdXModHlwZSkgJiYgdHlwZSAhPT0gU2VxdWVudGlhbDtcbn1cblxuY29uc3QgU0tJUCA9IHRvU2V0KFsnc2V0JywgJ21vZGlmaWVkJywgJ2NsZWFyJywgJ3R5cGUnLCAnc2NoZW1lJywgJ3NjaGVtZUV4dGVudCcsICdzY2hlbWVDb3VudCcsICdkb21haW4nLCAnZG9tYWluTWluJywgJ2RvbWFpbk1pZCcsICdkb21haW5NYXgnLCAnZG9tYWluUmF3JywgJ2RvbWFpbkltcGxpY2l0JywgJ25pY2UnLCAnemVybycsICdiaW5zJywgJ3JhbmdlJywgJ3JhbmdlU3RlcCcsICdyb3VuZCcsICdyZXZlcnNlJywgJ2ludGVycG9sYXRlJywgJ2ludGVycG9sYXRlR2FtbWEnXSk7XG4vKipcbiAqIE1haW50YWlucyBhIHNjYWxlIGZ1bmN0aW9uIG1hcHBpbmcgZGF0YSB2YWx1ZXMgdG8gdmlzdWFsIGNoYW5uZWxzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gU2NhbGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMubW9kaWZpZWQodHJ1ZSk7IC8vIGFsd2F5cyB0cmVhdCBhcyBtb2RpZmllZFxufVxuaW5oZXJpdHMoU2NhbGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgZGYgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgc2NhbGUkMSA9IHRoaXMudmFsdWUsXG4gICAgICAgIGtleSA9IHNjYWxlS2V5KF8pO1xuXG4gICAgaWYgKCFzY2FsZSQxIHx8IGtleSAhPT0gc2NhbGUkMS50eXBlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gc2NhbGUkMSA9IHNjYWxlKGtleSkoKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBfKSBpZiAoIVNLSVBba2V5XSkge1xuICAgICAgLy8gcGFkZGluZyBpcyBhIHNjYWxlIHByb3BlcnR5IGZvciBiYW5kL3BvaW50IGJ1dCBub3Qgb3RoZXJzXG4gICAgICBpZiAoa2V5ID09PSAncGFkZGluZycgJiYgaW5jbHVkZVBhZChzY2FsZSQxLnR5cGUpKSBjb250aW51ZTsgLy8gaW52b2tlIHNjYWxlIHByb3BlcnR5IHNldHRlciwgcmFpc2Ugd2FybmluZyBpZiBub3QgZm91bmRcblxuICAgICAgaXNGdW5jdGlvbihzY2FsZSQxW2tleV0pID8gc2NhbGUkMVtrZXldKF9ba2V5XSkgOiBkZi53YXJuKCdVbnN1cHBvcnRlZCBzY2FsZSBwcm9wZXJ0eTogJyArIGtleSk7XG4gICAgfVxuXG4gICAgY29uZmlndXJlUmFuZ2Uoc2NhbGUkMSwgXywgY29uZmlndXJlQmlucyhzY2FsZSQxLCBfLCBjb25maWd1cmVEb21haW4oc2NhbGUkMSwgXywgZGYpKSk7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2NhbGVLZXkoXykge1xuICB2YXIgdCA9IF8udHlwZSxcbiAgICAgIGQgPSAnJyxcbiAgICAgIG47IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSBWZWdhIDUuXG5cbiAgaWYgKHQgPT09IFNlcXVlbnRpYWwpIHJldHVybiBTZXF1ZW50aWFsICsgJy0nICsgTGluZWFyO1xuXG4gIGlmIChpc0NvbnRpbnVvdXNDb2xvcihfKSkge1xuICAgIG4gPSBfLnJhd0RvbWFpbiA/IF8ucmF3RG9tYWluLmxlbmd0aCA6IF8uZG9tYWluID8gXy5kb21haW4ubGVuZ3RoICsgKyhfLmRvbWFpbk1pZCAhPSBudWxsKSA6IDA7XG4gICAgZCA9IG4gPT09IDIgPyBTZXF1ZW50aWFsICsgJy0nIDogbiA9PT0gMyA/IERpdmVyZ2luZyArICctJyA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIChkICsgdCB8fCBMaW5lYXIpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGludW91c0NvbG9yKF8pIHtcbiAgY29uc3QgdCA9IF8udHlwZTtcbiAgcmV0dXJuIGlzQ29udGludW91cyh0KSAmJiB0ICE9PSBUaW1lICYmIHQgIT09IFVUQyAmJiAoXy5zY2hlbWUgfHwgXy5yYW5nZSAmJiBfLnJhbmdlLmxlbmd0aCAmJiBfLnJhbmdlLmV2ZXJ5KGlzU3RyaW5nKSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZURvbWFpbihzY2FsZSwgXywgZGYpIHtcbiAgLy8gY2hlY2sgcmF3IGRvbWFpbiwgaWYgcHJvdmlkZWQgdXNlIHRoYXQgYW5kIGV4aXQgZWFybHlcbiAgY29uc3QgcmF3ID0gcmF3RG9tYWluKHNjYWxlLCBfLmRvbWFpblJhdywgZGYpO1xuICBpZiAocmF3ID4gLTEpIHJldHVybiByYXc7XG4gIHZhciBkb21haW4gPSBfLmRvbWFpbixcbiAgICAgIHR5cGUgPSBzY2FsZS50eXBlLFxuICAgICAgemVybyA9IF8uemVybyB8fCBfLnplcm8gPT09IHVuZGVmaW5lZCAmJiBpbmNsdWRlWmVybyhzY2FsZSksXG4gICAgICBuLFxuICAgICAgbWlkO1xuICBpZiAoIWRvbWFpbikgcmV0dXJuIDA7IC8vIGFkanVzdCBjb250aW51b3VzIGRvbWFpbiBmb3IgbWluaW11bSBwaXhlbCBwYWRkaW5nXG5cbiAgaWYgKGluY2x1ZGVQYWQodHlwZSkgJiYgXy5wYWRkaW5nICYmIGRvbWFpblswXSAhPT0gcGVlayhkb21haW4pKSB7XG4gICAgZG9tYWluID0gcGFkRG9tYWluKHR5cGUsIGRvbWFpbiwgXy5yYW5nZSwgXy5wYWRkaW5nLCBfLmV4cG9uZW50LCBfLmNvbnN0YW50KTtcbiAgfSAvLyBhZGp1c3QgZG9tYWluIGJhc2VkIG9uIHplcm8sIG1pbiwgbWF4IHNldHRpbmdzXG5cblxuICBpZiAoemVybyB8fCBfLmRvbWFpbk1pbiAhPSBudWxsIHx8IF8uZG9tYWluTWF4ICE9IG51bGwgfHwgXy5kb21haW5NaWQgIT0gbnVsbCkge1xuICAgIG4gPSAoZG9tYWluID0gZG9tYWluLnNsaWNlKCkpLmxlbmd0aCAtIDEgfHwgMTtcblxuICAgIGlmICh6ZXJvKSB7XG4gICAgICBpZiAoZG9tYWluWzBdID4gMCkgZG9tYWluWzBdID0gMDtcbiAgICAgIGlmIChkb21haW5bbl0gPCAwKSBkb21haW5bbl0gPSAwO1xuICAgIH1cblxuICAgIGlmIChfLmRvbWFpbk1pbiAhPSBudWxsKSBkb21haW5bMF0gPSBfLmRvbWFpbk1pbjtcbiAgICBpZiAoXy5kb21haW5NYXggIT0gbnVsbCkgZG9tYWluW25dID0gXy5kb21haW5NYXg7XG5cbiAgICBpZiAoXy5kb21haW5NaWQgIT0gbnVsbCkge1xuICAgICAgbWlkID0gXy5kb21haW5NaWQ7XG4gICAgICBjb25zdCBpID0gbWlkID4gZG9tYWluW25dID8gbiArIDEgOiBtaWQgPCBkb21haW5bMF0gPyAwIDogbjtcbiAgICAgIGlmIChpICE9PSBuKSBkZi53YXJuKCdTY2FsZSBkb21haW5NaWQgZXhjZWVkcyBkb21haW4gbWluIG9yIG1heC4nLCBtaWQpO1xuICAgICAgZG9tYWluLnNwbGljZShpLCAwLCBtaWQpO1xuICAgIH1cbiAgfSAvLyBzZXQgdGhlIHNjYWxlIGRvbWFpblxuXG5cbiAgc2NhbGUuZG9tYWluKGRvbWFpbkNoZWNrKHR5cGUsIGRvbWFpbiwgZGYpKTsgLy8gaWYgb3JkaW5hbCBzY2FsZSBkb21haW4gaXMgZGVmaW5lZCwgcHJldmVudCBpbXBsaWNpdFxuICAvLyBkb21haW4gY29uc3RydWN0aW9uIGFzIHNpZGUtZWZmZWN0IG9mIHNjYWxlIGxvb2t1cFxuXG4gIGlmICh0eXBlID09PSBPcmRpbmFsKSB7XG4gICAgc2NhbGUudW5rbm93bihfLmRvbWFpbkltcGxpY2l0ID8gc2NhbGVJbXBsaWNpdCA6IHVuZGVmaW5lZCk7XG4gIH0gLy8gcGVyZm9ybSAnbmljZScgYWRqdXN0bWVudCBhcyByZXF1ZXN0ZWRcblxuXG4gIGlmIChfLm5pY2UgJiYgc2NhbGUubmljZSkge1xuICAgIHNjYWxlLm5pY2UoXy5uaWNlICE9PSB0cnVlICYmIHRpY2tDb3VudChzY2FsZSwgXy5uaWNlKSB8fCBudWxsKTtcbiAgfSAvLyByZXR1cm4gdGhlIGNhcmRpbmFsaXR5IG9mIHRoZSBkb21haW5cblxuXG4gIHJldHVybiBkb21haW4ubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiByYXdEb21haW4oc2NhbGUsIHJhdywgZGYpIHtcbiAgaWYgKHJhdykge1xuICAgIHNjYWxlLmRvbWFpbihkb21haW5DaGVjayhzY2FsZS50eXBlLCByYXcsIGRmKSk7XG4gICAgcmV0dXJuIHJhdy5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhZERvbWFpbih0eXBlLCBkb21haW4sIHJhbmdlLCBwYWQsIGV4cG9uZW50LCBjb25zdGFudCkge1xuICB2YXIgc3BhbiA9IE1hdGguYWJzKHBlZWsocmFuZ2UpIC0gcmFuZ2VbMF0pLFxuICAgICAgZnJhYyA9IHNwYW4gLyAoc3BhbiAtIDIgKiBwYWQpLFxuICAgICAgZCA9IHR5cGUgPT09IExvZyA/IHpvb21Mb2coZG9tYWluLCBudWxsLCBmcmFjKSA6IHR5cGUgPT09IFNxcnQgPyB6b29tUG93KGRvbWFpbiwgbnVsbCwgZnJhYywgMC41KSA6IHR5cGUgPT09IFBvdyA/IHpvb21Qb3coZG9tYWluLCBudWxsLCBmcmFjLCBleHBvbmVudCB8fCAxKSA6IHR5cGUgPT09IFN5bWxvZyA/IHpvb21TeW1sb2coZG9tYWluLCBudWxsLCBmcmFjLCBjb25zdGFudCB8fCAxKSA6IHpvb21MaW5lYXIoZG9tYWluLCBudWxsLCBmcmFjKTtcbiAgZG9tYWluID0gZG9tYWluLnNsaWNlKCk7XG4gIGRvbWFpblswXSA9IGRbMF07XG4gIGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0gPSBkWzFdO1xuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiBkb21haW5DaGVjayh0eXBlLCBkb21haW4sIGRmKSB7XG4gIGlmIChpc0xvZ2FyaXRobWljKHR5cGUpKSB7XG4gICAgLy8gc3VtIHNpZ25zIG9mIGRvbWFpbiB2YWx1ZXNcbiAgICAvLyBpZiBhbGwgcG9zIG9yIGFsbCBuZWcsIGFicyhzdW0pID09PSBkb21haW4ubGVuZ3RoXG4gICAgdmFyIHMgPSBNYXRoLmFicyhkb21haW4ucmVkdWNlKChzLCB2KSA9PiBzICsgKHYgPCAwID8gLTEgOiB2ID4gMCA/IDEgOiAwKSwgMCkpO1xuXG4gICAgaWYgKHMgIT09IGRvbWFpbi5sZW5ndGgpIHtcbiAgICAgIGRmLndhcm4oJ0xvZyBzY2FsZSBkb21haW4gaW5jbHVkZXMgemVybzogJyArIHN0cmluZ1ZhbHVlKGRvbWFpbikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUJpbnMoc2NhbGUsIF8sIGNvdW50KSB7XG4gIGxldCBiaW5zID0gXy5iaW5zO1xuXG4gIGlmIChiaW5zICYmICFpc0FycmF5KGJpbnMpKSB7XG4gICAgLy8gZ2VuZXJhdGUgYmluIGJvdW5kYXJ5IGFycmF5XG4gICAgY29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgICAgbG8gPSBkb21haW5bMF0sXG4gICAgICAgICAgaGkgPSBwZWVrKGRvbWFpbiksXG4gICAgICAgICAgc3RlcCA9IGJpbnMuc3RlcDtcbiAgICBsZXQgc3RhcnQgPSBiaW5zLnN0YXJ0ID09IG51bGwgPyBsbyA6IGJpbnMuc3RhcnQsXG4gICAgICAgIHN0b3AgPSBiaW5zLnN0b3AgPT0gbnVsbCA/IGhpIDogYmlucy5zdG9wO1xuICAgIGlmICghc3RlcCkgZXJyb3IoJ1NjYWxlIGJpbnMgcGFyYW1ldGVyIG1pc3Npbmcgc3RlcCBwcm9wZXJ0eS4nKTtcbiAgICBpZiAoc3RhcnQgPCBsbykgc3RhcnQgPSBzdGVwICogTWF0aC5jZWlsKGxvIC8gc3RlcCk7XG4gICAgaWYgKHN0b3AgPiBoaSkgc3RvcCA9IHN0ZXAgKiBNYXRoLmZsb29yKGhpIC8gc3RlcCk7XG4gICAgYmlucyA9IHJhbmdlKHN0YXJ0LCBzdG9wICsgc3RlcCAvIDIsIHN0ZXApO1xuICB9XG5cbiAgaWYgKGJpbnMpIHtcbiAgICAvLyBhc3NpZ24gYmluIGJvdW5kYXJpZXMgdG8gc2NhbGUgaW5zdGFuY2VcbiAgICBzY2FsZS5iaW5zID0gYmlucztcbiAgfSBlbHNlIGlmIChzY2FsZS5iaW5zKSB7XG4gICAgLy8gbm8gY3VycmVudCBiaW5zLCByZW1vdmUgYmlucyBpZiBwcmV2aW91c2x5IHNldFxuICAgIGRlbGV0ZSBzY2FsZS5iaW5zO1xuICB9IC8vIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGJpbi1vcmRpbmFsIHNjYWxlc1xuXG5cbiAgaWYgKHNjYWxlLnR5cGUgPT09IEJpbk9yZGluYWwpIHtcbiAgICBpZiAoIWJpbnMpIHtcbiAgICAgIC8vIHRoZSBkb21haW4gc3BlY2lmaWVzIHRoZSBiaW5zXG4gICAgICBzY2FsZS5iaW5zID0gc2NhbGUuZG9tYWluKCk7XG4gICAgfSBlbHNlIGlmICghXy5kb21haW4gJiYgIV8uZG9tYWluUmF3KSB7XG4gICAgICAvLyB0aGUgYmlucyBzcGVjaWZ5IHRoZSBkb21haW5cbiAgICAgIHNjYWxlLmRvbWFpbihiaW5zKTtcbiAgICAgIGNvdW50ID0gYmlucy5sZW5ndGg7XG4gICAgfVxuICB9IC8vIHJldHVybiBkb21haW4gY2FyZGluYWxpdHlcblxuXG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlUmFuZ2Uoc2NhbGUsIF8sIGNvdW50KSB7XG4gIHZhciB0eXBlID0gc2NhbGUudHlwZSxcbiAgICAgIHJvdW5kID0gXy5yb3VuZCB8fCBmYWxzZSxcbiAgICAgIHJhbmdlID0gXy5yYW5nZTsgLy8gaWYgcmFuZ2Ugc3RlcCBzcGVjaWZpZWQsIGNhbGN1bGF0ZSBmdWxsIHJhbmdlIGV4dGVudFxuXG4gIGlmIChfLnJhbmdlU3RlcCAhPSBudWxsKSB7XG4gICAgcmFuZ2UgPSBjb25maWd1cmVSYW5nZVN0ZXAodHlwZSwgXywgY291bnQpO1xuICB9IC8vIGVsc2UgaWYgYSByYW5nZSBzY2hlbWUgaXMgZGVmaW5lZCwgdXNlIHRoYXRcbiAgZWxzZSBpZiAoXy5zY2hlbWUpIHtcbiAgICAgIHJhbmdlID0gY29uZmlndXJlU2NoZW1lKHR5cGUsIF8sIGNvdW50KTtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24ocmFuZ2UpKSB7XG4gICAgICAgIGlmIChzY2FsZS5pbnRlcnBvbGF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gc2NhbGUuaW50ZXJwb2xhdG9yKHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcihcIlNjYWxlIHR5cGUgXCIuY29uY2F0KHR5cGUsIFwiIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJwb2xhdGluZyBjb2xvciBzY2hlbWVzLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGdpdmVuIGEgcmFuZ2UgYXJyYXkgZm9yIGFuIGludGVycG9sYXRpbmcgc2NhbGUsIGNvbnZlcnQgdG8gaW50ZXJwb2xhdG9yXG5cblxuICBpZiAocmFuZ2UgJiYgaXNJbnRlcnBvbGF0aW5nKHR5cGUpKSB7XG4gICAgcmV0dXJuIHNjYWxlLmludGVycG9sYXRvcihpbnRlcnBvbGF0ZUNvbG9ycyhmbGlwKHJhbmdlLCBfLnJldmVyc2UpLCBfLmludGVycG9sYXRlLCBfLmludGVycG9sYXRlR2FtbWEpKTtcbiAgfSAvLyBjb25maWd1cmUgcm91bmRpbmcgLyBpbnRlcnBvbGF0aW9uXG5cblxuICBpZiAocmFuZ2UgJiYgXy5pbnRlcnBvbGF0ZSAmJiBzY2FsZS5pbnRlcnBvbGF0ZSkge1xuICAgIHNjYWxlLmludGVycG9sYXRlKGludGVycG9sYXRlKF8uaW50ZXJwb2xhdGUsIF8uaW50ZXJwb2xhdGVHYW1tYSkpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc2NhbGUucm91bmQpKSB7XG4gICAgc2NhbGUucm91bmQocm91bmQpO1xuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oc2NhbGUucmFuZ2VSb3VuZCkpIHtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZShyb3VuZCA/IGludGVycG9sYXRlUm91bmQgOiBpbnRlcnBvbGF0ZSQxKTtcbiAgfVxuXG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UoZmxpcChyYW5nZSwgXy5yZXZlcnNlKSk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJhbmdlU3RlcCh0eXBlLCBfLCBjb3VudCkge1xuICBpZiAodHlwZSAhPT0gQmFuZCAmJiB0eXBlICE9PSBQb2ludCkge1xuICAgIGVycm9yKCdPbmx5IGJhbmQgYW5kIHBvaW50IHNjYWxlcyBzdXBwb3J0IHJhbmdlU3RlcC4nKTtcbiAgfSAvLyBjYWxjdWxhdGUgZnVsbCByYW5nZSBiYXNlZCBvbiByZXF1ZXN0ZWQgc3RlcCBzaXplIGFuZCBwYWRkaW5nXG5cblxuICB2YXIgb3V0ZXIgPSAoXy5wYWRkaW5nT3V0ZXIgIT0gbnVsbCA/IF8ucGFkZGluZ091dGVyIDogXy5wYWRkaW5nKSB8fCAwLFxuICAgICAgaW5uZXIgPSB0eXBlID09PSBQb2ludCA/IDEgOiAoXy5wYWRkaW5nSW5uZXIgIT0gbnVsbCA/IF8ucGFkZGluZ0lubmVyIDogXy5wYWRkaW5nKSB8fCAwO1xuICByZXR1cm4gWzAsIF8ucmFuZ2VTdGVwICogYmFuZFNwYWNlKGNvdW50LCBpbm5lciwgb3V0ZXIpXTtcbn1cblxuZnVuY3Rpb24gY29uZmlndXJlU2NoZW1lKHR5cGUsIF8sIGNvdW50KSB7XG4gIHZhciBleHRlbnQgPSBfLnNjaGVtZUV4dGVudCxcbiAgICAgIG5hbWUsXG4gICAgICBzY2hlbWUkMTtcblxuICBpZiAoaXNBcnJheShfLnNjaGVtZSkpIHtcbiAgICBzY2hlbWUkMSA9IGludGVycG9sYXRlQ29sb3JzKF8uc2NoZW1lLCBfLmludGVycG9sYXRlLCBfLmludGVycG9sYXRlR2FtbWEpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBfLnNjaGVtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHNjaGVtZSQxID0gc2NoZW1lKG5hbWUpO1xuICAgIGlmICghc2NoZW1lJDEpIGVycm9yKFwiVW5yZWNvZ25pemVkIHNjaGVtZSBuYW1lOiBcIi5jb25jYXQoXy5zY2hlbWUpKTtcbiAgfSAvLyBkZXRlcm1pbmUgc2l6ZSBmb3IgcG90ZW50aWFsIGRpc2NyZXRlIHJhbmdlXG5cblxuICBjb3VudCA9IHR5cGUgPT09IFRocmVzaG9sZCA/IGNvdW50ICsgMSA6IHR5cGUgPT09IEJpbk9yZGluYWwgPyBjb3VudCAtIDEgOiB0eXBlID09PSBRdWFudGlsZSB8fCB0eXBlID09PSBRdWFudGl6ZSA/ICtfLnNjaGVtZUNvdW50IHx8IERFRkFVTFRfQ09VTlQgOiBjb3VudDsgLy8gYWRqdXN0IGFuZC9vciBxdWFudGl6ZSBzY2hlbWUgYXMgYXBwcm9wcmlhdGVcblxuICByZXR1cm4gaXNJbnRlcnBvbGF0aW5nKHR5cGUpID8gYWRqdXN0U2NoZW1lKHNjaGVtZSQxLCBleHRlbnQsIF8ucmV2ZXJzZSkgOiBpc0Z1bmN0aW9uKHNjaGVtZSQxKSA/IHF1YW50aXplSW50ZXJwb2xhdG9yKGFkanVzdFNjaGVtZShzY2hlbWUkMSwgZXh0ZW50KSwgY291bnQpIDogdHlwZSA9PT0gT3JkaW5hbCA/IHNjaGVtZSQxIDogc2NoZW1lJDEuc2xpY2UoMCwgY291bnQpO1xufVxuXG5mdW5jdGlvbiBhZGp1c3RTY2hlbWUoc2NoZW1lLCBleHRlbnQsIHJldmVyc2UpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oc2NoZW1lKSAmJiAoZXh0ZW50IHx8IHJldmVyc2UpID8gaW50ZXJwb2xhdGVSYW5nZShzY2hlbWUsIGZsaXAoZXh0ZW50IHx8IFswLCAxXSwgcmV2ZXJzZSkpIDogc2NoZW1lO1xufVxuXG5mdW5jdGlvbiBmbGlwKGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiByZXZlcnNlID8gYXJyYXkuc2xpY2UoKS5yZXZlcnNlKCkgOiBhcnJheTtcbn1cblxuLyoqXG4gKiBTb3J0cyBzY2VuZWdyYXBoIGl0ZW1zIGluIHRoZSBwdWxzZSBzb3VyY2UgYXJyYXkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwqKTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yXG4gKiAgIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHR1cGxlcy5cbiAqL1xuXG5mdW5jdGlvbiBTb3J0SXRlbXMocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhTb3J0SXRlbXMsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5BREQpIHx8IHB1bHNlLm1vZGlmaWVkKF8uc29ydC5maWVsZHMpIHx8IHB1bHNlLm1vZGlmaWVkKCdkYXR1bScpO1xuICAgIGlmIChtb2QpIHB1bHNlLnNvdXJjZS5zb3J0KHN0YWJsZUNvbXBhcmUoXy5zb3J0KSk7XG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxuXG59KTtcblxuY29uc3QgWmVybyA9ICd6ZXJvJyxcbiAgICAgIENlbnRlciA9ICdjZW50ZXInLFxuICAgICAgTm9ybWFsaXplID0gJ25vcm1hbGl6ZScsXG4gICAgICBEZWZPdXRwdXQgPSBbJ3kwJywgJ3kxJ107XG4vKipcbiAqIFN0YWNrIGxheW91dCBmb3IgdmlzdWFsaXphdGlvbiBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gc3RhY2suXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCxvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBIGNvbXBhcmF0b3IgZm9yIHN0YWNrIHNvcnRpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29mZnNldD0nemVybyddIC0gU3RhY2sgYmFzZWxpbmUgb2Zmc2V0LiBPbmUgb2YgJ3plcm8nLCAnY2VudGVyJywgJ25vcm1hbGl6ZScuXG4gKi9cblxuZnVuY3Rpb24gU3RhY2socGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5TdGFjay5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTdGFjaycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnb2Zmc2V0JyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6IFplcm8sXG4gICAgJ3ZhbHVlcyc6IFtaZXJvLCBDZW50ZXIsIE5vcm1hbGl6ZV1cbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBEZWZPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhTdGFjaywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBhcyA9IF8uYXMgfHwgRGVmT3V0cHV0LFxuICAgICAgICB5MCA9IGFzWzBdLFxuICAgICAgICB5MSA9IGFzWzFdLFxuICAgICAgICBzb3J0ID0gc3RhYmxlQ29tcGFyZShfLnNvcnQpLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgb25lLFxuICAgICAgICBzdGFjayA9IF8ub2Zmc2V0ID09PSBDZW50ZXIgPyBzdGFja0NlbnRlciA6IF8ub2Zmc2V0ID09PSBOb3JtYWxpemUgPyBzdGFja05vcm1hbGl6ZSA6IHN0YWNrWmVybyxcbiAgICAgICAgZ3JvdXBzLFxuICAgICAgICBpLFxuICAgICAgICBuLFxuICAgICAgICBtYXg7IC8vIHBhcnRpdGlvbiwgc3VtLCBhbmQgc29ydCB0aGUgc3RhY2sgZ3JvdXBzXG5cbiAgICBncm91cHMgPSBwYXJ0aXRpb24ocHVsc2Uuc291cmNlLCBfLmdyb3VwYnksIHNvcnQsIGZpZWxkKTsgLy8gY29tcHV0ZSBzdGFjayBsYXlvdXRzIHBlciBncm91cFxuXG4gICAgZm9yIChpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGgsIG1heCA9IGdyb3Vwcy5tYXg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0YWNrKGdyb3Vwc1tpXSwgbWF4LCBmaWVsZCwgeTAsIHkxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzdGFja0NlbnRlcihncm91cCwgbWF4LCBmaWVsZCwgeTAsIHkxKSB7XG4gIHZhciBsYXN0ID0gKG1heCAtIGdyb3VwLnN1bSkgLyAyLFxuICAgICAgbSA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGogPSAwLFxuICAgICAgdDtcblxuICBmb3IgKDsgaiA8IG07ICsraikge1xuICAgIHQgPSBncm91cFtqXTtcbiAgICB0W3kwXSA9IGxhc3Q7XG4gICAgdFt5MV0gPSBsYXN0ICs9IE1hdGguYWJzKGZpZWxkKHQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFja05vcm1hbGl6ZShncm91cCwgbWF4LCBmaWVsZCwgeTAsIHkxKSB7XG4gIHZhciBzY2FsZSA9IDEgLyBncm91cC5zdW0sXG4gICAgICBsYXN0ID0gMCxcbiAgICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgICBqID0gMCxcbiAgICAgIHYgPSAwLFxuICAgICAgdDtcblxuICBmb3IgKDsgaiA8IG07ICsraikge1xuICAgIHQgPSBncm91cFtqXTtcbiAgICB0W3kwXSA9IGxhc3Q7XG4gICAgdFt5MV0gPSBsYXN0ID0gc2NhbGUgKiAodiArPSBNYXRoLmFicyhmaWVsZCh0KSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YWNrWmVybyhncm91cCwgbWF4LCBmaWVsZCwgeTAsIHkxKSB7XG4gIHZhciBsYXN0UG9zID0gMCxcbiAgICAgIGxhc3ROZWcgPSAwLFxuICAgICAgbSA9IGdyb3VwLmxlbmd0aCxcbiAgICAgIGogPSAwLFxuICAgICAgdixcbiAgICAgIHQ7XG5cbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdiA9ICtmaWVsZCh0KTtcblxuICAgIGlmICh2IDwgMCkge1xuICAgICAgdFt5MF0gPSBsYXN0TmVnO1xuICAgICAgdFt5MV0gPSBsYXN0TmVnICs9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRbeTBdID0gbGFzdFBvcztcbiAgICAgIHRbeTFdID0gbGFzdFBvcyArPSB2O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydCwgZmllbGQpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgZ2V0ID0gZiA9PiBmKHQpLFxuICAgICAgbWFwLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBtLFxuICAgICAgdCxcbiAgICAgIGssXG4gICAgICBnLFxuICAgICAgcyxcbiAgICAgIG1heDsgLy8gcGFydGl0aW9uIGRhdGEgcG9pbnRzIGludG8gc3RhY2sgZ3JvdXBzXG5cblxuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5zbGljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH0gLy8gY29tcHV0ZSBzdW1zIG9mIGdyb3Vwcywgc29ydCBncm91cHMgYXMgbmVlZGVkXG5cblxuICBmb3IgKGsgPSAwLCBtYXggPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgayA8IG07ICsraykge1xuICAgIGcgPSBncm91cHNba107XG5cbiAgICBmb3IgKGkgPSAwLCBzID0gMCwgbiA9IGcubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBzICs9IE1hdGguYWJzKGZpZWxkKGdbaV0pKTtcbiAgICB9XG5cbiAgICBnLnN1bSA9IHM7XG4gICAgaWYgKHMgPiBtYXgpIG1heCA9IHM7XG4gICAgaWYgKHNvcnQpIGcuc29ydChzb3J0KTtcbiAgfVxuXG4gIGdyb3Vwcy5tYXggPSBtYXg7XG4gIHJldHVybiBncm91cHM7XG59XG5cbmV4cG9ydCB7IEF4aXNUaWNrcyBhcyBheGlzdGlja3MsIERhdGFKb2luIGFzIGRhdGFqb2luLCBFbmNvZGUgYXMgZW5jb2RlLCBMZWdlbmRFbnRyaWVzIGFzIGxlZ2VuZGVudHJpZXMsIExpbmtQYXRoIGFzIGxpbmtwYXRoLCBQaWUgYXMgcGllLCBTY2FsZSBhcyBzY2FsZSwgU29ydEl0ZW1zIGFzIHNvcnRpdGVtcywgU3RhY2sgYXMgc3RhY2sgfTtcbiIsImNvbnN0IFZJRVcgPSAndmlldycsXG4gICAgICBMQlJBQ0sgPSAnWycsXG4gICAgICBSQlJBQ0sgPSAnXScsXG4gICAgICBMQlJBQ0UgPSAneycsXG4gICAgICBSQlJBQ0UgPSAnfScsXG4gICAgICBDT0xPTiA9ICc6JyxcbiAgICAgIENPTU1BID0gJywnLFxuICAgICAgTkFNRSA9ICdAJyxcbiAgICAgIEdUID0gJz4nLFxuICAgICAgSUxMRUdBTCA9IC9bW1xcXXt9XS8sXG4gICAgICBERUZBVUxUX01BUktTID0ge1xuICAnKic6IDEsXG4gIGFyYzogMSxcbiAgYXJlYTogMSxcbiAgZ3JvdXA6IDEsXG4gIGltYWdlOiAxLFxuICBsaW5lOiAxLFxuICBwYXRoOiAxLFxuICByZWN0OiAxLFxuICBydWxlOiAxLFxuICBzaGFwZTogMSxcbiAgc3ltYm9sOiAxLFxuICB0ZXh0OiAxLFxuICB0cmFpbDogMVxufTtcbmxldCBERUZBVUxUX1NPVVJDRSwgTUFSS1M7XG4vKipcbiAqIFBhcnNlIGFuIGV2ZW50IHNlbGVjdG9yIHN0cmluZy5cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZXZlbnQgc3RyZWFtIGRlZmluaXRpb25zLlxuICovXG5cbmZ1bmN0aW9uIGV2ZW50U2VsZWN0b3IgKHNlbGVjdG9yLCBzb3VyY2UsIG1hcmtzKSB7XG4gIERFRkFVTFRfU09VUkNFID0gc291cmNlIHx8IFZJRVc7XG4gIE1BUktTID0gbWFya3MgfHwgREVGQVVMVF9NQVJLUztcbiAgcmV0dXJuIHBhcnNlTWVyZ2Uoc2VsZWN0b3IudHJpbSgpKS5tYXAocGFyc2VTZWxlY3Rvcik7XG59XG5cbmZ1bmN0aW9uIGlzTWFya1R5cGUodHlwZSkge1xuICByZXR1cm4gTUFSS1NbdHlwZV07XG59XG5cbmZ1bmN0aW9uIGZpbmQocywgaSwgZW5kQ2hhciwgcHVzaENoYXIsIHBvcENoYXIpIHtcbiAgY29uc3QgbiA9IHMubGVuZ3RoO1xuICBsZXQgY291bnQgPSAwLFxuICAgICAgYztcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGMgPSBzW2ldO1xuICAgIGlmICghY291bnQgJiYgYyA9PT0gZW5kQ2hhcikgcmV0dXJuIGk7ZWxzZSBpZiAocG9wQ2hhciAmJiBwb3BDaGFyLmluZGV4T2YoYykgPj0gMCkgLS1jb3VudDtlbHNlIGlmIChwdXNoQ2hhciAmJiBwdXNoQ2hhci5pbmRleE9mKGMpID49IDApICsrY291bnQ7XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNZXJnZShzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdLFxuICAgICAgICBuID0gcy5sZW5ndGg7XG4gIGxldCBzdGFydCA9IDAsXG4gICAgICBpID0gMDtcblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBDT01NQSwgTEJSQUNLICsgTEJSQUNFLCBSQlJBQ0sgKyBSQlJBQ0UpO1xuICAgIG91dHB1dC5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIHN0YXJ0ID0gKytpO1xuICB9XG5cbiAgaWYgKG91dHB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAnRW1wdHkgZXZlbnQgc2VsZWN0b3I6ICcgKyBzO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gcGFyc2VTZWxlY3RvcihzKSB7XG4gIHJldHVybiBzWzBdID09PSAnWycgPyBwYXJzZUJldHdlZW4ocykgOiBwYXJzZVN0cmVhbShzKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VCZXR3ZWVuKHMpIHtcbiAgY29uc3QgbiA9IHMubGVuZ3RoO1xuICBsZXQgaSA9IDEsXG4gICAgICBiO1xuICBpID0gZmluZChzLCBpLCBSQlJBQ0ssIExCUkFDSywgUkJSQUNLKTtcblxuICBpZiAoaSA9PT0gbikge1xuICAgIHRocm93ICdFbXB0eSBiZXR3ZWVuIHNlbGVjdG9yOiAnICsgcztcbiAgfVxuXG4gIGIgPSBwYXJzZU1lcmdlKHMuc3Vic3RyaW5nKDEsIGkpKTtcblxuICBpZiAoYi5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyAnQmV0d2VlbiBzZWxlY3RvciBtdXN0IGhhdmUgdHdvIGVsZW1lbnRzOiAnICsgcztcbiAgfVxuXG4gIHMgPSBzLnNsaWNlKGkgKyAxKS50cmltKCk7XG5cbiAgaWYgKHNbMF0gIT09IEdUKSB7XG4gICAgdGhyb3cgJ0V4cGVjdGVkIFxcJz5cXCcgYWZ0ZXIgYmV0d2VlbiBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBiID0gYi5tYXAocGFyc2VTZWxlY3Rvcik7XG4gIGNvbnN0IHN0cmVhbSA9IHBhcnNlU2VsZWN0b3Iocy5zbGljZSgxKS50cmltKCkpO1xuXG4gIGlmIChzdHJlYW0uYmV0d2Vlbikge1xuICAgIHJldHVybiB7XG4gICAgICBiZXR3ZWVuOiBiLFxuICAgICAgc3RyZWFtOiBzdHJlYW1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5iZXR3ZWVuID0gYjtcbiAgfVxuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtKHMpIHtcbiAgY29uc3Qgc3RyZWFtID0ge1xuICAgIHNvdXJjZTogREVGQVVMVF9TT1VSQ0VcbiAgfSxcbiAgICAgICAgc291cmNlID0gW107XG4gIGxldCB0aHJvdHRsZSA9IFswLCAwXSxcbiAgICAgIG1hcmtuYW1lID0gMCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIG4gPSBzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgaixcbiAgICAgIGZpbHRlcjsgLy8gZXh0cmFjdCB0aHJvdHRsZSBmcm9tIGVuZFxuXG4gIGlmIChzW24gLSAxXSA9PT0gUkJSQUNFKSB7XG4gICAgaSA9IHMubGFzdEluZGV4T2YoTEJSQUNFKTtcblxuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm90dGxlID0gcGFyc2VUaHJvdHRsZShzLnN1YnN0cmluZyhpICsgMSwgbiAtIDEpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgdGhyb3R0bGUgc3BlY2lmaWNhdGlvbjogJyArIHM7XG4gICAgICB9XG5cbiAgICAgIHMgPSBzLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIG4gPSBzLmxlbmd0aDtcbiAgICB9IGVsc2UgdGhyb3cgJ1VubWF0Y2hlZCByaWdodCBicmFjZTogJyArIHM7XG5cbiAgICBpID0gMDtcbiAgfVxuXG4gIGlmICghbikgdGhyb3cgczsgLy8gc2V0IG5hbWUgZmxhZyBiYXNlZCBvbiBmaXJzdCBjaGFyXG5cbiAgaWYgKHNbMF0gPT09IE5BTUUpIG1hcmtuYW1lID0gKytpOyAvLyBleHRyYWN0IGZpcnN0IHBhcnQgb2YgbXVsdGktcGFydCBzdHJlYW0gc2VsZWN0b3JcblxuICBqID0gZmluZChzLCBpLCBDT0xPTik7XG5cbiAgaWYgKGogPCBuKSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGopLnRyaW0oKSk7XG4gICAgc3RhcnQgPSBpID0gKytqO1xuICB9IC8vIGV4dHJhY3QgcmVtYWluaW5nIHBhcnQgb2Ygc3RyZWFtIHNlbGVjdG9yXG5cblxuICBpID0gZmluZChzLCBpLCBMQlJBQ0spO1xuXG4gIGlmIChpID09PSBuKSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIG4pLnRyaW0oKSk7XG4gIH0gZWxzZSB7XG4gICAgc291cmNlLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGkpLnRyaW0oKSk7XG4gICAgZmlsdGVyID0gW107XG4gICAgc3RhcnQgPSArK2k7XG4gICAgaWYgKHN0YXJ0ID09PSBuKSB0aHJvdyAnVW5tYXRjaGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gIH0gLy8gZXh0cmFjdCBmaWx0ZXJzXG5cblxuICB3aGlsZSAoaSA8IG4pIHtcbiAgICBpID0gZmluZChzLCBpLCBSQlJBQ0spO1xuICAgIGlmIChpID09PSBuKSB0aHJvdyAnVW5tYXRjaGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgZmlsdGVyLnB1c2gocy5zdWJzdHJpbmcoc3RhcnQsIGkpLnRyaW0oKSk7XG4gICAgaWYgKGkgPCBuIC0gMSAmJiBzWysraV0gIT09IExCUkFDSykgdGhyb3cgJ0V4cGVjdGVkIGxlZnQgYnJhY2tldDogJyArIHM7XG4gICAgc3RhcnQgPSArK2k7XG4gIH0gLy8gbWFyc2hhbGwgZXZlbnQgc3RyZWFtIHNwZWNpZmljYXRpb25cblxuXG4gIGlmICghKG4gPSBzb3VyY2UubGVuZ3RoKSB8fCBJTExFR0FMLnRlc3Qoc291cmNlW24gLSAxXSkpIHtcbiAgICB0aHJvdyAnSW52YWxpZCBldmVudCBzZWxlY3RvcjogJyArIHM7XG4gIH1cblxuICBpZiAobiA+IDEpIHtcbiAgICBzdHJlYW0udHlwZSA9IHNvdXJjZVsxXTtcblxuICAgIGlmIChtYXJrbmFtZSkge1xuICAgICAgc3RyZWFtLm1hcmtuYW1lID0gc291cmNlWzBdLnNsaWNlKDEpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXJrVHlwZShzb3VyY2VbMF0pKSB7XG4gICAgICBzdHJlYW0ubWFya3R5cGUgPSBzb3VyY2VbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5zb3VyY2UgPSBzb3VyY2VbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0cmVhbS50eXBlID0gc291cmNlWzBdO1xuICB9XG5cbiAgaWYgKHN0cmVhbS50eXBlLnNsaWNlKC0xKSA9PT0gJyEnKSB7XG4gICAgc3RyZWFtLmNvbnN1bWUgPSB0cnVlO1xuICAgIHN0cmVhbS50eXBlID0gc3RyZWFtLnR5cGUuc2xpY2UoMCwgLTEpO1xuICB9XG5cbiAgaWYgKGZpbHRlciAhPSBudWxsKSBzdHJlYW0uZmlsdGVyID0gZmlsdGVyO1xuICBpZiAodGhyb3R0bGVbMF0pIHN0cmVhbS50aHJvdHRsZSA9IHRocm90dGxlWzBdO1xuICBpZiAodGhyb3R0bGVbMV0pIHN0cmVhbS5kZWJvdW5jZSA9IHRocm90dGxlWzFdO1xuICByZXR1cm4gc3RyZWFtO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRocm90dGxlKHMpIHtcbiAgY29uc3QgYSA9IHMuc3BsaXQoQ09NTUEpO1xuICBpZiAoIXMubGVuZ3RoIHx8IGEubGVuZ3RoID4gMikgdGhyb3cgcztcbiAgcmV0dXJuIGEubWFwKF8gPT4ge1xuICAgIGNvbnN0IHggPSArXztcbiAgICBpZiAoeCAhPT0geCkgdGhyb3cgcztcbiAgICByZXR1cm4geDtcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGV2ZW50U2VsZWN0b3IgYXMgcGFyc2VTZWxlY3RvciB9O1xuIiwiaW1wb3J0IHsgZXJyb3IsIHRvU2V0LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaGFzT3duUHJvcGVydHkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBSYXdDb2RlID0gJ1Jhd0NvZGUnO1xuY29uc3QgTGl0ZXJhbCA9ICdMaXRlcmFsJztcbmNvbnN0IFByb3BlcnR5ID0gJ1Byb3BlcnR5JztcbmNvbnN0IElkZW50aWZpZXIgPSAnSWRlbnRpZmllcic7XG5jb25zdCBBcnJheUV4cHJlc3Npb24gPSAnQXJyYXlFeHByZXNzaW9uJztcbmNvbnN0IEJpbmFyeUV4cHJlc3Npb24gPSAnQmluYXJ5RXhwcmVzc2lvbic7XG5jb25zdCBDYWxsRXhwcmVzc2lvbiA9ICdDYWxsRXhwcmVzc2lvbic7XG5jb25zdCBDb25kaXRpb25hbEV4cHJlc3Npb24gPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJztcbmNvbnN0IExvZ2ljYWxFeHByZXNzaW9uID0gJ0xvZ2ljYWxFeHByZXNzaW9uJztcbmNvbnN0IE1lbWJlckV4cHJlc3Npb24gPSAnTWVtYmVyRXhwcmVzc2lvbic7XG5jb25zdCBPYmplY3RFeHByZXNzaW9uID0gJ09iamVjdEV4cHJlc3Npb24nO1xuY29uc3QgVW5hcnlFeHByZXNzaW9uID0gJ1VuYXJ5RXhwcmVzc2lvbic7XG5mdW5jdGlvbiBBU1ROb2RlKHR5cGUpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbn1cblxuQVNUTm9kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICBsZXQgYywgaSwgbjtcbiAgaWYgKHZpc2l0b3IodGhpcykpIHJldHVybiAxO1xuXG4gIGZvciAoYyA9IGNoaWxkcmVuKHRoaXMpLCBpID0gMCwgbiA9IGMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGNbaV0udmlzaXQodmlzaXRvcikpIHJldHVybiAxO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjaGlsZHJlbihub2RlKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBBcnJheUV4cHJlc3Npb246XG4gICAgICByZXR1cm4gbm9kZS5lbGVtZW50cztcblxuICAgIGNhc2UgQmluYXJ5RXhwcmVzc2lvbjpcbiAgICBjYXNlIExvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmxlZnQsIG5vZGUucmlnaHRdO1xuXG4gICAgY2FzZSBDYWxsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5jYWxsZWVdLmNvbmNhdChub2RlLmFyZ3VtZW50cyk7XG5cbiAgICBjYXNlIENvbmRpdGlvbmFsRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS50ZXN0LCBub2RlLmNvbnNlcXVlbnQsIG5vZGUuYWx0ZXJuYXRlXTtcblxuICAgIGNhc2UgTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5vYmplY3QsIG5vZGUucHJvcGVydHldO1xuXG4gICAgY2FzZSBPYmplY3RFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcztcblxuICAgIGNhc2UgUHJvcGVydHk6XG4gICAgICByZXR1cm4gW25vZGUua2V5LCBub2RlLnZhbHVlXTtcblxuICAgIGNhc2UgVW5hcnlFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmFyZ3VtZW50XTtcblxuICAgIGNhc2UgSWRlbnRpZmllcjpcbiAgICBjYXNlIExpdGVyYWw6XG4gICAgY2FzZSBSYXdDb2RlOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG52YXIgVG9rZW5OYW1lLCBzb3VyY2UsIGluZGV4LCBsZW5ndGgsIGxvb2thaGVhZDtcbnZhciBUb2tlbkJvb2xlYW5MaXRlcmFsID0gMSxcbiAgICBUb2tlbkVPRiA9IDIsXG4gICAgVG9rZW5JZGVudGlmaWVyID0gMyxcbiAgICBUb2tlbktleXdvcmQgPSA0LFxuICAgIFRva2VuTnVsbExpdGVyYWwgPSA1LFxuICAgIFRva2VuTnVtZXJpY0xpdGVyYWwgPSA2LFxuICAgIFRva2VuUHVuY3R1YXRvciA9IDcsXG4gICAgVG9rZW5TdHJpbmdMaXRlcmFsID0gOCxcbiAgICBUb2tlblJlZ3VsYXJFeHByZXNzaW9uID0gOTtcblRva2VuTmFtZSA9IHt9O1xuVG9rZW5OYW1lW1Rva2VuQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuVG9rZW5OYW1lW1Rva2VuRU9GXSA9ICc8ZW5kPic7XG5Ub2tlbk5hbWVbVG9rZW5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcblRva2VuTmFtZVtUb2tlbktleXdvcmRdID0gJ0tleXdvcmQnO1xuVG9rZW5OYW1lW1Rva2VuTnVsbExpdGVyYWxdID0gJ051bGwnO1xuVG9rZW5OYW1lW1Rva2VuTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuVG9rZW5OYW1lW1Rva2VuUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG5Ub2tlbk5hbWVbVG9rZW5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuVG9rZW5OYW1lW1Rva2VuUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcbnZhciBTeW50YXhBcnJheUV4cHJlc3Npb24gPSAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICBTeW50YXhCaW5hcnlFeHByZXNzaW9uID0gJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgIFN5bnRheENhbGxFeHByZXNzaW9uID0gJ0NhbGxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhDb25kaXRpb25hbEV4cHJlc3Npb24gPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICBTeW50YXhJZGVudGlmaWVyID0gJ0lkZW50aWZpZXInLFxuICAgIFN5bnRheExpdGVyYWwgPSAnTGl0ZXJhbCcsXG4gICAgU3ludGF4TG9naWNhbEV4cHJlc3Npb24gPSAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgIFN5bnRheE1lbWJlckV4cHJlc3Npb24gPSAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgU3ludGF4T2JqZWN0RXhwcmVzc2lvbiA9ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICBTeW50YXhQcm9wZXJ0eSA9ICdQcm9wZXJ0eScsXG4gICAgU3ludGF4VW5hcnlFeHByZXNzaW9uID0gJ1VuYXJ5RXhwcmVzc2lvbic7IC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG5cbnZhciBNZXNzYWdlVW5leHBlY3RlZFRva2VuID0gJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkTnVtYmVyID0gJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICBNZXNzYWdlVW5leHBlY3RlZFN0cmluZyA9ICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRJZGVudGlmaWVyID0gJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgTWVzc2FnZVVuZXhwZWN0ZWRSZXNlcnZlZCA9ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgIE1lc3NhZ2VVbmV4cGVjdGVkRU9TID0gJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICBNZXNzYWdlSW52YWxpZFJlZ0V4cCA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgTWVzc2FnZVVudGVybWluYXRlZFJlZ0V4cCA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgICBNZXNzYWdlU3RyaWN0T2N0YWxMaXRlcmFsID0gJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgIE1lc3NhZ2VTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSA9ICdEdXBsaWNhdGUgZGF0YSBwcm9wZXJ0eSBpbiBvYmplY3QgbGl0ZXJhbCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZSc7XG52YXIgSUxMRUdBTCA9ICdJTExFR0FMJyxcbiAgICBESVNBQkxFRCA9ICdEaXNhYmxlZC4nOyAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuXG52YXIgUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJTdGFydCA9IG5ldyBSZWdFeHAoJ1tcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzcwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNUQwLVxcXFx1MDVFQVxcXFx1MDVGMC1cXFxcdTA1RjJcXFxcdTA2MjAtXFxcXHUwNjRBXFxcXHUwNjZFXFxcXHUwNjZGXFxcXHUwNjcxLVxcXFx1MDZEM1xcXFx1MDZENVxcXFx1MDZFNVxcXFx1MDZFNlxcXFx1MDZFRVxcXFx1MDZFRlxcXFx1MDZGQS1cXFxcdTA2RkNcXFxcdTA2RkZcXFxcdTA3MTBcXFxcdTA3MTItXFxcXHUwNzJGXFxcXHUwNzRELVxcXFx1MDdBNVxcXFx1MDdCMVxcXFx1MDdDQS1cXFxcdTA3RUFcXFxcdTA3RjRcXFxcdTA3RjVcXFxcdTA3RkFcXFxcdTA4MDAtXFxcXHUwODE1XFxcXHUwODFBXFxcXHUwODI0XFxcXHUwODI4XFxcXHUwODQwLVxcXFx1MDg1OFxcXFx1MDhBMC1cXFxcdTA4QjJcXFxcdTA5MDQtXFxcXHUwOTM5XFxcXHUwOTNEXFxcXHUwOTUwXFxcXHUwOTU4LVxcXFx1MDk2MVxcXFx1MDk3MS1cXFxcdTA5ODBcXFxcdTA5ODUtXFxcXHUwOThDXFxcXHUwOThGXFxcXHUwOTkwXFxcXHUwOTkzLVxcXFx1MDlBOFxcXFx1MDlBQS1cXFxcdTA5QjBcXFxcdTA5QjJcXFxcdTA5QjYtXFxcXHUwOUI5XFxcXHUwOUJEXFxcXHUwOUNFXFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFMVxcXFx1MDlGMFxcXFx1MDlGMVxcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEE1OS1cXFxcdTBBNUNcXFxcdTBBNUVcXFxcdTBBNzItXFxcXHUwQTc0XFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkRcXFxcdTBBRDBcXFxcdTBBRTBcXFxcdTBBRTFcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNEXFxcXHUwQjVDXFxcXHUwQjVEXFxcXHUwQjVGLVxcXFx1MEI2MVxcXFx1MEI3MVxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkQwXFxcXHUwQzA1LVxcXFx1MEMwQ1xcXFx1MEMwRS1cXFxcdTBDMTBcXFxcdTBDMTItXFxcXHUwQzI4XFxcXHUwQzJBLVxcXFx1MEMzOVxcXFx1MEMzRFxcXFx1MEM1OFxcXFx1MEM1OVxcXFx1MEM2MFxcXFx1MEM2MVxcXFx1MEM4NS1cXFxcdTBDOENcXFxcdTBDOEUtXFxcXHUwQzkwXFxcXHUwQzkyLVxcXFx1MENBOFxcXFx1MENBQS1cXFxcdTBDQjNcXFxcdTBDQjUtXFxcXHUwQ0I5XFxcXHUwQ0JEXFxcXHUwQ0RFXFxcXHUwQ0UwXFxcXHUwQ0UxXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDA1LVxcXFx1MEQwQ1xcXFx1MEQwRS1cXFxcdTBEMTBcXFxcdTBEMTItXFxcXHUwRDNBXFxcXHUwRDNEXFxcXHUwRDRFXFxcXHUwRDYwXFxcXHUwRDYxXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBFMDEtXFxcXHUwRTMwXFxcXHUwRTMyXFxcXHUwRTMzXFxcXHUwRTQwLVxcXFx1MEU0NlxcXFx1MEU4MVxcXFx1MEU4MlxcXFx1MEU4NFxcXFx1MEU4N1xcXFx1MEU4OFxcXFx1MEU4QVxcXFx1MEU4RFxcXFx1MEU5NC1cXFxcdTBFOTdcXFxcdTBFOTktXFxcXHUwRTlGXFxcXHUwRUExLVxcXFx1MEVBM1xcXFx1MEVBNVxcXFx1MEVBN1xcXFx1MEVBQVxcXFx1MEVBQlxcXFx1MEVBRC1cXFxcdTBFQjBcXFxcdTBFQjJcXFxcdTBFQjNcXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRURDLVxcXFx1MEVERlxcXFx1MEYwMFxcXFx1MEY0MC1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjg4LVxcXFx1MEY4Q1xcXFx1MTAwMC1cXFxcdTEwMkFcXFxcdTEwM0ZcXFxcdTEwNTAtXFxcXHUxMDU1XFxcXHUxMDVBLVxcXFx1MTA1RFxcXFx1MTA2MVxcXFx1MTA2NVxcXFx1MTA2NlxcXFx1MTA2RS1cXFxcdTEwNzBcXFxcdTEwNzUtXFxcXHUxMDgxXFxcXHUxMDhFXFxcXHUxMEEwLVxcXFx1MTBDNVxcXFx1MTBDN1xcXFx1MTBDRFxcXFx1MTBEMC1cXFxcdTEwRkFcXFxcdTEwRkMtXFxcXHUxMjQ4XFxcXHUxMjRBLVxcXFx1MTI0RFxcXFx1MTI1MC1cXFxcdTEyNTZcXFxcdTEyNThcXFxcdTEyNUEtXFxcXHUxMjVEXFxcXHUxMjYwLVxcXFx1MTI4OFxcXFx1MTI4QS1cXFxcdTEyOERcXFxcdTEyOTAtXFxcXHUxMkIwXFxcXHUxMkIyLVxcXFx1MTJCNVxcXFx1MTJCOC1cXFxcdTEyQkVcXFxcdTEyQzBcXFxcdTEyQzItXFxcXHUxMkM1XFxcXHUxMkM4LVxcXFx1MTJENlxcXFx1MTJEOC1cXFxcdTEzMTBcXFxcdTEzMTItXFxcXHUxMzE1XFxcXHUxMzE4LVxcXFx1MTM1QVxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxMVxcXFx1MTcyMC1cXFxcdTE3MzFcXFxcdTE3NDAtXFxcXHUxNzUxXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3ODAtXFxcXHUxN0IzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QThcXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTk1MC1cXFxcdTE5NkRcXFxcdTE5NzAtXFxcXHUxOTc0XFxcXHUxOTgwLVxcXFx1MTlBQlxcXFx1MTlDMS1cXFxcdTE5QzdcXFxcdTFBMDAtXFxcXHUxQTE2XFxcXHUxQTIwLVxcXFx1MUE1NFxcXFx1MUFBN1xcXFx1MUIwNS1cXFxcdTFCMzNcXFxcdTFCNDUtXFxcXHUxQjRCXFxcXHUxQjgzLVxcXFx1MUJBMFxcXFx1MUJBRVxcXFx1MUJBRlxcXFx1MUJCQS1cXFxcdTFCRTVcXFxcdTFDMDAtXFxcXHUxQzIzXFxcXHUxQzRELVxcXFx1MUM0RlxcXFx1MUM1QS1cXFxcdTFDN0RcXFxcdTFDRTktXFxcXHUxQ0VDXFxcXHUxQ0VFLVxcXFx1MUNGMVxcXFx1MUNGNVxcXFx1MUNGNlxcXFx1MUQwMC1cXFxcdTFEQkZcXFxcdTFFMDAtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRUVcXFxcdTJDRjJcXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ4MC1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDI5XFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYxRlxcXFx1QTYyQVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkVcXFxcdUE2N0YtXFxcXHVBNjlEXFxcXHVBNkEwLVxcXFx1QTZFRlxcXFx1QTcxNy1cXFxcdUE3MUZcXFxcdUE3MjItXFxcXHVBNzg4XFxcXHVBNzhCLVxcXFx1QTc4RVxcXFx1QTc5MC1cXFxcdUE3QURcXFxcdUE3QjBcXFxcdUE3QjFcXFxcdUE3RjctXFxcXHVBODAxXFxcXHVBODAzLVxcXFx1QTgwNVxcXFx1QTgwNy1cXFxcdUE4MEFcXFxcdUE4MEMtXFxcXHVBODIyXFxcXHVBODQwLVxcXFx1QTg3M1xcXFx1QTg4Mi1cXFxcdUE4QjNcXFxcdUE4RjItXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTBBLVxcXFx1QTkyNVxcXFx1QTkzMC1cXFxcdUE5NDZcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTg0LVxcXFx1QTlCMlxcXFx1QTlDRlxcXFx1QTlFMC1cXFxcdUE5RTRcXFxcdUE5RTYtXFxcXHVBOUVGXFxcXHVBOUZBLVxcXFx1QTlGRVxcXFx1QUEwMC1cXFxcdUFBMjhcXFxcdUFBNDAtXFxcXHVBQTQyXFxcXHVBQTQ0LVxcXFx1QUE0QlxcXFx1QUE2MC1cXFxcdUFBNzZcXFxcdUFBN0FcXFxcdUFBN0UtXFxcXHVBQUFGXFxcXHVBQUIxXFxcXHVBQUI1XFxcXHVBQUI2XFxcXHVBQUI5LVxcXFx1QUFCRFxcXFx1QUFDMFxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVBXFxcXHVBQUYyLVxcXFx1QUFGNFxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjRcXFxcdUFCNjVcXFxcdUFCQzAtXFxcXHVBQkUyXFxcXHVBQzAwLVxcXFx1RDdBM1xcXFx1RDdCMC1cXFxcdUQ3QzZcXFxcdUQ3Q0ItXFxcXHVEN0ZCXFxcXHVGOTAwLVxcXFx1RkE2RFxcXFx1RkE3MC1cXFxcdUZBRDlcXFxcdUZCMDAtXFxcXHVGQjA2XFxcXHVGQjEzLVxcXFx1RkIxN1xcXFx1RkIxRFxcXFx1RkIxRi1cXFxcdUZCMjhcXFxcdUZCMkEtXFxcXHVGQjM2XFxcXHVGQjM4LVxcXFx1RkIzQ1xcXFx1RkIzRVxcXFx1RkI0MFxcXFx1RkI0MVxcXFx1RkI0M1xcXFx1RkI0NFxcXFx1RkI0Ni1cXFxcdUZCQjFcXFxcdUZCRDMtXFxcXHVGRDNEXFxcXHVGRDUwLVxcXFx1RkQ4RlxcXFx1RkQ5Mi1cXFxcdUZEQzdcXFxcdUZERjAtXFxcXHVGREZCXFxcXHVGRTcwLVxcXFx1RkU3NFxcXFx1RkU3Ni1cXFxcdUZFRkNcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXScpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzc1xuUmVnZXhOb25Bc2NpaUlkZW50aWZpZXJQYXJ0ID0gbmV3IFJlZ0V4cCgnW1xcXFx4QUFcXFxceEI1XFxcXHhCQVxcXFx4QzAtXFxcXHhENlxcXFx4RDgtXFxcXHhGNlxcXFx4RjgtXFxcXHUwMkMxXFxcXHUwMkM2LVxcXFx1MDJEMVxcXFx1MDJFMC1cXFxcdTAyRTRcXFxcdTAyRUNcXFxcdTAyRUVcXFxcdTAzMDAtXFxcXHUwMzc0XFxcXHUwMzc2XFxcXHUwMzc3XFxcXHUwMzdBLVxcXFx1MDM3RFxcXFx1MDM3RlxcXFx1MDM4NlxcXFx1MDM4OC1cXFxcdTAzOEFcXFxcdTAzOENcXFxcdTAzOEUtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNGNVxcXFx1MDNGNy1cXFxcdTA0ODFcXFxcdTA0ODMtXFxcXHUwNDg3XFxcXHUwNDhBLVxcXFx1MDUyRlxcXFx1MDUzMS1cXFxcdTA1NTZcXFxcdTA1NTlcXFxcdTA1NjEtXFxcXHUwNTg3XFxcXHUwNTkxLVxcXFx1MDVCRFxcXFx1MDVCRlxcXFx1MDVDMVxcXFx1MDVDMlxcXFx1MDVDNFxcXFx1MDVDNVxcXFx1MDVDN1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjEwLVxcXFx1MDYxQVxcXFx1MDYyMC1cXFxcdTA2NjlcXFxcdTA2NkUtXFxcXHUwNkQzXFxcXHUwNkQ1LVxcXFx1MDZEQ1xcXFx1MDZERi1cXFxcdTA2RThcXFxcdTA2RUEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwLVxcXFx1MDc0QVxcXFx1MDc0RC1cXFxcdTA3QjFcXFxcdTA3QzAtXFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgyRFxcXFx1MDg0MC1cXFxcdTA4NUJcXFxcdTA4QTAtXFxcXHUwOEIyXFxcXHUwOEU0LVxcXFx1MDk2M1xcXFx1MDk2Ni1cXFxcdTA5NkZcXFxcdTA5NzEtXFxcXHUwOTgzXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCQy1cXFxcdTA5QzRcXFxcdTA5QzdcXFxcdTA5QzhcXFxcdTA5Q0ItXFxcXHUwOUNFXFxcXHUwOUQ3XFxcXHUwOURDXFxcXHUwOUREXFxcXHUwOURGLVxcXFx1MDlFM1xcXFx1MDlFNi1cXFxcdTA5RjFcXFxcdTBBMDEtXFxcXHUwQTAzXFxcXHUwQTA1LVxcXFx1MEEwQVxcXFx1MEEwRlxcXFx1MEExMFxcXFx1MEExMy1cXFxcdTBBMjhcXFxcdTBBMkEtXFxcXHUwQTMwXFxcXHUwQTMyXFxcXHUwQTMzXFxcXHUwQTM1XFxcXHUwQTM2XFxcXHUwQTM4XFxcXHUwQTM5XFxcXHUwQTNDXFxcXHUwQTNFLVxcXFx1MEE0MlxcXFx1MEE0N1xcXFx1MEE0OFxcXFx1MEE0Qi1cXFxcdTBBNERcXFxcdTBBNTFcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTY2LVxcXFx1MEE3NVxcXFx1MEE4MS1cXFxcdTBBODNcXFxcdTBBODUtXFxcXHUwQThEXFxcXHUwQThGLVxcXFx1MEE5MVxcXFx1MEE5My1cXFxcdTBBQThcXFxcdTBBQUEtXFxcXHUwQUIwXFxcXHUwQUIyXFxcXHUwQUIzXFxcXHUwQUI1LVxcXFx1MEFCOVxcXFx1MEFCQy1cXFxcdTBBQzVcXFxcdTBBQzctXFxcXHUwQUM5XFxcXHUwQUNCLVxcXFx1MEFDRFxcXFx1MEFEMFxcXFx1MEFFMC1cXFxcdTBBRTNcXFxcdTBBRTYtXFxcXHUwQUVGXFxcXHUwQjAxLVxcXFx1MEIwM1xcXFx1MEIwNS1cXFxcdTBCMENcXFxcdTBCMEZcXFxcdTBCMTBcXFxcdTBCMTMtXFxcXHUwQjI4XFxcXHUwQjJBLVxcXFx1MEIzMFxcXFx1MEIzMlxcXFx1MEIzM1xcXFx1MEIzNS1cXFxcdTBCMzlcXFxcdTBCM0MtXFxcXHUwQjQ0XFxcXHUwQjQ3XFxcXHUwQjQ4XFxcXHUwQjRCLVxcXFx1MEI0RFxcXFx1MEI1NlxcXFx1MEI1N1xcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjNcXFxcdTBCNjYtXFxcXHUwQjZGXFxcXHUwQjcxXFxcXHUwQjgyXFxcXHUwQjgzXFxcXHUwQjg1LVxcXFx1MEI4QVxcXFx1MEI4RS1cXFxcdTBCOTBcXFxcdTBCOTItXFxcXHUwQjk1XFxcXHUwQjk5XFxcXHUwQjlBXFxcXHUwQjlDXFxcXHUwQjlFXFxcXHUwQjlGXFxcXHUwQkEzXFxcXHUwQkE0XFxcXHUwQkE4LVxcXFx1MEJBQVxcXFx1MEJBRS1cXFxcdTBCQjlcXFxcdTBCQkUtXFxcXHUwQkMyXFxcXHUwQkM2LVxcXFx1MEJDOFxcXFx1MEJDQS1cXFxcdTBCQ0RcXFxcdTBCRDBcXFxcdTBCRDdcXFxcdTBCRTYtXFxcXHUwQkVGXFxcXHUwQzAwLVxcXFx1MEMwM1xcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzlcXFxcdTBDM0QtXFxcXHUwQzQ0XFxcXHUwQzQ2LVxcXFx1MEM0OFxcXFx1MEM0QS1cXFxcdTBDNERcXFxcdTBDNTVcXFxcdTBDNTZcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjAtXFxcXHUwQzYzXFxcXHUwQzY2LVxcXFx1MEM2RlxcXFx1MEM4MS1cXFxcdTBDODNcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCQy1cXFxcdTBDQzRcXFxcdTBDQzYtXFxcXHUwQ0M4XFxcXHUwQ0NBLVxcXFx1MENDRFxcXFx1MENENVxcXFx1MENENlxcXFx1MENERVxcXFx1MENFMC1cXFxcdTBDRTNcXFxcdTBDRTYtXFxcXHUwQ0VGXFxcXHUwQ0YxXFxcXHUwQ0YyXFxcXHUwRDAxLVxcXFx1MEQwM1xcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRC1cXFxcdTBENDRcXFxcdTBENDYtXFxcXHUwRDQ4XFxcXHUwRDRBLVxcXFx1MEQ0RVxcXFx1MEQ1N1xcXFx1MEQ2MC1cXFxcdTBENjNcXFxcdTBENjYtXFxcXHUwRDZGXFxcXHUwRDdBLVxcXFx1MEQ3RlxcXFx1MEQ4MlxcXFx1MEQ4M1xcXFx1MEQ4NS1cXFxcdTBEOTZcXFxcdTBEOUEtXFxcXHUwREIxXFxcXHUwREIzLVxcXFx1MERCQlxcXFx1MERCRFxcXFx1MERDMC1cXFxcdTBEQzZcXFxcdTBEQ0FcXFxcdTBEQ0YtXFxcXHUwREQ0XFxcXHUwREQ2XFxcXHUwREQ4LVxcXFx1MERERlxcXFx1MERFNi1cXFxcdTBERUZcXFxcdTBERjJcXFxcdTBERjNcXFxcdTBFMDEtXFxcXHUwRTNBXFxcXHUwRTQwLVxcXFx1MEU0RVxcXFx1MEU1MC1cXFxcdTBFNTlcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUI5XFxcXHUwRUJCLVxcXFx1MEVCRFxcXFx1MEVDMC1cXFxcdTBFQzRcXFxcdTBFQzZcXFxcdTBFQzgtXFxcXHUwRUNEXFxcXHUwRUQwLVxcXFx1MEVEOVxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGMThcXFxcdTBGMTlcXFxcdTBGMjAtXFxcXHUwRjI5XFxcXHUwRjM1XFxcXHUwRjM3XFxcXHUwRjM5XFxcXHUwRjNFLVxcXFx1MEY0N1xcXFx1MEY0OS1cXFxcdTBGNkNcXFxcdTBGNzEtXFxcXHUwRjg0XFxcXHUwRjg2LVxcXFx1MEY5N1xcXFx1MEY5OS1cXFxcdTBGQkNcXFxcdTBGQzZcXFxcdTEwMDAtXFxcXHUxMDQ5XFxcXHUxMDUwLVxcXFx1MTA5RFxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzNUQtXFxcXHUxMzVGXFxcXHUxMzgwLVxcXFx1MTM4RlxcXFx1MTNBMC1cXFxcdTEzRjRcXFxcdTE0MDEtXFxcXHUxNjZDXFxcXHUxNjZGLVxcXFx1MTY3RlxcXFx1MTY4MS1cXFxcdTE2OUFcXFxcdTE2QTAtXFxcXHUxNkVBXFxcXHUxNkVFLVxcXFx1MTZGOFxcXFx1MTcwMC1cXFxcdTE3MENcXFxcdTE3MEUtXFxcXHUxNzE0XFxcXHUxNzIwLVxcXFx1MTczNFxcXFx1MTc0MC1cXFxcdTE3NTNcXFxcdTE3NjAtXFxcXHUxNzZDXFxcXHUxNzZFLVxcXFx1MTc3MFxcXFx1MTc3MlxcXFx1MTc3M1xcXFx1MTc4MC1cXFxcdTE3RDNcXFxcdTE3RDdcXFxcdTE3RENcXFxcdTE3RERcXFxcdTE3RTAtXFxcXHUxN0U5XFxcXHUxODBCLVxcXFx1MTgwRFxcXFx1MTgxMC1cXFxcdTE4MTlcXFxcdTE4MjAtXFxcXHUxODc3XFxcXHUxODgwLVxcXFx1MThBQVxcXFx1MThCMC1cXFxcdTE4RjVcXFxcdTE5MDAtXFxcXHUxOTFFXFxcXHUxOTIwLVxcXFx1MTkyQlxcXFx1MTkzMC1cXFxcdTE5M0JcXFxcdTE5NDYtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QjAtXFxcXHUxOUM5XFxcXHUxOUQwLVxcXFx1MTlEOVxcXFx1MUEwMC1cXFxcdTFBMUJcXFxcdTFBMjAtXFxcXHUxQTVFXFxcXHUxQTYwLVxcXFx1MUE3Q1xcXFx1MUE3Ri1cXFxcdTFBODlcXFxcdTFBOTAtXFxcXHUxQTk5XFxcXHUxQUE3XFxcXHUxQUIwLVxcXFx1MUFCRFxcXFx1MUIwMC1cXFxcdTFCNEJcXFxcdTFCNTAtXFxcXHUxQjU5XFxcXHUxQjZCLVxcXFx1MUI3M1xcXFx1MUI4MC1cXFxcdTFCRjNcXFxcdTFDMDAtXFxcXHUxQzM3XFxcXHUxQzQwLVxcXFx1MUM0OVxcXFx1MUM0RC1cXFxcdTFDN0RcXFxcdTFDRDAtXFxcXHUxQ0QyXFxcXHUxQ0Q0LVxcXFx1MUNGNlxcXFx1MUNGOFxcXFx1MUNGOVxcXFx1MUQwMC1cXFxcdTFERjVcXFxcdTFERkMtXFxcXHUxRjE1XFxcXHUxRjE4LVxcXFx1MUYxRFxcXFx1MUYyMC1cXFxcdTFGNDVcXFxcdTFGNDgtXFxcXHUxRjREXFxcXHUxRjUwLVxcXFx1MUY1N1xcXFx1MUY1OVxcXFx1MUY1QlxcXFx1MUY1RFxcXFx1MUY1Ri1cXFxcdTFGN0RcXFxcdTFGODAtXFxcXHUxRkI0XFxcXHUxRkI2LVxcXFx1MUZCQ1xcXFx1MUZCRVxcXFx1MUZDMi1cXFxcdTFGQzRcXFxcdTFGQzYtXFxcXHUxRkNDXFxcXHUxRkQwLVxcXFx1MUZEM1xcXFx1MUZENi1cXFxcdTFGREJcXFxcdTFGRTAtXFxcXHUxRkVDXFxcXHUxRkYyLVxcXFx1MUZGNFxcXFx1MUZGNi1cXFxcdTFGRkNcXFxcdTIwMENcXFxcdTIwMERcXFxcdTIwM0ZcXFxcdTIwNDBcXFxcdTIwNTRcXFxcdTIwNzFcXFxcdTIwN0ZcXFxcdTIwOTAtXFxcXHUyMDlDXFxcXHUyMEQwLVxcXFx1MjBEQ1xcXFx1MjBFMVxcXFx1MjBFNS1cXFxcdTIwRjBcXFxcdTIxMDJcXFxcdTIxMDdcXFxcdTIxMEEtXFxcXHUyMTEzXFxcXHUyMTE1XFxcXHUyMTE5LVxcXFx1MjExRFxcXFx1MjEyNFxcXFx1MjEyNlxcXFx1MjEyOFxcXFx1MjEyQS1cXFxcdTIxMkRcXFxcdTIxMkYtXFxcXHUyMTM5XFxcXHUyMTNDLVxcXFx1MjEzRlxcXFx1MjE0NS1cXFxcdTIxNDlcXFxcdTIxNEVcXFxcdTIxNjAtXFxcXHUyMTg4XFxcXHUyQzAwLVxcXFx1MkMyRVxcXFx1MkMzMC1cXFxcdTJDNUVcXFxcdTJDNjAtXFxcXHUyQ0U0XFxcXHUyQ0VCLVxcXFx1MkNGM1xcXFx1MkQwMC1cXFxcdTJEMjVcXFxcdTJEMjdcXFxcdTJEMkRcXFxcdTJEMzAtXFxcXHUyRDY3XFxcXHUyRDZGXFxcXHUyRDdGLVxcXFx1MkQ5NlxcXFx1MkRBMC1cXFxcdTJEQTZcXFxcdTJEQTgtXFxcXHUyREFFXFxcXHUyREIwLVxcXFx1MkRCNlxcXFx1MkRCOC1cXFxcdTJEQkVcXFxcdTJEQzAtXFxcXHUyREM2XFxcXHUyREM4LVxcXFx1MkRDRVxcXFx1MkREMC1cXFxcdTJERDZcXFxcdTJERDgtXFxcXHUyRERFXFxcXHUyREUwLVxcXFx1MkRGRlxcXFx1MkUyRlxcXFx1MzAwNS1cXFxcdTMwMDdcXFxcdTMwMjEtXFxcXHUzMDJGXFxcXHUzMDMxLVxcXFx1MzAzNVxcXFx1MzAzOC1cXFxcdTMwM0NcXFxcdTMwNDEtXFxcXHUzMDk2XFxcXHUzMDk5XFxcXHUzMDlBXFxcXHUzMDlELVxcXFx1MzA5RlxcXFx1MzBBMS1cXFxcdTMwRkFcXFxcdTMwRkMtXFxcXHUzMEZGXFxcXHUzMTA1LVxcXFx1MzEyRFxcXFx1MzEzMS1cXFxcdTMxOEVcXFxcdTMxQTAtXFxcXHUzMUJBXFxcXHUzMUYwLVxcXFx1MzFGRlxcXFx1MzQwMC1cXFxcdTREQjVcXFxcdTRFMDAtXFxcXHU5RkNDXFxcXHVBMDAwLVxcXFx1QTQ4Q1xcXFx1QTREMC1cXFxcdUE0RkRcXFxcdUE1MDAtXFxcXHVBNjBDXFxcXHVBNjEwLVxcXFx1QTYyQlxcXFx1QTY0MC1cXFxcdUE2NkZcXFxcdUE2NzQtXFxcXHVBNjdEXFxcXHVBNjdGLVxcXFx1QTY5RFxcXFx1QTY5Ri1cXFxcdUE2RjFcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBN0FEXFxcXHVBN0IwXFxcXHVBN0IxXFxcXHVBN0Y3LVxcXFx1QTgyN1xcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODAtXFxcXHVBOEM0XFxcXHVBOEQwLVxcXFx1QThEOVxcXFx1QThFMC1cXFxcdUE4RjdcXFxcdUE4RkJcXFxcdUE5MDAtXFxcXHVBOTJEXFxcXHVBOTMwLVxcXFx1QTk1M1xcXFx1QTk2MC1cXFxcdUE5N0NcXFxcdUE5ODAtXFxcXHVBOUMwXFxcXHVBOUNGLVxcXFx1QTlEOVxcXFx1QTlFMC1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTM2XFxcXHVBQTQwLVxcXFx1QUE0RFxcXFx1QUE1MC1cXFxcdUFBNTlcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBLVxcXFx1QUFDMlxcXFx1QUFEQi1cXFxcdUFBRERcXFxcdUFBRTAtXFxcXHVBQUVGXFxcXHVBQUYyLVxcXFx1QUFGNlxcXFx1QUIwMS1cXFxcdUFCMDZcXFxcdUFCMDktXFxcXHVBQjBFXFxcXHVBQjExLVxcXFx1QUIxNlxcXFx1QUIyMC1cXFxcdUFCMjZcXFxcdUFCMjgtXFxcXHVBQjJFXFxcXHVBQjMwLVxcXFx1QUI1QVxcXFx1QUI1Qy1cXFxcdUFCNUZcXFxcdUFCNjRcXFxcdUFCNjVcXFxcdUFCQzAtXFxcXHVBQkVBXFxcXHVBQkVDXFxcXHVBQkVEXFxcXHVBQkYwLVxcXFx1QUJGOVxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMUQtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkUwMC1cXFxcdUZFMEZcXFxcdUZFMjAtXFxcXHVGRTJEXFxcXHVGRTMzXFxcXHVGRTM0XFxcXHVGRTRELVxcXFx1RkU0RlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjEwLVxcXFx1RkYxOVxcXFx1RkYyMS1cXFxcdUZGM0FcXFxcdUZGM0ZcXFxcdUZGNDEtXFxcXHVGRjVBXFxcXHVGRjY2LVxcXFx1RkZCRVxcXFx1RkZDMi1cXFxcdUZGQzdcXFxcdUZGQ0EtXFxcXHVGRkNGXFxcXHVGRkQyLVxcXFx1RkZEN1xcXFx1RkZEQS1cXFxcdUZGRENdJyk7IC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbi8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4vLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICByZXR1cm4gY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5OyAvLyAwLi45XG59XG5cbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbn0gLy8gNy4yIFdoaXRlIFNwYWNlXG5cblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyMCB8fCBjaCA9PT0gMHgwOSB8fCBjaCA9PT0gMHgwQiB8fCBjaCA9PT0gMHgwQyB8fCBjaCA9PT0gMHhBMCB8fCBjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwO1xufSAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG5cbmZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAweDBBIHx8IGNoID09PSAweDBEIHx8IGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOTtcbn0gLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAweDI0IHx8IGNoID09PSAweDVGIHx8IGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSB8fCBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHwgY2ggPT09IDB4NUMgfHwgY2ggPj0gMHg4MCAmJiBSZWdleE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fCBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHwgY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBIHx8IGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSB8fCBjaCA9PT0gMHg1QyB8fCBjaCA+PSAweDgwICYmIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbn0gLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG5cbmNvbnN0IGtleXdvcmRzID0ge1xuICAnaWYnOiAxLFxuICAnaW4nOiAxLFxuICAnZG8nOiAxLFxuICAndmFyJzogMSxcbiAgJ2Zvcic6IDEsXG4gICduZXcnOiAxLFxuICAndHJ5JzogMSxcbiAgJ2xldCc6IDEsXG4gICd0aGlzJzogMSxcbiAgJ2Vsc2UnOiAxLFxuICAnY2FzZSc6IDEsXG4gICd2b2lkJzogMSxcbiAgJ3dpdGgnOiAxLFxuICAnZW51bSc6IDEsXG4gICd3aGlsZSc6IDEsXG4gICdicmVhayc6IDEsXG4gICdjYXRjaCc6IDEsXG4gICd0aHJvdyc6IDEsXG4gICdjb25zdCc6IDEsXG4gICd5aWVsZCc6IDEsXG4gICdjbGFzcyc6IDEsXG4gICdzdXBlcic6IDEsXG4gICdyZXR1cm4nOiAxLFxuICAndHlwZW9mJzogMSxcbiAgJ2RlbGV0ZSc6IDEsXG4gICdzd2l0Y2gnOiAxLFxuICAnZXhwb3J0JzogMSxcbiAgJ2ltcG9ydCc6IDEsXG4gICdwdWJsaWMnOiAxLFxuICAnc3RhdGljJzogMSxcbiAgJ2RlZmF1bHQnOiAxLFxuICAnZmluYWxseSc6IDEsXG4gICdleHRlbmRzJzogMSxcbiAgJ3BhY2thZ2UnOiAxLFxuICAncHJpdmF0ZSc6IDEsXG4gICdmdW5jdGlvbic6IDEsXG4gICdjb250aW51ZSc6IDEsXG4gICdkZWJ1Z2dlcic6IDEsXG4gICdpbnRlcmZhY2UnOiAxLFxuICAncHJvdGVjdGVkJzogMSxcbiAgJ2luc3RhbmNlb2YnOiAxLFxuICAnaW1wbGVtZW50cyc6IDFcbn07XG5cbmZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjb25zdCBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChpc1doaXRlU3BhY2UoY2gpIHx8IGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICArK2luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgdmFyIGksXG4gICAgICBsZW4sXG4gICAgICBjaCxcbiAgICAgIGNvZGUgPSAwO1xuICBsZW4gPSBwcmVmaXggPT09ICd1JyA/IDQgOiAyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5cbmZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGNvZGUgPSAwOyAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cblxuICBpZiAoY2ggPT09ICd9Jykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfSAvLyBVVEYtMTYgRW5jb2RpbmdcblxuXG4gIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgY3UxID0gKGNvZGUgLSAweDEwMDAwID4+IDEwKSArIDB4RDgwMDtcbiAgY3UyID0gKGNvZGUgLSAweDEwMDAwICYgMTAyMykgKyAweERDMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbn1cblxuZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gIHZhciBjaCwgaWQ7XG4gIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7IC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgICB9XG5cbiAgICArK2luZGV4O1xuICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuXG4gICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuXG4gICAgaWQgPSBjaDtcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgKytpbmRleDtcbiAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTsgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuXG4gICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcblxuICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgICAgIH1cblxuICAgICAgKytpbmRleDtcbiAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuXG4gICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG5cbiAgICAgIGlkICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgdmFyIHN0YXJ0LCBjaDtcbiAgc3RhcnQgPSBpbmRleCsrO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xuICAgIH1cblxuICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgKytpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcbiAgc3RhcnQgPSBpbmRleDsgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cblxuICBpZCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QyA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7IC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuXG4gIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICB0eXBlID0gVG9rZW5JZGVudGlmaWVyO1xuICB9IGVsc2UgaWYgKGtleXdvcmRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgdHlwZSA9IFRva2VuS2V5d29yZDtcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgdHlwZSA9IFRva2VuTnVsbExpdGVyYWw7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgIHR5cGUgPSBUb2tlbkJvb2xlYW5MaXRlcmFsO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBUb2tlbklkZW50aWZpZXI7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdmFsdWU6IGlkLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59IC8vIDcuNyBQdW5jdHVhdG9yc1xuXG5cbmZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICBjb2RlMixcbiAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICBjaDIsXG4gICAgICBjaDMsXG4gICAgICBjaDQ7XG5cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgY2FzZSAweDJFOiAvLyAuIGRvdFxuXG4gICAgY2FzZSAweDI4OiAvLyAoIG9wZW4gYnJhY2tldFxuXG4gICAgY2FzZSAweDI5OiAvLyApIGNsb3NlIGJyYWNrZXRcblxuICAgIGNhc2UgMHgzQjogLy8gOyBzZW1pY29sb25cblxuICAgIGNhc2UgMHgyQzogLy8gLCBjb21tYVxuXG4gICAgY2FzZSAweDdCOiAvLyB7IG9wZW4gY3VybHkgYnJhY2VcblxuICAgIGNhc2UgMHg3RDogLy8gfSBjbG9zZSBjdXJseSBicmFjZVxuXG4gICAgY2FzZSAweDVCOiAvLyBbXG5cbiAgICBjYXNlIDB4NUQ6IC8vIF1cblxuICAgIGNhc2UgMHgzQTogLy8gOlxuXG4gICAgY2FzZSAweDNGOiAvLyA/XG5cbiAgICBjYXNlIDB4N0U6XG4gICAgICAvLyB+XG4gICAgICArK2luZGV4O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTsgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cblxuICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgIGNhc2UgMHgyQjogLy8gK1xuXG4gICAgICAgICAgY2FzZSAweDJEOiAvLyAtXG5cbiAgICAgICAgICBjYXNlIDB4MkY6IC8vIC9cblxuICAgICAgICAgIGNhc2UgMHgzQzogLy8gPFxuXG4gICAgICAgICAgY2FzZSAweDNFOiAvLyA+XG5cbiAgICAgICAgICBjYXNlIDB4NUU6IC8vIF5cblxuICAgICAgICAgIGNhc2UgMHg3QzogLy8gfFxuXG4gICAgICAgICAgY2FzZSAweDI1OiAvLyAlXG5cbiAgICAgICAgICBjYXNlIDB4MjY6IC8vICZcblxuICAgICAgICAgIGNhc2UgMHgyQTpcbiAgICAgICAgICAgIC8vICpcbiAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIGNhc2UgMHgyMTogLy8gIVxuXG4gICAgICAgICAgY2FzZSAweDNEOlxuICAgICAgICAgICAgLy8gPVxuICAgICAgICAgICAgaW5kZXggKz0gMjsgLy8gIT09IGFuZCA9PT1cblxuICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfSAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cblxuICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcblxuICBpZiAoY2g0ID09PSAnPj4+PScpIHtcbiAgICBpbmRleCArPSA0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICB2YWx1ZTogY2g0LFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBpbmRleFxuICAgIH07XG4gIH0gLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuXG4gIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XG4gICAgaW5kZXggKz0gMztcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMyxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9IC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuXG5cbiAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICBpZiAoY2gxID09PSBjaDJbMV0gJiYgJystPD4mfCcuaW5kZXhPZihjaDEpID49IDAgfHwgY2gyID09PSAnPT4nKSB7XG4gICAgaW5kZXggKz0gMjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMixcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgaWYgKGNoMiA9PT0gJy8vJykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9IC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG5cbiAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgKytpbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMSxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG59IC8vIDcuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuXG5mdW5jdGlvbiBzY2FuSGV4TGl0ZXJhbChzdGFydCkge1xuICBsZXQgbnVtYmVyID0gJyc7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICB9XG5cbiAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW1iZXIsIDE2KSxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KSB7XG4gIGxldCBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gIH1cblxuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgb2N0YWw6IHRydWUsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG4gIGNoID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IGNoID09PSAnLicsICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcbiAgc3RhcnQgPSBpbmRleDtcbiAgbnVtYmVyID0gJyc7XG5cbiAgaWYgKGNoICE9PSAnLicpIHtcbiAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdOyAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cblxuICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICArK2luZGV4O1xuICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICB9IC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cblxuXG4gICAgICBpZiAoY2ggJiYgaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnLicpIHtcbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgfVxuXG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG5cbiAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogVG9rZW5OdW1lcmljTGl0ZXJhbCxcbiAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59IC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG5cbmZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICB2YXIgc3RyID0gJycsXG4gICAgICBxdW90ZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgY2gsXG4gICAgICBjb2RlLFxuICAgICAgb2N0YWwgPSBmYWxzZTtcbiAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICBhc3NlcnQocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInLCAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG4gIHN0YXJ0ID0gaW5kZXg7XG4gICsraW5kZXg7XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICBxdW90ZSA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpOyAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTsgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcblxuICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJiBpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gY2g7XG4gICAgfVxuICB9XG5cbiAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlblN0cmluZ0xpdGVyYWwsXG4gICAgdmFsdWU6IHN0cixcbiAgICBvY3RhbDogb2N0YWwsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICBsZXQgdG1wID0gcGF0dGVybjtcblxuICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgLy8gYC91YCBmbGFnLlxuICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCAoJDAsICQxKSA9PiB7XG4gICAgICBpZiAocGFyc2VJbnQoJDEsIDE2KSA8PSAweDEwRkZGRikge1xuICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCk7XG4gICAgfSkucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICB9IC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuXG5cbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHRtcCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCk7XG4gIH0gLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAvLyB1c2VzLlxuXG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG4gIGNoID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG4gIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gIHRlcm1pbmF0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICBzdHIgKz0gY2g7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107IC8vIEVDTUEtMjYyIDcuOC41XG5cbiAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICBzdHIgKz0gY2g7XG4gICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghdGVybWluYXRlZCkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICB9IC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG5cblxuICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGJvZHksXG4gICAgbGl0ZXJhbDogc3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgdmFyIGNoLCBzdHIsIGZsYWdzO1xuICBzdHIgPSAnJztcbiAgZmxhZ3MgPSAnJztcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgICsraW5kZXg7XG5cbiAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgc3RyICs9IGNoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmbGFncy5zZWFyY2goL1teZ2ltdXldL2cpID49IDApIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCwgZmxhZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogZmxhZ3MsXG4gICAgbGl0ZXJhbDogc3RyXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuICBsb29rYWhlYWQgPSBudWxsO1xuICBza2lwQ29tbWVudCgpO1xuICBzdGFydCA9IGluZGV4O1xuICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICByZWdleDoge1xuICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgIH0sXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW5JZGVudGlmaWVyIHx8IHRva2VuLnR5cGUgPT09IFRva2VuS2V5d29yZCB8fCB0b2tlbi50eXBlID09PSBUb2tlbkJvb2xlYW5MaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuTnVsbExpdGVyYWw7XG59XG5cbmZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gIHNraXBDb21tZW50KCk7XG5cbiAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlbkVPRixcbiAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICB9IC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG5cblxuICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfSAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuXG5cbiAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gIH0gLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cblxuXG4gIGlmIChjaCA9PT0gMHgyRSkge1xuICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xuICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgfVxuXG4gIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xufVxuXG5mdW5jdGlvbiBsZXgoKSB7XG4gIGNvbnN0IHRva2VuID0gbG9va2FoZWFkO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgcmV0dXJuIHRva2VuO1xufVxuXG5mdW5jdGlvbiBwZWVrKCkge1xuICBjb25zdCBwb3MgPSBpbmRleDtcbiAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICBpbmRleCA9IHBvcztcbn1cblxuZnVuY3Rpb24gZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhBcnJheUV4cHJlc3Npb24pO1xuICBub2RlLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicgPyBTeW50YXhMb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheEJpbmFyeUV4cHJlc3Npb24pO1xuICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENhbGxFeHByZXNzaW9uKGNhbGxlZSwgYXJncykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4Q2FsbEV4cHJlc3Npb24pO1xuICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgbm9kZS5hcmd1bWVudHMgPSBhcmdzO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4Q29uZGl0aW9uYWxFeHByZXNzaW9uKTtcbiAgbm9kZS50ZXN0ID0gdGVzdDtcbiAgbm9kZS5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgbm9kZS5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hJZGVudGlmaWVyKG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheElkZW50aWZpZXIpO1xuICBub2RlLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZmluaXNoTGl0ZXJhbCh0b2tlbikge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4TGl0ZXJhbCk7XG4gIG5vZGUudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgbm9kZS5yYXcgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG5cbiAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgaWYgKG5vZGUucmF3ID09PSAnLy8nKSB7XG4gICAgICBub2RlLnJhdyA9ICcvKD86KS8nO1xuICAgIH1cblxuICAgIG5vZGUucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhNZW1iZXJFeHByZXNzaW9uKTtcbiAgbm9kZS5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gIG5vZGUub2JqZWN0ID0gb2JqZWN0O1xuICBub2RlLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gIGlmICghbm9kZS5jb21wdXRlZCkgcHJvcGVydHkubWVtYmVyID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4T2JqZWN0RXhwcmVzc2lvbik7XG4gIG5vZGUucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hQcm9wZXJ0eShraW5kLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhQcm9wZXJ0eSk7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUua2luZCA9IGtpbmQ7XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hVbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhVbmFyeUV4cHJlc3Npb24pO1xuICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gIG5vZGUuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICByZXR1cm4gbm9kZTtcbn0gLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cblxuZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICB2YXIgZXJyb3IsXG4gICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZSgvJShcXGQpL2csICh3aG9sZSwgaW5kZXgpID0+IHtcbiAgICBhc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gIH0pO1xuICBlcnJvciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnJvci5pbmRleCA9IGluZGV4O1xuICBlcnJvci5kZXNjcmlwdGlvbiA9IG1zZztcbiAgdGhyb3cgZXJyb3I7XG59IC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuXG5mdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRFT1MpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuTnVtZXJpY0xpdGVyYWwpIHtcbiAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZE51bWJlcik7XG4gIH1cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5TdHJpbmdMaXRlcmFsKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRTdHJpbmcpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllcikge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gIH1cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRSZXNlcnZlZCk7XG4gIH0gLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuXG5cbiAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xufSAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cblxuZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7XG5cbiAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICB9XG59IC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG5cbmZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG59IC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cblxuZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xufSAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuXG5mdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICBleHBlY3QoJ1snKTtcblxuICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgbGV4KCk7XG4gICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpO1xuXG4gICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV4KCk7XG4gIHJldHVybiBmaW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xufSAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cblxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7IC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlblN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5OdW1lcmljTGl0ZXJhbCkge1xuICAgIGlmICh0b2tlbi5vY3RhbCkge1xuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmlzaExpdGVyYWwodG9rZW4pO1xuICB9XG5cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICB2YXIgdG9rZW4sIGtleSwgaWQsIHZhbHVlO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllcikge1xuICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICByZXR1cm4gZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvcikge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICByZXR1cm4gZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCkge1xuICB2YXIgcHJvcGVydGllcyA9IFtdLFxuICAgICAgcHJvcGVydHksXG4gICAgICBuYW1lLFxuICAgICAga2V5LFxuICAgICAgbWFwID0ge30sXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGV4cGVjdCgneycpO1xuXG4gIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgaWYgKHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXhJZGVudGlmaWVyKSB7XG4gICAgICBuYW1lID0gcHJvcGVydHkua2V5Lm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgIH1cblxuICAgIGtleSA9ICckJyArIG5hbWU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwW2tleV0gPSB0cnVlO1xuICAgIH1cblxuICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgIGV4cGVjdCgnLCcpO1xuICAgIH1cbiAgfVxuXG4gIGV4cGVjdCgnfScpO1xuICByZXR1cm4gZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbn0gLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG5cbmZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICBleHBlY3QoJygnKTtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICBleHBlY3QoJyknKTtcbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG5cbmNvbnN0IGxlZ2FsS2V5d29yZHMgPSB7XG4gICdpZic6IDFcbn07XG5cbmZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gIHZhciB0eXBlLCB0b2tlbiwgZXhwcjtcblxuICBpZiAobWF0Y2goJygnKSkge1xuICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICB9XG5cbiAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gIH1cblxuICBpZiAobWF0Y2goJ3snKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gIH1cblxuICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuXG4gIGlmICh0eXBlID09PSBUb2tlbklkZW50aWZpZXIgfHwgbGVnYWxLZXl3b3Jkc1tsb29rYWhlYWQudmFsdWVdKSB7XG4gICAgZXhwciA9IGZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQsIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cblxuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbktleXdvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuQm9vbGVhbkxpdGVyYWwpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUgPT09ICd0cnVlJztcbiAgICBleHByID0gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW5OdWxsTGl0ZXJhbCkge1xuICAgIHRva2VuID0gbGV4KCk7XG4gICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgfSBlbHNlIGlmIChtYXRjaCgnLycpIHx8IG1hdGNoKCcvPScpKSB7XG4gICAgZXhwciA9IGZpbmlzaExpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICBwZWVrKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cblxuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXTtcbiAgZXhwZWN0KCcoJyk7XG5cbiAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcmdzLnB1c2gocGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSk7XG5cbiAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBleHBlY3QoJywnKTtcbiAgICB9XG4gIH1cblxuICBleHBlY3QoJyknKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7XG5cbiAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH1cblxuICByZXR1cm4gZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gIGV4cGVjdCgnLicpO1xuICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gIGV4cGVjdCgnWycpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gIGV4cGVjdCgnXScpO1xuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICB2YXIgZXhwciwgYXJncywgcHJvcGVydHk7XG4gIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICBleHByID0gZmluaXNoQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn0gLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXG5cblxuZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgY29uc3QgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuXG4gIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW5QdW5jdHVhdG9yKSB7XG4gICAgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByO1xufSAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG5cbmZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgdG9rZW4sIGV4cHI7XG5cbiAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuS2V5d29yZCkge1xuICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpO1xuICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgIGV4cHIgPSBmaW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufVxuXG5mdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuKSB7XG4gIGxldCBwcmVjID0gMDtcblxuICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuS2V5d29yZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgIGNhc2UgJ3x8JzpcbiAgICAgIHByZWMgPSAxO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICcmJic6XG4gICAgICBwcmVjID0gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnfCc6XG4gICAgICBwcmVjID0gMztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnXic6XG4gICAgICBwcmVjID0gNDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnJic6XG4gICAgICBwcmVjID0gNTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc9PT0nOlxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBwcmVjID0gNjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICBjYXNlICdpbic6XG4gICAgICBwcmVjID0gNztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnPDwnOlxuICAgIGNhc2UgJz4+JzpcbiAgICBjYXNlICc+Pj4nOlxuICAgICAgcHJlYyA9IDg7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJysnOlxuICAgIGNhc2UgJy0nOlxuICAgICAgcHJlYyA9IDk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJyonOlxuICAgIGNhc2UgJy8nOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcHJlYyA9IDExO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gcHJlYztcbn0gLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbi8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG4vLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4vLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4vLyAxMS45IEVxdWFsaXR5IE9wZXJhdG9yc1xuLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4vLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuXG5mdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gIGxlZnQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4pO1xuXG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cblxuICB0b2tlbi5wcmVjID0gcHJlYztcbiAgbGV4KCk7XG4gIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQpKSA+IDApIHtcbiAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDIgJiYgcHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSB7XG4gICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICBleHByID0gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICB9IC8vIFNoaWZ0LlxuXG5cbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgIHN0YWNrLnB1c2goZXhwcik7XG4gIH0gLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cblxuXG4gIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICBleHByID0gc3RhY2tbaV07XG4gIG1hcmtlcnMucG9wKCk7XG5cbiAgd2hpbGUgKGkgPiAxKSB7XG4gICAgbWFya2Vycy5wb3AoKTtcbiAgICBleHByID0gZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgaSAtPSAyO1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cblxuZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gIHZhciBleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG4gIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcblxuICBpZiAobWF0Y2goJz8nKSkge1xuICAgIGxleCgpO1xuICAgIGNvbnNlcXVlbnQgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIGFsdGVybmF0ZSA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG4gICAgZXhwciA9IGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICB9XG5cbiAgcmV0dXJuIGV4cHI7XG59IC8vIDExLjE0IENvbW1hIE9wZXJhdG9yXG5cblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICBjb25zdCBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICBpZiAobWF0Y2goJywnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gIH1cblxuICByZXR1cm4gZXhwcjtcbn1cblxuZnVuY3Rpb24gcGFyc2VyIChjb2RlKSB7XG4gIHNvdXJjZSA9IGNvZGU7XG4gIGluZGV4ID0gMDtcbiAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgbG9va2FoZWFkID0gbnVsbDtcbiAgcGVlaygpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbkVPRikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3QgdG9rZW4gYWZ0ZXIgZXhwcmVzc2lvbi4nKTtcbiAgfVxuXG4gIHJldHVybiBleHByO1xufVxuXG52YXIgQ29uc3RhbnRzID0ge1xuICBOYU46ICdOYU4nLFxuICBFOiAnTWF0aC5FJyxcbiAgTE4yOiAnTWF0aC5MTjInLFxuICBMTjEwOiAnTWF0aC5MTjEwJyxcbiAgTE9HMkU6ICdNYXRoLkxPRzJFJyxcbiAgTE9HMTBFOiAnTWF0aC5MT0cxMEUnLFxuICBQSTogJ01hdGguUEknLFxuICBTUVJUMV8yOiAnTWF0aC5TUVJUMV8yJyxcbiAgU1FSVDI6ICdNYXRoLlNRUlQyJyxcbiAgTUlOX1ZBTFVFOiAnTnVtYmVyLk1JTl9WQUxVRScsXG4gIE1BWF9WQUxVRTogJ051bWJlci5NQVhfVkFMVUUnXG59O1xuXG5mdW5jdGlvbiBGdW5jdGlvbnMgKGNvZGVnZW4pIHtcbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICBsZXQgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcblxuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgJygnICsgb2JqICsgJyknO1xuICAgICAgaWYgKGNhc3QubGFzdEluZGV4T2YoJ25ldyAnLCAwKSA9PT0gMCkgb2JqID0gJygnICsgb2JqICsgJyknO1xuICAgIH1cblxuICAgIHJldHVybiBvYmogKyAnLicgKyBuYW1lICsgKHR5cGUgPCAwID8gJycgOiB0eXBlID09PSAwID8gJygpJyA6ICcoJyArIGFyZ3Muc2xpY2UoMSkubWFwKGNvZGVnZW4pLmpvaW4oJywnKSArICcpJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmbihuYW1lLCBjYXN0LCB0eXBlKSB7XG4gICAgcmV0dXJuIGFyZ3MgPT4gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpO1xuICB9XG5cbiAgY29uc3QgREFURSA9ICduZXcgRGF0ZScsXG4gICAgICAgIFNUUklORyA9ICdTdHJpbmcnLFxuICAgICAgICBSRUdFWFAgPSAnUmVnRXhwJztcbiAgcmV0dXJuIHtcbiAgICAvLyBNQVRIIGZ1bmN0aW9uc1xuICAgIGlzTmFOOiAnTnVtYmVyLmlzTmFOJyxcbiAgICBpc0Zpbml0ZTogJ051bWJlci5pc0Zpbml0ZScsXG4gICAgYWJzOiAnTWF0aC5hYnMnLFxuICAgIGFjb3M6ICdNYXRoLmFjb3MnLFxuICAgIGFzaW46ICdNYXRoLmFzaW4nLFxuICAgIGF0YW46ICdNYXRoLmF0YW4nLFxuICAgIGF0YW4yOiAnTWF0aC5hdGFuMicsXG4gICAgY2VpbDogJ01hdGguY2VpbCcsXG4gICAgY29zOiAnTWF0aC5jb3MnLFxuICAgIGV4cDogJ01hdGguZXhwJyxcbiAgICBmbG9vcjogJ01hdGguZmxvb3InLFxuICAgIGxvZzogJ01hdGgubG9nJyxcbiAgICBtYXg6ICdNYXRoLm1heCcsXG4gICAgbWluOiAnTWF0aC5taW4nLFxuICAgIHBvdzogJ01hdGgucG93JyxcbiAgICByYW5kb206ICdNYXRoLnJhbmRvbScsXG4gICAgcm91bmQ6ICdNYXRoLnJvdW5kJyxcbiAgICBzaW46ICdNYXRoLnNpbicsXG4gICAgc3FydDogJ01hdGguc3FydCcsXG4gICAgdGFuOiAnTWF0aC50YW4nLFxuICAgIGNsYW1wOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykgZXJyb3IoJ01pc3NpbmcgYXJndW1lbnRzIHRvIGNsYW1wIGZ1bmN0aW9uLicpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykgZXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGNvbnN0IGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgIHJldHVybiAnTWF0aC5tYXgoJyArIGFbMV0gKyAnLCBNYXRoLm1pbignICsgYVsyXSArICcsJyArIGFbMF0gKyAnKSknO1xuICAgIH0sXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICBub3c6ICdEYXRlLm5vdycsXG4gICAgdXRjOiAnRGF0ZS5VVEMnLFxuICAgIGRhdGV0aW1lOiBEQVRFLFxuICAgIGRhdGU6IGZuKCdnZXREYXRlJywgREFURSwgMCksXG4gICAgZGF5OiBmbignZ2V0RGF5JywgREFURSwgMCksXG4gICAgeWVhcjogZm4oJ2dldEZ1bGxZZWFyJywgREFURSwgMCksXG4gICAgbW9udGg6IGZuKCdnZXRNb250aCcsIERBVEUsIDApLFxuICAgIGhvdXJzOiBmbignZ2V0SG91cnMnLCBEQVRFLCAwKSxcbiAgICBtaW51dGVzOiBmbignZ2V0TWludXRlcycsIERBVEUsIDApLFxuICAgIHNlY29uZHM6IGZuKCdnZXRTZWNvbmRzJywgREFURSwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBmbignZ2V0TWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgdGltZTogZm4oJ2dldFRpbWUnLCBEQVRFLCAwKSxcbiAgICB0aW1lem9uZW9mZnNldDogZm4oJ2dldFRpbWV6b25lT2Zmc2V0JywgREFURSwgMCksXG4gICAgdXRjZGF0ZTogZm4oJ2dldFVUQ0RhdGUnLCBEQVRFLCAwKSxcbiAgICB1dGNkYXk6IGZuKCdnZXRVVENEYXknLCBEQVRFLCAwKSxcbiAgICB1dGN5ZWFyOiBmbignZ2V0VVRDRnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICB1dGNtb250aDogZm4oJ2dldFVUQ01vbnRoJywgREFURSwgMCksXG4gICAgdXRjaG91cnM6IGZuKCdnZXRVVENIb3VycycsIERBVEUsIDApLFxuICAgIHV0Y21pbnV0ZXM6IGZuKCdnZXRVVENNaW51dGVzJywgREFURSwgMCksXG4gICAgdXRjc2Vjb25kczogZm4oJ2dldFVUQ1NlY29uZHMnLCBEQVRFLCAwKSxcbiAgICB1dGNtaWxsaXNlY29uZHM6IGZuKCdnZXRVVENNaWxsaXNlY29uZHMnLCBEQVRFLCAwKSxcbiAgICAvLyBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICBsZW5ndGg6IGZuKCdsZW5ndGgnLCBudWxsLCAtMSksXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgIHBhcnNlRmxvYXQ6ICdwYXJzZUZsb2F0JyxcbiAgICBwYXJzZUludDogJ3BhcnNlSW50JyxcbiAgICB1cHBlcjogZm4oJ3RvVXBwZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBsb3dlcjogZm4oJ3RvTG93ZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBzdWJzdHJpbmc6IGZuKCdzdWJzdHJpbmcnLCBTVFJJTkcpLFxuICAgIHNwbGl0OiBmbignc3BsaXQnLCBTVFJJTkcpLFxuICAgIHRyaW06IGZuKCd0cmltJywgU1RSSU5HLCAwKSxcbiAgICAvLyBSRUdFWFAgZnVuY3Rpb25zXG4gICAgcmVnZXhwOiBSRUdFWFAsXG4gICAgdGVzdDogZm4oJ3Rlc3QnLCBSRUdFWFApLFxuICAgIC8vIENvbnRyb2wgRmxvdyBmdW5jdGlvbnNcbiAgICBpZjogZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIGVycm9yKCdNaXNzaW5nIGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi4nKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpIGVycm9yKCdUb28gbWFueSBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICBjb25zdCBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICByZXR1cm4gJygnICsgYVswXSArICc/JyArIGFbMV0gKyAnOicgKyBhWzJdICsgJyknO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBRdW90ZXMocykge1xuICBjb25zdCBuID0gcyAmJiBzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBuICYmIChzWzBdID09PSAnXCInICYmIHNbbl0gPT09ICdcIicgfHwgc1swXSA9PT0gJ1xcJycgJiYgc1tuXSA9PT0gJ1xcJycpID8gcy5zbGljZSgxLCAtMSkgOiBzO1xufVxuXG5mdW5jdGlvbiBjb2RlZ2VuIChvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICBjb25zdCBhbGxvd2VkID0gb3B0LmFsbG93ZWQgPyB0b1NldChvcHQuYWxsb3dlZCkgOiB7fSxcbiAgICAgICAgZm9yYmlkZGVuID0gb3B0LmZvcmJpZGRlbiA/IHRvU2V0KG9wdC5mb3JiaWRkZW4pIDoge30sXG4gICAgICAgIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgQ29uc3RhbnRzLFxuICAgICAgICBmdW5jdGlvbnMgPSAob3B0LmZ1bmN0aW9ucyB8fCBGdW5jdGlvbnMpKHZpc2l0KSxcbiAgICAgICAgZ2xvYmFsdmFyID0gb3B0Lmdsb2JhbHZhcixcbiAgICAgICAgZmllbGR2YXIgPSBvcHQuZmllbGR2YXIsXG4gICAgICAgIG91dHB1dEdsb2JhbCA9IGlzRnVuY3Rpb24oZ2xvYmFsdmFyKSA/IGdsb2JhbHZhciA6IGlkID0+IGAke2dsb2JhbHZhcn1bXCIke2lkfVwiXWA7XG4gIGxldCBnbG9iYWxzID0ge30sXG4gICAgICBmaWVsZHMgPSB7fSxcbiAgICAgIG1lbWJlckRlcHRoID0gMDtcblxuICBmdW5jdGlvbiB2aXNpdChhc3QpIHtcbiAgICBpZiAoaXNTdHJpbmcoYXN0KSkgcmV0dXJuIGFzdDtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBHZW5lcmF0b3JzW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIGVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiAnICsgYXN0LnR5cGUpO1xuICAgIHJldHVybiBnZW5lcmF0b3IoYXN0KTtcbiAgfVxuXG4gIGNvbnN0IEdlbmVyYXRvcnMgPSB7XG4gICAgTGl0ZXJhbDogbiA9PiBuLnJhdyxcbiAgICBJZGVudGlmaWVyOiBuID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbi5uYW1lO1xuXG4gICAgICBpZiAobWVtYmVyRGVwdGggPiAwKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoZm9yYmlkZGVuLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKCdJbGxlZ2FsIGlkZW50aWZpZXI6ICcgKyBpZCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGNvbnN0YW50cywgaWQpKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShhbGxvd2VkLCBpZCkpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsc1tpZF0gPSAxO1xuICAgICAgICByZXR1cm4gb3V0cHV0R2xvYmFsKGlkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIE1lbWJlckV4cHJlc3Npb246IG4gPT4ge1xuICAgICAgY29uc3QgZCA9ICFuLmNvbXB1dGVkLFxuICAgICAgICAgICAgbyA9IHZpc2l0KG4ub2JqZWN0KTtcbiAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgY29uc3QgcCA9IHZpc2l0KG4ucHJvcGVydHkpO1xuXG4gICAgICBpZiAobyA9PT0gZmllbGR2YXIpIHtcbiAgICAgICAgLy8gc3RyaXAgcXVvdGVzIHRvIHNhbml0aXplIGZpZWxkIG5hbWUgKCMxNjUzKVxuICAgICAgICBmaWVsZHNbc3RyaXBRdW90ZXMocCldID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGQpIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICByZXR1cm4gbyArIChkID8gJy4nICsgcCA6ICdbJyArIHAgKyAnXScpO1xuICAgIH0sXG4gICAgQ2FsbEV4cHJlc3Npb246IG4gPT4ge1xuICAgICAgaWYgKG4uY2FsbGVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICBlcnJvcignSWxsZWdhbCBjYWxsZWUgdHlwZTogJyArIG4uY2FsbGVlLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lLFxuICAgICAgICAgICAgYXJncyA9IG4uYXJndW1lbnRzLFxuICAgICAgICAgICAgZm4gPSBoYXNPd25Qcm9wZXJ0eShmdW5jdGlvbnMsIGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICBpZiAoIWZuKSBlcnJvcignVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiAnICsgY2FsbGVlKTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZuKSA/IGZuKGFyZ3MpIDogZm4gKyAnKCcgKyBhcmdzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJyknO1xuICAgIH0sXG4gICAgQXJyYXlFeHByZXNzaW9uOiBuID0+ICdbJyArIG4uZWxlbWVudHMubWFwKHZpc2l0KS5qb2luKCcsJykgKyAnXScsXG4gICAgQmluYXJ5RXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLmxlZnQpICsgJyAnICsgbi5vcGVyYXRvciArICcgJyArIHZpc2l0KG4ucmlnaHQpICsgJyknLFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogbiA9PiAnKCcgKyBuLm9wZXJhdG9yICsgdmlzaXQobi5hcmd1bWVudCkgKyAnKScsXG4gICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBuID0+ICcoJyArIHZpc2l0KG4udGVzdCkgKyAnPycgKyB2aXNpdChuLmNvbnNlcXVlbnQpICsgJzonICsgdmlzaXQobi5hbHRlcm5hdGUpICsgJyknLFxuICAgIExvZ2ljYWxFeHByZXNzaW9uOiBuID0+ICcoJyArIHZpc2l0KG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgdmlzaXQobi5yaWdodCkgKyAnKScsXG4gICAgT2JqZWN0RXhwcmVzc2lvbjogbiA9PiAneycgKyBuLnByb3BlcnRpZXMubWFwKHZpc2l0KS5qb2luKCcsJykgKyAnfScsXG4gICAgUHJvcGVydHk6IG4gPT4ge1xuICAgICAgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgIGNvbnN0IGsgPSB2aXNpdChuLmtleSk7XG4gICAgICBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgcmV0dXJuIGsgKyAnOicgKyB2aXNpdChuLnZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29kZWdlbihhc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBjb2RlOiB2aXNpdChhc3QpLFxuICAgICAgZ2xvYmFsczogT2JqZWN0LmtleXMoZ2xvYmFscyksXG4gICAgICBmaWVsZHM6IE9iamVjdC5rZXlzKGZpZWxkcylcbiAgICB9O1xuICAgIGdsb2JhbHMgPSB7fTtcbiAgICBmaWVsZHMgPSB7fTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgY29kZWdlbi5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gIGNvZGVnZW4uY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICByZXR1cm4gY29kZWdlbjtcbn1cblxuZXhwb3J0IHsgQVNUTm9kZSwgQXJyYXlFeHByZXNzaW9uLCBCaW5hcnlFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiwgQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBJZGVudGlmaWVyLCBMaXRlcmFsLCBMb2dpY2FsRXhwcmVzc2lvbiwgTWVtYmVyRXhwcmVzc2lvbiwgT2JqZWN0RXhwcmVzc2lvbiwgUHJvcGVydHksIFJhd0NvZGUsIFVuYXJ5RXhwcmVzc2lvbiwgY29kZWdlbiBhcyBjb2RlZ2VuRXhwcmVzc2lvbiwgQ29uc3RhbnRzIGFzIGNvbnN0YW50cywgRnVuY3Rpb25zIGFzIGZ1bmN0aW9ucywgcGFyc2VyIGFzIHBhcnNlRXhwcmVzc2lvbiB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cywgYXJyYXksIGlzRnVuY3Rpb24sIGFjY2Vzc29yRmllbGRzLCBoYXNPd25Qcm9wZXJ0eSwgZXJyb3IgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgZm9yY2VTaW11bGF0aW9uLCBmb3JjZUNlbnRlciwgZm9yY2VDb2xsaWRlLCBmb3JjZU1hbnlCb2R5LCBmb3JjZUxpbmssIGZvcmNlWCwgZm9yY2VZIH0gZnJvbSAnZDMtZm9yY2UnO1xuXG5jb25zdCBGb3JjZU1hcCA9IHtcbiAgY2VudGVyOiBmb3JjZUNlbnRlcixcbiAgY29sbGlkZTogZm9yY2VDb2xsaWRlLFxuICBuYm9keTogZm9yY2VNYW55Qm9keSxcbiAgbGluazogZm9yY2VMaW5rLFxuICB4OiBmb3JjZVgsXG4gIHk6IGZvcmNlWVxufTtcbmNvbnN0IEZvcmNlcyA9ICdmb3JjZXMnLFxuICAgICAgRm9yY2VQYXJhbXMgPSBbJ2FscGhhJywgJ2FscGhhTWluJywgJ2FscGhhVGFyZ2V0JywgJ3ZlbG9jaXR5RGVjYXknLCAnZm9yY2VzJ10sXG4gICAgICBGb3JjZUNvbmZpZyA9IFsnc3RhdGljJywgJ2l0ZXJhdGlvbnMnXSxcbiAgICAgIEZvcmNlT3V0cHV0ID0gWyd4JywgJ3knLCAndngnLCAndnknXTtcbi8qKlxuICogRm9yY2Ugc2ltdWxhdGlvbiBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0Pn0gcGFyYW1zLmZvcmNlcyAtIFRoZSBmb3JjZXMgdG8gYXBwbHkuXG4gKi9cblxuZnVuY3Rpb24gRm9yY2UocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Gb3JjZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGb3JjZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3N0YXRpYycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVzdGFydCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaXRlcmF0aW9ucycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDMwMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGEnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhbHBoYU1pbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDAuMDAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhbHBoYVRhcmdldCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3ZlbG9jaXR5RGVjYXknLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjRcbiAgfSwge1xuICAgICduYW1lJzogJ2ZvcmNlcycsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3BhcmFtcyc6IFt7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAnY2VudGVyJ1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICd4JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3knLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDBcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ2NvbGxpZGUnXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ3JhZGl1cycsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC43XG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2l0ZXJhdGlvbnMnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDFcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ25ib2R5J1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogLTMwXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3RoZXRhJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwLjlcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnZGlzdGFuY2VNaW4nLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDFcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnZGlzdGFuY2VNYXgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICdsaW5rJ1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdsaW5rcycsXG4gICAgICAgICd0eXBlJzogJ2RhdGEnXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2lkJyxcbiAgICAgICAgJ3R5cGUnOiAnZmllbGQnXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2Rpc3RhbmNlJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAzMCxcbiAgICAgICAgJ2V4cHInOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3N0cmVuZ3RoJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2V4cHInOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2l0ZXJhdGlvbnMnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDFcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ3gnXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ3N0cmVuZ3RoJyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwLjFcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAneCcsXG4gICAgICAgICd0eXBlJzogJ2ZpZWxkJ1xuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAneSdcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDAuMVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd5JyxcbiAgICAgICAgJ3R5cGUnOiAnZmllbGQnXG4gICAgICB9XVxuICAgIH1dXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdtb2RpZnknOiBmYWxzZSxcbiAgICAnZGVmYXVsdCc6IEZvcmNlT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoRm9yY2UsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgc2ltID0gdGhpcy52YWx1ZSxcbiAgICAgICAgY2hhbmdlID0gcHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSxcbiAgICAgICAgcGFyYW1zID0gXy5tb2RpZmllZChGb3JjZVBhcmFtcyksXG4gICAgICAgIGl0ZXJzID0gXy5pdGVyYXRpb25zIHx8IDMwMDsgLy8gY29uZmlndXJlIHNpbXVsYXRpb25cblxuXG4gICAgaWYgKCFzaW0pIHtcbiAgICAgIHRoaXMudmFsdWUgPSBzaW0gPSBzaW11bGF0aW9uKHB1bHNlLnNvdXJjZSwgXyk7XG4gICAgICBzaW0ub24oJ3RpY2snLCByZXJ1bihwdWxzZS5kYXRhZmxvdywgdGhpcykpO1xuXG4gICAgICBpZiAoIV8uc3RhdGljKSB7XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIHNpbS50aWNrKCk7IC8vIGVuc3VyZSB3ZSBydW4gb24gaW5pdFxuICAgICAgfVxuXG4gICAgICBwdWxzZS5tb2RpZmllcygnaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBwdWxzZS5tb2RpZmllcygnaW5kZXgnKTtcbiAgICAgICAgc2ltLm5vZGVzKHB1bHNlLnNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJhbXMgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5NT0QpKSB7XG4gICAgICAgIHNldHVwKHNpbSwgXywgMCwgcHVsc2UpO1xuICAgICAgfVxuICAgIH0gLy8gcnVuIHNpbXVsYXRpb25cblxuXG4gICAgaWYgKHBhcmFtcyB8fCBjaGFuZ2UgfHwgXy5tb2RpZmllZChGb3JjZUNvbmZpZykgfHwgcHVsc2UuY2hhbmdlZCgpICYmIF8ucmVzdGFydCkge1xuICAgICAgc2ltLmFscGhhKE1hdGgubWF4KHNpbS5hbHBoYSgpLCBfLmFscGhhIHx8IDEpKS5hbHBoYURlY2F5KDEgLSBNYXRoLnBvdyhzaW0uYWxwaGFNaW4oKSwgMSAvIGl0ZXJzKSk7XG5cbiAgICAgIGlmIChfLnN0YXRpYykge1xuICAgICAgICBmb3IgKHNpbS5zdG9wKCk7IC0taXRlcnMgPj0gMDspIHNpbS50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2ltLnN0b3BwZWQoKSkgc2ltLnJlc3RhcnQoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247IC8vIGRlZmVyIHRvIHNpbSB0aWNrc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmlzaChfLCBwdWxzZSk7XG4gIH0sXG5cbiAgZmluaXNoKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZGF0YWZsb3cgPSBwdWxzZS5kYXRhZmxvdzsgLy8gaW5zcGVjdCBkZXBlbmRlbmNpZXMsIHRvdWNoIGxpbmsgc291cmNlIGRhdGFcblxuICAgIGZvciAobGV0IGFyZ3MgPSB0aGlzLl9hcmdvcHMsIGogPSAwLCBtID0gYXJncy5sZW5ndGgsIGFyZzsgaiA8IG07ICsraikge1xuICAgICAgYXJnID0gYXJnc1tqXTtcblxuICAgICAgaWYgKGFyZy5uYW1lICE9PSBGb3JjZXMgfHwgYXJnLm9wLl9hcmd2YWwuZm9yY2UgIT09ICdsaW5rJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgb3BzID0gYXJnLm9wLl9hcmdvcHMsIGkgPSAwLCBuID0gb3BzLmxlbmd0aCwgb3A7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKG9wc1tpXS5uYW1lID09PSAnbGlua3MnICYmIChvcCA9IG9wc1tpXS5vcC5zb3VyY2UpKSB7XG4gICAgICAgICAgZGF0YWZsb3cucHVsc2Uob3AsIGRhdGFmbG93LmNoYW5nZXNldCgpLnJlZmxvdygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gcmVmbG93IGFsbCBub2Rlc1xuXG5cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoRm9yY2VPdXRwdXQpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiByZXJ1bihkZiwgb3ApIHtcbiAgcmV0dXJuICgpID0+IGRmLnRvdWNoKG9wKS5ydW4oKTtcbn1cblxuZnVuY3Rpb24gc2ltdWxhdGlvbihub2RlcywgXykge1xuICBjb25zdCBzaW0gPSBmb3JjZVNpbXVsYXRpb24obm9kZXMpLFxuICAgICAgICBzdG9wID0gc2ltLnN0b3AsXG4gICAgICAgIHJlc3RhcnQgPSBzaW0ucmVzdGFydDtcbiAgbGV0IHN0b3BwZWQgPSBmYWxzZTtcblxuICBzaW0uc3RvcHBlZCA9ICgpID0+IHN0b3BwZWQ7XG5cbiAgc2ltLnJlc3RhcnQgPSAoKSA9PiAoc3RvcHBlZCA9IGZhbHNlLCByZXN0YXJ0KCkpO1xuXG4gIHNpbS5zdG9wID0gKCkgPT4gKHN0b3BwZWQgPSB0cnVlLCBzdG9wKCkpO1xuXG4gIHJldHVybiBzZXR1cChzaW0sIF8sIHRydWUpLm9uKCdlbmQnLCAoKSA9PiBzdG9wcGVkID0gdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNldHVwKHNpbSwgXywgaW5pdCwgcHVsc2UpIHtcbiAgdmFyIGYgPSBhcnJheShfLmZvcmNlcyksXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIHAsXG4gICAgICBuYW1lO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBGb3JjZVBhcmFtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBwID0gRm9yY2VQYXJhbXNbaV07XG4gICAgaWYgKHAgIT09IEZvcmNlcyAmJiBfLm1vZGlmaWVkKHApKSBzaW1bcF0oX1twXSk7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBuID0gZi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBuYW1lID0gRm9yY2VzICsgaTtcbiAgICBwID0gaW5pdCB8fCBfLm1vZGlmaWVkKEZvcmNlcywgaSkgPyBnZXRGb3JjZShmW2ldKSA6IHB1bHNlICYmIG1vZGlmaWVkKGZbaV0sIHB1bHNlKSA/IHNpbS5mb3JjZShuYW1lKSA6IG51bGw7XG4gICAgaWYgKHApIHNpbS5mb3JjZShuYW1lLCBwKTtcbiAgfVxuXG4gIGZvciAobiA9IHNpbS5udW1Gb3JjZXMgfHwgMDsgaSA8IG47ICsraSkge1xuICAgIHNpbS5mb3JjZShGb3JjZXMgKyBpLCBudWxsKTsgLy8gcmVtb3ZlXG4gIH1cblxuICBzaW0ubnVtRm9yY2VzID0gZi5sZW5ndGg7XG4gIHJldHVybiBzaW07XG59XG5cbmZ1bmN0aW9uIG1vZGlmaWVkKGYsIHB1bHNlKSB7XG4gIHZhciBrLCB2O1xuXG4gIGZvciAoayBpbiBmKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odiA9IGZba10pICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKHYpKSkgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZ2V0Rm9yY2UoXykge1xuICB2YXIgZiwgcDtcblxuICBpZiAoIWhhc093blByb3BlcnR5KEZvcmNlTWFwLCBfLmZvcmNlKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgZm9yY2U6ICcgKyBfLmZvcmNlKTtcbiAgfVxuXG4gIGYgPSBGb3JjZU1hcFtfLmZvcmNlXSgpO1xuXG4gIGZvciAocCBpbiBfKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZltwXSkpIHNldEZvcmNlUGFyYW0oZltwXSwgX1twXSwgXyk7XG4gIH1cblxuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gc2V0Rm9yY2VQYXJhbShmLCB2LCBfKSB7XG4gIGYoaXNGdW5jdGlvbih2KSA/IGQgPT4gdihkLCBfKSA6IHYpO1xufVxuXG5leHBvcnQgeyBGb3JjZSBhcyBmb3JjZSB9O1xuIiwiaW1wb3J0IHsgdGlja1N0ZXAgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBmb3JtYXRTcGVjaWZpZXIsIHByZWNpc2lvbkZpeGVkLCBwcmVjaXNpb25Sb3VuZCwgcHJlY2lzaW9uUHJlZml4LCBmb3JtYXRMb2NhbGUsIGZvcm1hdCwgZm9ybWF0UHJlZml4IH0gZnJvbSAnZDMtZm9ybWF0JztcbmltcG9ydCB7IFNFQ09ORFMsIE1JTlVURVMsIEhPVVJTLCBEQVRFLCBXRUVLLCBNT05USCwgUVVBUlRFUiwgWUVBUiwgTUlMTElTRUNPTkRTLCBEQVksIHRpbWVJbnRlcnZhbCwgdXRjSW50ZXJ2YWwgfSBmcm9tICd2ZWdhLXRpbWUnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGlzT2JqZWN0LCBlcnJvciwgZXh0ZW5kIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHRpbWVGb3JtYXQsIHRpbWVQYXJzZSwgdXRjRm9ybWF0LCB1dGNQYXJzZSwgdGltZUZvcm1hdExvY2FsZSBhcyB0aW1lRm9ybWF0TG9jYWxlJDEgfSBmcm9tICdkMy10aW1lLWZvcm1hdCc7XG5cbmZ1bmN0aW9uIG1lbW9pemUgKG1ldGhvZCkge1xuICBjb25zdCBjYWNoZSA9IHt9O1xuICByZXR1cm4gc3BlYyA9PiBjYWNoZVtzcGVjXSB8fCAoY2FjaGVbc3BlY10gPSBtZXRob2Qoc3BlYykpO1xufVxuXG5mdW5jdGlvbiB0cmltWmVyb2VzKG51bWJlckZvcm1hdCwgZGVjaW1hbENoYXIpIHtcbiAgcmV0dXJuIHggPT4ge1xuICAgIGNvbnN0IHN0ciA9IG51bWJlckZvcm1hdCh4KSxcbiAgICAgICAgICBkZWMgPSBzdHIuaW5kZXhPZihkZWNpbWFsQ2hhcik7XG4gICAgaWYgKGRlYyA8IDApIHJldHVybiBzdHI7XG4gICAgbGV0IGlkeCA9IHJpZ2h0bW9zdERpZ2l0KHN0ciwgZGVjKTtcbiAgICBjb25zdCBlbmQgPSBpZHggPCBzdHIubGVuZ3RoID8gc3RyLnNsaWNlKGlkeCkgOiAnJztcblxuICAgIHdoaWxlICgtLWlkeCA+IGRlYykgaWYgKHN0cltpZHhdICE9PSAnMCcpIHtcbiAgICAgICsraWR4O1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBpZHgpICsgZW5kO1xuICB9O1xufVxuXG5mdW5jdGlvbiByaWdodG1vc3REaWdpdChzdHIsIGRlYykge1xuICBsZXQgaSA9IHN0ci5sYXN0SW5kZXhPZignZScpLFxuICAgICAgYztcbiAgaWYgKGkgPiAwKSByZXR1cm4gaTtcblxuICBmb3IgKGkgPSBzdHIubGVuZ3RoOyAtLWkgPiBkZWM7KSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHJldHVybiBpICsgMTsgLy8gaXMgZGlnaXRcbiAgfVxufVxuXG5mdW5jdGlvbiBudW1iZXJMb2NhbGUobG9jYWxlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG1lbW9pemUobG9jYWxlLmZvcm1hdCksXG4gICAgICAgIGZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeCxcblxuICAgIGZvcm1hdEZsb2F0KHNwZWMpIHtcbiAgICAgIGNvbnN0IHMgPSBmb3JtYXRTcGVjaWZpZXIoc3BlYyB8fCAnLCcpO1xuXG4gICAgICBpZiAocy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzLnByZWNpc2lvbiA9IDEyO1xuXG4gICAgICAgIHN3aXRjaCAocy50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBzLnByZWNpc2lvbiAtPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgIHMucHJlY2lzaW9uIC09IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmltWmVyb2VzKGZvcm1hdChzKSwgLy8gbnVtYmVyIGZvcm1hdFxuICAgICAgICBmb3JtYXQoJy4xZicpKDEpWzFdIC8vIGRlY2ltYWwgcG9pbnQgY2hhcmFjdGVyXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZm9ybWF0KHMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBmb3JtYXRTcGFuKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyAnLGYnIDogc3BlY2lmaWVyKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKTtcbiAgICAgIGxldCBwcmVjaXNpb247XG5cbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICcnOlxuICAgICAgICAgIGNhc2UgJ2UnOlxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblJvdW5kKHN0ZXAsIHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSAnZScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05hTihwcmVjaXNpb24gPSBwcmVjaXNpb25GaXhlZChzdGVwKSkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSAnJScpICogMjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICB9XG5cbiAgfTtcbn1cblxubGV0IGRlZmF1bHROdW1iZXJMb2NhbGU7XG5yZXNldE51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbmZ1bmN0aW9uIHJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpIHtcbiAgcmV0dXJuIGRlZmF1bHROdW1iZXJMb2NhbGUgPSBudW1iZXJMb2NhbGUoe1xuICAgIGZvcm1hdDogZm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH0pO1xufVxuZnVuY3Rpb24gbnVtYmVyRm9ybWF0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIG51bWJlckxvY2FsZShmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikpO1xufVxuZnVuY3Rpb24gbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZGVmYXVsdE51bWJlckxvY2FsZSA9IG51bWJlckZvcm1hdExvY2FsZShkZWZpbml0aW9uKSA6IGRlZmF1bHROdW1iZXJMb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHRpbWVNdWx0aUZvcm1hdChmb3JtYXQsIGludGVydmFsLCBzcGVjKSB7XG4gIHNwZWMgPSBzcGVjIHx8IHt9O1xuXG4gIGlmICghaXNPYmplY3Qoc3BlYykpIHtcbiAgICBlcnJvcihcIkludmFsaWQgdGltZSBtdWx0aS1mb3JtYXQgc3BlY2lmaWVyOiBcIi5jb25jYXQoc3BlYykpO1xuICB9XG5cbiAgY29uc3Qgc2Vjb25kID0gaW50ZXJ2YWwoU0VDT05EUyksXG4gICAgICAgIG1pbnV0ZSA9IGludGVydmFsKE1JTlVURVMpLFxuICAgICAgICBob3VyID0gaW50ZXJ2YWwoSE9VUlMpLFxuICAgICAgICBkYXkgPSBpbnRlcnZhbChEQVRFKSxcbiAgICAgICAgd2VlayA9IGludGVydmFsKFdFRUspLFxuICAgICAgICBtb250aCA9IGludGVydmFsKE1PTlRIKSxcbiAgICAgICAgcXVhcnRlciA9IGludGVydmFsKFFVQVJURVIpLFxuICAgICAgICB5ZWFyID0gaW50ZXJ2YWwoWUVBUiksXG4gICAgICAgIEwgPSBmb3JtYXQoc3BlY1tNSUxMSVNFQ09ORFNdIHx8ICcuJUwnKSxcbiAgICAgICAgUyA9IGZvcm1hdChzcGVjW1NFQ09ORFNdIHx8ICc6JVMnKSxcbiAgICAgICAgTSA9IGZvcm1hdChzcGVjW01JTlVURVNdIHx8ICclSTolTScpLFxuICAgICAgICBIID0gZm9ybWF0KHNwZWNbSE9VUlNdIHx8ICclSSAlcCcpLFxuICAgICAgICBkID0gZm9ybWF0KHNwZWNbREFURV0gfHwgc3BlY1tEQVldIHx8ICclYSAlZCcpLFxuICAgICAgICB3ID0gZm9ybWF0KHNwZWNbV0VFS10gfHwgJyViICVkJyksXG4gICAgICAgIG0gPSBmb3JtYXQoc3BlY1tNT05USF0gfHwgJyVCJyksXG4gICAgICAgIHEgPSBmb3JtYXQoc3BlY1tRVUFSVEVSXSB8fCAnJUInKSxcbiAgICAgICAgeSA9IGZvcm1hdChzcGVjW1lFQVJdIHx8ICclWScpO1xuICByZXR1cm4gZGF0ZSA9PiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IEwgOiBtaW51dGUoZGF0ZSkgPCBkYXRlID8gUyA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gTSA6IGRheShkYXRlKSA8IGRhdGUgPyBIIDogbW9udGgoZGF0ZSkgPCBkYXRlID8gd2VlayhkYXRlKSA8IGRhdGUgPyBkIDogdyA6IHllYXIoZGF0ZSkgPCBkYXRlID8gcXVhcnRlcihkYXRlKSA8IGRhdGUgPyBtIDogcSA6IHkpKGRhdGUpO1xufVxuXG5mdW5jdGlvbiB0aW1lTG9jYWxlKGxvY2FsZSkge1xuICBjb25zdCB0aW1lRm9ybWF0ID0gbWVtb2l6ZShsb2NhbGUuZm9ybWF0KSxcbiAgICAgICAgdXRjRm9ybWF0ID0gbWVtb2l6ZShsb2NhbGUudXRjRm9ybWF0KTtcbiAgcmV0dXJuIHtcbiAgICB0aW1lRm9ybWF0OiBzcGVjID0+IGlzU3RyaW5nKHNwZWMpID8gdGltZUZvcm1hdChzcGVjKSA6IHRpbWVNdWx0aUZvcm1hdCh0aW1lRm9ybWF0LCB0aW1lSW50ZXJ2YWwsIHNwZWMpLFxuICAgIHV0Y0Zvcm1hdDogc3BlYyA9PiBpc1N0cmluZyhzcGVjKSA/IHV0Y0Zvcm1hdChzcGVjKSA6IHRpbWVNdWx0aUZvcm1hdCh1dGNGb3JtYXQsIHV0Y0ludGVydmFsLCBzcGVjKSxcbiAgICB0aW1lUGFyc2U6IG1lbW9pemUobG9jYWxlLnBhcnNlKSxcbiAgICB1dGNQYXJzZTogbWVtb2l6ZShsb2NhbGUudXRjUGFyc2UpXG4gIH07XG59XG5cbmxldCBkZWZhdWx0VGltZUxvY2FsZTtcbnJlc2V0VGltZUZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbmZ1bmN0aW9uIHJlc2V0VGltZUZvcm1hdERlZmF1bHRMb2NhbGUoKSB7XG4gIHJldHVybiBkZWZhdWx0VGltZUxvY2FsZSA9IHRpbWVMb2NhbGUoe1xuICAgIGZvcm1hdDogdGltZUZvcm1hdCxcbiAgICBwYXJzZTogdGltZVBhcnNlLFxuICAgIHV0Y0Zvcm1hdDogdXRjRm9ybWF0LFxuICAgIHV0Y1BhcnNlOiB1dGNQYXJzZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRpbWVGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gdGltZUxvY2FsZSh0aW1lRm9ybWF0TG9jYWxlJDEoZGVmaW5pdGlvbikpO1xufVxuZnVuY3Rpb24gdGltZUZvcm1hdERlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGRlZmF1bHRUaW1lTG9jYWxlID0gdGltZUZvcm1hdExvY2FsZShkZWZpbml0aW9uKSA6IGRlZmF1bHRUaW1lTG9jYWxlO1xufVxuXG5jb25zdCBjcmVhdGVMb2NhbGUgPSAobnVtYmVyLCB0aW1lKSA9PiBleHRlbmQoe30sIG51bWJlciwgdGltZSk7XG5cbmZ1bmN0aW9uIGxvY2FsZShudW1iZXJTcGVjLCB0aW1lU3BlYykge1xuICBjb25zdCBudW1iZXIgPSBudW1iZXJTcGVjID8gbnVtYmVyRm9ybWF0TG9jYWxlKG51bWJlclNwZWMpIDogbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICBjb25zdCB0aW1lID0gdGltZVNwZWMgPyB0aW1lRm9ybWF0TG9jYWxlKHRpbWVTcGVjKSA6IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHJldHVybiBjcmVhdGVMb2NhbGUobnVtYmVyLCB0aW1lKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUobnVtYmVyU3BlYywgdGltZVNwZWMpIHtcbiAgY29uc3QgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgaWYgKGFyZ3MgJiYgYXJncyAhPT0gMikge1xuICAgIGVycm9yKCdkZWZhdWx0TG9jYWxlIGV4cGVjdHMgZWl0aGVyIHplcm8gb3IgdHdvIGFyZ3VtZW50cy4nKTtcbiAgfVxuXG4gIHJldHVybiBhcmdzID8gY3JlYXRlTG9jYWxlKG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUobnVtYmVyU3BlYyksIHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKHRpbWVTcGVjKSkgOiBjcmVhdGVMb2NhbGUobnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpKTtcbn1cbmZ1bmN0aW9uIHJlc2V0RGVmYXVsdExvY2FsZSgpIHtcbiAgcmVzZXROdW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHJlc2V0VGltZUZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbiAgcmV0dXJuIGRlZmF1bHRMb2NhbGUoKTtcbn1cblxuZXhwb3J0IHsgZGVmYXVsdExvY2FsZSwgbG9jYWxlLCBudW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlLCBudW1iZXJGb3JtYXRMb2NhbGUsIHJlc2V0RGVmYXVsdExvY2FsZSwgcmVzZXROdW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlLCByZXNldFRpbWVGb3JtYXREZWZhdWx0TG9jYWxlLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdExvY2FsZSB9O1xuIiwiaW1wb3J0IHsgdHJ1dGh5LCBlcnJvciwgaGFzT3duUHJvcGVydHksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBzdHJpbmdWYWx1ZSwgZXh0ZW5kLCBpc0FycmF5LCBpc09iamVjdCwgZmllbGQsIHBlZWssIGlkZW50aXR5LCBhcnJheSBhcyBhcnJheSQxLCBpc0Jvb2xlYW4sIGlzRGF0ZSwgaXNOdW1iZXIsIGlzUmVnRXhwLCB0b0Jvb2xlYW4sIHRvRGF0ZSwgdG9OdW1iZXIsIHRvU3RyaW5nLCBmbHVzaCwgbGVycCwgcGFkLCBzcGFuLCBpbnJhbmdlLCB0cnVuY2F0ZSwgcXVhcnRlciwgdXRjcXVhcnRlciwgZXh0ZW50LCBjbGFtcFJhbmdlLCBwYW5MaW5lYXIsIHBhbkxvZywgcGFuUG93LCBwYW5TeW1sb2csIHpvb21MaW5lYXIsIHpvb21Mb2csIHpvb21Qb3csIHpvb21TeW1sb2cgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgTGl0ZXJhbCwgY29kZWdlbkV4cHJlc3Npb24sIGNvbnN0YW50cywgZnVuY3Rpb25zLCBwYXJzZUV4cHJlc3Npb24sIENhbGxFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1leHByZXNzaW9uJztcbmltcG9ydCB7IGdlb0JvdW5kcyBhcyBnZW9Cb3VuZHMkMSwgZ2VvQ2VudHJvaWQgYXMgZ2VvQ2VudHJvaWQkMSwgZ2VvQXJlYSBhcyBnZW9BcmVhJDEgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgcmdiLCBsYWIsIGhjbCwgaHNsIH0gZnJvbSAnZDMtY29sb3InO1xuaW1wb3J0IHsgaXNUdXBsZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgYmFuZFNwYWNlLCBzY2FsZSBhcyBzY2FsZSQxLCBzY2FsZUZyYWN0aW9uIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyBHcmFkaWVudCwgcGF0aFJlbmRlciwgcGF0aFBhcnNlLCBCb3VuZHMsIGludGVyc2VjdCBhcyBpbnRlcnNlY3QkMSB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBzZWxlY3Rpb25WaXNpdG9yLCBzZWxlY3Rpb25UZXN0LCBzZWxlY3Rpb25JZFRlc3QsIHNlbGVjdGlvblJlc29sdmUsIHNlbGVjdGlvblR1cGxlcyB9IGZyb20gJ3ZlZ2Etc2VsZWN0aW9ucyc7XG5pbXBvcnQgeyByYW5kb20sIGN1bXVsYXRpdmVOb3JtYWwsIGN1bXVsYXRpdmVMb2dOb3JtYWwsIGN1bXVsYXRpdmVVbmlmb3JtLCBkZW5zaXR5Tm9ybWFsLCBkZW5zaXR5TG9nTm9ybWFsLCBkZW5zaXR5VW5pZm9ybSwgcXVhbnRpbGVOb3JtYWwsIHF1YW50aWxlTG9nTm9ybWFsLCBxdWFudGlsZVVuaWZvcm0sIHNhbXBsZU5vcm1hbCwgc2FtcGxlTG9nTm9ybWFsLCBzYW1wbGVVbmlmb3JtIH0gZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmltcG9ydCB7IHV0Y09mZnNldCwgdXRjU2VxdWVuY2UsIHRpbWVPZmZzZXQsIHRpbWVTZXF1ZW5jZSwgdGltZVVuaXRTcGVjaWZpZXIsIHdlZWssIHV0Y3dlZWssIGRheW9meWVhciwgdXRjZGF5b2Z5ZWFyIH0gZnJvbSAndmVnYS10aW1lJztcbmltcG9ydCB7IHJhbmdlIGFzIHJhbmdlJDEgfSBmcm9tICdkMy1hcnJheSc7XG5cbmZ1bmN0aW9uIGRhdGEobmFtZSkge1xuICBjb25zdCBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV07XG4gIHJldHVybiBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXTtcbn1cbmZ1bmN0aW9uIGluZGF0YShuYW1lLCBmaWVsZCwgdmFsdWUpIHtcbiAgY29uc3QgaW5kZXggPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXVsnaW5kZXg6JyArIGZpZWxkXSxcbiAgICAgICAgZW50cnkgPSBpbmRleCA/IGluZGV4LnZhbHVlLmdldCh2YWx1ZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBlbnRyeSA/IGVudHJ5LmNvdW50IDogZW50cnk7XG59XG5mdW5jdGlvbiBzZXRkYXRhKG5hbWUsIHR1cGxlcykge1xuICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICAgICAgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgICBpbnB1dCA9IGRhdGEuaW5wdXQ7XG4gIGRmLnB1bHNlKGlucHV0LCBkZi5jaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQodHVwbGVzKSk7XG4gIHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBlbmNvZGUgKGl0ZW0sIG5hbWUsIHJldHZhbCkge1xuICBpZiAoaXRlbSkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5jb250ZXh0LmRhdGFmbG93LFxuICAgICAgICAgIHRhcmdldCA9IGl0ZW0ubWFyay5zb3VyY2U7XG4gICAgZGYucHVsc2UodGFyZ2V0LCBkZi5jaGFuZ2VzZXQoKS5lbmNvZGUoaXRlbSwgbmFtZSkpO1xuICB9XG5cbiAgcmV0dXJuIHJldHZhbCAhPT0gdW5kZWZpbmVkID8gcmV0dmFsIDogaXRlbTtcbn1cblxuY29uc3Qgd3JhcCA9IG1ldGhvZCA9PiBmdW5jdGlvbiAodmFsdWUsIHNwZWMpIHtcbiAgY29uc3QgbG9jYWxlID0gdGhpcy5jb250ZXh0LmRhdGFmbG93LmxvY2FsZSgpO1xuICByZXR1cm4gbG9jYWxlW21ldGhvZF0oc3BlYykodmFsdWUpO1xufTtcblxuY29uc3QgZm9ybWF0ID0gd3JhcCgnZm9ybWF0Jyk7XG5jb25zdCB0aW1lRm9ybWF0ID0gd3JhcCgndGltZUZvcm1hdCcpO1xuY29uc3QgdXRjRm9ybWF0ID0gd3JhcCgndXRjRm9ybWF0Jyk7XG5jb25zdCB0aW1lUGFyc2UgPSB3cmFwKCd0aW1lUGFyc2UnKTtcbmNvbnN0IHV0Y1BhcnNlID0gd3JhcCgndXRjUGFyc2UnKTtcbmNvbnN0IGRhdGVPYmogPSBuZXcgRGF0ZSgyMDAwLCAwLCAxKTtcblxuZnVuY3Rpb24gdGltZShtb250aCwgZGF5LCBzcGVjaWZpZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1vbnRoKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihkYXkpKSByZXR1cm4gJyc7XG4gIGRhdGVPYmouc2V0WWVhcigyMDAwKTtcbiAgZGF0ZU9iai5zZXRNb250aChtb250aCk7XG4gIGRhdGVPYmouc2V0RGF0ZShkYXkpO1xuICByZXR1cm4gdGltZUZvcm1hdC5jYWxsKHRoaXMsIGRhdGVPYmosIHNwZWNpZmllcik7XG59XG5cbmZ1bmN0aW9uIG1vbnRoRm9ybWF0KG1vbnRoKSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgbW9udGgsIDEsICclQicpO1xufVxuZnVuY3Rpb24gbW9udGhBYmJyZXZGb3JtYXQobW9udGgpIHtcbiAgcmV0dXJuIHRpbWUuY2FsbCh0aGlzLCBtb250aCwgMSwgJyViJyk7XG59XG5mdW5jdGlvbiBkYXlGb3JtYXQoZGF5KSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgMCwgMiArIGRheSwgJyVBJyk7XG59XG5mdW5jdGlvbiBkYXlBYmJyZXZGb3JtYXQoZGF5KSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgMCwgMiArIGRheSwgJyVhJyk7XG59XG5cbmNvbnN0IERhdGFQcmVmaXggPSAnOic7XG5jb25zdCBJbmRleFByZWZpeCA9ICdAJztcbmNvbnN0IFNjYWxlUHJlZml4ID0gJyUnO1xuY29uc3QgU2lnbmFsUHJlZml4ID0gJyQnO1xuXG5mdW5jdGlvbiBkYXRhVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgIT09IExpdGVyYWwpIHtcbiAgICBlcnJvcignRmlyc3QgYXJndW1lbnQgdG8gZGF0YSBmdW5jdGlvbnMgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IGFyZ3NbMF0udmFsdWUsXG4gICAgICAgIGRhdGFOYW1lID0gRGF0YVByZWZpeCArIGRhdGE7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShkYXRhTmFtZSwgcGFyYW1zKSkge1xuICAgIHRyeSB7XG4gICAgICBwYXJhbXNbZGF0YU5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS50dXBsZXNSZWYoKTtcbiAgICB9IGNhdGNoIChlcnIpIHsvLyBpZiBkYXRhIHNldCBkb2VzIG5vdCBleGlzdCwgdGhlcmUncyBub3RoaW5nIHRvIHRyYWNrXG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbmRhdGFWaXNpdG9yKG5hbWUsIGFyZ3MsIHNjb3BlLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3NbMF0udHlwZSAhPT0gTGl0ZXJhbCkgZXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIGluZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGlmIChhcmdzWzFdLnR5cGUgIT09IExpdGVyYWwpIGVycm9yKCdTZWNvbmQgYXJndW1lbnQgdG8gaW5kYXRhIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgY29uc3QgZGF0YSA9IGFyZ3NbMF0udmFsdWUsXG4gICAgICAgIGZpZWxkID0gYXJnc1sxXS52YWx1ZSxcbiAgICAgICAgaW5kZXhOYW1lID0gSW5kZXhQcmVmaXggKyBmaWVsZDtcblxuICBpZiAoIWhhc093blByb3BlcnR5KGluZGV4TmFtZSwgcGFyYW1zKSkge1xuICAgIHBhcmFtc1tpbmRleE5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS5pbmRhdGFSZWYoc2NvcGUsIGZpZWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NhbGVWaXNpdG9yKG5hbWUsIGFyZ3MsIHNjb3BlLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3NbMF0udHlwZSA9PT0gTGl0ZXJhbCkge1xuICAgIC8vIGFkZCBzY2FsZSBkZXBlbmRlbmN5XG4gICAgYWRkU2NhbGVEZXBlbmRlbmN5KHNjb3BlLCBwYXJhbXMsIGFyZ3NbMF0udmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluZGlyZWN0IHNjYWxlIGxvb2t1cDsgYWRkIGFsbCBzY2FsZXMgYXMgcGFyYW1ldGVyc1xuICAgIGZvciAobmFtZSBpbiBzY29wZS5zY2FsZXMpIHtcbiAgICAgIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU2NhbGVEZXBlbmRlbmN5KHNjb3BlLCBwYXJhbXMsIG5hbWUpIHtcbiAgY29uc3Qgc2NhbGVOYW1lID0gU2NhbGVQcmVmaXggKyBuYW1lO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkocGFyYW1zLCBzY2FsZU5hbWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcmFtc1tzY2FsZU5hbWVdID0gc2NvcGUuc2NhbGVSZWYobmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gVE9ETzogZXJyb3IgaGFuZGxpbmc/IHdhcm5pbmc/XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlKG5hbWUsIGN0eCkge1xuICBsZXQgcztcbiAgcmV0dXJuIGlzRnVuY3Rpb24obmFtZSkgPyBuYW1lIDogaXNTdHJpbmcobmFtZSkgPyAocyA9IGN0eC5zY2FsZXNbbmFtZV0pICYmIHMudmFsdWUgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpbnRlcm5hbFNjYWxlRnVuY3Rpb25zKGNvZGVnZW4sIGZuY3R4LCB2aXNpdG9ycykge1xuICAvLyBhZGQgaGVscGVyIG1ldGhvZCB0byB0aGUgJ3RoaXMnIGV4cHJlc3Npb24gZnVuY3Rpb24gY29udGV4dFxuICBmbmN0eC5fX2JhbmR3aWR0aCA9IHMgPT4gcyAmJiBzLmJhbmR3aWR0aCA/IHMuYmFuZHdpZHRoKCkgOiAwOyAvLyByZWdpc3RlciBBU1QgdmlzaXRvcnMgZm9yIGludGVybmFsIHNjYWxlIGZ1bmN0aW9uc1xuXG5cbiAgdmlzaXRvcnMuX2JhbmR3aWR0aCA9IHNjYWxlVmlzaXRvcjtcbiAgdmlzaXRvcnMuX3JhbmdlID0gc2NhbGVWaXNpdG9yO1xuICB2aXNpdG9ycy5fc2NhbGUgPSBzY2FsZVZpc2l0b3I7IC8vIHJlc29sdmUgc2NhbGUgcmVmZXJlbmNlIGRpcmVjdGx5IHRvIHRoZSBzaWduYWwgaGFzaCBhcmd1bWVudFxuXG4gIGNvbnN0IHJlZiA9IGFyZyA9PiAnX1snICsgKGFyZy50eXBlID09PSBMaXRlcmFsID8gc3RyaW5nVmFsdWUoU2NhbGVQcmVmaXggKyBhcmcudmFsdWUpIDogc3RyaW5nVmFsdWUoU2NhbGVQcmVmaXgpICsgJysnICsgY29kZWdlbihhcmcpKSArICddJzsgLy8gZGVmaW5lIGFuZCByZXR1cm4gaW50ZXJuYWwgc2NhbGUgZnVuY3Rpb24gY29kZSBnZW5lcmF0b3JzXG4gIC8vIHRoZXNlIGludGVybmFsIGZ1bmN0aW9ucyBhcmUgY2FsbGVkIGJ5IG1hcmsgZW5jb2RlcnNcblxuXG4gIHJldHVybiB7XG4gICAgX2JhbmR3aWR0aDogYXJncyA9PiBgdGhpcy5fX2JhbmR3aWR0aCgke3JlZihhcmdzWzBdKX0pYCxcbiAgICBfcmFuZ2U6IGFyZ3MgPT4gYCR7cmVmKGFyZ3NbMF0pfS5yYW5nZSgpYCxcbiAgICBfc2NhbGU6IGFyZ3MgPT4gYCR7cmVmKGFyZ3NbMF0pfSgke2NvZGVnZW4oYXJnc1sxXSl9KWBcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2VvTWV0aG9kKG1ldGhvZE5hbWUsIGdsb2JhbE1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb2plY3Rpb24sIGdlb2pzb24sIGdyb3VwKSB7XG4gICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgIC8vIHByb2plY3Rpb24gZGVmaW5lZCwgdXNlIGl0XG4gICAgICBjb25zdCBwID0gZ2V0U2NhbGUocHJvamVjdGlvbiwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHAgJiYgcC5wYXRoW21ldGhvZE5hbWVdKGdlb2pzb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcm9qZWN0aW9uIHVuZGVmaW5lZCwgdXNlIGdsb2JhbCBtZXRob2RcbiAgICAgIHJldHVybiBnbG9iYWxNZXRob2QoZ2VvanNvbik7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBnZW9BcmVhID0gZ2VvTWV0aG9kKCdhcmVhJywgZ2VvQXJlYSQxKTtcbmNvbnN0IGdlb0JvdW5kcyA9IGdlb01ldGhvZCgnYm91bmRzJywgZ2VvQm91bmRzJDEpO1xuY29uc3QgZ2VvQ2VudHJvaWQgPSBnZW9NZXRob2QoJ2NlbnRyb2lkJywgZ2VvQ2VudHJvaWQkMSk7XG5cbmZ1bmN0aW9uIGluU2NvcGUgKGl0ZW0pIHtcbiAgY29uc3QgZ3JvdXAgPSB0aGlzLmNvbnRleHQuZ3JvdXA7XG4gIGxldCB2YWx1ZSA9IGZhbHNlO1xuICBpZiAoZ3JvdXApIHdoaWxlIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT09IGdyb3VwKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpdGVtID0gaXRlbS5tYXJrLmdyb3VwO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbG9nKGRmLCBtZXRob2QsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBkZlttZXRob2RdLmFwcGx5KGRmLCBbJ0VYUFJFU1NJT04nXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi53YXJuKGVycik7XG4gIH1cblxuICByZXR1cm4gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB3YXJuKCkge1xuICByZXR1cm4gbG9nKHRoaXMuY29udGV4dC5kYXRhZmxvdywgJ3dhcm4nLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gaW5mbygpIHtcbiAgcmV0dXJuIGxvZyh0aGlzLmNvbnRleHQuZGF0YWZsb3csICdpbmZvJywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGRlYnVnKCkge1xuICByZXR1cm4gbG9nKHRoaXMuY29udGV4dC5kYXRhZmxvdywgJ2RlYnVnJywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gY2hhbm5lbF9sdW1pbmFuY2VfdmFsdWUoY2hhbm5lbFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IGNoYW5uZWxWYWx1ZSAvIDI1NTtcblxuICBpZiAodmFsIDw9IDAuMDM5MjgpIHtcbiAgICByZXR1cm4gdmFsIC8gMTIuOTI7XG4gIH1cblxuICByZXR1cm4gTWF0aC5wb3coKHZhbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufVxuXG5mdW5jdGlvbiBsdW1pbmFuY2UoY29sb3IpIHtcbiAgY29uc3QgYyA9IHJnYihjb2xvciksXG4gICAgICAgIHIgPSBjaGFubmVsX2x1bWluYW5jZV92YWx1ZShjLnIpLFxuICAgICAgICBnID0gY2hhbm5lbF9sdW1pbmFuY2VfdmFsdWUoYy5nKSxcbiAgICAgICAgYiA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuYik7XG4gIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XG59IC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG5cbmZ1bmN0aW9uIGNvbnRyYXN0KGNvbG9yMSwgY29sb3IyKSB7XG4gIGNvbnN0IGx1bTEgPSBsdW1pbmFuY2UoY29sb3IxKSxcbiAgICAgICAgbHVtMiA9IGx1bWluYW5jZShjb2xvcjIpLFxuICAgICAgICBsdW1MID0gTWF0aC5tYXgobHVtMSwgbHVtMiksXG4gICAgICAgIGx1bUQgPSBNYXRoLm1pbihsdW0xLCBsdW0yKTtcbiAgcmV0dXJuIChsdW1MICsgMC4wNSkgLyAobHVtRCArIDAuMDUpO1xufVxuXG5mdW5jdGlvbiBtZXJnZSAoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCh7fSk7XG4gIHJldHVybiBleHRlbmQoLi4uYXJncyk7XG59XG5cbmZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSAhPT0gYSAmJiBiICE9PSBiID8gdHJ1ZSA6IGlzQXJyYXkoYSkgPyBpc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCA/IGVxdWFsQXJyYXkoYSwgYikgOiBmYWxzZSA6IGlzT2JqZWN0KGEpICYmIGlzT2JqZWN0KGIpID8gZXF1YWxPYmplY3QoYSwgYikgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZXF1YWxBcnJheShhLCBiKSB7XG4gIGZvciAobGV0IGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZXF1YWxPYmplY3QoYSwgYikge1xuICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVQcmVkaWNhdGUocHJvcHMpIHtcbiAgcmV0dXJuIF8gPT4gZXF1YWxPYmplY3QocHJvcHMsIF8pO1xufVxuXG5mdW5jdGlvbiBtb2RpZnkgKG5hbWUsIGluc2VydCwgcmVtb3ZlLCB0b2dnbGUsIG1vZGlmeSwgdmFsdWVzKSB7XG4gIGNvbnN0IGRmID0gdGhpcy5jb250ZXh0LmRhdGFmbG93LFxuICAgICAgICBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgICAgIGlucHV0ID0gZGF0YS5pbnB1dCxcbiAgICAgICAgc3RhbXAgPSBkZi5zdGFtcCgpO1xuICBsZXQgY2hhbmdlcyA9IGRhdGEuY2hhbmdlcyxcbiAgICAgIHByZWRpY2F0ZSxcbiAgICAgIGtleTtcblxuICBpZiAoZGYuX3RyaWdnZXIgPT09IGZhbHNlIHx8ICEoaW5wdXQudmFsdWUubGVuZ3RoIHx8IGluc2VydCB8fCB0b2dnbGUpKSB7XG4gICAgLy8gbm90aGluZyB0byBkbyFcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmICghY2hhbmdlcyB8fCBjaGFuZ2VzLnN0YW1wIDwgc3RhbXApIHtcbiAgICBkYXRhLmNoYW5nZXMgPSBjaGFuZ2VzID0gZGYuY2hhbmdlc2V0KCk7XG4gICAgY2hhbmdlcy5zdGFtcCA9IHN0YW1wO1xuICAgIGRmLnJ1bkFmdGVyKCgpID0+IHtcbiAgICAgIGRhdGEubW9kaWZpZWQgPSB0cnVlO1xuICAgICAgZGYucHVsc2UoaW5wdXQsIGNoYW5nZXMpLnJ1bigpO1xuICAgIH0sIHRydWUsIDEpO1xuICB9XG5cbiAgaWYgKHJlbW92ZSkge1xuICAgIHByZWRpY2F0ZSA9IHJlbW92ZSA9PT0gdHJ1ZSA/IHRydXRoeSA6IGlzQXJyYXkocmVtb3ZlKSB8fCBpc1R1cGxlKHJlbW92ZSkgPyByZW1vdmUgOiByZW1vdmVQcmVkaWNhdGUocmVtb3ZlKTtcbiAgICBjaGFuZ2VzLnJlbW92ZShwcmVkaWNhdGUpO1xuICB9XG5cbiAgaWYgKGluc2VydCkge1xuICAgIGNoYW5nZXMuaW5zZXJ0KGluc2VydCk7XG4gIH1cblxuICBpZiAodG9nZ2xlKSB7XG4gICAgcHJlZGljYXRlID0gcmVtb3ZlUHJlZGljYXRlKHRvZ2dsZSk7XG5cbiAgICBpZiAoaW5wdXQudmFsdWUuc29tZShwcmVkaWNhdGUpKSB7XG4gICAgICBjaGFuZ2VzLnJlbW92ZShwcmVkaWNhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VzLmluc2VydCh0b2dnbGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtb2RpZnkpIHtcbiAgICBmb3IgKGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIGNoYW5nZXMubW9kaWZ5KG1vZGlmeSwga2V5LCB2YWx1ZXNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIHBpbmNoRGlzdGFuY2UoZXZlbnQpIHtcbiAgY29uc3QgdCA9IGV2ZW50LnRvdWNoZXMsXG4gICAgICAgIGR4ID0gdFswXS5jbGllbnRYIC0gdFsxXS5jbGllbnRYLFxuICAgICAgICBkeSA9IHRbMF0uY2xpZW50WSAtIHRbMV0uY2xpZW50WTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG59XG5mdW5jdGlvbiBwaW5jaEFuZ2xlKGV2ZW50KSB7XG4gIGNvbnN0IHQgPSBldmVudC50b3VjaGVzO1xuICByZXR1cm4gTWF0aC5hdGFuMih0WzBdLmNsaWVudFkgLSB0WzFdLmNsaWVudFksIHRbMF0uY2xpZW50WCAtIHRbMV0uY2xpZW50WCk7XG59XG5cbmNvbnN0IGFjY2Vzc29ycyA9IHt9O1xuZnVuY3Rpb24gcGx1Y2sgKGRhdGEsIG5hbWUpIHtcbiAgY29uc3QgYWNjZXNzb3IgPSBhY2Nlc3NvcnNbbmFtZV0gfHwgKGFjY2Vzc29yc1tuYW1lXSA9IGZpZWxkKG5hbWUpKTtcbiAgcmV0dXJuIGlzQXJyYXkoZGF0YSkgPyBkYXRhLm1hcChhY2Nlc3NvcikgOiBhY2Nlc3NvcihkYXRhKTtcbn1cblxuZnVuY3Rpb24gYXJyYXkoc2VxKSB7XG4gIHJldHVybiBpc0FycmF5KHNlcSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHNlcSkgPyBzZXEgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZShzZXEpIHtcbiAgcmV0dXJuIGFycmF5KHNlcSkgfHwgKGlzU3RyaW5nKHNlcSkgPyBzZXEgOiBudWxsKTtcbn1cblxuZnVuY3Rpb24gam9pbihzZXEsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGFycmF5KHNlcSkuam9pbiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGluZGV4b2Yoc2VxLCAuLi5hcmdzKSB7XG4gIHJldHVybiBzZXF1ZW5jZShzZXEpLmluZGV4T2YoLi4uYXJncyk7XG59XG5mdW5jdGlvbiBsYXN0aW5kZXhvZihzZXEsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHNlcSkubGFzdEluZGV4T2YoLi4uYXJncyk7XG59XG5mdW5jdGlvbiBzbGljZShzZXEsIC4uLmFyZ3MpIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHNlcSkuc2xpY2UoLi4uYXJncyk7XG59XG5mdW5jdGlvbiByZXBsYWNlKHN0ciwgcGF0dGVybiwgcmVwbCkge1xuICBpZiAoaXNGdW5jdGlvbihyZXBsKSkgZXJyb3IoJ0Z1bmN0aW9uIGFyZ3VtZW50IHBhc3NlZCB0byByZXBsYWNlLicpO1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShwYXR0ZXJuLCByZXBsKTtcbn1cbmZ1bmN0aW9uIHJldmVyc2Uoc2VxKSB7XG4gIHJldHVybiBhcnJheShzZXEpLnNsaWNlKCkucmV2ZXJzZSgpO1xufVxuXG5mdW5jdGlvbiBiYW5kc3BhY2UoY291bnQsIHBhZGRpbmdJbm5lciwgcGFkZGluZ091dGVyKSB7XG4gIHJldHVybiBiYW5kU3BhY2UoY291bnQgfHwgMCwgcGFkZGluZ0lubmVyIHx8IDAsIHBhZGRpbmdPdXRlciB8fCAwKTtcbn1cbmZ1bmN0aW9uIGJhbmR3aWR0aChuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyAmJiBzLmJhbmR3aWR0aCA/IHMuYmFuZHdpZHRoKCkgOiAwO1xufVxuZnVuY3Rpb24gY29weShuYW1lLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyA/IHMuY29weSgpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZG9tYWluKG5hbWUsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBzID8gcy5kb21haW4oKSA6IFtdO1xufVxuZnVuY3Rpb24gaW52ZXJ0KG5hbWUsIHJhbmdlLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gIXMgPyB1bmRlZmluZWQgOiBpc0FycmF5KHJhbmdlKSA/IChzLmludmVydFJhbmdlIHx8IHMuaW52ZXJ0KShyYW5nZSkgOiAocy5pbnZlcnQgfHwgcy5pbnZlcnRFeHRlbnQpKHJhbmdlKTtcbn1cbmZ1bmN0aW9uIHJhbmdlKG5hbWUsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBzICYmIHMucmFuZ2UgPyBzLnJhbmdlKCkgOiBbXTtcbn1cbmZ1bmN0aW9uIHNjYWxlKG5hbWUsIHZhbHVlLCBncm91cCkge1xuICBjb25zdCBzID0gZ2V0U2NhbGUobmFtZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICByZXR1cm4gcyA/IHModmFsdWUpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzY2FsZUdyYWRpZW50IChzY2FsZSwgcDAsIHAxLCBjb3VudCwgZ3JvdXApIHtcbiAgc2NhbGUgPSBnZXRTY2FsZShzY2FsZSwgKGdyb3VwIHx8IHRoaXMpLmNvbnRleHQpO1xuICBjb25zdCBncmFkaWVudCA9IEdyYWRpZW50KHAwLCBwMSk7XG4gIGxldCBzdG9wcyA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgbWluID0gc3RvcHNbMF0sXG4gICAgICBtYXggPSBwZWVrKHN0b3BzKSxcbiAgICAgIGZyYWN0aW9uID0gaWRlbnRpdHk7XG5cbiAgaWYgKCEobWF4IC0gbWluKSkge1xuICAgIC8vIGV4cGFuZCBzY2FsZSBpZiBkb21haW4gaGFzIHplcm8gc3BhbiwgZml4ICMxNDc5XG4gICAgc2NhbGUgPSAoc2NhbGUuaW50ZXJwb2xhdG9yID8gc2NhbGUkMSgnc2VxdWVudGlhbCcpKCkuaW50ZXJwb2xhdG9yKHNjYWxlLmludGVycG9sYXRvcigpKSA6IHNjYWxlJDEoJ2xpbmVhcicpKCkuaW50ZXJwb2xhdGUoc2NhbGUuaW50ZXJwb2xhdGUoKSkucmFuZ2Uoc2NhbGUucmFuZ2UoKSkpLmRvbWFpbihbbWluID0gMCwgbWF4ID0gMV0pO1xuICB9IGVsc2Uge1xuICAgIGZyYWN0aW9uID0gc2NhbGVGcmFjdGlvbihzY2FsZSwgbWluLCBtYXgpO1xuICB9XG5cbiAgaWYgKHNjYWxlLnRpY2tzKSB7XG4gICAgc3RvcHMgPSBzY2FsZS50aWNrcygrY291bnQgfHwgMTUpO1xuICAgIGlmIChtaW4gIT09IHN0b3BzWzBdKSBzdG9wcy51bnNoaWZ0KG1pbik7XG4gICAgaWYgKG1heCAhPT0gcGVlayhzdG9wcykpIHN0b3BzLnB1c2gobWF4KTtcbiAgfVxuXG4gIHN0b3BzLmZvckVhY2goXyA9PiBncmFkaWVudC5zdG9wKGZyYWN0aW9uKF8pLCBzY2FsZShfKSkpO1xuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGdlb1NoYXBlKHByb2plY3Rpb24sIGdlb2pzb24sIGdyb3VwKSB7XG4gIGNvbnN0IHAgPSBnZXRTY2FsZShwcm9qZWN0aW9uLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHJldHVybiBwID8gcC5wYXRoLmNvbnRleHQoY29udGV4dCkoZ2VvanNvbikgOiAnJztcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhTaGFwZShwYXRoKSB7XG4gIGxldCBwID0gbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgPyBwYXRoUmVuZGVyKGNvbnRleHQsIHAgPSBwIHx8IHBhdGhQYXJzZShwYXRoKSkgOiBwYXRoO1xuICB9O1xufVxuXG5jb25zdCBkYXR1bSA9IGQgPT4gZC5kYXRhO1xuXG5mdW5jdGlvbiB0cmVlTm9kZXMobmFtZSwgY29udGV4dCkge1xuICBjb25zdCB0cmVlID0gZGF0YS5jYWxsKGNvbnRleHQsIG5hbWUpO1xuICByZXR1cm4gdHJlZS5yb290ICYmIHRyZWUucm9vdC5sb29rdXAgfHwge307XG59XG5cbmZ1bmN0aW9uIHRyZWVQYXRoKG5hbWUsIHNvdXJjZSwgdGFyZ2V0KSB7XG4gIGNvbnN0IG5vZGVzID0gdHJlZU5vZGVzKG5hbWUsIHRoaXMpLFxuICAgICAgICBzID0gbm9kZXNbc291cmNlXSxcbiAgICAgICAgdCA9IG5vZGVzW3RhcmdldF07XG4gIHJldHVybiBzICYmIHQgPyBzLnBhdGgodCkubWFwKGRhdHVtKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRyZWVBbmNlc3RvcnMobmFtZSwgbm9kZSkge1xuICBjb25zdCBuID0gdHJlZU5vZGVzKG5hbWUsIHRoaXMpW25vZGVdO1xuICByZXR1cm4gbiA/IG4uYW5jZXN0b3JzKCkubWFwKGRhdHVtKSA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgX3dpbmRvdyA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyB8fCBudWxsO1xuXG5mdW5jdGlvbiBzY3JlZW4oKSB7XG4gIGNvbnN0IHcgPSBfd2luZG93KCk7XG5cbiAgcmV0dXJuIHcgPyB3LnNjcmVlbiA6IHt9O1xufVxuZnVuY3Rpb24gd2luZG93U2l6ZSgpIHtcbiAgY29uc3QgdyA9IF93aW5kb3coKTtcblxuICByZXR1cm4gdyA/IFt3LmlubmVyV2lkdGgsIHcuaW5uZXJIZWlnaHRdIDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5lclNpemUoKSB7XG4gIGNvbnN0IHZpZXcgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3csXG4gICAgICAgIGVsID0gdmlldy5jb250YWluZXIgJiYgdmlldy5jb250YWluZXIoKTtcbiAgcmV0dXJuIGVsID8gW2VsLmNsaWVudFdpZHRoLCBlbC5jbGllbnRIZWlnaHRdIDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0IChiLCBvcHQsIGdyb3VwKSB7XG4gIGlmICghYikgcmV0dXJuIFtdO1xuICBjb25zdCBbdSwgdl0gPSBiLFxuICAgICAgICBib3ggPSBuZXcgQm91bmRzKCkuc2V0KHVbMF0sIHVbMV0sIHZbMF0sIHZbMV0pLFxuICAgICAgICBzY2VuZSA9IGdyb3VwIHx8IHRoaXMuY29udGV4dC5kYXRhZmxvdy5zY2VuZWdyYXBoKCkucm9vdDtcbiAgcmV0dXJuIGludGVyc2VjdCQxKHNjZW5lLCBib3gsIGZpbHRlcihvcHQpKTtcbn1cblxuZnVuY3Rpb24gZmlsdGVyKG9wdCkge1xuICBsZXQgcCA9IG51bGw7XG5cbiAgaWYgKG9wdCkge1xuICAgIGNvbnN0IHR5cGVzID0gYXJyYXkkMShvcHQubWFya3R5cGUpLFxuICAgICAgICAgIG5hbWVzID0gYXJyYXkkMShvcHQubWFya25hbWUpO1xuXG4gICAgcCA9IF8gPT4gKCF0eXBlcy5sZW5ndGggfHwgdHlwZXMuc29tZSh0ID0+IF8ubWFya3R5cGUgPT09IHQpKSAmJiAoIW5hbWVzLmxlbmd0aCB8fCBuYW1lcy5zb21lKHMgPT4gXy5uYW1lID09PSBzKSk7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuY29uc3QgZnVuY3Rpb25Db250ZXh0ID0ge1xuICByYW5kb20oKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpO1xuICB9LFxuXG4gIC8vIG92ZXJyaWRlIGRlZmF1bHRcbiAgY3VtdWxhdGl2ZU5vcm1hbCxcbiAgY3VtdWxhdGl2ZUxvZ05vcm1hbCxcbiAgY3VtdWxhdGl2ZVVuaWZvcm0sXG4gIGRlbnNpdHlOb3JtYWwsXG4gIGRlbnNpdHlMb2dOb3JtYWwsXG4gIGRlbnNpdHlVbmlmb3JtLFxuICBxdWFudGlsZU5vcm1hbCxcbiAgcXVhbnRpbGVMb2dOb3JtYWwsXG4gIHF1YW50aWxlVW5pZm9ybSxcbiAgc2FtcGxlTm9ybWFsLFxuICBzYW1wbGVMb2dOb3JtYWwsXG4gIHNhbXBsZVVuaWZvcm0sXG4gIGlzQXJyYXksXG4gIGlzQm9vbGVhbixcbiAgaXNEYXRlLFxuXG4gIGlzRGVmaW5lZChfKSB7XG4gICAgcmV0dXJuIF8gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBpc051bWJlcixcbiAgaXNPYmplY3QsXG4gIGlzUmVnRXhwLFxuICBpc1N0cmluZyxcbiAgaXNUdXBsZSxcblxuICBpc1ZhbGlkKF8pIHtcbiAgICByZXR1cm4gXyAhPSBudWxsICYmIF8gPT09IF87XG4gIH0sXG5cbiAgdG9Cb29sZWFuLFxuICB0b0RhdGUsXG4gIHRvTnVtYmVyLFxuICB0b1N0cmluZyxcbiAgaW5kZXhvZixcbiAgam9pbixcbiAgbGFzdGluZGV4b2YsXG4gIHJlcGxhY2UsXG4gIHJldmVyc2UsXG4gIHNsaWNlLFxuICBmbHVzaCxcbiAgbGVycCxcbiAgbWVyZ2UsXG4gIHBhZCxcbiAgcGVlayxcbiAgcGx1Y2ssXG4gIHNwYW4sXG4gIGlucmFuZ2UsXG4gIHRydW5jYXRlLFxuICByZ2IsXG4gIGxhYixcbiAgaGNsLFxuICBoc2wsXG4gIGx1bWluYW5jZSxcbiAgY29udHJhc3QsXG4gIHNlcXVlbmNlOiByYW5nZSQxLFxuICBmb3JtYXQsXG4gIHV0Y0Zvcm1hdCxcbiAgdXRjUGFyc2UsXG4gIHV0Y09mZnNldCxcbiAgdXRjU2VxdWVuY2UsXG4gIHRpbWVGb3JtYXQsXG4gIHRpbWVQYXJzZSxcbiAgdGltZU9mZnNldCxcbiAgdGltZVNlcXVlbmNlLFxuICB0aW1lVW5pdFNwZWNpZmllcixcbiAgbW9udGhGb3JtYXQsXG4gIG1vbnRoQWJicmV2Rm9ybWF0LFxuICBkYXlGb3JtYXQsXG4gIGRheUFiYnJldkZvcm1hdCxcbiAgcXVhcnRlcixcbiAgdXRjcXVhcnRlcixcbiAgd2VlayxcbiAgdXRjd2VlayxcbiAgZGF5b2Z5ZWFyLFxuICB1dGNkYXlvZnllYXIsXG4gIHdhcm4sXG4gIGluZm8sXG4gIGRlYnVnLFxuICBleHRlbnQsXG4gIGluU2NvcGUsXG4gIGludGVyc2VjdCxcbiAgY2xhbXBSYW5nZSxcbiAgcGluY2hEaXN0YW5jZSxcbiAgcGluY2hBbmdsZSxcbiAgc2NyZWVuLFxuICBjb250YWluZXJTaXplLFxuICB3aW5kb3dTaXplLFxuICBiYW5kc3BhY2UsXG4gIHNldGRhdGEsXG4gIHBhdGhTaGFwZSxcbiAgcGFuTGluZWFyLFxuICBwYW5Mb2csXG4gIHBhblBvdyxcbiAgcGFuU3ltbG9nLFxuICB6b29tTGluZWFyLFxuICB6b29tTG9nLFxuICB6b29tUG93LFxuICB6b29tU3ltbG9nLFxuICBlbmNvZGUsXG4gIG1vZGlmeVxufTtcbmNvbnN0IGV2ZW50RnVuY3Rpb25zID0gWyd2aWV3JywgJ2l0ZW0nLCAnZ3JvdXAnLCAneHknLCAneCcsICd5J10sXG4gICAgICAvLyBldmVudCBmdW5jdGlvbnNcbmV2ZW50UHJlZml4ID0gJ2V2ZW50LnZlZ2EuJyxcbiAgICAgIC8vIGV2ZW50IGZ1bmN0aW9uIHByZWZpeFxudGhpc1ByZWZpeCA9ICd0aGlzLicsXG4gICAgICAvLyBmdW5jdGlvbiBjb250ZXh0IHByZWZpeFxuYXN0VmlzaXRvcnMgPSB7fTsgLy8gQVNUIHZpc2l0b3JzIGZvciBkZXBlbmRlbmN5IGFuYWx5c2lzXG4vLyBleHBvcnQgY29kZSBnZW5lcmF0b3IgcGFyYW1ldGVyc1xuXG5jb25zdCBjb2RlZ2VuUGFyYW1zID0ge1xuICBmb3JiaWRkZW46IFsnXyddLFxuICBhbGxvd2VkOiBbJ2RhdHVtJywgJ2V2ZW50JywgJ2l0ZW0nXSxcbiAgZmllbGR2YXI6ICdkYXR1bScsXG4gIGdsb2JhbHZhcjogaWQgPT4gYF9bJHtzdHJpbmdWYWx1ZShTaWduYWxQcmVmaXggKyBpZCl9XWAsXG4gIGZ1bmN0aW9uczogYnVpbGRGdW5jdGlvbnMsXG4gIGNvbnN0YW50czogY29uc3RhbnRzLFxuICB2aXNpdG9yczogYXN0VmlzaXRvcnNcbn07IC8vIGV4cG9ydCBjb2RlIGdlbmVyYXRvclxuXG5jb25zdCBjb2RlR2VuZXJhdG9yID0gY29kZWdlbkV4cHJlc3Npb24oY29kZWdlblBhcmFtcyk7IC8vIEJ1aWxkIGV4cHJlc3Npb24gZnVuY3Rpb24gcmVnaXN0cnlcblxuZnVuY3Rpb24gYnVpbGRGdW5jdGlvbnMoY29kZWdlbikge1xuICBjb25zdCBmbiA9IGZ1bmN0aW9ucyhjb2RlZ2VuKTtcbiAgZXZlbnRGdW5jdGlvbnMuZm9yRWFjaChuYW1lID0+IGZuW25hbWVdID0gZXZlbnRQcmVmaXggKyBuYW1lKTtcblxuICBmb3IgKGNvbnN0IG5hbWUgaW4gZnVuY3Rpb25Db250ZXh0KSB7XG4gICAgZm5bbmFtZV0gPSB0aGlzUHJlZml4ICsgbmFtZTtcbiAgfVxuXG4gIGV4dGVuZChmbiwgaW50ZXJuYWxTY2FsZUZ1bmN0aW9ucyhjb2RlZ2VuLCBmdW5jdGlvbkNvbnRleHQsIGFzdFZpc2l0b3JzKSk7XG4gIHJldHVybiBmbjtcbn0gLy8gUmVnaXN0ZXIgYW4gZXhwcmVzc2lvbiBmdW5jdGlvblxuXG5cbmZ1bmN0aW9uIGV4cHJlc3Npb25GdW5jdGlvbihuYW1lLCBmbiwgdmlzaXRvcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jdGlvbkNvbnRleHRbbmFtZV07XG4gIH0gLy8gcmVnaXN0ZXIgd2l0aCB0aGUgZnVuY3Rpb25Db250ZXh0XG5cblxuICBmdW5jdGlvbkNvbnRleHRbbmFtZV0gPSBmbjsgLy8gaWYgdGhlcmUgaXMgYW4gYXN0VmlzaXRvciByZWdpc3RlciB0aGF0LCB0b29cblxuICBpZiAodmlzaXRvcikgYXN0VmlzaXRvcnNbbmFtZV0gPSB2aXNpdG9yOyAvLyBpZiB0aGUgY29kZSBnZW5lcmF0b3IgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZCxcbiAgLy8gd2UgbmVlZCB0byBhbHNvIHJlZ2lzdGVyIHRoZSBmdW5jdGlvbiB3aXRoIGl0XG5cbiAgaWYgKGNvZGVHZW5lcmF0b3IpIGNvZGVHZW5lcmF0b3IuZnVuY3Rpb25zW25hbWVdID0gdGhpc1ByZWZpeCArIG5hbWU7XG4gIHJldHVybiB0aGlzO1xufSAvLyByZWdpc3RlciBleHByZXNzaW9uIGZ1bmN0aW9ucyB3aXRoIGFzdCB2aXNpdG9yc1xuXG5leHByZXNzaW9uRnVuY3Rpb24oJ2JhbmR3aWR0aCcsIGJhbmR3aWR0aCwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignY29weScsIGNvcHksIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2RvbWFpbicsIGRvbWFpbiwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigncmFuZ2UnLCByYW5nZSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignaW52ZXJ0JywgaW52ZXJ0LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdzY2FsZScsIHNjYWxlLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdncmFkaWVudCcsIHNjYWxlR3JhZGllbnQsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2dlb0FyZWEnLCBnZW9BcmVhLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9Cb3VuZHMnLCBnZW9Cb3VuZHMsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2dlb0NlbnRyb2lkJywgZ2VvQ2VudHJvaWQsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2dlb1NoYXBlJywgZ2VvU2hhcGUsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2luZGF0YScsIGluZGF0YSwgaW5kYXRhVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2RhdGEnLCBkYXRhLCBkYXRhVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3RyZWVQYXRoJywgdHJlZVBhdGgsIGRhdGFWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigndHJlZUFuY2VzdG9ycycsIHRyZWVBbmNlc3RvcnMsIGRhdGFWaXNpdG9yKTsgLy8gcmVnaXN0ZXIgVmVnYS1MaXRlIHNlbGVjdGlvbiBmdW5jdGlvbnNcblxuZXhwcmVzc2lvbkZ1bmN0aW9uKCd2bFNlbGVjdGlvblRlc3QnLCBzZWxlY3Rpb25UZXN0LCBzZWxlY3Rpb25WaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25JZFRlc3QnLCBzZWxlY3Rpb25JZFRlc3QsIHNlbGVjdGlvblZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd2bFNlbGVjdGlvblJlc29sdmUnLCBzZWxlY3Rpb25SZXNvbHZlLCBzZWxlY3Rpb25WaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbigndmxTZWxlY3Rpb25UdXBsZXMnLCBzZWxlY3Rpb25UdXBsZXMpO1xuXG5mdW5jdGlvbiBwYXJzZXIgKGV4cHIsIHNjb3BlKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHt9OyAvLyBwYXJzZSB0aGUgZXhwcmVzc2lvbiB0byBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSAoYXN0KVxuXG4gIGxldCBhc3Q7XG5cbiAgdHJ5IHtcbiAgICBleHByID0gaXNTdHJpbmcoZXhwcikgPyBleHByIDogc3RyaW5nVmFsdWUoZXhwcikgKyAnJztcbiAgICBhc3QgPSBwYXJzZUV4cHJlc3Npb24oZXhwcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKCdFeHByZXNzaW9uIHBhcnNlIGVycm9yOiAnICsgZXhwcik7XG4gIH0gLy8gYW5hbHl6ZSBhc3QgZnVuY3Rpb24gY2FsbHMgZm9yIGRlcGVuZGVuY2llc1xuXG5cbiAgYXN0LnZpc2l0KG5vZGUgPT4ge1xuICAgIGlmIChub2RlLnR5cGUgIT09IENhbGxFeHByZXNzaW9uKSByZXR1cm47XG4gICAgY29uc3QgbmFtZSA9IG5vZGUuY2FsbGVlLm5hbWUsXG4gICAgICAgICAgdmlzaXQgPSBjb2RlZ2VuUGFyYW1zLnZpc2l0b3JzW25hbWVdO1xuICAgIGlmICh2aXNpdCkgdmlzaXQobmFtZSwgbm9kZS5hcmd1bWVudHMsIHNjb3BlLCBwYXJhbXMpO1xuICB9KTsgLy8gcGVyZm9ybSBjb2RlIGdlbmVyYXRpb25cblxuICBjb25zdCBnZW4gPSBjb2RlR2VuZXJhdG9yKGFzdCk7IC8vIGNvbGxlY3Qgc2lnbmFsIGRlcGVuZGVuY2llc1xuXG4gIGdlbi5nbG9iYWxzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3Qgc2lnbmFsTmFtZSA9IFNpZ25hbFByZWZpeCArIG5hbWU7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KHBhcmFtcywgc2lnbmFsTmFtZSkgJiYgc2NvcGUuZ2V0U2lnbmFsKG5hbWUpKSB7XG4gICAgICBwYXJhbXNbc2lnbmFsTmFtZV0gPSBzY29wZS5zaWduYWxSZWYobmFtZSk7XG4gICAgfVxuICB9KTsgLy8gcmV0dXJuIGdlbmVyYXRlZCBleHByZXNzaW9uIGNvZGUgYW5kIGRlcGVuZGVuY2llc1xuXG4gIHJldHVybiB7XG4gICAgJGV4cHI6IGV4dGVuZCh7XG4gICAgICBjb2RlOiBnZW4uY29kZVxuICAgIH0sIHNjb3BlLm9wdGlvbnMuYXN0ID8ge1xuICAgICAgYXN0XG4gICAgfSA6IG51bGwpLFxuICAgICRmaWVsZHM6IGdlbi5maWVsZHMsXG4gICAgJHBhcmFtczogcGFyYW1zXG4gIH07XG59XG5cbmV4cG9ydCB7IERhdGFQcmVmaXgsIEluZGV4UHJlZml4LCBTY2FsZVByZWZpeCwgU2lnbmFsUHJlZml4LCBiYW5kc3BhY2UsIGJhbmR3aWR0aCwgY29kZUdlbmVyYXRvciwgY29kZWdlblBhcmFtcywgY29udGFpbmVyU2l6ZSwgY29udHJhc3QsIGNvcHksIGRhdGEsIGRhdGFWaXNpdG9yLCBkYXlBYmJyZXZGb3JtYXQsIGRheUZvcm1hdCwgZGVidWcsIGRvbWFpbiwgZW5jb2RlLCBleHByZXNzaW9uRnVuY3Rpb24sIGZvcm1hdCwgZnVuY3Rpb25Db250ZXh0LCBnZW9BcmVhLCBnZW9Cb3VuZHMsIGdlb0NlbnRyb2lkLCBnZW9TaGFwZSwgaW5TY29wZSwgaW5kYXRhLCBpbmRhdGFWaXNpdG9yLCBpbmRleG9mLCBpbmZvLCBpbnZlcnQsIGpvaW4sIGxhc3RpbmRleG9mLCBsdW1pbmFuY2UsIG1lcmdlLCBtb2RpZnksIG1vbnRoQWJicmV2Rm9ybWF0LCBtb250aEZvcm1hdCwgcGFyc2VyIGFzIHBhcnNlRXhwcmVzc2lvbiwgcGF0aFNoYXBlLCBwaW5jaEFuZ2xlLCBwaW5jaERpc3RhbmNlLCBwbHVjaywgcmFuZ2UsIHJlcGxhY2UsIHJldmVyc2UsIHNjYWxlLCBzY2FsZUdyYWRpZW50LCBzY2FsZVZpc2l0b3IsIHNjcmVlbiwgc2V0ZGF0YSwgc2xpY2UsIHRpbWVGb3JtYXQsIHRpbWVQYXJzZSwgdHJlZUFuY2VzdG9ycywgdHJlZVBhdGgsIHV0Y0Zvcm1hdCwgdXRjUGFyc2UsIHdhcm4sIHdpbmRvd1NpemUgfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSwgcmVkZXJpdmUsIGluZ2VzdCwgcmVwbGFjZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgZXJyb3IsIGV4dGVudCwgaW5oZXJpdHMsIGlkZW50aXR5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgY29uc3RhbnQsIGFycmF5LCBvbmUsIGFjY2Vzc29yTmFtZSwgYWNjZXNzb3JGaWVsZHMsIGZpZWxkLCBleHRlbmQsIHRvU2V0LCB6ZXJvIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHJhbmdlLCB0aWNrU3RlcCwgbWF4LCBzdW0gfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBiYW5kd2lkdGhOUkQgfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHsgZ2V0UHJvamVjdGlvblBhdGgsIHByb2plY3Rpb25Qcm9wZXJ0aWVzLCBwcm9qZWN0aW9uIH0gZnJvbSAndmVnYS1wcm9qZWN0aW9uJztcbmltcG9ydCB7IGdlb0dyYXRpY3VsZSB9IGZyb20gJ2QzLWdlbyc7XG5pbXBvcnQgeyByZ2IgfSBmcm9tICdkMy1jb2xvcic7XG5pbXBvcnQgeyBjYW52YXMgfSBmcm9tICd2ZWdhLWNhbnZhcyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5jb25zdCBjYXNlcyA9IFtbXSwgW1tbMS4wLCAxLjVdLCBbMC41LCAxLjBdXV0sIFtbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLCBbW1sxLjUsIDEuMF0sIFswLjUsIDEuMF1dXSwgW1tbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV0sIFtbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMC41XSwgWzEuMCwgMS41XV1dLCBbW1sxLjAsIDAuNV0sIFswLjUsIDEuMF1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXV0sIFtbWzEuMCwgMS41XSwgWzEuMCwgMC41XV1dLCBbW1swLjUsIDEuMF0sIFsxLjAsIDAuNV1dLCBbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLCBbW1sxLjUsIDEuMF0sIFsxLjAsIDAuNV1dXSwgW1tbMC41LCAxLjBdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMS41XSwgWzEuNSwgMS4wXV1dLCBbW1swLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW11dOyAvLyBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gZDMvZDMtY29udG91ci4gVGhhbmtzIVxuXG5mdW5jdGlvbiBjb250b3VycyAoKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICBzbW9vdGggPSBzbW9vdGhMaW5lYXI7XG5cbiAgZnVuY3Rpb24gY29udG91cnModmFsdWVzLCB0eikge1xuICAgIHJldHVybiB0ei5tYXAodmFsdWUgPT4gY29udG91cih2YWx1ZXMsIHZhbHVlKSk7XG4gIH0gLy8gQWNjdW11bGF0ZSwgc21vb3RoIGNvbnRvdXIgcmluZ3MsIGFzc2lnbiBob2xlcyB0byBleHRlcmlvciByaW5ncy5cbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL3NoYXBlZmlsZS9ibG9iL3YwLjYuMi9zaHAvcG9seWdvbi5qc1xuXG5cbiAgZnVuY3Rpb24gY29udG91cih2YWx1ZXMsIHZhbHVlKSB7XG4gICAgdmFyIHBvbHlnb25zID0gW10sXG4gICAgICAgIGhvbGVzID0gW107XG4gICAgaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgcmluZyA9PiB7XG4gICAgICBzbW9vdGgocmluZywgdmFsdWVzLCB2YWx1ZSk7XG4gICAgICBpZiAoYXJlYShyaW5nKSA+IDApIHBvbHlnb25zLnB1c2goW3JpbmddKTtlbHNlIGhvbGVzLnB1c2gocmluZyk7XG4gICAgfSk7XG4gICAgaG9sZXMuZm9yRWFjaChob2xlID0+IHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoLCBwb2x5Z29uOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChjb250YWlucygocG9seWdvbiA9IHBvbHlnb25zW2ldKVswXSwgaG9sZSkgIT09IC0xKSB7XG4gICAgICAgICAgcG9seWdvbi5wdXNoKGhvbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uc1xuICAgIH07XG4gIH0gLy8gTWFyY2hpbmcgc3F1YXJlcyB3aXRoIGlzb2xpbmVzIHN0aXRjaGVkIGludG8gcmluZ3MuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90b3BvanNvbi90b3BvanNvbi1jbGllbnQvYmxvYi92My4wLjAvc3JjL3N0aXRjaC5qc1xuXG5cbiAgZnVuY3Rpb24gaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnJhZ21lbnRCeVN0YXJ0ID0gbmV3IEFycmF5KCksXG4gICAgICAgIGZyYWdtZW50QnlFbmQgPSBuZXcgQXJyYXkoKSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgdDAsXG4gICAgICAgIHQxLFxuICAgICAgICB0MixcbiAgICAgICAgdDM7IC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGZpcnN0IHJvdyAoeSA9IC0xLCB0MiA9IHQzID0gMCkuXG5cbiAgICB4ID0geSA9IC0xO1xuICAgIHQxID0gdmFsdWVzWzBdID49IHZhbHVlO1xuICAgIGNhc2VzW3QxIDw8IDFdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgIHQwID0gdDEsIHQxID0gdmFsdWVzW3ggKyAxXSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QwIHwgdDEgPDwgMV0uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cblxuICAgIGNhc2VzW3QxIDw8IDBdLmZvckVhY2goc3RpdGNoKTsgLy8gR2VuZXJhbCBjYXNlIGZvciB0aGUgaW50ZXJtZWRpYXRlIHJvd3MuXG5cbiAgICB3aGlsZSAoKyt5IDwgZHkgLSAxKSB7XG4gICAgICB4ID0gLTE7XG4gICAgICB0MSA9IHZhbHVlc1t5ICogZHggKyBkeF0gPj0gdmFsdWU7XG4gICAgICB0MiA9IHZhbHVlc1t5ICogZHhdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDEgPDwgMSB8IHQyIDw8IDJdLmZvckVhY2goc3RpdGNoKTtcblxuICAgICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t5ICogZHggKyBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgdDMgPSB0MiwgdDIgPSB2YWx1ZXNbeSAqIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgICBjYXNlc1t0MCB8IHQxIDw8IDEgfCB0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgICAgfVxuXG4gICAgICBjYXNlc1t0MSB8IHQyIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9IC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3Qgcm93ICh5ID0gZHkgLSAxLCB0MCA9IHQxID0gMCkuXG5cblxuICAgIHggPSAtMTtcbiAgICB0MiA9IHZhbHVlc1t5ICogZHhdID49IHZhbHVlO1xuICAgIGNhc2VzW3QyIDw8IDJdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QyIDw8IDIgfCB0MyA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuXG4gICAgY2FzZXNbdDIgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuXG4gICAgZnVuY3Rpb24gc3RpdGNoKGxpbmUpIHtcbiAgICAgIHZhciBzdGFydCA9IFtsaW5lWzBdWzBdICsgeCwgbGluZVswXVsxXSArIHldLFxuICAgICAgICAgIGVuZCA9IFtsaW5lWzFdWzBdICsgeCwgbGluZVsxXVsxXSArIHldLFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleChzdGFydCksXG4gICAgICAgICAgZW5kSW5kZXggPSBpbmRleChlbmQpLFxuICAgICAgICAgIGYsXG4gICAgICAgICAgZztcblxuICAgICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0SW5kZXhdKSB7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZEluZGV4XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuXG4gICAgICAgICAgaWYgKGYgPT09IGcpIHtcbiAgICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhmLnJpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2cuZW5kXSA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGYuc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogZy5lbmQsXG4gICAgICAgICAgICAgIHJpbmc6IGYucmluZy5jb25jYXQoZy5yaW5nKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgICAgIGYucmluZy5wdXNoKGVuZCk7XG4gICAgICAgICAgZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZEluZGV4XSA9IGY7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0SW5kZXhdKSB7XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG5cbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGYucmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0ge1xuICAgICAgICAgICAgICBzdGFydDogZy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBmLmVuZCxcbiAgICAgICAgICAgICAgcmluZzogZy5yaW5nLmNvbmNhdChmLnJpbmcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICAgIGYucmluZy51bnNoaWZ0KHN0YXJ0KTtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0SW5kZXhdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0SW5kZXhdID0gZnJhZ21lbnRCeUVuZFtlbmRJbmRleF0gPSB7XG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kOiBlbmRJbmRleCxcbiAgICAgICAgICByaW5nOiBbc3RhcnQsIGVuZF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleChwb2ludCkge1xuICAgIHJldHVybiBwb2ludFswXSAqIDIgKyBwb2ludFsxXSAqIChkeCArIDEpICogNDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNtb290aExpbmVhcihyaW5nLCB2YWx1ZXMsIHZhbHVlKSB7XG4gICAgcmluZy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgIHZhciB4ID0gcG9pbnRbMF0sXG4gICAgICAgICAgeSA9IHBvaW50WzFdLFxuICAgICAgICAgIHh0ID0geCB8IDAsXG4gICAgICAgICAgeXQgPSB5IHwgMCxcbiAgICAgICAgICB2MCxcbiAgICAgICAgICB2MSA9IHZhbHVlc1t5dCAqIGR4ICsgeHRdO1xuXG4gICAgICBpZiAoeCA+IDAgJiYgeCA8IGR4ICYmIHh0ID09PSB4KSB7XG4gICAgICAgIHYwID0gdmFsdWVzW3l0ICogZHggKyB4dCAtIDFdO1xuICAgICAgICBwb2ludFswXSA9IHggKyAodmFsdWUgLSB2MCkgLyAodjEgLSB2MCkgLSAwLjU7XG4gICAgICB9XG5cbiAgICAgIGlmICh5ID4gMCAmJiB5IDwgZHkgJiYgeXQgPT09IHkpIHtcbiAgICAgICAgdjAgPSB2YWx1ZXNbKHl0IC0gMSkgKiBkeCArIHh0XTtcbiAgICAgICAgcG9pbnRbMV0gPSB5ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29udG91cnMuY29udG91ciA9IGNvbnRvdXI7XG5cbiAgY29udG91cnMuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gW2R4LCBkeV07XG5cbiAgICB2YXIgXzAgPSBNYXRoLmZsb29yKF9bMF0pLFxuICAgICAgICBfMSA9IE1hdGguZmxvb3IoX1sxXSk7XG5cbiAgICBpZiAoIShfMCA+PSAwICYmIF8xID49IDApKSBlcnJvcignaW52YWxpZCBzaXplJyk7XG4gICAgcmV0dXJuIGR4ID0gXzAsIGR5ID0gXzEsIGNvbnRvdXJzO1xuICB9O1xuXG4gIGNvbnRvdXJzLnNtb290aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc21vb3RoID0gXyA/IHNtb290aExpbmVhciA6IG5vb3AsIGNvbnRvdXJzKSA6IHNtb290aCA9PT0gc21vb3RoTGluZWFyO1xuICB9O1xuXG4gIHJldHVybiBjb250b3Vycztcbn1cblxuZnVuY3Rpb24gYXJlYShyaW5nKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICAgIGFyZWEgPSByaW5nW24gLSAxXVsxXSAqIHJpbmdbMF1bMF0gLSByaW5nW24gLSAxXVswXSAqIHJpbmdbMF1bMV07XG5cbiAgd2hpbGUgKCsraSA8IG4pIGFyZWEgKz0gcmluZ1tpIC0gMV1bMV0gKiByaW5nW2ldWzBdIC0gcmluZ1tpIC0gMV1bMF0gKiByaW5nW2ldWzFdO1xuXG4gIHJldHVybiBhcmVhO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyhyaW5nLCBob2xlKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gaG9sZS5sZW5ndGgsXG4gICAgICBjO1xuXG4gIHdoaWxlICgrK2kgPCBuKSBpZiAoYyA9IHJpbmdDb250YWlucyhyaW5nLCBob2xlW2ldKSkgcmV0dXJuIGM7XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIHJpbmdDb250YWlucyhyaW5nLCBwb2ludCkge1xuICB2YXIgeCA9IHBvaW50WzBdLFxuICAgICAgeSA9IHBvaW50WzFdLFxuICAgICAgY29udGFpbnMgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBqID0gbiAtIDE7IGkgPCBuOyBqID0gaSsrKSB7XG4gICAgdmFyIHBpID0gcmluZ1tpXSxcbiAgICAgICAgeGkgPSBwaVswXSxcbiAgICAgICAgeWkgPSBwaVsxXSxcbiAgICAgICAgcGogPSByaW5nW2pdLFxuICAgICAgICB4aiA9IHBqWzBdLFxuICAgICAgICB5aiA9IHBqWzFdO1xuICAgIGlmIChzZWdtZW50Q29udGFpbnMocGksIHBqLCBwb2ludCkpIHJldHVybiAwO1xuICAgIGlmICh5aSA+IHkgIT09IHlqID4geSAmJiB4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSkgY29udGFpbnMgPSAtY29udGFpbnM7XG4gIH1cblxuICByZXR1cm4gY29udGFpbnM7XG59XG5cbmZ1bmN0aW9uIHNlZ21lbnRDb250YWlucyhhLCBiLCBjKSB7XG4gIHZhciBpO1xuICByZXR1cm4gY29sbGluZWFyKGEsIGIsIGMpICYmIHdpdGhpbihhW2kgPSArKGFbMF0gPT09IGJbMF0pXSwgY1tpXSwgYltpXSk7XG59XG5cbmZ1bmN0aW9uIGNvbGxpbmVhcihhLCBiLCBjKSB7XG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSA9PT0gKGNbMF0gLSBhWzBdKSAqIChiWzFdIC0gYVsxXSk7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihwLCBxLCByKSB7XG4gIHJldHVybiBwIDw9IHEgJiYgcSA8PSByIHx8IHIgPD0gcSAmJiBxIDw9IHA7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplIChrLCBuaWNlLCB6ZXJvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIGV4ID0gZXh0ZW50KHZhbHVlcyksXG4gICAgICAgIHN0YXJ0ID0gemVybyA/IE1hdGgubWluKGV4WzBdLCAwKSA6IGV4WzBdLFxuICAgICAgICBzdG9wID0gZXhbMV0sXG4gICAgICAgIHNwYW4gPSBzdG9wIC0gc3RhcnQsXG4gICAgICAgIHN0ZXAgPSBuaWNlID8gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGspIDogc3BhbiAvIChrICsgMSk7XG4gICAgcmV0dXJuIHJhbmdlKHN0YXJ0ICsgc3RlcCwgc3RvcCwgc3RlcCk7XG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgaXNvY29udG91cnMgKGxldmVsIHNldHMpIGJhc2VkIG9uIGlucHV0IHJhc3RlciBncmlkIGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5maWVsZF0gLSBUaGUgZmllbGQgd2l0aCByYXN0ZXIgZ3JpZFxuICogICBkYXRhLiBJZiB1bnNwZWNpZmllZCwgdGhlIHR1cGxlIGl0c2VsZiBpcyBpbnRlcnByZXRlZCBhcyBhIHJhc3RlciBncmlkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnRocmVzaG9sZHNdIC0gQ29udG91ciB0aHJlc2hvbGQgYXJyYXkuIElmXG4gKiAgIHNwZWNpZmllZCwgdGhlIGxldmVscywgbmljZSwgcmVzb2x2ZSwgYW5kIHplcm8gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmxldmVsc10gLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY29udG91ciBsZXZlbHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMubmljZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICB0aHJlc2hvbGQgdmFsdWVzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGFsaWduZWQgdG8gXCJuaWNlXCJcbiAqICAgaHVtYW4tZnJpZW5kbHkgdmFsdWVzLiBTZXR0aW5nIHRoaXMgZmxhZyBtYXkgY2F1c2UgdGhlIG51bWJlciBvZlxuICogICB0aHJlc2hvbGRzIHRvIGRldmlhdGUgZnJvbSB0aGUgc3BlY2lmaWVkIGxldmVscy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmVdIC0gVGhlIG1ldGhvZCBmb3IgcmVzb2x2aW5nIHRocmVzaG9sZHNcbiAqICAgYWNyb3NzIG11bHRpcGxlIGlucHV0IGdyaWRzLiBJZiAnaW5kZXBlbmRlbnQnICh0aGUgZGVmYXVsdCksIHRocmVzaG9sZFxuICogICBjYWxjdWxhdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCBzZXBhcmF0ZWx5IGZvciBlYWNoIGdyaWQuIElmICdzaGFyZWQnLCBhXG4gKiAgIHNpbmdsZSBzZXQgb2YgdGhyZXNob2xkIHZhbHVlcyB3aWxsIGJlIHVzZWQgZm9yIGFsbCBpbnB1dCBncmlkcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy56ZXJvXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHRocmVzaG9sZCB2YWx1ZXMgc2hvdWxkIGluY2x1ZGUgemVyby5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5zbW9vdGhdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgcG9seWdvbnMgc2hvdWxkIGJlIHNtb290aGVkIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBUaGUgZGVmYXVsdCBpc1xuICogICB0cnVlLiBUaGUgcGFyYW1ldGVyIGlzIGlnbm9yZWQgd2hlbiB1c2luZyBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc2NhbGVdIC0gT3B0aW9uYWwgbnVtZXJpY2FsIHZhbHVlIGJ5IHdoaWNoIHRvXG4gKiAgIHNjYWxlIHRoZSBvdXRwdXQgaXNvY29udG91ciBjb29yZGluYXRlcy4gVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWZ1bFxuICogICB0byBzY2FsZSB0aGUgY29udG91cnMgdG8gbWF0Y2ggYSBkZXNpcmVkIG91dHB1dCByZXNvbHV0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J2NvbnRvdXInXSAtIFRoZSBvdXRwdXQgZmllbGQgaW4gd2hpY2ggdG8gc3RvcmVcbiAqICAgdGhlIGdlbmVyYXRlZCBpc29jb250b3VyIGRhdGEgKGRlZmF1bHQgJ2NvbnRvdXInKS5cbiAqL1xuXG5mdW5jdGlvbiBJc29jb250b3VyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuSXNvY29udG91ci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdJc29jb250b3VyJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3RocmVzaG9sZHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbGV2ZWxzJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduaWNlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyZXNvbHZlJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAndmFsdWVzJzogWydzaGFyZWQnLCAnaW5kZXBlbmRlbnQnXSxcbiAgICAnZGVmYXVsdCc6ICdpbmRlcGVuZGVudCdcbiAgfSwge1xuICAgICduYW1lJzogJ3plcm8nLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc21vb3RoJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3NjYWxlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndHJhbnNsYXRlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAnY29udG91cidcbiAgfV1cbn07XG5pbmhlcml0cyhJc29jb250b3VyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIXB1bHNlLmNoYW5nZWQoKSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICAgIHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgaWRlbnRpdHksXG4gICAgICAgIGNvbnRvdXIgPSBjb250b3VycygpLnNtb290aChfLnNtb290aCAhPT0gZmFsc2UpLFxuICAgICAgICB0eiA9IF8udGhyZXNob2xkcyB8fCBsZXZlbHMoc291cmNlLCBmaWVsZCwgXyksXG4gICAgICAgIGFzID0gXy5hcyA9PT0gbnVsbCA/IG51bGwgOiBfLmFzIHx8ICdjb250b3VyJyxcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgc291cmNlLmZvckVhY2godCA9PiB7XG4gICAgICBjb25zdCBncmlkID0gZmllbGQodCk7IC8vIGdlbmVyYXRlIGNvbnRvdXIgcGF0aHMgaW4gR2VvSlNPTiBmb3JtYXRcblxuICAgICAgY29uc3QgcGF0aHMgPSBjb250b3VyLnNpemUoW2dyaWQud2lkdGgsIGdyaWQuaGVpZ2h0XSkoZ3JpZC52YWx1ZXMsIGlzQXJyYXkodHopID8gdHogOiB0eihncmlkLnZhbHVlcykpOyAvLyBhZGp1c3QgY29udG91ciBwYXRoIGNvb3JkaW5hdGVzIGFzIG5lZWRlZFxuXG4gICAgICB0cmFuc2Zvcm1QYXRocyhwYXRocywgZ3JpZCwgdCwgXyk7IC8vIGluZ2VzdDsgY29weSBzb3VyY2UgZGF0YSBwcm9wZXJ0aWVzIHRvIG91dHB1dFxuXG4gICAgICBwYXRocy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICB2YWx1ZXMucHVzaChyZWRlcml2ZSh0LCBpbmdlc3QoYXMgIT0gbnVsbCA/IHtcbiAgICAgICAgICBbYXNdOiBwXG4gICAgICAgIH0gOiBwKSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBsZXZlbHModmFsdWVzLCBmLCBfKSB7XG4gIGNvbnN0IHEgPSBxdWFudGl6ZShfLmxldmVscyB8fCAxMCwgXy5uaWNlLCBfLnplcm8gIT09IGZhbHNlKTtcbiAgcmV0dXJuIF8ucmVzb2x2ZSAhPT0gJ3NoYXJlZCcgPyBxIDogcSh2YWx1ZXMubWFwKHQgPT4gbWF4KGYodCkudmFsdWVzKSkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1QYXRocyhwYXRocywgZ3JpZCwgZGF0dW0sIF8pIHtcbiAgbGV0IHMgPSBfLnNjYWxlIHx8IGdyaWQuc2NhbGUsXG4gICAgICB0ID0gXy50cmFuc2xhdGUgfHwgZ3JpZC50cmFuc2xhdGU7XG4gIGlmIChpc0Z1bmN0aW9uKHMpKSBzID0gcyhkYXR1bSwgXyk7XG4gIGlmIChpc0Z1bmN0aW9uKHQpKSB0ID0gdChkYXR1bSwgXyk7XG4gIGlmICgocyA9PT0gMSB8fCBzID09IG51bGwpICYmICF0KSByZXR1cm47XG4gIGNvbnN0IHN4ID0gKGlzTnVtYmVyKHMpID8gcyA6IHNbMF0pIHx8IDEsXG4gICAgICAgIHN5ID0gKGlzTnVtYmVyKHMpID8gcyA6IHNbMV0pIHx8IDEsXG4gICAgICAgIHR4ID0gdCAmJiB0WzBdIHx8IDAsXG4gICAgICAgIHR5ID0gdCAmJiB0WzFdIHx8IDA7XG4gIHBhdGhzLmZvckVhY2godHJhbnNmb3JtKGdyaWQsIHN4LCBzeSwgdHgsIHR5KSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShncmlkLCBzeCwgc3ksIHR4LCB0eSkge1xuICBjb25zdCB4MSA9IGdyaWQueDEgfHwgMCxcbiAgICAgICAgeTEgPSBncmlkLnkxIHx8IDAsXG4gICAgICAgIGZsaXAgPSBzeCAqIHN5IDwgMDtcblxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMuZm9yRWFjaCh0cmFuc2Zvcm1SaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVJpbmcoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoZmxpcCkgY29vcmRpbmF0ZXMucmV2ZXJzZSgpOyAvLyBtYWludGFpbiB3aW5kaW5nIG9yZGVyXG5cbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvaW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXNbMF0gPSAoY29vcmRpbmF0ZXNbMF0gLSB4MSkgKiBzeCArIHR4O1xuICAgIGNvb3JkaW5hdGVzWzFdID0gKGNvb3JkaW5hdGVzWzFdIC0geTEpICogc3kgKyB0eTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoZ2VvbWV0cnkpIHtcbiAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvbHlnb24pO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmFkaXVzKGJ3LCBkYXRhLCBmKSB7XG4gIGNvbnN0IHYgPSBidyA+PSAwID8gYncgOiBiYW5kd2lkdGhOUkQoZGF0YSwgZik7XG4gIHJldHVybiBNYXRoLnJvdW5kKChNYXRoLnNxcnQoNCAqIHYgKiB2ICsgMSkgLSAxKSAvIDIpO1xufVxuXG5mdW5jdGlvbiBudW1iZXIoXykge1xuICByZXR1cm4gaXNGdW5jdGlvbihfKSA/IF8gOiBjb25zdGFudCgrXyk7XG59IC8vIEltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbSBkMy9kMy1jb250b3VyLiBUaGFua3MhXG5cblxuZnVuY3Rpb24gZGVuc2l0eTJEICgpIHtcbiAgdmFyIHggPSBkID0+IGRbMF0sXG4gICAgICB5ID0gZCA9PiBkWzFdLFxuICAgICAgd2VpZ2h0ID0gb25lLFxuICAgICAgYmFuZHdpZHRoID0gWy0xLCAtMV0sXG4gICAgICBkeCA9IDk2MCxcbiAgICAgIGR5ID0gNTAwLFxuICAgICAgayA9IDI7IC8vIGxvZzIoY2VsbFNpemUpXG5cblxuICBmdW5jdGlvbiBkZW5zaXR5KGRhdGEsIGNvdW50cykge1xuICAgIGNvbnN0IHJ4ID0gcmFkaXVzKGJhbmR3aWR0aFswXSwgZGF0YSwgeCkgPj4gayxcbiAgICAgICAgICAvLyBibHVyIHgtcmFkaXVzXG4gICAgcnkgPSByYWRpdXMoYmFuZHdpZHRoWzFdLCBkYXRhLCB5KSA+PiBrLFxuICAgICAgICAgIC8vIGJsdXIgeS1yYWRpdXNcbiAgICBveCA9IHJ4ID8gcnggKyAyIDogMCxcbiAgICAgICAgICAvLyB4LW9mZnNldCBwYWRkaW5nIGZvciBibHVyXG4gICAgb3kgPSByeSA/IHJ5ICsgMiA6IDAsXG4gICAgICAgICAgLy8geS1vZmZzZXQgcGFkZGluZyBmb3IgYmx1clxuICAgIG4gPSAyICogb3ggKyAoZHggPj4gayksXG4gICAgICAgICAgLy8gZ3JpZCB3aWR0aFxuICAgIG0gPSAyICogb3kgKyAoZHkgPj4gayksXG4gICAgICAgICAgLy8gZ3JpZCBoZWlnaHRcbiAgICB2YWx1ZXMwID0gbmV3IEZsb2F0MzJBcnJheShuICogbSksXG4gICAgICAgICAgdmFsdWVzMSA9IG5ldyBGbG9hdDMyQXJyYXkobiAqIG0pO1xuICAgIGxldCB2YWx1ZXMgPSB2YWx1ZXMwO1xuICAgIGRhdGEuZm9yRWFjaChkID0+IHtcbiAgICAgIGNvbnN0IHhpID0gb3ggKyAoK3goZCkgPj4gayksXG4gICAgICAgICAgICB5aSA9IG95ICsgKCt5KGQpID4+IGspO1xuXG4gICAgICBpZiAoeGkgPj0gMCAmJiB4aSA8IG4gJiYgeWkgPj0gMCAmJiB5aSA8IG0pIHtcbiAgICAgICAgdmFsdWVzMFt4aSArIHlpICogbl0gKz0gK3dlaWdodChkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgfSBlbHNlIGlmIChyeCA+IDApIHtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ4KTtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczEsIHZhbHVlczAsIHJ4KTtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ4KTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlczE7XG4gICAgfSBlbHNlIGlmIChyeSA+IDApIHtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ5KTtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczEsIHZhbHVlczAsIHJ5KTtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ5KTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlczE7XG4gICAgfSAvLyBzY2FsZSBkZW5zaXR5IGVzdGltYXRlc1xuICAgIC8vIGRlbnNpdHkgaW4gcG9pbnRzIHBlciBzcXVhcmUgcGl4ZWwgb3IgcHJvYmFiaWxpdHkgZGVuc2l0eVxuXG5cbiAgICBjb25zdCBzID0gY291bnRzID8gTWF0aC5wb3coMiwgLTIgKiBrKSA6IDEgLyBzdW0odmFsdWVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBzeiA9IG4gKiBtOyBpIDwgc3o7ICsraSkgdmFsdWVzW2ldICo9IHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBzY2FsZTogMSA8PCBrLFxuICAgICAgd2lkdGg6IG4sXG4gICAgICBoZWlnaHQ6IG0sXG4gICAgICB4MTogb3gsXG4gICAgICB5MTogb3ksXG4gICAgICB4Mjogb3ggKyAoZHggPj4gayksXG4gICAgICB5Mjogb3kgKyAoZHkgPj4gaylcbiAgICB9O1xuICB9XG5cbiAgZGVuc2l0eS54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gbnVtYmVyKF8pLCBkZW5zaXR5KSA6IHg7XG4gIH07XG5cbiAgZGVuc2l0eS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gbnVtYmVyKF8pLCBkZW5zaXR5KSA6IHk7XG4gIH07XG5cbiAgZGVuc2l0eS53ZWlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdlaWdodCA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB3ZWlnaHQ7XG4gIH07XG5cbiAgZGVuc2l0eS5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcblxuICAgIHZhciBfMCA9ICtfWzBdLFxuICAgICAgICBfMSA9ICtfWzFdO1xuXG4gICAgaWYgKCEoXzAgPj0gMCAmJiBfMSA+PSAwKSkgZXJyb3IoJ2ludmFsaWQgc2l6ZScpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCBkZW5zaXR5O1xuICB9O1xuXG4gIGRlbnNpdHkuY2VsbFNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIDEgPDwgaztcbiAgICBpZiAoISgoXyA9ICtfKSA+PSAxKSkgZXJyb3IoJ2ludmFsaWQgY2VsbCBzaXplJyk7XG4gICAgayA9IE1hdGguZmxvb3IoTWF0aC5sb2coXykgLyBNYXRoLkxOMik7XG4gICAgcmV0dXJuIGRlbnNpdHk7XG4gIH07XG5cbiAgZGVuc2l0eS5iYW5kd2lkdGggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhbmR3aWR0aDtcbiAgICBfID0gYXJyYXkoXyk7XG4gICAgaWYgKF8ubGVuZ3RoID09PSAxKSBfID0gWytfWzBdLCArX1swXV07XG4gICAgaWYgKF8ubGVuZ3RoICE9PSAyKSBlcnJvcignaW52YWxpZCBiYW5kd2lkdGgnKTtcbiAgICByZXR1cm4gYmFuZHdpZHRoID0gXywgZGVuc2l0eTtcbiAgfTtcblxuICByZXR1cm4gZGVuc2l0eTtcbn1cblxuZnVuY3Rpb24gYmx1clgobiwgbSwgc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgY29uc3QgdyA9IChyIDw8IDEpICsgMTtcblxuICBmb3IgKGxldCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAobGV0IGkgPSAwLCBzciA9IDA7IGkgPCBuICsgcjsgKytpKSB7XG4gICAgICBpZiAoaSA8IG4pIHtcbiAgICAgICAgc3IgKz0gc291cmNlW2kgKyBqICogbl07XG4gICAgICB9XG5cbiAgICAgIGlmIChpID49IHIpIHtcbiAgICAgICAgaWYgKGkgPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZVtpIC0gdyArIGogKiBuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldFtpIC0gciArIGogKiBuXSA9IHNyIC8gTWF0aC5taW4oaSArIDEsIG4gLSAxICsgdyAtIGksIHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBibHVyWShuLCBtLCBzb3VyY2UsIHRhcmdldCwgcikge1xuICBjb25zdCB3ID0gKHIgPDwgMSkgKyAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDAsIHNyID0gMDsgaiA8IG0gKyByOyArK2opIHtcbiAgICAgIGlmIChqIDwgbSkge1xuICAgICAgICBzciArPSBzb3VyY2VbaSArIGogKiBuXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGogPj0gcikge1xuICAgICAgICBpZiAoaiA+PSB3KSB7XG4gICAgICAgICAgc3IgLT0gc291cmNlW2kgKyAoaiAtIHcpICogbl07XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbaSArIChqIC0gcikgKiBuXSA9IHNyIC8gTWF0aC5taW4oaiArIDEsIG0gLSAxICsgdyAtIGosIHcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm0gMkQga2VybmVsLWRlbnNpdHkgZXN0aW1hdGlvbiBvZiBwb2ludCBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhcmFtcy5zaXplIC0gVGhlIFt3aWR0aCwgaGVpZ2h0XSBleHRlbnQgKGluXG4gKiAgIHVuaXRzIG9mIGlucHV0IHBpeGVscykgb3ZlciB3aGljaCB0byBwZXJmb3JtIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBwYXJhbXMueCAtIFRoZSB4LWNvb3JkaW5hdGUgYWNjZXNzb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gcGFyYW1zLnkgLSBUaGUgeS1jb29yZGluYXRlIGFjY2Vzc29yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMud2VpZ2h0XSAtIFRoZSB3ZWlnaHQgYWNjZXNzb3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5jZWxsU2l6ZV0gLSBDb250b3VyIGRlbnNpdHkgY2FsY3VsYXRpb24gY2VsbCBzaXplLlxuICogICBUaGlzIHBhcmFtZXRlciBkZXRlcm1pbmVzIHRoZSBsZXZlbCBvZiBzcGF0aWFsIGFwcHJveGltYXRpb24uIEZvciBleGFtcGxlLFxuICogICB0aGUgZGVmYXVsdCB2YWx1ZSBvZiA0IG1hcHMgdG8gMnggcmVkdWN0aW9ucyBpbiBib3RoIHgtIGFuZCB5LSBkaW1lbnNpb25zLlxuICogICBBIHZhbHVlIG9mIDEgd2lsbCByZXN1bHQgaW4gYW4gb3V0cHV0IHJhc3RlciBncmlkIHdob3NlIGRpbWVuc2lvbnMgZXhhY3RseVxuICogICBtYXRjaGVzIHRoZSBzaXplIHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5iYW5kd2lkdGhdIC0gVGhlIEtERSBrZXJuZWwgYmFuZHdpZHRocyxcbiAqICAgaW4gcGl4ZWxzLiBUaGUgaW5wdXQgY2FuIGJlIGEgdHdvLWVsZW1lbnQgYXJyYXkgc3BlY2lmeWluZyBzZXBhcmF0ZVxuICogICB4IGFuZCB5IGJhbmR3aWR0aHMsIG9yIGEgc2luZ2xlLWVsZW1lbnQgYXJyYXkgc3BlY2lmeWluZyBib3RoLiBJZiB0aGVcbiAqICAgYmFuZHdpZHRoIGlzIHVuc3BlY2lmaWVkIG9yIGxlc3MgdGhhbiB6ZXJvLCB0aGUgYmFuZHdpZHRoIHdpbGwgYmVcbiAqICAgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmNvdW50cz1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZVxuICogICBvdXRwdXQgdmFsdWVzIHNob3VsZCBiZSBwcm9iYWJpbGl0eSBlc3RpbWF0ZXMgKGZhbHNlLCBkZWZhdWx0KSBvclxuICogICBzbW9vdGhlZCBjb3VudHMgKHRydWUpLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J2dyaWQnXSAtIFRoZSBvdXRwdXQgZmllbGQgaW4gd2hpY2ggdG8gc3RvcmVcbiAqICAgdGhlIGdlbmVyYXRlZCByYXN0ZXIgZ3JpZCAoZGVmYXVsdCAnZ3JpZCcpLlxuICovXG5cbmZ1bmN0aW9uIEtERTJEKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuS0RFMkQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnS0RFMkQnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnd2VpZ2h0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjZWxsU2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50cycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnZ3JpZCdcbiAgfV1cbn07XG5jb25zdCBQQVJBTVMgPSBbJ3gnLCAneScsICd3ZWlnaHQnLCAnc2l6ZScsICdjZWxsU2l6ZScsICdiYW5kd2lkdGgnXTtcbmZ1bmN0aW9uIHBhcmFtcyhvYmosIF8pIHtcbiAgUEFSQU1TLmZvckVhY2gocGFyYW0gPT4gX1twYXJhbV0gIT0gbnVsbCA/IG9ialtwYXJhbV0oX1twYXJhbV0pIDogMCk7XG4gIHJldHVybiBvYmo7XG59XG5pbmhlcml0cyhLREUyRCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgZ3JvdXBzID0gcGFydGl0aW9uKHNvdXJjZSwgXy5ncm91cGJ5KSxcbiAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAga2RlID0gcGFyYW1zKGRlbnNpdHkyRCgpLCBfKSxcbiAgICAgICAgYXMgPSBfLmFzIHx8ICdncmlkJyxcbiAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBzZXQodCwgdmFscykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkgdFtuYW1lc1tpXV0gPSB2YWxzW2ldO1xuXG4gICAgICByZXR1cm4gdDtcbiAgICB9IC8vIGdlbmVyYXRlIGRlbnNpdHkgcmFzdGVyIGdyaWRzXG5cblxuICAgIHZhbHVlcyA9IGdyb3Vwcy5tYXAoZyA9PiBpbmdlc3Qoc2V0KHtcbiAgICAgIFthc106IGtkZShnLCBfLmNvdW50cylcbiAgICB9LCBnLmRpbXMpKSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnkpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgICAgZ2V0ID0gZiA9PiBmKHQpLFxuICAgICAgbWFwLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgayxcbiAgICAgIGc7IC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIGdyb3Vwc1xuXG5cbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobWFwID0ge30sIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSBkYXRhW2ldO1xuICAgICAgayA9IGdyb3VwYnkubWFwKGdldCk7XG4gICAgICBnID0gbWFwW2tdO1xuXG4gICAgICBpZiAoIWcpIHtcbiAgICAgICAgbWFwW2tdID0gZyA9IFtdO1xuICAgICAgICBnLmRpbXMgPSBrO1xuICAgICAgICBncm91cHMucHVzaChnKTtcbiAgICAgIH1cblxuICAgICAgZy5wdXNoKHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncm91cHM7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgY29udG91cnMgYmFzZWQgb24ga2VybmVsLWRlbnNpdHkgZXN0aW1hdGlvbiBvZiBwb2ludCBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhcmFtcy5zaXplIC0gVGhlIGRpbWVuc2lvbnMgW3dpZHRoLCBoZWlnaHRdIG92ZXIgd2hpY2ggdG8gY29tcHV0ZSBjb250b3Vycy5cbiAqICBJZiB0aGUgdmFsdWVzIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdGhpcyBtdXN0IGJlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBpbnB1dCBkYXRhLlxuICogIElmIGRlbnNpdHkgZXN0aW1hdGlvbiBpcyBwZXJmb3JtZWQsIHRoaXMgaXMgdGhlIG91dHB1dCB2aWV3IGRpbWVuc2lvbnMgaW4gcGl4ZWxzLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnZhbHVlc10gLSBBbiBhcnJheSBvZiBudW1lcmljIHZhbHVlcyByZXByZXNlbnRpbmcgYW5cbiAqICB3aWR0aCB4IGhlaWdodCBncmlkIG9mIHZhbHVlcyBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgY29udG91cnMuIElmIHVuc3BlY2lmaWVkLCB0aGlzXG4gKiAgdHJhbnNmb3JtIHdpbGwgaW5zdGVhZCBhdHRlbXB0IHRvIGNvbXB1dGUgY29udG91cnMgZm9yIHRoZSBrZXJuZWwgZGVuc2l0eSBlc3RpbWF0ZVxuICogIHVzaW5nIHZhbHVlcyBkcmF3biBmcm9tIGRhdGEgdHVwbGVzIGluIHRoZSBpbnB1dCBwdWxzZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLnhdIC0gVGhlIHBpeGVsIHgtY29vcmRpbmF0ZSBhY2Nlc3NvciBmb3IgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMueV0gLSBUaGUgcGl4ZWwgeS1jb29yZGluYXRlIGFjY2Vzc29yIGZvciBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gW3BhcmFtcy53ZWlnaHRdIC0gVGhlIGRhdGEgcG9pbnQgd2VpZ2h0IGFjY2Vzc29yIGZvciBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5jZWxsU2l6ZV0gLSBDb250b3VyIGRlbnNpdHkgY2FsY3VsYXRpb24gY2VsbCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuYmFuZHdpZHRoXSAtIEtlcm5lbCBkZW5zaXR5IGVzdGltYXRpb24gYmFuZHdpZHRoLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnRocmVzaG9sZHNdIC0gQ29udG91ciB0aHJlc2hvbGQgYXJyYXkuIElmXG4gKiAgIHRoaXMgcGFyYW1ldGVyIGlzIHNldCwgdGhlIGNvdW50IGFuZCBuaWNlIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuY291bnRdIC0gVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNvbnRvdXJzLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLm5pY2VdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgdGhyZXNob2xkIHZhbHVlcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhbGlnbmVkIHRvIFwibmljZVwiXG4gKiAgIGh1bWFuLWZyaWVuZGx5IHZhbHVlcy4gU2V0dGluZyB0aGlzIGZsYWcgbWF5IGNhdXNlIHRoZSBudW1iZXIgb2ZcbiAqICAgdGhyZXNob2xkcyB0byBkZXZpYXRlIGZyb20gdGhlIHNwZWNpZmllZCBjb3VudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5zbW9vdGhdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgcG9seWdvbnMgc2hvdWxkIGJlIHNtb290aGVkIHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLiBUaGUgZGVmYXVsdCBpc1xuICogICB0cnVlLiBUaGUgcGFyYW1ldGVyIGlzIGlnbm9yZWQgd2hlbiB1c2luZyBkZW5zaXR5IGVzdGltYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gQ29udG91cihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkNvbnRvdXIuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ29udG91cicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWVzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd3ZWlnaHQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnY2VsbFNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnY291bnQnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ25pY2UnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3RocmVzaG9sZHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc21vb3RoJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhDb250b3VyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIXB1bHNlLmNoYW5nZWQoKSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICAgIGNvbnRvdXIgPSBjb250b3VycygpLnNtb290aChfLnNtb290aCAhPT0gZmFsc2UpLFxuICAgICAgICB2YWx1ZXMgPSBfLnZhbHVlcyxcbiAgICAgICAgdGhyZXNoID0gXy50aHJlc2hvbGRzIHx8IHF1YW50aXplKF8uY291bnQgfHwgMTAsIF8ubmljZSwgISF2YWx1ZXMpLFxuICAgICAgICBzaXplID0gXy5zaXplLFxuICAgICAgICBncmlkLFxuICAgICAgICBwb3N0O1xuXG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIHZhbHVlcyA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlO1xuICAgICAgZ3JpZCA9IHBhcmFtcyhkZW5zaXR5MkQoKSwgXykodmFsdWVzLCB0cnVlKTtcbiAgICAgIHBvc3QgPSB0cmFuc2Zvcm0oZ3JpZCwgZ3JpZC5zY2FsZSB8fCAxLCBncmlkLnNjYWxlIHx8IDEsIDAsIDApO1xuICAgICAgc2l6ZSA9IFtncmlkLndpZHRoLCBncmlkLmhlaWdodF07XG4gICAgICB2YWx1ZXMgPSBncmlkLnZhbHVlcztcbiAgICB9XG5cbiAgICB0aHJlc2ggPSBpc0FycmF5KHRocmVzaCkgPyB0aHJlc2ggOiB0aHJlc2godmFsdWVzKTtcbiAgICB2YWx1ZXMgPSBjb250b3VyLnNpemUoc2l6ZSkodmFsdWVzLCB0aHJlc2gpO1xuICAgIGlmIChwb3N0KSB2YWx1ZXMuZm9yRWFjaChwb3N0KTtcbiAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy52YWx1ZSA9IG91dC5zb3VyY2UgPSBvdXQuYWRkID0gKHZhbHVlcyB8fCBbXSkubWFwKGluZ2VzdCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgRmVhdHVyZSA9ICdGZWF0dXJlJztcbmNvbnN0IEZlYXR1cmVDb2xsZWN0aW9uID0gJ0ZlYXR1cmVDb2xsZWN0aW9uJztcbmNvbnN0IE11bHRpUG9pbnQgPSAnTXVsdGlQb2ludCc7XG5cbi8qKlxuICogQ29uc29saWRhdGUgYW4gYXJyYXkgb2YgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHBvaW50cyBvciBHZW9KU09OIGZlYXR1cmVzXG4gKiBpbnRvIGEgY29tYmluZWQgR2VvSlNPTiBvYmplY3QuIFRoaXMgdHJhbnNmb3JtIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yXG4gKiBjb21iaW5pbmcgZ2VvIGRhdGEgZm9yIGEgUHJvamVjdGlvbidzIGZpdCBhcmd1bWVudC4gVGhlIHJlc3VsdGluZyBHZW9KU09OXG4gKiBkYXRhIGlzIGF2YWlsYWJsZSBhcyB0aGlzIHRyYW5zZm9ybSdzIHZhbHVlLiBJbnB1dCBwdWxzZXMgYXJlIHVuY2hhbmdlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5maWVsZHNdIC0gQSB0d28tZWxlbWVudCBhcnJheVxuICogICBvZiBmaWVsZCBhY2Nlc3NvcnMgZm9yIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmdlb2pzb24gLSBBIGZpZWxkIGFjY2Vzc29yIGZvclxuICogICByZXRyaWV2aW5nIEdlb0pTT04gZmVhdHVyZSBkYXRhLlxuICovXG5cbmZ1bmN0aW9uIEdlb0pTT04ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9KU09OLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0dlb0pTT04nLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ2VvanNvbicsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoR2VvSlNPTiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuX2ZlYXR1cmVzLFxuICAgICAgICBwb2ludHMgPSB0aGlzLl9wb2ludHMsXG4gICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICBsb24gPSBmaWVsZHMgJiYgZmllbGRzWzBdLFxuICAgICAgICBsYXQgPSBmaWVsZHMgJiYgZmllbGRzWzFdLFxuICAgICAgICBnZW9qc29uID0gXy5nZW9qc29uIHx8ICFmaWVsZHMgJiYgaWRlbnRpdHksXG4gICAgICAgIGZsYWcgPSBwdWxzZS5BREQsXG4gICAgICAgIG1vZDtcbiAgICBtb2QgPSBfLm1vZGlmaWVkKCkgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pIHx8IHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGdlb2pzb24pKSB8fCBsb24gJiYgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMobG9uKSkgfHwgbGF0ICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGxhdCkpO1xuXG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IG1vZCkge1xuICAgICAgZmxhZyA9IHB1bHNlLlNPVVJDRTtcbiAgICAgIHRoaXMuX2ZlYXR1cmVzID0gZmVhdHVyZXMgPSBbXTtcbiAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cyA9IFtdO1xuICAgIH1cblxuICAgIGlmIChnZW9qc29uKSB7XG4gICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IGZlYXR1cmVzLnB1c2goZ2VvanNvbih0KSkpO1xuICAgIH1cblxuICAgIGlmIChsb24gJiYgbGF0KSB7XG4gICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IHtcbiAgICAgICAgdmFyIHggPSBsb24odCksXG4gICAgICAgICAgICB5ID0gbGF0KHQpO1xuXG4gICAgICAgIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsICYmICh4ID0gK3gpID09PSB4ICYmICh5ID0gK3kpID09PSB5KSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzLmNvbmNhdCh7XG4gICAgICAgIHR5cGU6IEZlYXR1cmUsXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogTXVsdGlQb2ludCxcbiAgICAgICAgICBjb29yZGluYXRlczogcG9pbnRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICB0eXBlOiBGZWF0dXJlQ29sbGVjdGlvbixcbiAgICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICAgIH07XG4gIH1cblxufSk7XG5cbi8qKlxuICogTWFwIEdlb0pTT04gZGF0YSB0byBhbiBTVkcgcGF0aCBzdHJpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBudW1iZXIpOiAqfSBwYXJhbXMucHJvamVjdGlvbiAtIFRoZSBjYXJ0b2dyYXBoaWNcbiAqICAgcHJvamVjdGlvbiB0byBhcHBseS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5maWVsZF0gLSBUaGUgZmllbGQgd2l0aCBHZW9KU09OIGRhdGEsXG4gKiAgIG9yIG51bGwgaWYgdGhlIHR1cGxlIGl0c2VsZiBpcyBhIEdlb0pTT04gZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdwYXRoJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgcGF0aCBkYXRhIChkZWZhdWx0ICdwYXRoJykuXG4gKi9cblxuZnVuY3Rpb24gR2VvUGF0aChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkdlb1BhdGguRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR2VvUGF0aCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwb2ludFJhZGl1cycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BhdGgnXG4gIH1dXG59O1xuaW5oZXJpdHMoR2VvUGF0aCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgIHBhdGggPSB0aGlzLnZhbHVlLFxuICAgICAgICBmaWVsZCA9IF8uZmllbGQgfHwgaWRlbnRpdHksXG4gICAgICAgIGFzID0gXy5hcyB8fCAncGF0aCcsXG4gICAgICAgIGZsYWcgPSBvdXQuU09VUkNFO1xuXG4gICAgaWYgKCFwYXRoIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgLy8gcGFyYW1ldGVycyB1cGRhdGVkLCByZXNldCBhbmQgcmVmbG93XG4gICAgICB0aGlzLnZhbHVlID0gcGF0aCA9IGdldFByb2plY3Rpb25QYXRoKF8ucHJvamVjdGlvbik7XG4gICAgICBvdXQubWF0ZXJpYWxpemUoKS5yZWZsb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZyA9IGZpZWxkID09PSBpZGVudGl0eSB8fCBwdWxzZS5tb2RpZmllZChmaWVsZC5maWVsZHMpID8gb3V0LkFERF9NT0QgOiBvdXQuQUREO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXYgPSBpbml0UGF0aChwYXRoLCBfLnBvaW50UmFkaXVzKTtcbiAgICBvdXQudmlzaXQoZmxhZywgdCA9PiB0W2FzXSA9IHBhdGgoZmllbGQodCkpKTtcbiAgICBwYXRoLnBvaW50UmFkaXVzKHByZXYpO1xuICAgIHJldHVybiBvdXQubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBpbml0UGF0aChwYXRoLCBwb2ludFJhZGl1cykge1xuICBjb25zdCBwcmV2ID0gcGF0aC5wb2ludFJhZGl1cygpO1xuICBwYXRoLmNvbnRleHQobnVsbCk7XG5cbiAgaWYgKHBvaW50UmFkaXVzICE9IG51bGwpIHtcbiAgICBwYXRoLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgfVxuXG4gIHJldHVybiBwcmV2O1xufVxuXG4vKipcbiAqIEdlby1jb2RlIGEgbG9uZ2l0dWRlL2xhdGl0dWRlIHBvaW50IHRvIGFuIHgveSBjb29yZGluYXRlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMuZmllbGRzIC0gQSB0d28tZWxlbWVudCBhcnJheSBvZlxuICogICBmaWVsZCBhY2Nlc3NvcnMgZm9yIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBBIHR3by1lbGVtZW50IGFycmF5IG9mIGZpZWxkIG5hbWVzXG4gKiAgIHVuZGVyIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuIERlZmF1bHRzIHRvIFsneCcsJ3knXS5cbiAqL1xuXG5mdW5jdGlvbiBHZW9Qb2ludChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkdlb1BvaW50LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0dlb1BvaW50JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAncHJvamVjdGlvbicsXG4gICAgJ3R5cGUnOiAncHJvamVjdGlvbicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWyd4JywgJ3knXVxuICB9XVxufTtcbmluaGVyaXRzKEdlb1BvaW50LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIHByb2ogPSBfLnByb2plY3Rpb24sXG4gICAgICAgIGxvbiA9IF8uZmllbGRzWzBdLFxuICAgICAgICBsYXQgPSBfLmZpZWxkc1sxXSxcbiAgICAgICAgYXMgPSBfLmFzIHx8IFsneCcsICd5J10sXG4gICAgICAgIHggPSBhc1swXSxcbiAgICAgICAgeSA9IGFzWzFdLFxuICAgICAgICBtb2Q7XG5cbiAgICBmdW5jdGlvbiBzZXQodCkge1xuICAgICAgY29uc3QgeHkgPSBwcm9qKFtsb24odCksIGxhdCh0KV0pO1xuXG4gICAgICBpZiAoeHkpIHtcbiAgICAgICAgdFt4XSA9IHh5WzBdO1xuICAgICAgICB0W3ldID0geHlbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0W3hdID0gdW5kZWZpbmVkO1xuICAgICAgICB0W3ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVmbG93XG4gICAgICBwdWxzZSA9IHB1bHNlLm1hdGVyaWFsaXplKCkucmVmbG93KHRydWUpLnZpc2l0KHB1bHNlLlNPVVJDRSwgc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kID0gcHVsc2UubW9kaWZpZWQobG9uLmZpZWxkcykgfHwgcHVsc2UubW9kaWZpZWQobGF0LmZpZWxkcyk7XG4gICAgICBwdWxzZS52aXNpdChtb2QgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQURELCBzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQW5ub3RhdGUgaXRlbXMgd2l0aCBhIGdlb3BhdGggc2hhcGUgZ2VuZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggR2VvSlNPTiBkYXRhLFxuICogICBvciBudWxsIGlmIHRoZSB0dXBsZSBpdHNlbGYgaXMgYSBHZW9KU09OIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0nc2hhcGUnXSAtIFRoZSBvdXRwdXQgZmllbGQgaW4gd2hpY2ggdG8gc3RvcmVcbiAqICAgdGhlIGdlbmVyYXRlZCBwYXRoIGRhdGEgKGRlZmF1bHQgJ3NoYXBlJykuXG4gKi9cblxuZnVuY3Rpb24gR2VvU2hhcGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9TaGFwZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9TaGFwZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlLFxuICAgICdub21vZCc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAncHJvamVjdGlvbicsXG4gICAgJ3R5cGUnOiAncHJvamVjdGlvbidcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiAnZGF0dW0nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwb2ludFJhZGl1cycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3NoYXBlJ1xuICB9XVxufTtcbmluaGVyaXRzKEdlb1NoYXBlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgICAgc2hhcGUgPSB0aGlzLnZhbHVlLFxuICAgICAgICBhcyA9IF8uYXMgfHwgJ3NoYXBlJyxcbiAgICAgICAgZmxhZyA9IG91dC5BREQ7XG5cbiAgICBpZiAoIXNoYXBlIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgLy8gcGFyYW1ldGVycyB1cGRhdGVkLCByZXNldCBhbmQgcmVmbG93XG4gICAgICB0aGlzLnZhbHVlID0gc2hhcGUgPSBzaGFwZUdlbmVyYXRvcihnZXRQcm9qZWN0aW9uUGF0aChfLnByb2plY3Rpb24pLCBfLmZpZWxkIHx8IGZpZWxkKCdkYXR1bScpLCBfLnBvaW50UmFkaXVzKTtcbiAgICAgIG91dC5tYXRlcmlhbGl6ZSgpLnJlZmxvdygpO1xuICAgICAgZmxhZyA9IG91dC5TT1VSQ0U7XG4gICAgfVxuXG4gICAgb3V0LnZpc2l0KGZsYWcsIHQgPT4gdFthc10gPSBzaGFwZSk7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNoYXBlR2VuZXJhdG9yKHBhdGgsIGZpZWxkLCBwb2ludFJhZGl1cykge1xuICBjb25zdCBzaGFwZSA9IHBvaW50UmFkaXVzID09IG51bGwgPyBfID0+IHBhdGgoZmllbGQoXykpIDogXyA9PiB7XG4gICAgdmFyIHByZXYgPSBwYXRoLnBvaW50UmFkaXVzKCksXG4gICAgICAgIHZhbHVlID0gcGF0aC5wb2ludFJhZGl1cyhwb2ludFJhZGl1cykoZmllbGQoXykpO1xuICAgIHBhdGgucG9pbnRSYWRpdXMocHJldik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIHNoYXBlLmNvbnRleHQgPSBfID0+IHtcbiAgICBwYXRoLmNvbnRleHQoXyk7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBzaGFwZTtcbn1cblxuLyoqXG4gKiBHZW9KU09OIGZlYXR1cmUgZ2VuZXJhdG9yIGZvciBjcmVhdGluZyBncmF0aWN1bGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gR3JhdGljdWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbiAgdGhpcy5nZW5lcmF0b3IgPSBnZW9HcmF0aWN1bGUoKTtcbn1cbkdyYXRpY3VsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHcmF0aWN1bGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2NoYW5nZXMnOiB0cnVlLFxuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50TWFqb3InLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudE1pbm9yJyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBNYWpvcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWzkwLCAzNjBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwTWlub3InLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsxMCwgMTBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwcmVjaXNpb24nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAyLjVcbiAgfV1cbn07XG5pbmhlcml0cyhHcmF0aWN1bGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgc3JjID0gdGhpcy52YWx1ZSxcbiAgICAgICAgZ2VuID0gdGhpcy5nZW5lcmF0b3IsXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoIXNyYy5sZW5ndGggfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gXykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihnZW5bcHJvcF0pKSB7XG4gICAgICAgICAgZ2VuW3Byb3BdKF9bcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdCA9IGdlbigpO1xuXG4gICAgaWYgKHNyYy5sZW5ndGgpIHtcbiAgICAgIHB1bHNlLm1vZC5wdXNoKHJlcGxhY2Uoc3JjWzBdLCB0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLmFkZC5wdXNoKGluZ2VzdCh0KSk7XG4gICAgfVxuXG4gICAgc3JjWzBdID0gdDtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUmVuZGVyIGEgaGVhdG1hcCBpbWFnZSBmb3IgaW5wdXQgcmFzdGVyIGdyaWQgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBbcGFyYW1zLmZpZWxkXSAtIFRoZSBmaWVsZCB3aXRoIHJhc3RlciBncmlkXG4gKiAgIGRhdGEuIElmIHVuc3BlY2lmaWVkLCB0aGUgdHVwbGUgaXRzZWxmIGlzIGludGVycHJldGVkIGFzIGEgcmFzdGVyIGdyaWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5jb2xvcl0gLSBBIGNvbnN0YW50IGNvbG9yIHZhbHVlIG9yIGZ1bmN0aW9uIGZvclxuICogICBpbmRpdmlkdWFsIHBpeGVsIGNvbG9yLiBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBpbnB1dFxuICogICBvYmplY3QgdGhhdCBpbmNsdWRlcyAkeCwgJHksICR2YWx1ZSwgYW5kICRtYXggZmllbGRzIGZvciB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLm9wYWNpdHldIC0gQSBjb25zdGFudCBvcGFjaXR5IHZhbHVlIG9yIGZ1bmN0aW9uIGZvclxuICogICBpbmRpdmlkdWFsIHBpeGVsIG9wYWNpdHkuIElmIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgaW52b2tlZCB3aXRoIGFuIGlucHV0XG4gKiAgIG9iamVjdCB0aGF0IGluY2x1ZGVzICR4LCAkeSwgJHZhbHVlLCBhbmQgJG1heCBmaWVsZHMgZm9yIHRoZSBncmlkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMucmVzb2x2ZV0gLSBUaGUgbWV0aG9kIGZvciByZXNvbHZpbmcgbWF4aW11bSB2YWx1ZXNcbiAqICAgYWNyb3NzIG11bHRpcGxlIGlucHV0IGdyaWRzLiBJZiAnaW5kZXBlbmRlbnQnICh0aGUgZGVmYXVsdCksIG1heGltdW1cbiAqICAgY2FsY3VsYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBncmlkLiBJZiAnc2hhcmVkJyxcbiAqICAgYSBzaW5nbGUgZ2xvYmFsIG1heGltdW0gd2lsbCBiZSB1c2VkIGZvciBhbGwgaW5wdXQgZ3JpZHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0naW1hZ2UnXSAtIFRoZSBvdXRwdXQgZmllbGQgaW4gd2hpY2ggdG8gc3RvcmVcbiAqICAgdGhlIGdlbmVyYXRlZCBiaXRtYXAgY2FudmFzIGltYWdlcyAoZGVmYXVsdCAnaW1hZ2UnKS5cbiAqL1xuXG5mdW5jdGlvbiBIZWF0bWFwKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuSGVhdG1hcC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdoZWF0bWFwJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnY29sb3InLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcGFjaXR5JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVzb2x2ZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFsnc2hhcmVkJywgJ2luZGVwZW5kZW50J10sXG4gICAgJ2RlZmF1bHQnOiAnaW5kZXBlbmRlbnQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdpbWFnZSdcbiAgfV1cbn07XG5pbmhlcml0cyhIZWF0bWFwLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIHNoYXJlZCA9IF8ucmVzb2x2ZSA9PT0gJ3NoYXJlZCcsXG4gICAgICAgIGZpZWxkID0gXy5maWVsZCB8fCBpZGVudGl0eSxcbiAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHlfKF8ub3BhY2l0eSwgXyksXG4gICAgICAgIGNvbG9yID0gY29sb3JfKF8uY29sb3IsIF8pLFxuICAgICAgICBhcyA9IF8uYXMgfHwgJ2ltYWdlJyxcbiAgICAgICAgb2JqID0ge1xuICAgICAgJHg6IDAsXG4gICAgICAkeTogMCxcbiAgICAgICR2YWx1ZTogMCxcbiAgICAgICRtYXg6IHNoYXJlZCA/IG1heChzb3VyY2UubWFwKHQgPT4gbWF4KGZpZWxkKHQpLnZhbHVlcykpKSA6IDBcbiAgICB9O1xuICAgIHNvdXJjZS5mb3JFYWNoKHQgPT4ge1xuICAgICAgY29uc3QgdiA9IGZpZWxkKHQpOyAvLyBidWlsZCBwcm94eSBkYXRhIG9iamVjdFxuXG4gICAgICBjb25zdCBvID0gZXh0ZW5kKHt9LCB0LCBvYmopOyAvLyBzZXQgbWF4aW11bSB2YWx1ZSBpZiBub3QgZ2xvYmFsbHkgc2hhcmVkXG5cbiAgICAgIGlmICghc2hhcmVkKSBvLiRtYXggPSBtYXgodi52YWx1ZXMgfHwgW10pOyAvLyBnZW5lcmF0ZSBjYW52YXMgaW1hZ2VcbiAgICAgIC8vIG9wdGltaXplIGNvbG9yL29wYWNpdHkgaWYgbm90IHBpeGVsLWRlcGVuZGVudFxuXG4gICAgICB0W2FzXSA9IHRvQ2FudmFzKHYsIG8sIGNvbG9yLmRlcCA/IGNvbG9yIDogY29uc3RhbnQoY29sb3IobykpLCBvcGFjaXR5LmRlcCA/IG9wYWNpdHkgOiBjb25zdGFudChvcGFjaXR5KG8pKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyh0cnVlKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7IC8vIGdldCBpbWFnZSBjb2xvciBmdW5jdGlvblxuXG5mdW5jdGlvbiBjb2xvcl8oY29sb3IsIF8pIHtcbiAgbGV0IGY7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY29sb3IpKSB7XG4gICAgZiA9IG9iaiA9PiByZ2IoY29sb3Iob2JqLCBfKSk7XG5cbiAgICBmLmRlcCA9IGRlcGVuZGVuY3koY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgdG8gbWlkLWdyZXlcbiAgICBmID0gY29uc3RhbnQocmdiKGNvbG9yIHx8ICcjODg4JykpO1xuICB9XG5cbiAgcmV0dXJuIGY7XG59IC8vIGdldCBpbWFnZSBvcGFjaXR5IGZ1bmN0aW9uXG5cblxuZnVuY3Rpb24gb3BhY2l0eV8ob3BhY2l0eSwgXykge1xuICBsZXQgZjtcblxuICBpZiAoaXNGdW5jdGlvbihvcGFjaXR5KSkge1xuICAgIGYgPSBvYmogPT4gb3BhY2l0eShvYmosIF8pO1xuXG4gICAgZi5kZXAgPSBkZXBlbmRlbmN5KG9wYWNpdHkpO1xuICB9IGVsc2UgaWYgKG9wYWNpdHkpIHtcbiAgICBmID0gY29uc3RhbnQob3BhY2l0eSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmYXVsdCB0byBbMCwgbWF4XSBvcGFjaXR5IGdyYWRpZW50XG4gICAgZiA9IG9iaiA9PiBvYmouJHZhbHVlIC8gb2JqLiRtYXggfHwgMDtcblxuICAgIGYuZGVwID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmO1xufSAvLyBjaGVjayBpZiBmdW5jdGlvbiBkZXBlbmRzIG9uIGluZGl2aWR1YWwgcGl4ZWwgZGF0YVxuXG5cbmZ1bmN0aW9uIGRlcGVuZGVuY3koZikge1xuICBpZiAoIWlzRnVuY3Rpb24oZikpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc2V0ID0gdG9TZXQoYWNjZXNzb3JGaWVsZHMoZikpO1xuICByZXR1cm4gc2V0LiR4IHx8IHNldC4keSB8fCBzZXQuJHZhbHVlIHx8IHNldC4kbWF4O1xufSAvLyByZW5kZXIgcmFzdGVyIGdyaWQgdG8gY2FudmFzXG5cblxuZnVuY3Rpb24gdG9DYW52YXMoZ3JpZCwgb2JqLCBjb2xvciwgb3BhY2l0eSkge1xuICBjb25zdCBuID0gZ3JpZC53aWR0aCxcbiAgICAgICAgbSA9IGdyaWQuaGVpZ2h0LFxuICAgICAgICB4MSA9IGdyaWQueDEgfHwgMCxcbiAgICAgICAgeTEgPSBncmlkLnkxIHx8IDAsXG4gICAgICAgIHgyID0gZ3JpZC54MiB8fCBuLFxuICAgICAgICB5MiA9IGdyaWQueTIgfHwgbSxcbiAgICAgICAgdmFsID0gZ3JpZC52YWx1ZXMsXG4gICAgICAgIHZhbHVlID0gdmFsID8gaSA9PiB2YWxbaV0gOiB6ZXJvLFxuICAgICAgICBjYW4gPSBjYW52YXMoeDIgLSB4MSwgeTIgLSB5MSksXG4gICAgICAgIGN0eCA9IGNhbi5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICBpbWcgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHgyIC0geDEsIHkyIC0geTEpLFxuICAgICAgICBwaXggPSBpbWcuZGF0YTtcblxuICBmb3IgKGxldCBqID0geTEsIGsgPSAwOyBqIDwgeTI7ICsraikge1xuICAgIG9iai4keSA9IGogLSB5MTtcblxuICAgIGZvciAobGV0IGkgPSB4MSwgciA9IGogKiBuOyBpIDwgeDI7ICsraSwgayArPSA0KSB7XG4gICAgICBvYmouJHggPSBpIC0geDE7XG4gICAgICBvYmouJHZhbHVlID0gdmFsdWUoaSArIHIpO1xuICAgICAgY29uc3QgdiA9IGNvbG9yKG9iaik7XG4gICAgICBwaXhbayArIDBdID0gdi5yO1xuICAgICAgcGl4W2sgKyAxXSA9IHYuZztcbiAgICAgIHBpeFtrICsgMl0gPSB2LmI7XG4gICAgICBwaXhbayArIDNdID0gfn4oMjU1ICogb3BhY2l0eShvYmopKTtcbiAgICB9XG4gIH1cblxuICBjdHgucHV0SW1hZ2VEYXRhKGltZywgMCwgMCk7XG4gIHJldHVybiBjYW47XG59XG5cbi8qKlxuICogTWFpbnRhaW5zIGEgY2FydG9ncmFwaGljIHByb2plY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBQcm9qZWN0aW9uKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpOyAvLyBhbHdheXMgdHJlYXQgYXMgbW9kaWZpZWRcbn1cbmluaGVyaXRzKFByb2plY3Rpb24sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBsZXQgcHJvaiA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAoIXByb2ogfHwgXy5tb2RpZmllZCgndHlwZScpKSB7XG4gICAgICB0aGlzLnZhbHVlID0gcHJvaiA9IGNyZWF0ZShfLnR5cGUpO1xuICAgICAgcHJvamVjdGlvblByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKF9bcHJvcF0gIT0gbnVsbCkgc2V0KHByb2osIHByb3AsIF9bcHJvcF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2plY3Rpb25Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChfLm1vZGlmaWVkKHByb3ApKSBzZXQocHJvaiwgcHJvcCwgX1twcm9wXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXy5wb2ludFJhZGl1cyAhPSBudWxsKSBwcm9qLnBhdGgucG9pbnRSYWRpdXMoXy5wb2ludFJhZGl1cyk7XG4gICAgaWYgKF8uZml0KSBmaXQocHJvaiwgXyk7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gZml0KHByb2osIF8pIHtcbiAgY29uc3QgZGF0YSA9IGNvbGxlY3RHZW9KU09OKF8uZml0KTtcbiAgXy5leHRlbnQgPyBwcm9qLmZpdEV4dGVudChfLmV4dGVudCwgZGF0YSkgOiBfLnNpemUgPyBwcm9qLmZpdFNpemUoXy5zaXplLCBkYXRhKSA6IDA7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gcHJvamVjdGlvbigodHlwZSB8fCAnbWVyY2F0b3InKS50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKCFjb25zdHJ1Y3RvcikgZXJyb3IoJ1VucmVjb2duaXplZCBwcm9qZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yKCk7XG59XG5cbmZ1bmN0aW9uIHNldChwcm9qLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Z1bmN0aW9uKHByb2pba2V5XSkpIHByb2pba2V5XSh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3RHZW9KU09OKGRhdGEpIHtcbiAgZGF0YSA9IGFycmF5KGRhdGEpO1xuICByZXR1cm4gZGF0YS5sZW5ndGggPT09IDEgPyBkYXRhWzBdIDoge1xuICAgIHR5cGU6IEZlYXR1cmVDb2xsZWN0aW9uLFxuICAgIGZlYXR1cmVzOiBkYXRhLnJlZHVjZSgoYSwgZikgPT4gYS5jb25jYXQoZmVhdHVyaXplKGYpKSwgW10pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGZlYXR1cml6ZShmKSB7XG4gIHJldHVybiBmLnR5cGUgPT09IEZlYXR1cmVDb2xsZWN0aW9uID8gZi5mZWF0dXJlcyA6IGFycmF5KGYpLmZpbHRlcihkID0+IGQgIT0gbnVsbCkubWFwKGQgPT4gZC50eXBlID09PSBGZWF0dXJlID8gZCA6IHtcbiAgICB0eXBlOiBGZWF0dXJlLFxuICAgIGdlb21ldHJ5OiBkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb250b3VyIGFzIGNvbnRvdXIsIEdlb0pTT04gYXMgZ2VvanNvbiwgR2VvUGF0aCBhcyBnZW9wYXRoLCBHZW9Qb2ludCBhcyBnZW9wb2ludCwgR2VvU2hhcGUgYXMgZ2Vvc2hhcGUsIEdyYXRpY3VsZSBhcyBncmF0aWN1bGUsIEhlYXRtYXAgYXMgaGVhdG1hcCwgSXNvY29udG91ciBhcyBpc29jb250b3VyLCBLREUyRCBhcyBrZGUyZCwgUHJvamVjdGlvbiBhcyBwcm9qZWN0aW9uIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIGlzVHVwbGUsIGluZ2VzdCwgdHVwbGVpZCwgc3RhYmxlQ29tcGFyZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGVycm9yLCBhcnJheSwgb25lLCB0cnV0aHksIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGhpZXJhcmNoeSwgcGFjaywgcGFydGl0aW9uLCBzdHJhdGlmeSwgdHJlZSwgY2x1c3RlciwgdHJlZW1hcCwgdHJlZW1hcEJpbmFyeSwgdHJlZW1hcERpY2UsIHRyZWVtYXBTbGljZSwgdHJlZW1hcFNsaWNlRGljZSwgdHJlZW1hcFNxdWFyaWZ5LCB0cmVlbWFwUmVzcXVhcmlmeSB9IGZyb20gJ2QzLWhpZXJhcmNoeSc7XG5cbi8vIEJ1aWxkIGxvb2t1cCB0YWJsZSBtYXBwaW5nIHR1cGxlIGtleXMgdG8gdHJlZSBub2RlIGluc3RhbmNlc1xuZnVuY3Rpb24gbG9va3VwICh0cmVlLCBrZXksIGZpbHRlcikge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgdHJlZS5lYWNoKG5vZGUgPT4ge1xuICAgIGNvbnN0IHQgPSBub2RlLmRhdGE7XG4gICAgaWYgKGZpbHRlcih0KSkgbWFwW2tleSh0KV0gPSBub2RlO1xuICB9KTtcbiAgdHJlZS5sb29rdXAgPSBtYXA7XG4gIHJldHVybiB0cmVlO1xufVxuXG4vKipcbiAqIE5lc3QgdHVwbGVzIGludG8gYSB0cmVlIHN0cnVjdHVyZSwgZ3JvdXBlZCBieSBrZXkgdmFsdWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMua2V5cyAtIFRoZSBrZXkgZmllbGRzIHRvIG5lc3QgYnksIGluIG9yZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmdlbmVyYXRlPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWZcbiAqICAgbm9uLWxlYWYgbm9kZXMgZ2VuZXJhdGVkIGJ5IHRoaXMgdHJhbnNmb3JtIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAqICAgb3V0cHV0LiBUaGUgZGVmYXVsdCAoZmFsc2UpIGluY2x1ZGVzIG9ubHkgdGhlIGlucHV0IGRhdGEgKGxlYWYgbm9kZXMpXG4gKiAgIGluIHRoZSBkYXRhIHN0cmVhbS5cbiAqL1xuXG5mdW5jdGlvbiBOZXN0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuTmVzdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdOZXN0JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlc291cmNlJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAna2V5cycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dlbmVyYXRlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJ1xuICB9XVxufTtcblxuY29uc3QgY2hpbGRyZW4gPSBuID0+IG4udmFsdWVzO1xuXG5pbmhlcml0cyhOZXN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5zb3VyY2UpIHtcbiAgICAgIGVycm9yKCdOZXN0IHRyYW5zZm9ybSByZXF1aXJlcyBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VuID0gXy5nZW5lcmF0ZSxcbiAgICAgICAgbW9kID0gXy5tb2RpZmllZCgpLFxuICAgICAgICBvdXQgPSBwdWxzZS5jbG9uZSgpLFxuICAgICAgICB0cmVlID0gdGhpcy52YWx1ZTtcblxuICAgIGlmICghdHJlZSB8fCBtb2QgfHwgcHVsc2UuY2hhbmdlZCgpKSB7XG4gICAgICAvLyBjb2xsZWN0IG5vZGVzIHRvIHJlbW92ZVxuICAgICAgaWYgKHRyZWUpIHtcbiAgICAgICAgdHJlZS5lYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuICYmIGlzVHVwbGUobm9kZS5kYXRhKSkge1xuICAgICAgICAgICAgb3V0LnJlbS5wdXNoKG5vZGUuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gZ2VuZXJhdGUgbmV3IHRyZWUgc3RydWN0dXJlXG5cblxuICAgICAgdGhpcy52YWx1ZSA9IHRyZWUgPSBoaWVyYXJjaHkoe1xuICAgICAgICB2YWx1ZXM6IGFycmF5KF8ua2V5cykucmVkdWNlKChuLCBrKSA9PiB7XG4gICAgICAgICAgbi5rZXkoayk7XG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH0sIG5lc3QoKSkuZW50cmllcyhvdXQuc291cmNlKVxuICAgICAgfSwgY2hpbGRyZW4pOyAvLyBjb2xsZWN0IG5vZGVzIHRvIGFkZFxuXG4gICAgICBpZiAoZ2VuKSB7XG4gICAgICAgIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgbm9kZSA9IGluZ2VzdChub2RlLmRhdGEpO1xuICAgICAgICAgICAgb3V0LmFkZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgb3V0LnNvdXJjZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIGJ1aWxkIGxvb2t1cCB0YWJsZVxuXG5cbiAgICAgIGxvb2t1cCh0cmVlLCB0dXBsZWlkLCB0dXBsZWlkKTtcbiAgICB9XG5cbiAgICBvdXQuc291cmNlLnJvb3QgPSB0cmVlO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIG5lc3QoKSB7XG4gIGNvbnN0IGtleXMgPSBbXSxcbiAgICAgICAgbmVzdCA9IHtcbiAgICBlbnRyaWVzOiBhcnJheSA9PiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwKSwgMCksXG4gICAga2V5OiBkID0+IChrZXlzLnB1c2goZCksIG5lc3QpXG4gIH07XG5cbiAgZnVuY3Rpb24gYXBwbHkoYXJyYXksIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBrZXkgPSBrZXlzW2RlcHRoKytdLFxuICAgICAgICAgIHZhbHVlc0J5S2V5ID0ge30sXG4gICAgICAgICAgcmVzdWx0ID0ge307XG4gICAgbGV0IGkgPSAtMSxcbiAgICAgICAga2V5VmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZXM7XG5cbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAga2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyAnJztcblxuICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5W2tleVZhbHVlXSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNCeUtleVtrZXlWYWx1ZV0gPSBbdmFsdWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoa2V5VmFsdWUgaW4gdmFsdWVzQnlLZXkpIHtcbiAgICAgIHJlc3VsdFtrZXlWYWx1ZV0gPSBhcHBseSh2YWx1ZXNCeUtleVtrZXlWYWx1ZV0sIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgaWYgKCsrZGVwdGggPiBrZXlzLmxlbmd0aCkgcmV0dXJuIG1hcDtcbiAgICBjb25zdCBhcnJheSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XG4gICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZXM6IGVudHJpZXMobWFwW2tleV0sIGRlcHRoKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgcmV0dXJuIG5lc3Q7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIHRyZWUgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gSGllcmFyY2h5TGF5b3V0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuXG5jb25zdCBkZWZhdWx0U2VwYXJhdGlvbiA9IChhLCBiKSA9PiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcblxuaW5oZXJpdHMoSGllcmFyY2h5TGF5b3V0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5zb3VyY2UgfHwgIXB1bHNlLnNvdXJjZS5yb290KSB7XG4gICAgICBlcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnIHRyYW5zZm9ybSByZXF1aXJlcyBhIGJhY2tpbmcgdHJlZSBkYXRhIHNvdXJjZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsYXlvdXQgPSB0aGlzLmxheW91dChfLm1ldGhvZCksXG4gICAgICAgICAgZmllbGRzID0gdGhpcy5maWVsZHMsXG4gICAgICAgICAgcm9vdCA9IHB1bHNlLnNvdXJjZS5yb290LFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBmaWVsZHM7XG4gICAgaWYgKF8uZmllbGQpIHJvb3Quc3VtKF8uZmllbGQpO2Vsc2Ugcm9vdC5jb3VudCgpO1xuICAgIGlmIChfLnNvcnQpIHJvb3Quc29ydChzdGFibGVDb21wYXJlKF8uc29ydCwgZCA9PiBkLmRhdGEpKTtcbiAgICBzZXRQYXJhbXMobGF5b3V0LCB0aGlzLnBhcmFtcywgXyk7XG5cbiAgICBpZiAobGF5b3V0LnNlcGFyYXRpb24pIHtcbiAgICAgIGxheW91dC5zZXBhcmF0aW9uKF8uc2VwYXJhdGlvbiAhPT0gZmFsc2UgPyBkZWZhdWx0U2VwYXJhdGlvbiA6IG9uZSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudmFsdWUgPSBsYXlvdXQocm9vdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvcihlcnIpO1xuICAgIH1cblxuICAgIHJvb3QuZWFjaChub2RlID0+IHNldEZpZWxkcyhub2RlLCBmaWVsZHMsIGFzKSk7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKS5tb2RpZmllcygnbGVhZicpO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzZXRQYXJhbXMobGF5b3V0LCBwYXJhbXMsIF8pIHtcbiAgZm9yIChsZXQgcCwgaSA9IDAsIG4gPSBwYXJhbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgcCA9IHBhcmFtc1tpXTtcbiAgICBpZiAocCBpbiBfKSBsYXlvdXRbcF0oX1twXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RmllbGRzKG5vZGUsIGZpZWxkcywgYXMpIHtcbiAgY29uc3QgdCA9IG5vZGUuZGF0YSxcbiAgICAgICAgbiA9IGZpZWxkcy5sZW5ndGggLSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgdFthc1tpXV0gPSBub2RlW2ZpZWxkc1tpXV07XG4gIH1cblxuICB0W2FzW25dXSA9IG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuLmxlbmd0aCA6IDA7XG59XG5cbmNvbnN0IE91dHB1dCA9IFsneCcsICd5JywgJ3InLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcbi8qKlxuICogUGFja2VkIGNpcmNsZSB0cmVlIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gc2l6ZSBub2Rlcy5cbiAqL1xuXG5mdW5jdGlvbiBQYWNrKHBhcmFtcykge1xuICBIaWVyYXJjaHlMYXlvdXQuY2FsbCh0aGlzLCBwYXJhbXMpO1xufVxuUGFjay5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQYWNrJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlJzogdHJ1ZSxcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NvcnQnLFxuICAgICd0eXBlJzogJ2NvbXBhcmUnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncmFkaXVzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2RlZmF1bHQnOiBudWxsXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IE91dHB1dC5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhQYWNrLCBIaWVyYXJjaHlMYXlvdXQsIHtcbiAgbGF5b3V0OiBwYWNrLFxuICBwYXJhbXM6IFsncmFkaXVzJywgJ3NpemUnLCAncGFkZGluZyddLFxuICBmaWVsZHM6IE91dHB1dFxufSk7XG5cbmNvbnN0IE91dHB1dCQxID0gWyd4MCcsICd5MCcsICd4MScsICd5MScsICdkZXB0aCcsICdjaGlsZHJlbiddO1xuLyoqXG4gKiBQYXJ0aXRpb24gdHJlZSBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgbm9kZXMuXG4gKi9cblxuZnVuY3Rpb24gUGFydGl0aW9uKHBhcmFtcykge1xuICBIaWVyYXJjaHlMYXlvdXQuY2FsbCh0aGlzLCBwYXJhbXMpO1xufVxuUGFydGl0aW9uLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1BhcnRpdGlvbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3JvdW5kJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IE91dHB1dCQxLmxlbmd0aCxcbiAgICAnZGVmYXVsdCc6IE91dHB1dCQxXG4gIH1dXG59O1xuaW5oZXJpdHMoUGFydGl0aW9uLCBIaWVyYXJjaHlMYXlvdXQsIHtcbiAgbGF5b3V0OiBwYXJ0aXRpb24sXG4gIHBhcmFtczogWydzaXplJywgJ3JvdW5kJywgJ3BhZGRpbmcnXSxcbiAgZmllbGRzOiBPdXRwdXQkMVxufSk7XG5cbi8qKlxuICogU3RyYXRpZnkgYSBjb2xsZWN0aW9uIG9mIHR1cGxlcyBpbnRvIGEgdHJlZSBzdHJ1Y3R1cmUgYmFzZWQgb25cbiAqIGlkIGFuZCBwYXJlbnQgaWQgZmllbGRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5rZXkgLSBVbmlxdWUga2V5IGZpZWxkIGZvciBlYWNoIHR1cGxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMucGFyZW50S2V5IC0gRmllbGQgd2l0aCBrZXkgZm9yIHBhcmVudCB0dXBsZS5cbiAqL1xuXG5mdW5jdGlvbiBTdHJhdGlmeShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblN0cmF0aWZ5LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1N0cmF0aWZ5JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlc291cmNlJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXJlbnRLZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoU3RyYXRpZnksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAoIXB1bHNlLnNvdXJjZSkge1xuICAgICAgZXJyb3IoJ1N0cmF0aWZ5IHRyYW5zZm9ybSByZXF1aXJlcyBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS4nKTtcbiAgICB9XG5cbiAgICBsZXQgdHJlZSA9IHRoaXMudmFsdWU7XG5cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCksXG4gICAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSksXG4gICAgICAgICAgcnVuID0gIXRyZWUgfHwgbW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgcHVsc2UubW9kaWZpZWQoXy5rZXkuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZChfLnBhcmVudEtleS5maWVsZHMpOyAvLyBwcmV2ZW50IHVwc3RyZWFtIHNvdXJjZSBwb2xsdXRpb25cblxuXG4gICAgb3V0LnNvdXJjZSA9IG91dC5zb3VyY2Uuc2xpY2UoKTtcblxuICAgIGlmIChydW4pIHtcbiAgICAgIHRyZWUgPSBvdXQuc291cmNlLmxlbmd0aCA/IGxvb2t1cChzdHJhdGlmeSgpLmlkKF8ua2V5KS5wYXJlbnRJZChfLnBhcmVudEtleSkob3V0LnNvdXJjZSksIF8ua2V5LCB0cnV0aHkpIDogbG9va3VwKHN0cmF0aWZ5KCkoW3t9XSksIF8ua2V5LCBfLmtleSk7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZS5yb290ID0gdGhpcy52YWx1ZSA9IHRyZWU7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgTGF5b3V0cyA9IHtcbiAgdGlkeTogdHJlZSxcbiAgY2x1c3RlcjogY2x1c3RlclxufTtcbmNvbnN0IE91dHB1dCQyID0gWyd4JywgJ3knLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcbi8qKlxuICogVHJlZSBsYXlvdXQuIERlcGVuZGluZyBvbiB0aGUgbWV0aG9kIHBhcmFtZXRlciwgcGVyZm9ybXMgZWl0aGVyXG4gKiBSZWluZ29sZC1UaWxmb3JkICd0aWR5JyBsYXlvdXQgb3IgZGVuZHJvZ3JhbSAnY2x1c3RlcicgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gVHJlZShwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblRyZWUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVHJlZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd0aWR5JyxcbiAgICAndmFsdWVzJzogWyd0aWR5JywgJ2NsdXN0ZXInXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdub2RlU2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzZXBhcmF0aW9uJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IE91dHB1dCQyLmxlbmd0aCxcbiAgICAnZGVmYXVsdCc6IE91dHB1dCQyXG4gIH1dXG59O1xuaW5oZXJpdHMoVHJlZSwgSGllcmFyY2h5TGF5b3V0LCB7XG4gIC8qKlxuICAgKiBUcmVlIGxheW91dCBnZW5lcmF0b3IuIFN1cHBvcnRzIGJvdGggJ3RpZHknIGFuZCAnY2x1c3RlcicgbGF5b3V0cy5cbiAgICovXG4gIGxheW91dChtZXRob2QpIHtcbiAgICBjb25zdCBtID0gbWV0aG9kIHx8ICd0aWR5JztcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoTGF5b3V0cywgbSkpIHJldHVybiBMYXlvdXRzW21dKCk7ZWxzZSBlcnJvcignVW5yZWNvZ25pemVkIFRyZWUgbGF5b3V0IG1ldGhvZDogJyArIG0pO1xuICB9LFxuXG4gIHBhcmFtczogWydzaXplJywgJ25vZGVTaXplJ10sXG4gIGZpZWxkczogT3V0cHV0JDJcbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlIHR1cGxlcyByZXByZXNlbnRpbmcgbGlua3MgYmV0d2VlbiB0cmVlIG5vZGVzLlxuICogVGhlIHJlc3VsdGluZyB0dXBsZXMgd2lsbCBjb250YWluICdzb3VyY2UnIGFuZCAndGFyZ2V0JyBmaWVsZHMsXG4gKiB3aGljaCBwb2ludCB0byBwYXJlbnQgYW5kIGNoaWxkIG5vZGUgdHVwbGVzLCByZXNwZWN0aXZlbHkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuXG5mdW5jdGlvbiBUcmVlTGlua3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuVHJlZUxpbmtzLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RyZWVMaW5rcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbXVxufTtcbmluaGVyaXRzKFRyZWVMaW5rcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGxpbmtzID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICB0cmVlID0gcHVsc2Uuc291cmNlICYmIHB1bHNlLnNvdXJjZS5yb290LFxuICAgICAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgICAgICBsdXQgPSB7fTtcbiAgICBpZiAoIXRyZWUpIGVycm9yKCdUcmVlTGlua3MgdHJhbnNmb3JtIHJlcXVpcmVzIGEgdHJlZSBkYXRhIHNvdXJjZS4nKTtcblxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pKSB7XG4gICAgICAvLyByZW1vdmUgcHJldmlvdXMgbGlua3NcbiAgICAgIG91dC5yZW0gPSBsaW5rczsgLy8gYnVpbGQgbG9va3VwIHRhYmxlIG9mIHZhbGlkIHR1cGxlc1xuXG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gbHV0W3R1cGxlaWQodCldID0gMSk7IC8vIGdlbmVyYXRlIGxpbmtzIGZvciBhbGwgZWRnZXMgaW5jaWRlbnQgb24gdmFsaWQgdHVwbGVzXG5cbiAgICAgIHRyZWUuZWFjaChub2RlID0+IHtcbiAgICAgICAgY29uc3QgdCA9IG5vZGUuZGF0YSxcbiAgICAgICAgICAgICAgcCA9IG5vZGUucGFyZW50ICYmIG5vZGUucGFyZW50LmRhdGE7XG5cbiAgICAgICAgaWYgKHAgJiYgbHV0W3R1cGxlaWQodCldICYmIGx1dFt0dXBsZWlkKHApXSkge1xuICAgICAgICAgIG91dC5hZGQucHVzaChpbmdlc3Qoe1xuICAgICAgICAgICAgc291cmNlOiBwLFxuICAgICAgICAgICAgdGFyZ2V0OiB0XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkO1xuICAgIH0gZWxzZSBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5NT0QpKSB7XG4gICAgICAvLyBidWlsZCBsb29rdXAgdGFibGUgb2YgbW9kaWZpZWQgdHVwbGVzXG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4gbHV0W3R1cGxlaWQodCldID0gMSk7IC8vIGdhdGhlciBsaW5rcyBpbmNpZGVudCBvbiBtb2RpZmllZCB0dXBsZXNcblxuICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgaWYgKGx1dFt0dXBsZWlkKGxpbmsuc291cmNlKV0gfHwgbHV0W3R1cGxlaWQobGluay50YXJnZXQpXSkge1xuICAgICAgICAgIG91dC5tb2QucHVzaChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgVGlsZXMgPSB7XG4gIGJpbmFyeTogdHJlZW1hcEJpbmFyeSxcbiAgZGljZTogdHJlZW1hcERpY2UsXG4gIHNsaWNlOiB0cmVlbWFwU2xpY2UsXG4gIHNsaWNlZGljZTogdHJlZW1hcFNsaWNlRGljZSxcbiAgc3F1YXJpZnk6IHRyZWVtYXBTcXVhcmlmeSxcbiAgcmVzcXVhcmlmeTogdHJlZW1hcFJlc3F1YXJpZnlcbn07XG5jb25zdCBPdXRwdXQkMyA9IFsneDAnLCAneTAnLCAneDEnLCAneTEnLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcbi8qKlxuICogVHJlZW1hcCBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgbm9kZXMuXG4gKi9cblxuZnVuY3Rpb24gVHJlZW1hcChwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblRyZWVtYXAuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVHJlZW1hcCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICdzcXVhcmlmeScsXG4gICAgJ3ZhbHVlcyc6IFsnc3F1YXJpZnknLCAncmVzcXVhcmlmeScsICdiaW5hcnknLCAnZGljZScsICdzbGljZScsICdzbGljZWRpY2UnXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdJbm5lcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdPdXRlcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdUb3AnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nUmlnaHQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nQm90dG9tJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ0xlZnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyYXRpbycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEuNjE4MDMzOTg4NzQ5ODk1XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyb3VuZCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQkMy5sZW5ndGgsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXQkM1xuICB9XVxufTtcbmluaGVyaXRzKFRyZWVtYXAsIEhpZXJhcmNoeUxheW91dCwge1xuICAvKipcbiAgICogVHJlZW1hcCBsYXlvdXQgZ2VuZXJhdG9yLiBBZGRzICdtZXRob2QnIGFuZCAncmF0aW8nIHBhcmFtZXRlcnNcbiAgICogdG8gY29uZmlndXJlIHRoZSB1bmRlcmx5aW5nIHRpbGUgbWV0aG9kLlxuICAgKi9cbiAgbGF5b3V0KCkge1xuICAgIGNvbnN0IHggPSB0cmVlbWFwKCk7XG5cbiAgICB4LnJhdGlvID0gXyA9PiB7XG4gICAgICBjb25zdCB0ID0geC50aWxlKCk7XG4gICAgICBpZiAodC5yYXRpbykgeC50aWxlKHQucmF0aW8oXykpO1xuICAgIH07XG5cbiAgICB4Lm1ldGhvZCA9IF8gPT4ge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5KFRpbGVzLCBfKSkgeC50aWxlKFRpbGVzW19dKTtlbHNlIGVycm9yKCdVbnJlY29nbml6ZWQgVHJlZW1hcCBsYXlvdXQgbWV0aG9kOiAnICsgXyk7XG4gICAgfTtcblxuICAgIHJldHVybiB4O1xuICB9LFxuXG4gIHBhcmFtczogWydtZXRob2QnLCAncmF0aW8nLCAnc2l6ZScsICdyb3VuZCcsICdwYWRkaW5nJywgJ3BhZGRpbmdJbm5lcicsICdwYWRkaW5nT3V0ZXInLCAncGFkZGluZ1RvcCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCddLFxuICBmaWVsZHM6IE91dHB1dCQzXG59KTtcblxuZXhwb3J0IHsgTmVzdCBhcyBuZXN0LCBQYWNrIGFzIHBhY2ssIFBhcnRpdGlvbiBhcyBwYXJ0aXRpb24sIFN0cmF0aWZ5IGFzIHN0cmF0aWZ5LCBUcmVlIGFzIHRyZWUsIFRyZWVMaW5rcyBhcyB0cmVlbGlua3MsIFRyZWVtYXAgYXMgdHJlZW1hcCB9O1xuIiwiaW1wb3J0IHsgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuaW1wb3J0IHsgcmVkZXJpdmUsIFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgTWFya3MsIHRleHRNZXRyaWNzIH0gZnJvbSAndmVnYS1zY2VuZWdyYXBoJztcbmltcG9ydCB7IGluaGVyaXRzLCBpc0Z1bmN0aW9uLCBlcnJvciwgYXJyYXkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBBTFBIQV9NQVNLID0gMHhmZjAwMDAwMDsgLy8gYWxwaGEgdmFsdWUgZXF1aXZhbGVudCB0byBvcGFjaXR5IDAuMDYyNVxuXG5jb25zdCBJTlNJREVfT1BBQ0lUWV9JTl9BTFBIQSA9IDB4MTAwMDAwMDA7XG5jb25zdCBJTlNJREVfT1BBQ0lUWSA9IDAuMDYyNTtcbmZ1bmN0aW9uIGJhc2VCaXRtYXBzKCQsIGRhdGEpIHtcbiAgY29uc3QgYml0bWFwID0gJC5iaXRtYXAoKTsgLy8gd2hlbiB0aGVyZSBpcyBubyBiYXNlIG1hcmsgYnV0IGRhdGEgcG9pbnRzIGFyZSB0byBiZSBhdm9pZGVkXG5cbiAgKGRhdGEgfHwgW10pLmZvckVhY2goZCA9PiBiaXRtYXAuc2V0KCQoZC5ib3VuZGFyeVswXSksICQoZC5ib3VuZGFyeVszXSkpKTtcbiAgcmV0dXJuIFtiaXRtYXAsIHVuZGVmaW5lZF07XG59XG5mdW5jdGlvbiBtYXJrQml0bWFwcygkLCBhdm9pZE1hcmtzLCBsYWJlbEluc2lkZSwgaXNHcm91cEFyZWEpIHtcbiAgLy8gY3JlYXRlIGNhbnZhc1xuICBjb25zdCB3aWR0aCA9ICQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9ICQuaGVpZ2h0LFxuICAgICAgICBib3JkZXIgPSBsYWJlbEluc2lkZSB8fCBpc0dyb3VwQXJlYSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpOyAvLyByZW5kZXIgYWxsIG1hcmtzIHRvIGJlIGF2b2lkZWQgaW50byBjYW52YXNcblxuICBhdm9pZE1hcmtzLmZvckVhY2goaXRlbXMgPT4gZHJhdyhjb250ZXh0LCBpdGVtcywgYm9yZGVyKSk7IC8vIGdldCBjYW52YXMgYnVmZmVyLCBjcmVhdGUgYml0bWFwc1xuXG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhLmJ1ZmZlciksXG4gICAgICAgIGxheWVyMSA9ICQuYml0bWFwKCksXG4gICAgICAgIGxheWVyMiA9IGJvcmRlciAmJiAkLmJpdG1hcCgpOyAvLyBwb3B1bGF0ZSBiaXRtYXAgbGF5ZXJzXG5cbiAgbGV0IHgsIHksIHUsIHYsIGFscGhhO1xuXG4gIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSkge1xuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICBhbHBoYSA9IGJ1ZmZlclt5ICogd2lkdGggKyB4XSAmIEFMUEhBX01BU0s7XG5cbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICB1ID0gJCh4KTtcbiAgICAgICAgdiA9ICQoeSk7XG4gICAgICAgIGlmICghaXNHcm91cEFyZWEpIGxheWVyMS5zZXQodSwgdik7IC8vIHVwZGF0ZSBpbnRlcmlvciBiaXRtYXBcblxuICAgICAgICBpZiAoYm9yZGVyICYmIGFscGhhIF4gSU5TSURFX09QQUNJVFlfSU5fQUxQSEEpIGxheWVyMi5zZXQodSwgdik7IC8vIHVwZGF0ZSBib3JkZXIgYml0bWFwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtsYXllcjEsIGxheWVyMl07XG59XG5cbmZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbXMsIGludGVyaW9yKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIGNvbnN0IHR5cGUgPSBpdGVtc1swXS5tYXJrLm1hcmt0eXBlO1xuXG4gIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgaXRlbXMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICBncm91cC5pdGVtcy5mb3JFYWNoKG1hcmsgPT4gZHJhdyhjb250ZXh0LCBtYXJrLml0ZW1zLCBpbnRlcmlvcikpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIE1hcmtzW3R5cGVdLmRyYXcoY29udGV4dCwge1xuICAgICAgaXRlbXM6IGludGVyaW9yID8gaXRlbXMubWFwKHByZXBhcmUpIDogaXRlbXNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBQcmVwYXJlIGl0ZW0gYmVmb3JlIGRyYXdpbmcgaW50byBjYW52YXMgKHNldHRpbmcgc3Ryb2tlIGFuZCBvcGFjaXR5KVxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBpdGVtIHRvIGJlIHByZXBhcmVkXG4gKiBAcmV0dXJucyBwcmVwYXJlZCBpdGVtXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlKHNvdXJjZSkge1xuICBjb25zdCBpdGVtID0gcmVkZXJpdmUoc291cmNlLCB7fSk7XG5cbiAgaWYgKGl0ZW0uc3Ryb2tlKSB7XG4gICAgaXRlbS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgfVxuXG4gIGlmIChpdGVtLmZpbGwpIHtcbiAgICBpdGVtLmZpbGxPcGFjaXR5ID0gSU5TSURFX09QQUNJVFk7XG4gICAgaXRlbS5zdHJva2UgPSAnIzAwMCc7XG4gICAgaXRlbS5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICBpdGVtLnN0cm9rZVdpZHRoID0gMjtcbiAgfVxuXG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBESVYgPSA1LFxuICAgICAgLy8gYml0IHNoaWZ0IGZyb20geCwgeSBpbmRleCB0byBiaXQgdmVjdG9yIGFycmF5IGluZGV4XG5NT0QgPSAzMSxcbiAgICAgIC8vIGJpdCBtYXNrIGZvciBpbmRleCBsb29rdXAgd2l0aGluIGEgYml0IHZlY3RvclxuU0laRSA9IDMyLFxuICAgICAgLy8gaW5kaXZpZHVhbCBiaXQgdmVjdG9yIHNpemVcblJJR0hUMCA9IG5ldyBVaW50MzJBcnJheShTSVpFICsgMSksXG4gICAgICAvLyBsZWZ0LWFuY2hvcmVkIGJpdCB2ZWN0b3JzLCBmdWxsIC0+IDBcblJJR0hUMSA9IG5ldyBVaW50MzJBcnJheShTSVpFICsgMSk7IC8vIHJpZ2h0LWFuY2hvcmVkIGJpdCB2ZWN0b3JzLCAwIC0+IGZ1bGxcblxuUklHSFQxWzBdID0gMDtcblJJR0hUMFswXSA9IH5SSUdIVDFbMF07XG5cbmZvciAobGV0IGkgPSAxOyBpIDw9IFNJWkU7ICsraSkge1xuICBSSUdIVDFbaV0gPSBSSUdIVDFbaSAtIDFdIDw8IDEgfCAxO1xuICBSSUdIVDBbaV0gPSB+UklHSFQxW2ldO1xufVxuXG5mdW5jdGlvbiBCaXRtYXAgKHcsIGgpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkofn4oKHcgKiBoICsgU0laRSkgLyBTSVpFKSk7XG5cbiAgZnVuY3Rpb24gX3NldChpbmRleCwgbWFzaykge1xuICAgIGFycmF5W2luZGV4XSB8PSBtYXNrO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsZWFyKGluZGV4LCBtYXNrKSB7XG4gICAgYXJyYXlbaW5kZXhdICY9IG1hc2s7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFycmF5OiBhcnJheSxcbiAgICBnZXQ6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcbiAgICAgIHJldHVybiBhcnJheVtpbmRleCA+Pj4gRElWXSAmIDEgPDwgKGluZGV4ICYgTU9EKTtcbiAgICB9LFxuICAgIHNldDogKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geSAqIHcgKyB4O1xuXG4gICAgICBfc2V0KGluZGV4ID4+PiBESVYsIDEgPDwgKGluZGV4ICYgTU9EKSk7XG4gICAgfSxcbiAgICBjbGVhcjogKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geSAqIHcgKyB4O1xuXG4gICAgICBfY2xlYXIoaW5kZXggPj4+IERJViwgfigxIDw8IChpbmRleCAmIE1PRCkpKTtcbiAgICB9LFxuICAgIGdldFJhbmdlOiAoeCwgeSwgeDIsIHkyKSA9PiB7XG4gICAgICBsZXQgciA9IHkyLFxuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgICBpbmRleFN0YXJ0LFxuICAgICAgICAgIGluZGV4RW5kO1xuXG4gICAgICBmb3IgKDsgciA+PSB5OyAtLXIpIHtcbiAgICAgICAgc3RhcnQgPSByICogdyArIHg7XG4gICAgICAgIGVuZCA9IHIgKiB3ICsgeDI7XG4gICAgICAgIGluZGV4U3RhcnQgPSBzdGFydCA+Pj4gRElWO1xuICAgICAgICBpbmRleEVuZCA9IGVuZCA+Pj4gRElWO1xuXG4gICAgICAgIGlmIChpbmRleFN0YXJ0ID09PSBpbmRleEVuZCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleFN0YXJ0XSAmIFJJR0hUMFtzdGFydCAmIE1PRF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleFN0YXJ0XSAmIFJJR0hUMFtzdGFydCAmIE1PRF0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleEVuZF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSkgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXhTdGFydCArIDE7IGkgPCBpbmRleEVuZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXRSYW5nZTogKHgsIHksIHgyLCB5MikgPT4ge1xuICAgICAgbGV0IHN0YXJ0LCBlbmQsIGluZGV4U3RhcnQsIGluZGV4RW5kLCBpO1xuXG4gICAgICBmb3IgKDsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgIHN0YXJ0ID0geSAqIHcgKyB4O1xuICAgICAgICBlbmQgPSB5ICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcblxuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBfc2V0KGluZGV4U3RhcnQsIFJJR0hUMFtzdGFydCAmIE1PRF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NldChpbmRleFN0YXJ0LCBSSUdIVDBbc3RhcnQgJiBNT0RdKTtcblxuICAgICAgICAgIF9zZXQoaW5kZXhFbmQsIFJJR0hUMVsoZW5kICYgTU9EKSArIDFdKTtcblxuICAgICAgICAgIGZvciAoaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkgX3NldChpLCAweGZmZmZmZmZmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXJSYW5nZTogKHgsIHksIHgyLCB5MikgPT4ge1xuICAgICAgbGV0IHN0YXJ0LCBlbmQsIGluZGV4U3RhcnQsIGluZGV4RW5kLCBpO1xuXG4gICAgICBmb3IgKDsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgIHN0YXJ0ID0geSAqIHcgKyB4O1xuICAgICAgICBlbmQgPSB5ICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcblxuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBfY2xlYXIoaW5kZXhTdGFydCwgUklHSFQxW3N0YXJ0ICYgTU9EXSB8IFJJR0hUMFsoZW5kICYgTU9EKSArIDFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY2xlYXIoaW5kZXhTdGFydCwgUklHSFQxW3N0YXJ0ICYgTU9EXSk7XG5cbiAgICAgICAgICBfY2xlYXIoaW5kZXhFbmQsIFJJR0hUMFsoZW5kICYgTU9EKSArIDFdKTtcblxuICAgICAgICAgIGZvciAoaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkgX2NsZWFyKGksIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvdXRPZkJvdW5kczogKHgsIHksIHgyLCB5MikgPT4geCA8IDAgfHwgeSA8IDAgfHwgeTIgPj0gaCB8fCB4MiA+PSB3XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYWxlciAod2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBjb25zdCByYXRpbyA9IE1hdGgubWF4KDEsIE1hdGguc3FydCh3aWR0aCAqIGhlaWdodCAvIDFlNikpLFxuICAgICAgICB3ID0gfn4oKHdpZHRoICsgMiAqIHBhZGRpbmcgKyByYXRpbykgLyByYXRpbyksXG4gICAgICAgIGggPSB+figoaGVpZ2h0ICsgMiAqIHBhZGRpbmcgKyByYXRpbykgLyByYXRpbyksXG4gICAgICAgIHNjYWxlID0gXyA9PiB+figoXyArIHBhZGRpbmcpIC8gcmF0aW8pO1xuXG4gIHNjYWxlLmludmVydCA9IF8gPT4gXyAqIHJhdGlvIC0gcGFkZGluZztcblxuICBzY2FsZS5iaXRtYXAgPSAoKSA9PiBCaXRtYXAodywgaCk7XG5cbiAgc2NhbGUucmF0aW8gPSByYXRpbztcbiAgc2NhbGUucGFkZGluZyA9IHBhZGRpbmc7XG4gIHNjYWxlLndpZHRoID0gd2lkdGg7XG4gIHNjYWxlLmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBwbGFjZUFyZWFMYWJlbE5haXZlICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodDsgLy8gdHJ5IHRvIHBsYWNlIGEgbGFiZWwgd2l0aGluIGFuIGlucHV0IGFyZWEgbWFya1xuXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGl0ZW1zID0gZC5kYXR1bS5kYXR1bS5pdGVtc1ttYXJrSW5kZXhdLml0ZW1zLFxuICAgICAgICAgIC8vIGFyZWEgcG9pbnRzXG4gICAgbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAvLyBudW1iZXIgb2YgcG9pbnRzXG4gICAgdGV4dEhlaWdodCA9IGQuZGF0dW0uZm9udFNpemUsXG4gICAgICAgICAgLy8gbGFiZWwgd2lkdGhcbiAgICB0ZXh0V2lkdGggPSB0ZXh0TWV0cmljcy53aWR0aChkLmRhdHVtLCBkLmRhdHVtLnRleHQpOyAvLyBsYWJlbCBoZWlnaHRcblxuICAgIGxldCBtYXhBcmVhV2lkdGggPSAwLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYXJlYVdpZHRoOyAvLyBmb3IgZWFjaCBhcmVhIHNhbXBsZSBwb2ludFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyO1xuICAgICAgeCA9ICh4MSArIHgyKSAvIDI7XG4gICAgICB5ID0gKHkxICsgeTIpIC8gMjtcbiAgICAgIGFyZWFXaWR0aCA9IE1hdGguYWJzKHgyIC0geDEgKyB5MiAtIHkxKTtcblxuICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGgpIHtcbiAgICAgICAgbWF4QXJlYVdpZHRoID0gYXJlYVdpZHRoO1xuICAgICAgICBkLnggPSB4O1xuICAgICAgICBkLnkgPSB5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHggPSB0ZXh0V2lkdGggLyAyO1xuICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICB4MSA9IGQueCAtIHg7XG4gICAgeDIgPSBkLnggKyB4O1xuICAgIHkxID0gZC55IC0geTtcbiAgICB5MiA9IGQueSArIHk7XG4gICAgZC5hbGlnbiA9ICdjZW50ZXInO1xuXG4gICAgaWYgKHgxIDwgMCAmJiB4MiA8PSB3aWR0aCkge1xuICAgICAgZC5hbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKDAgPD0geDEgJiYgd2lkdGggPCB4Mikge1xuICAgICAgZC5hbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgZC5iYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHkxIDwgMCAmJiB5MiA8PSBoZWlnaHQpIHtcbiAgICAgIGQuYmFzZWxpbmUgPSAndG9wJztcbiAgICB9IGVsc2UgaWYgKDAgPD0geTEgJiYgaGVpZ2h0IDwgeTIpIHtcbiAgICAgIGQuYmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3V0T2ZCb3VuZHMoeCwgeSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGxldCByID0gdGV4dFdpZHRoIC8gMjtcbiAgcmV0dXJuIHggLSByIDwgMCB8fCB4ICsgciA+IHdpZHRoIHx8IHkgLSAociA9IHRleHRIZWlnaHQgLyAyKSA8IDAgfHwgeSArIHIgPiBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIF9vdXRPZkJvdW5kcygpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBoLCBibTAsIGJtMSkge1xuICBjb25zdCB3ID0gdGV4dFdpZHRoICogaCAvICh0ZXh0SGVpZ2h0ICogMiksXG4gICAgICAgIHgxID0gJCh4IC0gdyksXG4gICAgICAgIHgyID0gJCh4ICsgdyksXG4gICAgICAgIHkxID0gJCh5IC0gKGggPSBoIC8gMikpLFxuICAgICAgICB5MiA9ICQoeSArIGgpO1xuICByZXR1cm4gYm0wLm91dE9mQm91bmRzKHgxLCB5MSwgeDIsIHkyKSB8fCBibTAuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpIHx8IGJtMSAmJiBibTEuZ2V0UmFuZ2UoeDEsIHkxLCB4MiwgeTIpO1xufVxuXG5mdW5jdGlvbiBfY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgaCwgYm0wLCBibTEpIHtcbiAgY29uc3QgdyA9IHRleHRXaWR0aCAqIGggLyAodGV4dEhlaWdodCAqIDIpO1xuICBsZXQgeDEgPSAkKHggLSB3KSxcbiAgICAgIHgyID0gJCh4ICsgdyksXG4gICAgICB5MSA9ICQoeSAtIChoID0gaCAvIDIpKSxcbiAgICAgIHkyID0gJCh5ICsgaCk7XG4gIHgxID0geDEgPiAwID8geDEgOiAwO1xuICB5MSA9IHkxID4gMCA/IHkxIDogMDtcbiAgeDIgPSB4MiA8ICQud2lkdGggPyB4MiA6ICQud2lkdGggLSAxO1xuICB5MiA9IHkyIDwgJC5oZWlnaHQgPyB5MiA6ICQuaGVpZ2h0IC0gMTtcbiAgcmV0dXJuIGJtMC5nZXRSYW5nZSh4MSwgeTEsIHgyLCB5MikgfHwgYm0xICYmIGJtMS5nZXRSYW5nZSh4MSwgeTEsIHgyLCB5Mik7XG59XG5cbmZ1bmN0aW9uIGdldFRlc3RzKGluZlBhZGRpbmcpIHtcbiAgcmV0dXJuIGluZlBhZGRpbmcgPyBbX2NvbGxpc2lvbiwgX291dE9mQm91bmRzXSA6IFtjb2xsaXNpb24sIG91dE9mQm91bmRzXTtcbn1cblxuZnVuY3Rpb24gcGxhY2VBcmVhTGFiZWxSZWR1Y2VkU2VhcmNoICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgsIGluZlBhZGRpbmcpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgW2NvbGxpc2lvbiwgb3V0T2ZCb3VuZHNdID0gZ2V0VGVzdHMoaW5mUGFkZGluZyksXG4gICAgICAgIGJtMCA9IGJpdG1hcHNbMF0sXG4gICAgICAgIC8vIHdoZXJlIGxhYmVscyBoYXZlIGJlZW4gcGxhY2VkXG4gIGJtMSA9IGJpdG1hcHNbMV07IC8vIGFyZWEgb3V0bGluZXNcblxuICBmdW5jdGlvbiB0cnlMYWJlbChfeCwgX3ksIG1heFNpemUsIHRleHRXaWR0aCwgdGV4dEhlaWdodCkge1xuICAgIGNvbnN0IHggPSAkLmludmVydChfeCksXG4gICAgICAgICAgeSA9ICQuaW52ZXJ0KF95KTtcbiAgICBsZXQgbG8gPSBtYXhTaXplLFxuICAgICAgICBoaSA9IGhlaWdodCxcbiAgICAgICAgbWlkO1xuXG4gICAgaWYgKCFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBsbywgYm0wLCBibTEpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAvLyBpZiB0aGUgbGFiZWwgZml0cyBhdCB0aGUgY3VycmVudCBzYW1wbGUgcG9pbnQsXG4gICAgICAvLyBwZXJmb3JtIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbGFyZ2VzdCBmb250IHNpemUgdGhhdCBmaXRzXG4gICAgICB3aGlsZSAoaGkgLSBsbyA+PSAxKSB7XG4gICAgICAgIG1pZCA9IChsbyArIGhpKSAvIDI7XG5cbiAgICAgICAgaWYgKGNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIG1pZCwgYm0wLCBibTEpKSB7XG4gICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG8gPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcGxhY2UgbGFiZWwgaWYgY3VycmVudCBsb3dlciBib3VuZCBleGNlZWRzIHByaW9yIG1heCBmb250IHNpemVcblxuXG4gICAgICBpZiAobG8gPiBtYXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbeCwgeSwgbG8sIHRydWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0cnkgdG8gcGxhY2UgYSBsYWJlbCB3aXRoaW4gYW4gaW5wdXQgYXJlYSBtYXJrXG5cblxuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICBjb25zdCBpdGVtcyA9IGQuZGF0dW0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5pdGVtcyxcbiAgICAgICAgICAvLyBhcmVhIHBvaW50c1xuICAgIG4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAgICAgLy8gbnVtYmVyIG9mIHBvaW50c1xuICAgIHRleHRIZWlnaHQgPSBkLmRhdHVtLmZvbnRTaXplLFxuICAgICAgICAgIC8vIGxhYmVsIHdpZHRoXG4gICAgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGgoZC5kYXR1bSwgZC5kYXR1bS50ZXh0KTsgLy8gbGFiZWwgaGVpZ2h0XG5cbiAgICBsZXQgbWF4U2l6ZSA9IGF2b2lkQmFzZU1hcmsgPyB0ZXh0SGVpZ2h0IDogMCxcbiAgICAgICAgbGFiZWxQbGFjZWQgPSBmYWxzZSxcbiAgICAgICAgbGFiZWxQbGFjZWQyID0gZmFsc2UsXG4gICAgICAgIG1heEFyZWFXaWR0aCA9IDAsXG4gICAgICAgIHgxLFxuICAgICAgICB4MixcbiAgICAgICAgeTEsXG4gICAgICAgIHkyLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBfeCxcbiAgICAgICAgX3ksXG4gICAgICAgIF94MSxcbiAgICAgICAgX3hNaWQsXG4gICAgICAgIF94MixcbiAgICAgICAgX3kxLFxuICAgICAgICBfeU1pZCxcbiAgICAgICAgX3kyLFxuICAgICAgICBhcmVhV2lkdGgsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc3dhcFRtcDsgLy8gZm9yIGVhY2ggYXJlYSBzYW1wbGUgcG9pbnRcblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyO1xuXG4gICAgICBpZiAoeDEgPiB4Mikge1xuICAgICAgICBzd2FwVG1wID0geDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcFRtcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHkxID4geTIpIHtcbiAgICAgICAgc3dhcFRtcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXBUbXA7XG4gICAgICB9XG5cbiAgICAgIF94MSA9ICQoeDEpO1xuICAgICAgX3gyID0gJCh4Mik7XG4gICAgICBfeE1pZCA9IH5+KChfeDEgKyBfeDIpIC8gMik7XG4gICAgICBfeTEgPSAkKHkxKTtcbiAgICAgIF95MiA9ICQoeTIpO1xuICAgICAgX3lNaWQgPSB+figoX3kxICsgX3kyKSAvIDIpOyAvLyBzZWFyY2ggYWxvbmcgdGhlIGxpbmUgZnJvbSBtaWQgcG9pbnQgYmV0d2VlbiB0aGUgMiBib3JkZXIgdG8gbG93ZXIgYm9yZGVyXG5cbiAgICAgIGZvciAoX3ggPSBfeE1pZDsgX3ggPj0gX3gxOyAtLV94KSB7XG4gICAgICAgIGZvciAoX3kgPSBfeU1pZDsgX3kgPj0gX3kxOyAtLV95KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ5TGFiZWwoX3gsIF95LCBtYXhTaXplLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgW2QueCwgZC55LCBtYXhTaXplLCBsYWJlbFBsYWNlZF0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIHNlYXJjaCBhbG9uZyB0aGUgbGluZSBmcm9tIG1pZCBwb2ludCBiZXR3ZWVuIHRoZSAyIGJvcmRlciB0byB1cHBlciBib3JkZXJcblxuXG4gICAgICBmb3IgKF94ID0gX3hNaWQ7IF94IDw9IF94MjsgKytfeCkge1xuICAgICAgICBmb3IgKF95ID0gX3lNaWQ7IF95IDw9IF95MjsgKytfeSkge1xuICAgICAgICAgIHJlc3VsdCA9IHRyeUxhYmVsKF94LCBfeSwgbWF4U2l6ZSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIFtkLngsIGQueSwgbWF4U2l6ZSwgbGFiZWxQbGFjZWRdID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBwbGFjZSBsYWJlbCBhdCBzbGljZSBjZW50ZXIgaWYgbm90IHBsYWNlZCB0aHJvdWdoIG90aGVyIG1lYW5zXG4gICAgICAvLyBhbmQgaWYgd2UncmUgbm90IGF2b2lkaW5nIG92ZXJsYXAgd2l0aCBvdGhlciBhcmVhc1xuXG5cbiAgICAgIGlmICghbGFiZWxQbGFjZWQgJiYgIWF2b2lkQmFzZU1hcmspIHtcbiAgICAgICAgLy8gb25lIHNwYW4gaXMgemVybywgaGVuY2Ugd2UgY2FuIGFkZFxuICAgICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG4gICAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTIpIC8gMjsgLy8gcGxhY2UgbGFiZWwgaWYgaXQgZml0cyBhbmQgaW1wcm92ZXMgdGhlIG1heCBhcmVhIHdpZHRoXG5cbiAgICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGggJiYgIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICBtYXhBcmVhV2lkdGggPSBhcmVhV2lkdGg7XG4gICAgICAgICAgZC54ID0geDtcbiAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgIGxhYmVsUGxhY2VkMiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlY29yZCBjdXJyZW50IGxhYmVsIHBsYWNlbWVudCBpbmZvcm1hdGlvbiwgdXBkYXRlIGxhYmVsIGJpdG1hcFxuXG5cbiAgICBpZiAobGFiZWxQbGFjZWQgfHwgbGFiZWxQbGFjZWQyKSB7XG4gICAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICAgIGJtMC5zZXRSYW5nZSgkKGQueCAtIHgpLCAkKGQueSAtIHkpLCAkKGQueCArIHgpLCAkKGQueSArIHkpKTtcbiAgICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBYX0RJUiA9IFstMSwgLTEsIDEsIDFdO1xuY29uc3QgWV9ESVIgPSBbLTEsIDEsIC0xLCAxXTtcbmZ1bmN0aW9uIHBsYWNlQXJlYUxhYmVsRmxvb2RGaWxsICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgsIGluZlBhZGRpbmcpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICAgICAgW2NvbGxpc2lvbiwgb3V0T2ZCb3VuZHNdID0gZ2V0VGVzdHMoaW5mUGFkZGluZyksXG4gICAgICAgIGJtMCA9IGJpdG1hcHNbMF0sXG4gICAgICAgIC8vIHdoZXJlIGxhYmVscyBoYXZlIGJlZW4gcGxhY2VkXG4gIGJtMSA9IGJpdG1hcHNbMV0sXG4gICAgICAgIC8vIGFyZWEgb3V0bGluZXNcbiAgYm0yID0gJC5iaXRtYXAoKTsgLy8gZmxvb2QtZmlsbCB2aXNpdGF0aW9uc1xuICAvLyB0cnkgdG8gcGxhY2UgYSBsYWJlbCB3aXRoaW4gYW4gaW5wdXQgYXJlYSBtYXJrXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXMsXG4gICAgICAgICAgLy8gYXJlYSBwb2ludHNcbiAgICBuID0gaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIC8vIG51bWJlciBvZiBwb2ludHNcbiAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZSxcbiAgICAgICAgICAvLyBsYWJlbCB3aWR0aFxuICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCksXG4gICAgICAgICAgLy8gbGFiZWwgaGVpZ2h0XG4gICAgc3RhY2sgPSBbXTsgLy8gZmxvb2QgZmlsbCBzdGFja1xuXG4gICAgbGV0IG1heFNpemUgPSBhdm9pZEJhc2VNYXJrID8gdGV4dEhlaWdodCA6IDAsXG4gICAgICAgIGxhYmVsUGxhY2VkID0gZmFsc2UsXG4gICAgICAgIGxhYmVsUGxhY2VkMiA9IGZhbHNlLFxuICAgICAgICBtYXhBcmVhV2lkdGggPSAwLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgX3gsXG4gICAgICAgIF95LFxuICAgICAgICBsbyxcbiAgICAgICAgaGksXG4gICAgICAgIG1pZCxcbiAgICAgICAgYXJlYVdpZHRoOyAvLyBmb3IgZWFjaCBhcmVhIHNhbXBsZSBwb2ludFxuXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeDEgPSBpdGVtc1tpXS54O1xuICAgICAgeTEgPSBpdGVtc1tpXS55O1xuICAgICAgeDIgPSBpdGVtc1tpXS54MiA9PT0gdW5kZWZpbmVkID8geDEgOiBpdGVtc1tpXS54MjtcbiAgICAgIHkyID0gaXRlbXNbaV0ueTIgPT09IHVuZGVmaW5lZCA/IHkxIDogaXRlbXNbaV0ueTI7IC8vIGFkZCBzY2FsZWQgY2VudGVyIHBvaW50IHRvIHN0YWNrXG5cbiAgICAgIHN0YWNrLnB1c2goWyQoKHgxICsgeDIpIC8gMiksICQoKHkxICsgeTIpIC8gMildKTsgLy8gcGVyZm9ybSBmbG9vZCBmaWxsLCB2aXNpdCBwb2ludHNcblxuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBbX3gsIF95XSA9IHN0YWNrLnBvcCgpOyAvLyBleGl0IGlmIHBvaW50IGFscmVhZHkgbWFya2VkXG5cbiAgICAgICAgaWYgKGJtMC5nZXQoX3gsIF95KSB8fCBibTEuZ2V0KF94LCBfeSkgfHwgYm0yLmdldChfeCwgX3kpKSBjb250aW51ZTsgLy8gbWFyayBwb2ludCBpbiBmbG9vZCBmaWxsIGJpdG1hcFxuICAgICAgICAvLyBhZGQgc2VhcmNoIHBvaW50cyBmb3IgYWxsIChpbiBib3VuZCkgZGlyZWN0aW9uc1xuXG4gICAgICAgIGJtMi5zZXQoX3gsIF95KTtcblxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7ICsraikge1xuICAgICAgICAgIHggPSBfeCArIFhfRElSW2pdO1xuICAgICAgICAgIHkgPSBfeSArIFlfRElSW2pdO1xuICAgICAgICAgIGlmICghYm0yLm91dE9mQm91bmRzKHgsIHksIHgsIHkpKSBzdGFjay5wdXNoKFt4LCB5XSk7XG4gICAgICAgIH0gLy8gdW5zY2FsZSBwb2ludCBiYWNrIHRvIHgsIHkgc3BhY2VcblxuXG4gICAgICAgIHggPSAkLmludmVydChfeCk7XG4gICAgICAgIHkgPSAkLmludmVydChfeSk7XG4gICAgICAgIGxvID0gbWF4U2l6ZTtcbiAgICAgICAgaGkgPSBoZWlnaHQ7IC8vIFRPRE86IG1ha2UgdGhpcyBib3VuZCBzbWFsbGVyXG5cbiAgICAgICAgaWYgKCFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBsbywgYm0wLCBibTEpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAgICAgLy8gaWYgdGhlIGxhYmVsIGZpdHMgYXQgdGhlIGN1cnJlbnQgc2FtcGxlIHBvaW50LFxuICAgICAgICAgIC8vIHBlcmZvcm0gYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBsYXJnZXN0IGZvbnQgc2l6ZSB0aGF0IGZpdHNcbiAgICAgICAgICB3aGlsZSAoaGkgLSBsbyA+PSAxKSB7XG4gICAgICAgICAgICBtaWQgPSAobG8gKyBoaSkgLyAyO1xuXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgbWlkLCBibTAsIGJtMSkpIHtcbiAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsbyA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHBsYWNlIGxhYmVsIGlmIGN1cnJlbnQgbG93ZXIgYm91bmQgZXhjZWVkcyBwcmlvciBtYXggZm9udCBzaXplXG5cblxuICAgICAgICAgIGlmIChsbyA+IG1heFNpemUpIHtcbiAgICAgICAgICAgIGQueCA9IHg7XG4gICAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgICAgbWF4U2l6ZSA9IGxvO1xuICAgICAgICAgICAgbGFiZWxQbGFjZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBwbGFjZSBsYWJlbCBhdCBzbGljZSBjZW50ZXIgaWYgbm90IHBsYWNlZCB0aHJvdWdoIG90aGVyIG1lYW5zXG4gICAgICAvLyBhbmQgaWYgd2UncmUgbm90IGF2b2lkaW5nIG92ZXJsYXAgd2l0aCBvdGhlciBhcmVhc1xuXG5cbiAgICAgIGlmICghbGFiZWxQbGFjZWQgJiYgIWF2b2lkQmFzZU1hcmspIHtcbiAgICAgICAgLy8gb25lIHNwYW4gaXMgemVybywgaGVuY2Ugd2UgY2FuIGFkZFxuICAgICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG4gICAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTIpIC8gMjsgLy8gcGxhY2UgbGFiZWwgaWYgaXQgZml0cyBhbmQgaW1wcm92ZXMgdGhlIG1heCBhcmVhIHdpZHRoXG5cbiAgICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGggJiYgIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICBtYXhBcmVhV2lkdGggPSBhcmVhV2lkdGg7XG4gICAgICAgICAgZC54ID0geDtcbiAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgIGxhYmVsUGxhY2VkMiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHJlY29yZCBjdXJyZW50IGxhYmVsIHBsYWNlbWVudCBpbmZvcm1hdGlvbiwgdXBkYXRlIGxhYmVsIGJpdG1hcFxuXG5cbiAgICBpZiAobGFiZWxQbGFjZWQgfHwgbGFiZWxQbGFjZWQyKSB7XG4gICAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICAgIGJtMC5zZXRSYW5nZSgkKGQueCAtIHgpLCAkKGQueSAtIHkpLCAkKGQueCArIHgpLCAkKGQueSArIHkpKTtcbiAgICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBBbGlnbnMgPSBbJ3JpZ2h0JywgJ2NlbnRlcicsICdsZWZ0J10sXG4gICAgICBCYXNlbGluZXMgPSBbJ2JvdHRvbScsICdtaWRkbGUnLCAndG9wJ107XG5mdW5jdGlvbiBwbGFjZU1hcmtMYWJlbCAoJCwgYml0bWFwcywgYW5jaG9ycywgb2Zmc2V0cywgaW5mUGFkZGluZykge1xuICBjb25zdCB3aWR0aCA9ICQud2lkdGgsXG4gICAgICAgIGhlaWdodCA9ICQuaGVpZ2h0LFxuICAgICAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgICAgICBibTEgPSBiaXRtYXBzWzFdLFxuICAgICAgICBuID0gb2Zmc2V0cy5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGJvdW5kYXJ5ID0gZC5ib3VuZGFyeSxcbiAgICAgICAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZTsgLy8gY2FuIG5vdCBiZSBwbGFjZWQgaWYgdGhlIG1hcmsgaXMgbm90IHZpc2libGUgaW4gdGhlIGdyYXBoIGJvdW5kXG5cbiAgICBpZiAoIWluZlBhZGRpbmcgJiYgKGJvdW5kYXJ5WzJdIDwgMCB8fCBib3VuZGFyeVs1XSA8IDAgfHwgYm91bmRhcnlbMF0gPiB3aWR0aCB8fCBib3VuZGFyeVszXSA+IGhlaWdodCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgdGV4dFdpZHRoID0gMCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5LFxuICAgICAgICBpc0luc2lkZSxcbiAgICAgICAgc2l6ZUZhY3RvcixcbiAgICAgICAgaW5zaWRlRmFjdG9yLFxuICAgICAgICB4MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkxLFxuICAgICAgICB5MixcbiAgICAgICAgeGMsXG4gICAgICAgIHljLFxuICAgICAgICBfeDEsXG4gICAgICAgIF94MixcbiAgICAgICAgX3kxLFxuICAgICAgICBfeTI7IC8vIGZvciBlYWNoIGFuY2hvciBhbmQgb2Zmc2V0XG5cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBkeCA9IChhbmNob3JzW2ldICYgMHgzKSAtIDE7XG4gICAgICBkeSA9IChhbmNob3JzW2ldID4+PiAweDIgJiAweDMpIC0gMTtcbiAgICAgIGlzSW5zaWRlID0gZHggPT09IDAgJiYgZHkgPT09IDAgfHwgb2Zmc2V0c1tpXSA8IDA7XG4gICAgICBzaXplRmFjdG9yID0gZHggJiYgZHkgPyBNYXRoLlNRUlQxXzIgOiAxO1xuICAgICAgaW5zaWRlRmFjdG9yID0gb2Zmc2V0c1tpXSA8IDAgPyAtMSA6IDE7XG4gICAgICB4MSA9IGJvdW5kYXJ5WzEgKyBkeF0gKyBvZmZzZXRzW2ldICogZHggKiBzaXplRmFjdG9yO1xuICAgICAgeWMgPSBib3VuZGFyeVs0ICsgZHldICsgaW5zaWRlRmFjdG9yICogdGV4dEhlaWdodCAqIGR5IC8gMiArIG9mZnNldHNbaV0gKiBkeSAqIHNpemVGYWN0b3I7XG4gICAgICB5MSA9IHljIC0gdGV4dEhlaWdodCAvIDI7XG4gICAgICB5MiA9IHljICsgdGV4dEhlaWdodCAvIDI7XG4gICAgICBfeDEgPSAkKHgxKTtcbiAgICAgIF95MSA9ICQoeTEpO1xuICAgICAgX3kyID0gJCh5Mik7XG5cbiAgICAgIGlmIChpbmZQYWRkaW5nKSB7XG4gICAgICAgIF94MSA9IF94MSA8IDAgPyAwIDogX3gxO1xuICAgICAgICBfeTEgPSBfeTEgPCAwID8gMCA6IF95MTtcbiAgICAgICAgX3kyID0gX3kyID49ICQuaGVpZ2h0ID8gJC5oZWlnaHQgLSAxIDogX3kyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHRXaWR0aCkge1xuICAgICAgICAvLyB0byBhdm9pZCBmaW5kaW5nIHdpZHRoIG9mIHRleHQgbGFiZWwsXG4gICAgICAgIGlmICghdGVzdChfeDEsIF94MSwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDEsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSkge1xuICAgICAgICAgIC8vIHNraXAgdGhpcyBhbmNob3Ivb2Zmc2V0IG9wdGlvbiBpZiB3ZSBmYWlsIHRvIHBsYWNlIGEgbGFiZWwgd2l0aCAxcHggd2lkdGhcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGZpbmQgdGhlIGxhYmVsIHdpZHRoXG4gICAgICAgICAgdGV4dFdpZHRoID0gdGV4dE1ldHJpY3Mud2lkdGgoZC5kYXR1bSwgZC5kYXR1bS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4YyA9IHgxICsgaW5zaWRlRmFjdG9yICogdGV4dFdpZHRoICogZHggLyAyO1xuICAgICAgeDEgPSB4YyAtIHRleHRXaWR0aCAvIDI7XG4gICAgICB4MiA9IHhjICsgdGV4dFdpZHRoIC8gMjtcbiAgICAgIF94MSA9ICQoeDEpO1xuICAgICAgX3gyID0gJCh4Mik7XG5cbiAgICAgIGlmIChpbmZQYWRkaW5nKSB7XG4gICAgICAgIF94MSA9IF94MSA8IDAgPyAwIDogX3gxO1xuICAgICAgICBfeDIgPSBfeDIgPj0gJC53aWR0aCA/ICQud2lkdGggLSAxIDogX3gyO1xuICAgICAgfVxuXG4gICAgICBpZiAodGVzdChfeDEsIF94MiwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDIsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSkge1xuICAgICAgICAvLyBwbGFjZSBsYWJlbCBpZiB0aGUgcG9zaXRpb24gaXMgcGxhY2VhYmxlXG4gICAgICAgIGQueCA9ICFkeCA/IHhjIDogZHggKiBpbnNpZGVGYWN0b3IgPCAwID8geDIgOiB4MTtcbiAgICAgICAgZC55ID0gIWR5ID8geWMgOiBkeSAqIGluc2lkZUZhY3RvciA8IDAgPyB5MiA6IHkxO1xuICAgICAgICBkLmFsaWduID0gQWxpZ25zW2R4ICogaW5zaWRlRmFjdG9yICsgMV07XG4gICAgICAgIGQuYmFzZWxpbmUgPSBCYXNlbGluZXNbZHkgKiBpbnNpZGVGYWN0b3IgKyAxXTtcbiAgICAgICAgYm0wLnNldFJhbmdlKF94MSwgX3kxLCBfeDIsIF95Mik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn0gLy8gVGVzdCBpZiBhIGxhYmVsIHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMgY2FuIGJlIGFkZGVkIHdpdGhvdXQgb3ZlcmxhcFxuXG5mdW5jdGlvbiB0ZXN0KF94MSwgX3gyLCBfeTEsIF95MiwgYm0wLCBibTEsIHgxLCB4MiwgeTEsIHkyLCBib3VuZGFyeSwgaXNJbnNpZGUpIHtcbiAgcmV0dXJuICEoYm0wLm91dE9mQm91bmRzKF94MSwgX3kxLCBfeDIsIF95MikgfHwgKGlzSW5zaWRlICYmIGJtMSA/IGJtMS5nZXRSYW5nZShfeDEsIF95MSwgX3gyLCBfeTIpIHx8ICFpc0luTWFya0JvdW5kKHgxLCB5MSwgeDIsIHkyLCBib3VuZGFyeSkgOiBibTAuZ2V0UmFuZ2UoX3gxLCBfeTEsIF94MiwgX3kyKSkpO1xufVxuXG5mdW5jdGlvbiBpc0luTWFya0JvdW5kKHgxLCB5MSwgeDIsIHkyLCBib3VuZGFyeSkge1xuICByZXR1cm4gYm91bmRhcnlbMF0gPD0geDEgJiYgeDIgPD0gYm91bmRhcnlbMl0gJiYgYm91bmRhcnlbM10gPD0geTEgJiYgeTIgPD0gYm91bmRhcnlbNV07XG59XG5cbmNvbnN0IFRPUCA9IDB4MCxcbiAgICAgIE1JRERMRSA9IDB4NCxcbiAgICAgIEJPVFRPTSA9IDB4OCxcbiAgICAgIExFRlQgPSAweDAsXG4gICAgICBDRU5URVIgPSAweDEsXG4gICAgICBSSUdIVCA9IDB4MjsgLy8gTWFwcGluZyBmcm9tIHRleHQgYW5jaG9yIHRvIG51bWJlciByZXByZXNlbnRhdGlvblxuXG5jb25zdCBhbmNob3JDb2RlID0ge1xuICAndG9wLWxlZnQnOiBUT1AgKyBMRUZULFxuICAndG9wJzogVE9QICsgQ0VOVEVSLFxuICAndG9wLXJpZ2h0JzogVE9QICsgUklHSFQsXG4gICdsZWZ0JzogTUlERExFICsgTEVGVCxcbiAgJ21pZGRsZSc6IE1JRERMRSArIENFTlRFUixcbiAgJ3JpZ2h0JzogTUlERExFICsgUklHSFQsXG4gICdib3R0b20tbGVmdCc6IEJPVFRPTSArIExFRlQsXG4gICdib3R0b20nOiBCT1RUT00gKyBDRU5URVIsXG4gICdib3R0b20tcmlnaHQnOiBCT1RUT00gKyBSSUdIVFxufTtcbmNvbnN0IHBsYWNlQXJlYUxhYmVsID0ge1xuICAnbmFpdmUnOiBwbGFjZUFyZWFMYWJlbE5haXZlLFxuICAncmVkdWNlZC1zZWFyY2gnOiBwbGFjZUFyZWFMYWJlbFJlZHVjZWRTZWFyY2gsXG4gICdmbG9vZGZpbGwnOiBwbGFjZUFyZWFMYWJlbEZsb29kRmlsbFxufTtcbmZ1bmN0aW9uIGxhYmVsTGF5b3V0ICh0ZXh0cywgc2l6ZSwgY29tcGFyZSwgb2Zmc2V0LCBhbmNob3IsIGF2b2lkTWFya3MsIGF2b2lkQmFzZU1hcmssIGxpbmVBbmNob3IsIG1hcmtJbmRleCwgcGFkZGluZywgbWV0aG9kKSB7XG4gIC8vIGVhcmx5IGV4aXQgZm9yIGVtcHR5IGRhdGFcbiAgaWYgKCF0ZXh0cy5sZW5ndGgpIHJldHVybiB0ZXh0cztcbiAgY29uc3QgcG9zaXRpb25zID0gTWF0aC5tYXgob2Zmc2V0Lmxlbmd0aCwgYW5jaG9yLmxlbmd0aCksXG4gICAgICAgIG9mZnNldHMgPSBnZXRPZmZzZXRzKG9mZnNldCwgcG9zaXRpb25zKSxcbiAgICAgICAgYW5jaG9ycyA9IGdldEFuY2hvcnMoYW5jaG9yLCBwb3NpdGlvbnMpLFxuICAgICAgICBtYXJrdHlwZSA9IG1hcmtUeXBlKHRleHRzWzBdLmRhdHVtKSxcbiAgICAgICAgZ3JvdXB0eXBlID0gbWFya3R5cGUgPT09ICdncm91cCcgJiYgdGV4dHNbMF0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5tYXJrdHlwZSxcbiAgICAgICAgaXNHcm91cEFyZWEgPSBncm91cHR5cGUgPT09ICdhcmVhJyxcbiAgICAgICAgYm91bmRhcnkgPSBtYXJrQm91bmRhcnkobWFya3R5cGUsIGdyb3VwdHlwZSwgbGluZUFuY2hvciwgbWFya0luZGV4KSxcbiAgICAgICAgaW5mUGFkZGluZyA9IHBhZGRpbmcgPT09IG51bGwgfHwgcGFkZGluZyA9PT0gSW5maW5pdHksXG4gICAgICAgICQgPSBzY2FsZXIoc2l6ZVswXSwgc2l6ZVsxXSwgaW5mUGFkZGluZyA/IDAgOiBwYWRkaW5nKSxcbiAgICAgICAgaXNOYWl2ZUdyb3VwQXJlYSA9IGlzR3JvdXBBcmVhICYmIG1ldGhvZCA9PT0gJ25haXZlJzsgLy8gcHJlcGFyZSB0ZXh0IG1hcmsgZGF0YSBmb3IgcGxhY2luZ1xuXG4gIGNvbnN0IGRhdGEgPSB0ZXh0cy5tYXAoZCA9PiAoe1xuICAgIGRhdHVtOiBkLFxuICAgIG9wYWNpdHk6IDAsXG4gICAgeDogdW5kZWZpbmVkLFxuICAgIHk6IHVuZGVmaW5lZCxcbiAgICBhbGlnbjogdW5kZWZpbmVkLFxuICAgIGJhc2VsaW5lOiB1bmRlZmluZWQsXG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5KGQpXG4gIH0pKTtcbiAgbGV0IGJpdG1hcHM7XG5cbiAgaWYgKCFpc05haXZlR3JvdXBBcmVhKSB7XG4gICAgLy8gc29ydCBsYWJlbHMgaW4gcHJpb3JpdHkgb3JkZXIsIGlmIGNvbXBhcmF0b3IgaXMgcHJvdmlkZWRcbiAgICBpZiAoY29tcGFyZSkge1xuICAgICAgZGF0YS5zb3J0KChhLCBiKSA9PiBjb21wYXJlKGEuZGF0dW0sIGIuZGF0dW0pKTtcbiAgICB9IC8vIGZsYWcgaW5kaWNhdGluZyBpZiBsYWJlbCBjYW4gYmUgcGxhY2VkIGluc2lkZSBpdHMgYmFzZSBtYXJrXG5cblxuICAgIGxldCBsYWJlbEluc2lkZSA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JzLmxlbmd0aCAmJiAhbGFiZWxJbnNpZGU7ICsraSkge1xuICAgICAgLy8gbGFiZWwgaW5zaWRlIGlmIGFuY2hvciBpcyBhdCBjZW50ZXJcbiAgICAgIC8vIGxhYmVsIGluc2lkZSBpZiBvZmZzZXQgdG8gYmUgaW5zaWRlIHRoZSBtYXJrIGJvdW5kXG4gICAgICBsYWJlbEluc2lkZSA9IGFuY2hvcnNbaV0gPT09IDB4NSB8fCBvZmZzZXRzW2ldIDwgMDtcbiAgICB9IC8vIGV4dHJhY3QgZGF0YSBpbmZvcm1hdGlvbiBmcm9tIGJhc2UgbWFyayB3aGVuIGJhc2UgbWFyayBpcyB0byBiZSBhdm9pZGVkXG4gICAgLy8gYmFzZSBtYXJrIGlzIGltcGxpY2l0bHkgYXZvaWRlZCBpZiBpdCBpcyBhIGdyb3VwIGFyZWFcblxuXG4gICAgaWYgKG1hcmt0eXBlICYmIChhdm9pZEJhc2VNYXJrIHx8IGlzR3JvdXBBcmVhKSkge1xuICAgICAgYXZvaWRNYXJrcyA9IFt0ZXh0cy5tYXAoZCA9PiBkLmRhdHVtKV0uY29uY2F0KGF2b2lkTWFya3MpO1xuICAgIH0gLy8gZ2VuZXJhdGUgYml0bWFwcyBmb3IgbGF5b3V0IGNhbGN1bGF0aW9uXG5cblxuICAgIGJpdG1hcHMgPSBhdm9pZE1hcmtzLmxlbmd0aCA/IG1hcmtCaXRtYXBzKCQsIGF2b2lkTWFya3MsIGxhYmVsSW5zaWRlLCBpc0dyb3VwQXJlYSkgOiBiYXNlQml0bWFwcygkLCBhdm9pZEJhc2VNYXJrICYmIGRhdGEpO1xuICB9IC8vIGdlbmVyYXRlIGxhYmVsIHBsYWNlbWVudCBmdW5jdGlvblxuXG5cbiAgY29uc3QgcGxhY2UgPSBpc0dyb3VwQXJlYSA/IHBsYWNlQXJlYUxhYmVsW21ldGhvZF0oJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4LCBpbmZQYWRkaW5nKSA6IHBsYWNlTWFya0xhYmVsKCQsIGJpdG1hcHMsIGFuY2hvcnMsIG9mZnNldHMsIGluZlBhZGRpbmcpOyAvLyBwbGFjZSBhbGwgbGFiZWxzXG5cbiAgZGF0YS5mb3JFYWNoKGQgPT4gZC5vcGFjaXR5ID0gK3BsYWNlKGQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldHMoXywgY291bnQpIHtcbiAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBGbG9hdDY0QXJyYXkoY291bnQpLFxuICAgICAgICBuID0gXy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIG9mZnNldHNbaV0gPSBfW2ldIHx8IDA7XG5cbiAgZm9yIChsZXQgaSA9IG47IGkgPCBjb3VudDsgKytpKSBvZmZzZXRzW2ldID0gb2Zmc2V0c1tuIC0gMV07XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldEFuY2hvcnMoXywgY291bnQpIHtcbiAgY29uc3QgYW5jaG9ycyA9IG5ldyBJbnQ4QXJyYXkoY291bnQpLFxuICAgICAgICBuID0gXy5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGFuY2hvcnNbaV0gfD0gYW5jaG9yQ29kZVtfW2ldXTtcblxuICBmb3IgKGxldCBpID0gbjsgaSA8IGNvdW50OyArK2kpIGFuY2hvcnNbaV0gPSBhbmNob3JzW24gLSAxXTtcblxuICByZXR1cm4gYW5jaG9ycztcbn1cblxuZnVuY3Rpb24gbWFya1R5cGUoaXRlbSkge1xuICByZXR1cm4gaXRlbSAmJiBpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLm1hcmt0eXBlO1xufVxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBmb3IgZ2V0dGluZyBiYXNlIG1hcmsgYm91bmRhcnksIGRlcGVuZGluZ1xuICogb24gbWFyayBhbmQgZ3JvdXAgdHlwZS4gV2hlbiBtYXJrIHR5cGUgaXMgdW5kZWZpbmVkLCBsaW5lIG9yIGFyZWE6IGJvdW5kYXJ5XG4gKiBpcyB0aGUgY29vcmRpbmF0ZSBvZiBlYWNoIGRhdGEgcG9pbnQuIFdoZW4gYmFzZSBtYXJrIGlzIGdyb3VwZWQgbGluZSxcbiAqIGJvdW5kYXJ5IGlzIGVpdGhlciBhdCB0aGUgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgbGluZSBkZXBlbmRpbmcgb24gdGhlXG4gKiB2YWx1ZSBvZiBsaW5lQW5jaG9yLiBPdGhlcndpc2UsIHVzZSBib3VuZHMgb2YgYmFzZSBtYXJrLlxuICovXG5cblxuZnVuY3Rpb24gbWFya0JvdW5kYXJ5KG1hcmt0eXBlLCBncm91cHR5cGUsIGxpbmVBbmNob3IsIG1hcmtJbmRleCkge1xuICBjb25zdCB4eSA9IGQgPT4gW2QueCwgZC54LCBkLngsIGQueSwgZC55LCBkLnldO1xuXG4gIGlmICghbWFya3R5cGUpIHtcbiAgICByZXR1cm4geHk7IC8vIG5vIHJlYWN0aXZlIGdlb21ldHJ5XG4gIH0gZWxzZSBpZiAobWFya3R5cGUgPT09ICdsaW5lJyB8fCBtYXJrdHlwZSA9PT0gJ2FyZWEnKSB7XG4gICAgcmV0dXJuIGQgPT4geHkoZC5kYXR1bSk7XG4gIH0gZWxzZSBpZiAoZ3JvdXB0eXBlID09PSAnbGluZScpIHtcbiAgICByZXR1cm4gZCA9PiB7XG4gICAgICBjb25zdCBpdGVtcyA9IGQuZGF0dW0uaXRlbXNbbWFya0luZGV4XS5pdGVtcztcbiAgICAgIHJldHVybiB4eShpdGVtcy5sZW5ndGggPyBpdGVtc1tsaW5lQW5jaG9yID09PSAnc3RhcnQnID8gMCA6IGl0ZW1zLmxlbmd0aCAtIDFdIDoge1xuICAgICAgICB4OiBOYU4sXG4gICAgICAgIHk6IE5hTlxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZCA9PiB7XG4gICAgICBjb25zdCBiID0gZC5kYXR1bS5ib3VuZHM7XG4gICAgICByZXR1cm4gW2IueDEsIChiLngxICsgYi54MikgLyAyLCBiLngyLCBiLnkxLCAoYi55MSArIGIueTIpIC8gMiwgYi55Ml07XG4gICAgfTtcbiAgfVxufVxuXG5jb25zdCBPdXRwdXQgPSBbJ3gnLCAneScsICdvcGFjaXR5JywgJ2FsaWduJywgJ2Jhc2VsaW5lJ107XG5jb25zdCBBbmNob3JzID0gWyd0b3AtbGVmdCcsICdsZWZ0JywgJ2JvdHRvbS1sZWZ0JywgJ3RvcCcsICdib3R0b20nLCAndG9wLXJpZ2h0JywgJ3JpZ2h0JywgJ2JvdHRvbS1yaWdodCddO1xuLyoqXG4gKiBDb21wdXRlIHRleHQgbGFiZWwgbGF5b3V0IHRvIGFubm90YXRlIG1hcmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHBhcmFtcy5zaXplIC0gVGhlIHNpemUgb2YgdGhlIGxheW91dCwgcHJvdmlkZWQgYXMgYSBbd2lkdGgsIGhlaWdodF0gYXJyYXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgbGFiZWwgZGF0YSBpbiBwcmlvcml0eSBvcmRlci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hbmNob3JdIC0gTGFiZWwgYW5jaG9yIHBvaW50cyByZWxhdGl2ZSB0byB0aGUgYmFzZSBtYXJrIGJvdW5kaW5nIGJveC5cbiAqICAgVGhlIGF2YWlsYWJsZSBvcHRpb25zIGFyZSAndG9wLWxlZnQnLCAnbGVmdCcsICdib3R0b20tbGVmdCcsICd0b3AnLFxuICogICAnYm90dG9tJywgJ3RvcC1yaWdodCcsICdyaWdodCcsICdib3R0b20tcmlnaHQnLCAnbWlkZGxlJy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5vZmZzZXRdIC0gTGFiZWwgb2Zmc2V0cyAoaW4gcGl4ZWxzKSBmcm9tIHRoZSBiYXNlIG1hcmsgYm91bmRpbmcgYm94LlxuICogICBUaGlzIHBhcmFtZXRlciBpcyBwYXJhbGxlbCB0byB0aGUgbGlzdCBvZiBhbmNob3IgcG9pbnRzLlxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbcGFyYW1zLnBhZGRpbmc9MF0gLSBUaGUgYW1vdW50IChpbiBwaXhlbHMpIHRoYXQgYSBsYWJlbCBtYXkgZXhjZWVkIHRoZSBsYXlvdXQgc2l6ZS5cbiAqICAgSWYgdGhpcyBwYXJhbWV0ZXIgaXMgbnVsbCwgYSBsYWJlbCBtYXkgZXhjZWVkIHRoZSBsYXlvdXQgc2l6ZSB3aXRob3V0IGFueSBib3VuZGFyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmxpbmVBbmNob3I9J2VuZCddIC0gRm9yIGdyb3VwIGxpbmUgbWFyayBsYWJlbHMgb25seSwgaW5kaWNhdGVzIHRoZSBhbmNob3JcbiAqICAgcG9zaXRpb24gZm9yIGxhYmVscy4gT25lIG9mICdzdGFydCcgb3IgJ2VuZCcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tYXJrSW5kZXg9MF0gLSBGb3IgZ3JvdXAgbWFyayBsYWJlbHMgb25seSwgYW4gaW5kZXggaW5kaWNhdGluZ1xuICogICB3aGljaCBtYXJrIHdpdGhpbiB0aGUgZ3JvdXAgc2hvdWxkIGJlIGxhYmVsZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuYXZvaWRNYXJrc10gLSBBIGxpc3Qgb2YgYWRkaXRpb25hbCBtYXJrIG5hbWVzIGZvciB3aGljaCB0aGUgbGFiZWxcbiAqICAgbGF5b3V0IHNob3VsZCBhdm9pZCBvdmVybGFwLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmF2b2lkQmFzZU1hcms9dHJ1ZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiBsYWJlbHMgc2hvdWxkIGF2b2lkXG4gKiAgIG92ZXJsYXAgd2l0aCB0aGUgdW5kZXJseWluZyBiYXNlIG1hcmsgYmVpbmcgbGFiZWxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1ldGhvZD0nbmFpdmUnXSAtIEZvciBhcmVhIG1ha2UgbGFiZWxzIG9ubHksIGEgbWV0aG9kIGZvclxuICogICBwbGFjZSBsYWJlbHMuIE9uZSBvZiAnbmFpdmUnLCAncmVkdWNlZC1zZWFyY2gnLCBvciAnZmxvb2RmaWxsJy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBUaGUgb3V0cHV0IGZpZWxkcyB3cml0dGVuIGJ5IHRoZSB0cmFuc2Zvcm0uXG4gKiAgIFRoZSBkZWZhdWx0IGlzIFsneCcsICd5JywgJ29wYWNpdHknLCAnYWxpZ24nLCAnYmFzZWxpbmUnXS5cbiAqL1xuXG5mdW5jdGlvbiBMYWJlbChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkxhYmVsLkRlZmluaXRpb24gPSB7XG4gIHR5cGU6ICdMYWJlbCcsXG4gIG1ldGFkYXRhOiB7XG4gICAgbW9kaWZpZXM6IHRydWVcbiAgfSxcbiAgcGFyYW1zOiBbe1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBhcnJheTogdHJ1ZSxcbiAgICBsZW5ndGg6IDIsXG4gICAgcmVxdWlyZWQ6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdzb3J0JyxcbiAgICB0eXBlOiAnY29tcGFyZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhbmNob3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGRlZmF1bHQ6IEFuY2hvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGRlZmF1bHQ6IFsxXVxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmcnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IDAsXG4gICAgbnVsbDogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmVBbmNob3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbHVlczogWydzdGFydCcsICdlbmQnXSxcbiAgICBkZWZhdWx0OiAnZW5kJ1xuICB9LCB7XG4gICAgbmFtZTogJ21hcmtJbmRleCcsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgbmFtZTogJ2F2b2lkQmFzZU1hcmsnLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnYXZvaWRNYXJrcycsXG4gICAgdHlwZTogJ2RhdGEnLFxuICAgIGFycmF5OiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnbWV0aG9kJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiAnbmFpdmUnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXMnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGxlbmd0aDogT3V0cHV0Lmxlbmd0aCxcbiAgICBkZWZhdWx0OiBPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhMYWJlbCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGZ1bmN0aW9uIG1vZHAocGFyYW0pIHtcbiAgICAgIGNvbnN0IHAgPSBfW3BhcmFtXTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHApICYmIHB1bHNlLm1vZGlmaWVkKHAuZmllbGRzKTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCk7XG5cbiAgICBpZiAoIShtb2QgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSB8fCBtb2RwKCdzb3J0JykpKSByZXR1cm47XG5cbiAgICBpZiAoIV8uc2l6ZSB8fCBfLnNpemUubGVuZ3RoICE9PSAyKSB7XG4gICAgICBlcnJvcignU2l6ZSBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIFt3aWR0aCwgaGVpZ2h0XSBhcnJheS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcyA9IF8uYXMgfHwgT3V0cHV0OyAvLyBydW4gbGFiZWwgbGF5b3V0XG5cbiAgICBsYWJlbExheW91dChwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSB8fCBbXSwgXy5zaXplLCBfLnNvcnQsIGFycmF5KF8ub2Zmc2V0ID09IG51bGwgPyAxIDogXy5vZmZzZXQpLCBhcnJheShfLmFuY2hvciB8fCBBbmNob3JzKSwgXy5hdm9pZE1hcmtzIHx8IFtdLCBfLmF2b2lkQmFzZU1hcmsgIT09IGZhbHNlLCBfLmxpbmVBbmNob3IgfHwgJ2VuZCcsIF8ubWFya0luZGV4IHx8IDAsIF8ucGFkZGluZyA9PT0gdW5kZWZpbmVkID8gMCA6IF8ucGFkZGluZywgXy5tZXRob2QgfHwgJ25haXZlJykuZm9yRWFjaChsID0+IHtcbiAgICAgIC8vIHdyaXRlIGxheW91dCByZXN1bHRzIHRvIGRhdGEgc3RyZWFtXG4gICAgICBjb25zdCB0ID0gbC5kYXR1bTtcbiAgICAgIHRbYXNbMF1dID0gbC54O1xuICAgICAgdFthc1sxXV0gPSBsLnk7XG4gICAgICB0W2FzWzJdXSA9IGwub3BhY2l0eTtcbiAgICAgIHRbYXNbM11dID0gbC5hbGlnbjtcbiAgICAgIHRbYXNbNF1dID0gbC5iYXNlbGluZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KG1vZCkubW9kaWZpZXMoYXMpO1xuICB9XG5cbn0pO1xuXG5leHBvcnQgeyBMYWJlbCBhcyBsYWJlbCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kLCBlcnJvciwgaXNGdW5jdGlvbiwgc3RyaW5nVmFsdWUsIHRvQm9vbGVhbiwgdG9OdW1iZXIsIHRvRGF0ZSwgdG9TdHJpbmcsIGlkZW50aXR5LCBmaWVsZCwgaXNPYmplY3QsIGlzQXJyYXksIGlzSXRlcmFibGUsIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGRzdkZvcm1hdCB9IGZyb20gJ2QzLWRzdic7XG5pbXBvcnQgeyBmZWF0dXJlLCBtZXNoIH0gZnJvbSAndG9wb2pzb24tY2xpZW50JztcbmltcG9ydCB7IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cblxuY29uc3QgcHJvdG9jb2xfcmUgPSAvXihkYXRhOnwoW0EtWmEtel0rOik/XFwvXFwvKS87IC8vIE1hdGNoZXMgYWxsb3dlZCBVUklzLiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jdXJlNTMvRE9NUHVyaWZ5L2Jsb2IvbWFzdGVyL3NyYy9yZWdleHAuanMgd2l0aCBhZGRlZCBmaWxlOi8vXG5cbmNvbnN0IGFsbG93ZWRfcmUgPSAvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcHxmaWxlfGRhdGEpOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuY29uc3Qgd2hpdGVzcGFjZV9yZSA9IC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1ZlxcdTMwMDBdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG5cbmNvbnN0IGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcbi8qKlxuICogRmFjdG9yeSBmb3IgYSBsb2FkZXIgY29uc3RydWN0b3IgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciByZXF1ZXN0aW5nXG4gKiBmaWxlcyBmcm9tIGVpdGhlciB0aGUgbmV0d29yayBvciBkaXNrLCBhbmQgZm9yIHNhbml0aXppbmcgcmVxdWVzdCBVUklzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmV0Y2ggLSBUaGUgRmV0Y2ggQVBJIGZvciBIVFRQIG5ldHdvcmsgcmVxdWVzdHMuXG4gKiAgIElmIG51bGwgb3IgdW5kZWZpbmVkLCBIVFRQIGxvYWRpbmcgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmcyAtIFRoZSBmaWxlIHN5c3RlbSBpbnRlcmZhY2UgZm9yIGZpbGUgbG9hZGluZy5cbiAqICAgSWYgbnVsbCBvciB1bmRlZmluZWQsIGxvY2FsIGZpbGUgbG9hZGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEEgbG9hZGVyIGNvbnN0cnVjdG9yIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiAgIHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGRlZmF1bHQgbG9hZGluZyBvcHRpb25zIHRvIHVzZS5cbiAqICAgcmV0dXJuIHtvYmplY3R9IC0gQSBuZXcgbG9hZGVyIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGxvYWRlckZhY3RvcnkgKGZldGNoLCBmcykge1xuICByZXR1cm4gb3B0aW9ucyA9PiAoe1xuICAgIG9wdGlvbnM6IG9wdGlvbnMgfHwge30sXG4gICAgc2FuaXRpemU6IHNhbml0aXplLFxuICAgIGxvYWQ6IGxvYWQsXG4gICAgZmlsZUFjY2VzczogISFmcyxcbiAgICBmaWxlOiBmaWxlTG9hZGVyKGZzKSxcbiAgICBodHRwOiBodHRwTG9hZGVyKGZldGNoKVxuICB9KTtcbn1cbi8qKlxuICogTG9hZCBhbiBleHRlcm5hbCByZXNvdXJjZSwgdHlwaWNhbGx5IGVpdGhlciBmcm9tIHRoZSB3ZWIgb3IgZnJvbSB0aGUgbG9jYWxcbiAqIGZpbGVzeXN0ZW0uIFRoaXMgZnVuY3Rpb24gdXNlcyB7QGxpbmsgc2FuaXRpemV9IHRvIGZpcnN0IHNhbml0aXplIHRoZSB1cmksXG4gKiB0aGVuIGNhbGxzIGVpdGhlciB7QGxpbmsgaHR0cH0gKGZvciB3ZWIgcmVxdWVzdHMpIG9yIHtAbGluayBmaWxlfSAoZm9yXG4gKiBmaWxlc3lzdGVtIGxvYWRpbmcpLlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSByZXNvdXJjZSBpbmRpY2F0b3IgKGUuZy4sIFVSTCBvciBmaWxlbmFtZSkuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWwgbG9hZGluZyBvcHRpb25zLiBUaGVzZSBvcHRpb25zIHdpbGxcbiAqICAgb3ZlcnJpZGUgYW55IGV4aXN0aW5nIGRlZmF1bHQgb3B0aW9ucy5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBjb250ZW50LlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGxvYWQodXJpLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IGF3YWl0IHRoaXMuc2FuaXRpemUodXJpLCBvcHRpb25zKSxcbiAgICAgICAgdXJsID0gb3B0LmhyZWY7XG4gIHJldHVybiBvcHQubG9jYWxGaWxlID8gdGhpcy5maWxlKHVybCkgOiB0aGlzLmh0dHAodXJsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogVVJJIHNhbml0aXplciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgdXJpICh1cmwgb3IgZmlsZW5hbWUpIHRvIGNoZWNrLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgc2FuaXRpemVkIHVyaSBkYXRhLCBvciByZWplY3RzIGl0IHRoZSBpbnB1dCB1cmkgaXMgZGVlbWVkIGludmFsaWQuXG4gKiAgVGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc29sdmVkIG9iamVjdCBhcmUgYXNzdW1lZCB0byBiZVxuICogIHZhbGlkIGF0dHJpYnV0ZXMgZm9yIGFuIEhUTUwgJ2EnIHRhZy4gVGhlIHNhbml0aXplZCB1cmkgKm11c3QqIGJlXG4gKiAgcHJvdmlkZWQgYnkgdGhlICdocmVmJyBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gc2FuaXRpemUodXJpLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBleHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIGNvbnN0IGZpbGVBY2Nlc3MgPSB0aGlzLmZpbGVBY2Nlc3MsXG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICBocmVmOiBudWxsXG4gIH07XG4gIGxldCBpc0ZpbGUsIGxvYWRGaWxlLCBiYXNlO1xuICBjb25zdCBpc0FsbG93ZWQgPSBhbGxvd2VkX3JlLnRlc3QodXJpLnJlcGxhY2Uod2hpdGVzcGFjZV9yZSwgJycpKTtcblxuICBpZiAodXJpID09IG51bGwgfHwgdHlwZW9mIHVyaSAhPT0gJ3N0cmluZycgfHwgIWlzQWxsb3dlZCkge1xuICAgIGVycm9yKCdTYW5pdGl6ZSBmYWlsdXJlLCBpbnZhbGlkIFVSSTogJyArIHN0cmluZ1ZhbHVlKHVyaSkpO1xuICB9XG5cbiAgY29uc3QgaGFzUHJvdG9jb2wgPSBwcm90b2NvbF9yZS50ZXN0KHVyaSk7IC8vIGlmIHJlbGF0aXZlIHVybCAobm8gcHJvdG9jb2wvaG9zdCksIHByZXBlbmQgYmFzZVVSTFxuXG4gIGlmICgoYmFzZSA9IG9wdGlvbnMuYmFzZVVSTCkgJiYgIWhhc1Byb3RvY29sKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgaWYgKCF1cmkuc3RhcnRzV2l0aCgnLycpICYmICFiYXNlLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgIHVyaSA9ICcvJyArIHVyaTtcbiAgICB9XG5cbiAgICB1cmkgPSBiYXNlICsgdXJpO1xuICB9IC8vIHNob3VsZCB3ZSBsb2FkIGZyb20gZmlsZSBzeXN0ZW0/XG5cblxuICBsb2FkRmlsZSA9IChpc0ZpbGUgPSB1cmkuc3RhcnRzV2l0aChmaWxlUHJvdG9jb2wpKSB8fCBvcHRpb25zLm1vZGUgPT09ICdmaWxlJyB8fCBvcHRpb25zLm1vZGUgIT09ICdodHRwJyAmJiAhaGFzUHJvdG9jb2wgJiYgZmlsZUFjY2VzcztcblxuICBpZiAoaXNGaWxlKSB7XG4gICAgLy8gc3RyaXAgZmlsZSBwcm90b2NvbFxuICAgIHVyaSA9IHVyaS5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh1cmkuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgIGlmIChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gJ2ZpbGUnKSB7XG4gICAgICAvLyBpZiBpcyBmaWxlLCBzdHJpcCBwcm90b2NvbCBhbmQgc2V0IGxvYWRGaWxlIGZsYWdcbiAgICAgIHVyaSA9IHVyaS5zbGljZSgyKTtcbiAgICAgIGxvYWRGaWxlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgcmVsYXRpdmUgcHJvdG9jb2wgKHN0YXJ0cyB3aXRoICcvLycpLCBwcmVwZW5kIGRlZmF1bHQgcHJvdG9jb2xcbiAgICAgIHVyaSA9IChvcHRpb25zLmRlZmF1bHRQcm90b2NvbCB8fCAnaHR0cCcpICsgJzonICsgdXJpO1xuICAgIH1cbiAgfSAvLyBzZXQgbm9uLWVudW1lcmFibGUgbW9kZSBmbGFnIHRvIGluZGljYXRlIGxvY2FsIGZpbGUgbG9hZFxuXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ2xvY2FsRmlsZScsIHtcbiAgICB2YWx1ZTogISFsb2FkRmlsZVxuICB9KTsgLy8gc2V0IHVyaVxuXG4gIHJlc3VsdC5ocmVmID0gdXJpOyAvLyBzZXQgZGVmYXVsdCByZXN1bHQgdGFyZ2V0LCBpZiBzcGVjaWZpZWRcblxuICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICByZXN1bHQudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQgKyAnJztcbiAgfSAvLyBzZXQgZGVmYXVsdCByZXN1bHQgcmVsLCBpZiBzcGVjaWZpZWQgKCMxNTQyKVxuXG5cbiAgaWYgKG9wdGlvbnMucmVsKSB7XG4gICAgcmVzdWx0LnJlbCA9IG9wdGlvbnMucmVsICsgJyc7XG4gIH0gLy8gcHJvdmlkZSBjb250cm9sIG92ZXIgY3Jvc3Mtb3JpZ2luIGltYWdlIGhhbmRsaW5nICgjMjIzOClcbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9DT1JTX2VuYWJsZWRfaW1hZ2VcblxuXG4gIGlmIChvcHRpb25zLmNvbnRleHQgPT09ICdpbWFnZScgJiYgb3B0aW9ucy5jcm9zc09yaWdpbikge1xuICAgIHJlc3VsdC5jcm9zc09yaWdpbiA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4gKyAnJztcbiAgfSAvLyByZXR1cm5cblxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbGUgc3lzdGVtIGxvYWRlciBmYWN0b3J5LlxuICogQHBhcmFtIHtvYmplY3R9IGZzIC0gVGhlIGZpbGUgc3lzdGVtIGludGVyZmFjZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAtIEEgZmlsZSBsb2FkZXIgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqICAgcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgZmlsZSBzeXN0ZW0gcGF0aCB0byBsb2FkLlxuICogICBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBmaWxlIHN5c3RlbSBwYXRoIHRvIGxvYWQuXG4gKiAgIHJldHVybiB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbGUgY29udGVudHMuXG4gKi9cblxuXG5mdW5jdGlvbiBmaWxlTG9hZGVyKGZzKSB7XG4gIHJldHVybiBmcyA/IGZpbGVuYW1lID0+IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnJvcikgcmVqZWN0KGVycm9yKTtlbHNlIGFjY2VwdChkYXRhKTtcbiAgICB9KTtcbiAgfSkgOiBmaWxlUmVqZWN0O1xufVxuLyoqXG4gKiBEZWZhdWx0IGZpbGUgc3lzdGVtIGxvYWRlciB0aGF0IHNpbXBseSByZWplY3RzLlxuICovXG5cblxuYXN5bmMgZnVuY3Rpb24gZmlsZVJlamVjdCgpIHtcbiAgZXJyb3IoJ05vIGZpbGUgc3lzdGVtIGFjY2Vzcy4nKTtcbn1cbi8qKlxuICogSFRUUCByZXF1ZXN0IGhhbmRsZXIgZmFjdG9yeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZldGNoIC0gVGhlIEZldGNoIEFQSSBtZXRob2QuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBBbiBodHRwIGxvYWRlciB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogICBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHJlcXVlc3QuXG4gKiAgIHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiAgIHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmlsZSBjb250ZW50cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGh0dHBMb2FkZXIoZmV0Y2gpIHtcbiAgcmV0dXJuIGZldGNoID8gYXN5bmMgZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IGV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmh0dHAsIG9wdGlvbnMpLFxuICAgICAgICAgIHR5cGUgPSBvcHRpb25zICYmIG9wdGlvbnMucmVzcG9uc2UsXG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdCk7XG4gICAgcmV0dXJuICFyZXNwb25zZS5vayA/IGVycm9yKHJlc3BvbnNlLnN0YXR1cyArICcnICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCkgOiBpc0Z1bmN0aW9uKHJlc3BvbnNlW3R5cGVdKSA/IHJlc3BvbnNlW3R5cGVdKCkgOiByZXNwb25zZS50ZXh0KCk7XG4gIH0gOiBodHRwUmVqZWN0O1xufVxuLyoqXG4gKiBEZWZhdWx0IGh0dHAgcmVxdWVzdCBoYW5kbGVyIHRoYXQgc2ltcGx5IHJlamVjdHMuXG4gKi9cblxuXG5hc3luYyBmdW5jdGlvbiBodHRwUmVqZWN0KCkge1xuICBlcnJvcignTm8gSFRUUCBmZXRjaCBtZXRob2QgYXZhaWxhYmxlLicpO1xufVxuXG5jb25zdCBpc1ZhbGlkID0gXyA9PiBfICE9IG51bGwgJiYgXyA9PT0gXztcblxuY29uc3QgaXNCb29sZWFuID0gXyA9PiBfID09PSAndHJ1ZScgfHwgXyA9PT0gJ2ZhbHNlJyB8fCBfID09PSB0cnVlIHx8IF8gPT09IGZhbHNlO1xuXG5jb25zdCBpc0RhdGUgPSBfID0+ICFOdW1iZXIuaXNOYU4oRGF0ZS5wYXJzZShfKSk7XG5cbmNvbnN0IGlzTnVtYmVyID0gXyA9PiAhTnVtYmVyLmlzTmFOKCtfKSAmJiAhKF8gaW5zdGFuY2VvZiBEYXRlKTtcblxuY29uc3QgaXNJbnRlZ2VyID0gXyA9PiBpc051bWJlcihfKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKCtfKTtcblxuY29uc3QgdHlwZVBhcnNlcnMgPSB7XG4gIGJvb2xlYW46IHRvQm9vbGVhbixcbiAgaW50ZWdlcjogdG9OdW1iZXIsXG4gIG51bWJlcjogdG9OdW1iZXIsXG4gIGRhdGU6IHRvRGF0ZSxcbiAgc3RyaW5nOiB0b1N0cmluZyxcbiAgdW5rbm93bjogaWRlbnRpdHlcbn07XG5jb25zdCB0eXBlVGVzdHMgPSBbaXNCb29sZWFuLCBpc0ludGVnZXIsIGlzTnVtYmVyLCBpc0RhdGVdO1xuY29uc3QgdHlwZUxpc3QgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuZnVuY3Rpb24gaW5mZXJUeXBlKHZhbHVlcywgZmllbGQpIHtcbiAgaWYgKCF2YWx1ZXMgfHwgIXZhbHVlcy5sZW5ndGgpIHJldHVybiAndW5rbm93bic7XG4gIGNvbnN0IG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBtID0gdHlwZVRlc3RzLmxlbmd0aCxcbiAgICAgICAgYSA9IHR5cGVUZXN0cy5tYXAoKF8sIGkpID0+IGkgKyAxKTtcblxuICBmb3IgKGxldCBpID0gMCwgdCA9IDAsIGosIHZhbHVlOyBpIDwgbjsgKytpKSB7XG4gICAgdmFsdWUgPSBmaWVsZCA/IHZhbHVlc1tpXVtmaWVsZF0gOiB2YWx1ZXNbaV07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoYVtqXSAmJiBpc1ZhbGlkKHZhbHVlKSAmJiAhdHlwZVRlc3RzW2pdKHZhbHVlKSkge1xuICAgICAgICBhW2pdID0gMDtcbiAgICAgICAgKyt0O1xuICAgICAgICBpZiAodCA9PT0gdHlwZVRlc3RzLmxlbmd0aCkgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0eXBlTGlzdFthLnJlZHVjZSgodSwgdikgPT4gdSA9PT0gMCA/IHYgOiB1LCAwKSAtIDFdO1xufVxuZnVuY3Rpb24gaW5mZXJUeXBlcyhkYXRhLCBmaWVsZHMpIHtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKHR5cGVzLCBmaWVsZCkgPT4ge1xuICAgIHR5cGVzW2ZpZWxkXSA9IGluZmVyVHlwZShkYXRhLCBmaWVsZCk7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGRlbGltaXRlZEZvcm1hdChkZWxpbWl0ZXIpIHtcbiAgY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAoZGF0YSwgZm9ybWF0KSB7XG4gICAgY29uc3QgZGVsaW0gPSB7XG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlclxuICAgIH07XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyBleHRlbmQoZm9ybWF0LCBkZWxpbSkgOiBkZWxpbSk7XG4gIH07XG5cbiAgcGFyc2UucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICByZXR1cm4gcGFyc2U7XG59XG5mdW5jdGlvbiBkc3YoZGF0YSwgZm9ybWF0KSB7XG4gIGlmIChmb3JtYXQuaGVhZGVyKSB7XG4gICAgZGF0YSA9IGZvcm1hdC5oZWFkZXIubWFwKHN0cmluZ1ZhbHVlKS5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgKyBkYXRhO1xuICB9XG5cbiAgcmV0dXJuIGRzdkZvcm1hdChmb3JtYXQuZGVsaW1pdGVyKS5wYXJzZShkYXRhICsgJycpO1xufVxuZHN2LnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcblxuZnVuY3Rpb24gaXNCdWZmZXIoXykge1xuICByZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Z1bmN0aW9uKEJ1ZmZlci5pc0J1ZmZlcikgPyBCdWZmZXIuaXNCdWZmZXIoXykgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24ganNvbihkYXRhLCBmb3JtYXQpIHtcbiAgY29uc3QgcHJvcCA9IGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkgPyBmaWVsZChmb3JtYXQucHJvcGVydHkpIDogaWRlbnRpdHk7XG4gIHJldHVybiBpc09iamVjdChkYXRhKSAmJiAhaXNCdWZmZXIoZGF0YSkgPyBwYXJzZUpTT04ocHJvcChkYXRhKSwgZm9ybWF0KSA6IHByb3AoSlNPTi5wYXJzZShkYXRhKSk7XG59XG5qc29uLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcblxuZnVuY3Rpb24gcGFyc2VKU09OKGRhdGEsIGZvcm1hdCkge1xuICBpZiAoIWlzQXJyYXkoZGF0YSkgJiYgaXNJdGVyYWJsZShkYXRhKSkge1xuICAgIGRhdGEgPSBbLi4uZGF0YV07XG4gIH1cblxuICByZXR1cm4gZm9ybWF0ICYmIGZvcm1hdC5jb3B5ID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgOiBkYXRhO1xufVxuXG5jb25zdCBmaWx0ZXJzID0ge1xuICBpbnRlcmlvcjogKGEsIGIpID0+IGEgIT09IGIsXG4gIGV4dGVyaW9yOiAoYSwgYikgPT4gYSA9PT0gYlxufTtcbmZ1bmN0aW9uIHRvcG9qc29uKGRhdGEsIGZvcm1hdCkge1xuICBsZXQgbWV0aG9kLCBvYmplY3QsIHByb3BlcnR5LCBmaWx0ZXI7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIG1ldGhvZCA9IGZlYXR1cmU7XG4gICAgcHJvcGVydHkgPSBmb3JtYXQuZmVhdHVyZTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgJiYgZm9ybWF0Lm1lc2gpIHtcbiAgICBtZXRob2QgPSBtZXNoO1xuICAgIHByb3BlcnR5ID0gZm9ybWF0Lm1lc2g7XG4gICAgZmlsdGVyID0gZmlsdGVyc1tmb3JtYXQuZmlsdGVyXTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvcignTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgb2JqZWN0ID0gKG9iamVjdCA9IGRhdGEub2JqZWN0c1twcm9wZXJ0eV0pID8gbWV0aG9kKGRhdGEsIG9iamVjdCwgZmlsdGVyKSA6IGVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIHByb3BlcnR5KTtcbiAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuZmVhdHVyZXMgfHwgW29iamVjdF07XG59XG50b3BvanNvbi5yZXNwb25zZVR5cGUgPSAnanNvbic7XG5cbmNvbnN0IGZvcm1hdCA9IHtcbiAgZHN2OiBkc3YsXG4gIGNzdjogZGVsaW1pdGVkRm9ybWF0KCcsJyksXG4gIHRzdjogZGVsaW1pdGVkRm9ybWF0KCdcXHQnKSxcbiAganNvbjoganNvbixcbiAgdG9wb2pzb246IHRvcG9qc29uXG59O1xuZnVuY3Rpb24gZm9ybWF0cyhuYW1lLCByZWFkZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9ybWF0W25hbWVdID0gcmVhZGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eShmb3JtYXQsIG5hbWUpID8gZm9ybWF0W25hbWVdIDogbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzcG9uc2VUeXBlKHR5cGUpIHtcbiAgY29uc3QgZiA9IGZvcm1hdHModHlwZSk7XG4gIHJldHVybiBmICYmIGYucmVzcG9uc2VUeXBlIHx8ICd0ZXh0Jztcbn1cblxuZnVuY3Rpb24gcmVhZCAoZGF0YSwgc2NoZW1hLCB0aW1lUGFyc2VyLCB1dGNQYXJzZXIpIHtcbiAgc2NoZW1hID0gc2NoZW1hIHx8IHt9O1xuICBjb25zdCByZWFkZXIgPSBmb3JtYXRzKHNjaGVtYS50eXBlIHx8ICdqc29uJyk7XG4gIGlmICghcmVhZGVyKSBlcnJvcignVW5rbm93biBkYXRhIGZvcm1hdCB0eXBlOiAnICsgc2NoZW1hLnR5cGUpO1xuICBkYXRhID0gcmVhZGVyKGRhdGEsIHNjaGVtYSk7XG4gIGlmIChzY2hlbWEucGFyc2UpIHBhcnNlKGRhdGEsIHNjaGVtYS5wYXJzZSwgdGltZVBhcnNlciwgdXRjUGFyc2VyKTtcbiAgaWYgKGhhc093blByb3BlcnR5KGRhdGEsICdjb2x1bW5zJykpIGRlbGV0ZSBkYXRhLmNvbHVtbnM7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcywgdGltZVBhcnNlciwgdXRjUGFyc2VyKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjsgLy8gZWFybHkgZXhpdCBmb3IgZW1wdHkgZGF0YVxuXG4gIGNvbnN0IGxvY2FsZSA9IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHRpbWVQYXJzZXIgPSB0aW1lUGFyc2VyIHx8IGxvY2FsZS50aW1lUGFyc2U7XG4gIHV0Y1BhcnNlciA9IHV0Y1BhcnNlciB8fCBsb2NhbGUudXRjUGFyc2U7XG4gIGxldCBmaWVsZHMgPSBkYXRhLmNvbHVtbnMgfHwgT2JqZWN0LmtleXMoZGF0YVswXSksXG4gICAgICBkYXR1bSxcbiAgICAgIGZpZWxkLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICBuLFxuICAgICAgbTtcbiAgaWYgKHR5cGVzID09PSAnYXV0bycpIHR5cGVzID0gaW5mZXJUeXBlcyhkYXRhLCBmaWVsZHMpO1xuICBmaWVsZHMgPSBPYmplY3Qua2V5cyh0eXBlcyk7XG4gIGNvbnN0IHBhcnNlcnMgPSBmaWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmllbGRdO1xuICAgIGxldCBwYXJ0cywgcGF0dGVybjtcblxuICAgIGlmICh0eXBlICYmICh0eXBlLnN0YXJ0c1dpdGgoJ2RhdGU6JykgfHwgdHlwZS5zdGFydHNXaXRoKCd1dGM6JykpKSB7XG4gICAgICBwYXJ0cyA9IHR5cGUuc3BsaXQoLzooLispPy8sIDIpOyAvLyBzcGxpdCBvbiBmaXJzdCA6XG5cbiAgICAgIHBhdHRlcm4gPSBwYXJ0c1sxXTtcblxuICAgICAgaWYgKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJ1xcJycgfHwgcGF0dGVyblswXSA9PT0gJ1wiJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZSA9IHBhcnRzWzBdID09PSAndXRjJyA/IHV0Y1BhcnNlciA6IHRpbWVQYXJzZXI7XG4gICAgICByZXR1cm4gcGFyc2UocGF0dGVybik7XG4gICAgfVxuXG4gICAgaWYgKCF0eXBlUGFyc2Vyc1t0eXBlXSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0lsbGVnYWwgZm9ybWF0IHBhdHRlcm46ICcgKyBmaWVsZCArICc6JyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlUGFyc2Vyc1t0eXBlXTtcbiAgfSk7XG5cbiAgZm9yIChpID0gMCwgbiA9IGRhdGEubGVuZ3RoLCBtID0gZmllbGRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgZGF0dW1bZmllbGRdID0gcGFyc2Vyc1tqXShkYXR1bVtmaWVsZF0pO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2FkZXIgPSBsb2FkZXJGYWN0b3J5KHR5cGVvZiBmZXRjaCAhPT0gJ3VuZGVmaW5lZCcgJiYgZmV0Y2gsIC8vIHVzZSBidWlsdC1pbiBmZXRjaCBBUElcbm51bGwgLy8gbm8gZmlsZSBzeXN0ZW0gYWNjZXNzXG4pO1xuXG5leHBvcnQgeyBmb3JtYXQsIGZvcm1hdHMsIGluZmVyVHlwZSwgaW5mZXJUeXBlcywgbG9hZGVyLCByZWFkLCByZXNwb25zZVR5cGUsIHR5cGVQYXJzZXJzIH07XG4iLCJpbXBvcnQgeyBpc09iamVjdCwgaXNBcnJheSwgZXh0ZW5kLCBoYXNPd25Qcm9wZXJ0eSwgYXJyYXksIHN0cmluZ1ZhbHVlLCBwZWVrLCBpc1N0cmluZywgZXJyb3IsIHNwbGl0QWNjZXNzUGF0aCwgbWVyZ2VDb25maWcgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgcGFyc2VTZWxlY3RvciB9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuaW1wb3J0IHsgaXNWYWxpZFNjYWxlVHlwZSwgaXNEaXNjcmV0ZSwgaXNRdWFudGlsZSwgaXNEaXNjcmV0aXppbmcsIGlzQ29udGludW91cyB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgZGVmaW5pdGlvbiBhcyBkZWZpbml0aW9uJDEgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcblxuZnVuY3Rpb24gcGFyc2VBdXRvc2l6ZSAoc3BlYykge1xuICByZXR1cm4gaXNPYmplY3Qoc3BlYykgPyBzcGVjIDoge1xuICAgIHR5cGU6IHNwZWMgfHwgJ3BhZCdcbiAgfTtcbn1cblxuY29uc3QgbnVtYmVyID0gXyA9PiArXyB8fCAwO1xuXG5jb25zdCBwYWRkaW5nT2JqZWN0ID0gXyA9PiAoe1xuICB0b3A6IF8sXG4gIGJvdHRvbTogXyxcbiAgbGVmdDogXyxcbiAgcmlnaHQ6IF9cbn0pO1xuXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmcgKHNwZWMpIHtcbiAgcmV0dXJuICFpc09iamVjdChzcGVjKSA/IHBhZGRpbmdPYmplY3QobnVtYmVyKHNwZWMpKSA6IHNwZWMuc2lnbmFsID8gc3BlYyA6IHtcbiAgICB0b3A6IG51bWJlcihzcGVjLnRvcCksXG4gICAgYm90dG9tOiBudW1iZXIoc3BlYy5ib3R0b20pLFxuICAgIGxlZnQ6IG51bWJlcihzcGVjLmxlZnQpLFxuICAgIHJpZ2h0OiBudW1iZXIoc3BlYy5yaWdodClcbiAgfTtcbn1cblxuY29uc3QgZW5jb2RlciA9IF8gPT4gaXNPYmplY3QoXykgJiYgIWlzQXJyYXkoXykgPyBleHRlbmQoe30sIF8pIDoge1xuICB2YWx1ZTogX1xufTtcbmZ1bmN0aW9uIGFkZEVuY29kZShvYmplY3QsIG5hbWUsIHZhbHVlLCBzZXQpIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBjb25zdCBpc0VuY29kZXIgPSBpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCAmJiBpc09iamVjdCh2YWx1ZVswXSk7IC8vIEFsd2F5cyBhc3NpZ24gc2lnbmFsIHRvIHVwZGF0ZSwgZXZlbiBpZiB0aGUgc2lnbmFsIGlzIGZyb20gdGhlIGVudGVyIGJsb2NrXG5cbiAgICBpZiAoaXNFbmNvZGVyKSB7XG4gICAgICBvYmplY3QudXBkYXRlW25hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdFtzZXQgfHwgJ2VudGVyJ11bbmFtZV0gPSB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gYWRkRW5jb2RlcnMob2JqZWN0LCBlbnRlciwgdXBkYXRlKSB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBlbnRlcikge1xuICAgIGFkZEVuY29kZShvYmplY3QsIG5hbWUsIGVudGVyW25hbWVdKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbmFtZSBpbiB1cGRhdGUpIHtcbiAgICBhZGRFbmNvZGUob2JqZWN0LCBuYW1lLCB1cGRhdGVbbmFtZV0sICd1cGRhdGUnKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0ZW5kRW5jb2RlKGVuY29kZSwgZXh0cmEsIHNraXApIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIGV4dHJhKSB7XG4gICAgaWYgKHNraXAgJiYgaGFzT3duUHJvcGVydHkoc2tpcCwgbmFtZSkpIGNvbnRpbnVlO1xuICAgIGVuY29kZVtuYW1lXSA9IGV4dGVuZChlbmNvZGVbbmFtZV0gfHwge30sIGV4dHJhW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGU7XG59XG5mdW5jdGlvbiBoYXMoa2V5LCBlbmNvZGUpIHtcbiAgcmV0dXJuIGVuY29kZSAmJiAoZW5jb2RlLmVudGVyICYmIGVuY29kZS5lbnRlcltrZXldIHx8IGVuY29kZS51cGRhdGUgJiYgZW5jb2RlLnVwZGF0ZVtrZXldKTtcbn1cblxuY29uc3QgTWFya1JvbGUgPSAnbWFyayc7XG5jb25zdCBGcmFtZVJvbGUgPSAnZnJhbWUnO1xuY29uc3QgU2NvcGVSb2xlID0gJ3Njb3BlJztcbmNvbnN0IEF4aXNSb2xlID0gJ2F4aXMnO1xuY29uc3QgQXhpc0RvbWFpblJvbGUgPSAnYXhpcy1kb21haW4nO1xuY29uc3QgQXhpc0dyaWRSb2xlID0gJ2F4aXMtZ3JpZCc7XG5jb25zdCBBeGlzTGFiZWxSb2xlID0gJ2F4aXMtbGFiZWwnO1xuY29uc3QgQXhpc1RpY2tSb2xlID0gJ2F4aXMtdGljayc7XG5jb25zdCBBeGlzVGl0bGVSb2xlID0gJ2F4aXMtdGl0bGUnO1xuY29uc3QgTGVnZW5kUm9sZSA9ICdsZWdlbmQnO1xuY29uc3QgTGVnZW5kQmFuZFJvbGUgPSAnbGVnZW5kLWJhbmQnO1xuY29uc3QgTGVnZW5kRW50cnlSb2xlID0gJ2xlZ2VuZC1lbnRyeSc7XG5jb25zdCBMZWdlbmRHcmFkaWVudFJvbGUgPSAnbGVnZW5kLWdyYWRpZW50JztcbmNvbnN0IExlZ2VuZExhYmVsUm9sZSA9ICdsZWdlbmQtbGFiZWwnO1xuY29uc3QgTGVnZW5kU3ltYm9sUm9sZSA9ICdsZWdlbmQtc3ltYm9sJztcbmNvbnN0IExlZ2VuZFRpdGxlUm9sZSA9ICdsZWdlbmQtdGl0bGUnO1xuY29uc3QgVGl0bGVSb2xlID0gJ3RpdGxlJztcbmNvbnN0IFRpdGxlVGV4dFJvbGUgPSAndGl0bGUtdGV4dCc7XG5jb25zdCBUaXRsZVN1YnRpdGxlUm9sZSA9ICd0aXRsZS1zdWJ0aXRsZSc7XG5cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMgKGVuY29kZSwgdHlwZSwgcm9sZSwgc3R5bGUsIGNvbmZpZykge1xuICBjb25zdCBkZWZhdWx0cyA9IHt9LFxuICAgICAgICBlbnRlciA9IHt9O1xuICBsZXQgdXBkYXRlLCBrZXksIHNraXAsIHByb3BzOyAvLyBpZiB0ZXh0IG1hcmssIGFwcGx5IGdsb2JhbCBsaW5lQnJlYWsgc2V0dGluZ3MgKCMyMzcwKVxuXG4gIGtleSA9ICdsaW5lQnJlYWsnO1xuXG4gIGlmICh0eXBlID09PSAndGV4dCcgJiYgY29uZmlnW2tleV0gIT0gbnVsbCAmJiAhaGFzKGtleSwgZW5jb2RlKSkge1xuICAgIGFwcGx5RGVmYXVsdChkZWZhdWx0cywga2V5LCBjb25maWdba2V5XSk7XG4gIH0gLy8gaWdub3JlIGxlZ2VuZCBhbmQgYXhpcyByb2xlc1xuXG5cbiAgaWYgKHJvbGUgPT0gJ2xlZ2VuZCcgfHwgU3RyaW5nKHJvbGUpLnN0YXJ0c1dpdGgoJ2F4aXMnKSkge1xuICAgIHJvbGUgPSBudWxsO1xuICB9IC8vIHJlc29sdmUgbWFyayBjb25maWdcblxuXG4gIHByb3BzID0gcm9sZSA9PT0gRnJhbWVSb2xlID8gY29uZmlnLmdyb3VwIDogcm9sZSA9PT0gTWFya1JvbGUgPyBleHRlbmQoe30sIGNvbmZpZy5tYXJrLCBjb25maWdbdHlwZV0pIDogbnVsbDtcblxuICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgIC8vIGRvIG5vdCBhcHBseSBkZWZhdWx0cyBpZiByZWxldmFudCBmaWVsZHMgYXJlIGRlZmluZWRcbiAgICBza2lwID0gaGFzKGtleSwgZW5jb2RlKSB8fCAoa2V5ID09PSAnZmlsbCcgfHwga2V5ID09PSAnc3Ryb2tlJykgJiYgKGhhcygnZmlsbCcsIGVuY29kZSkgfHwgaGFzKCdzdHJva2UnLCBlbmNvZGUpKTtcbiAgICBpZiAoIXNraXApIGFwcGx5RGVmYXVsdChkZWZhdWx0cywga2V5LCBwcm9wc1trZXldKTtcbiAgfSAvLyByZXNvbHZlIHN0eWxlcywgYXBwbHkgd2l0aCBpbmNyZWFzaW5nIHByZWNlZGVuY2VcblxuXG4gIGFycmF5KHN0eWxlKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgIGNvbnN0IHByb3BzID0gY29uZmlnLnN0eWxlICYmIGNvbmZpZy5zdHlsZVtuYW1lXTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIWhhcyhrZXksIGVuY29kZSkpIHtcbiAgICAgICAgYXBwbHlEZWZhdWx0KGRlZmF1bHRzLCBrZXksIHByb3BzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVuY29kZSA9IGV4dGVuZCh7fSwgZW5jb2RlKTsgLy8gZGVmZW5zaXZlIGNvcHlcblxuICBmb3IgKGtleSBpbiBkZWZhdWx0cykge1xuICAgIHByb3BzID0gZGVmYXVsdHNba2V5XTtcblxuICAgIGlmIChwcm9wcy5zaWduYWwpIHtcbiAgICAgICh1cGRhdGUgPSB1cGRhdGUgfHwge30pW2tleV0gPSBwcm9wcztcbiAgICB9IGVsc2Uge1xuICAgICAgZW50ZXJba2V5XSA9IHByb3BzO1xuICAgIH1cbiAgfVxuXG4gIGVuY29kZS5lbnRlciA9IGV4dGVuZChlbnRlciwgZW5jb2RlLmVudGVyKTtcbiAgaWYgKHVwZGF0ZSkgZW5jb2RlLnVwZGF0ZSA9IGV4dGVuZCh1cGRhdGUsIGVuY29kZS51cGRhdGUpO1xuICByZXR1cm4gZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgdmFsdWUpIHtcbiAgZGVmYXVsdHNba2V5XSA9IHZhbHVlICYmIHZhbHVlLnNpZ25hbCA/IHtcbiAgICBzaWduYWw6IHZhbHVlLnNpZ25hbFxuICB9IDoge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufVxuXG5jb25zdCBzY2FsZVJlZiA9IHNjYWxlID0+IGlzU3RyaW5nKHNjYWxlKSA/IHN0cmluZ1ZhbHVlKHNjYWxlKSA6IHNjYWxlLnNpZ25hbCA/IGAoJHtzY2FsZS5zaWduYWx9KWAgOiBmaWVsZChzY2FsZSk7XG5cbmZ1bmN0aW9uIGVudHJ5JDEoZW5jKSB7XG4gIGlmIChlbmMuZ3JhZGllbnQgIT0gbnVsbCkge1xuICAgIHJldHVybiBncmFkaWVudChlbmMpO1xuICB9XG5cbiAgbGV0IHZhbHVlID0gZW5jLnNpZ25hbCA/IGAoJHtlbmMuc2lnbmFsfSlgIDogZW5jLmNvbG9yID8gY29sb3IoZW5jLmNvbG9yKSA6IGVuYy5maWVsZCAhPSBudWxsID8gZmllbGQoZW5jLmZpZWxkKSA6IGVuYy52YWx1ZSAhPT0gdW5kZWZpbmVkID8gc3RyaW5nVmFsdWUoZW5jLnZhbHVlKSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZW5jLnNjYWxlICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IHNjYWxlKGVuYywgdmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cblxuICBpZiAoZW5jLmV4cG9uZW50ICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IGBwb3coJHt2YWx1ZX0sJHtwcm9wZXJ0eShlbmMuZXhwb25lbnQpfSlgO1xuICB9XG5cbiAgaWYgKGVuYy5tdWx0ICE9IG51bGwpIHtcbiAgICB2YWx1ZSArPSBgKiR7cHJvcGVydHkoZW5jLm11bHQpfWA7XG4gIH1cblxuICBpZiAoZW5jLm9mZnNldCAhPSBudWxsKSB7XG4gICAgdmFsdWUgKz0gYCske3Byb3BlcnR5KGVuYy5vZmZzZXQpfWA7XG4gIH1cblxuICBpZiAoZW5jLnJvdW5kKSB7XG4gICAgdmFsdWUgPSBgcm91bmQoJHt2YWx1ZX0pYDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuY29uc3QgX2NvbG9yID0gKHR5cGUsIHgsIHksIHopID0+IGAoJHt0eXBlfSgke1t4LCB5LCB6XS5tYXAoZW50cnkkMSkuam9pbignLCcpfSkrJycpYDtcblxuZnVuY3Rpb24gY29sb3IoZW5jKSB7XG4gIHJldHVybiBlbmMuYyA/IF9jb2xvcignaGNsJywgZW5jLmgsIGVuYy5jLCBlbmMubCkgOiBlbmMuaCB8fCBlbmMucyA/IF9jb2xvcignaHNsJywgZW5jLmgsIGVuYy5zLCBlbmMubCkgOiBlbmMubCB8fCBlbmMuYSA/IF9jb2xvcignbGFiJywgZW5jLmwsIGVuYy5hLCBlbmMuYikgOiBlbmMuciB8fCBlbmMuZyB8fCBlbmMuYiA/IF9jb2xvcigncmdiJywgZW5jLnIsIGVuYy5nLCBlbmMuYikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChlbmMpIHtcbiAgLy8gbWFwIHVuZGVmaW5lZCB0byBudWxsOyBleHByZXNzaW9uIGxhbmcgZG9lcyBub3QgYWxsb3cgdW5kZWZpbmVkXG4gIGNvbnN0IGFyZ3MgPSBbZW5jLnN0YXJ0LCBlbmMuc3RvcCwgZW5jLmNvdW50XS5tYXAoXyA9PiBfID09IG51bGwgPyBudWxsIDogc3RyaW5nVmFsdWUoXykpOyAvLyB0cmltIG51bGwgaW5wdXRzIGZyb20gdGhlIGVuZFxuXG4gIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBwZWVrKGFyZ3MpID09IG51bGwpIGFyZ3MucG9wKCk7XG5cbiAgYXJncy51bnNoaWZ0KHNjYWxlUmVmKGVuYy5ncmFkaWVudCkpO1xuICByZXR1cm4gYGdyYWRpZW50KCR7YXJncy5qb2luKCcsJyl9KWA7XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBpc09iamVjdChwcm9wZXJ0eSkgPyAnKCcgKyBlbnRyeSQxKHByb3BlcnR5KSArICcpJyA6IHByb3BlcnR5O1xufVxuXG5mdW5jdGlvbiBmaWVsZChyZWYpIHtcbiAgcmV0dXJuIHJlc29sdmVGaWVsZChpc09iamVjdChyZWYpID8gcmVmIDoge1xuICAgIGRhdHVtOiByZWZcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGaWVsZChyZWYpIHtcbiAgbGV0IG9iamVjdCwgbGV2ZWwsIGZpZWxkO1xuXG4gIGlmIChyZWYuc2lnbmFsKSB7XG4gICAgb2JqZWN0ID0gJ2RhdHVtJztcbiAgICBmaWVsZCA9IHJlZi5zaWduYWw7XG4gIH0gZWxzZSBpZiAocmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQpIHtcbiAgICBsZXZlbCA9IE1hdGgubWF4KDEsIHJlZi5sZXZlbCB8fCAxKTtcbiAgICBvYmplY3QgPSAnaXRlbSc7XG5cbiAgICB3aGlsZSAobGV2ZWwtLSA+IDApIHtcbiAgICAgIG9iamVjdCArPSAnLm1hcmsuZ3JvdXAnO1xuICAgIH1cblxuICAgIGlmIChyZWYucGFyZW50KSB7XG4gICAgICBmaWVsZCA9IHJlZi5wYXJlbnQ7XG4gICAgICBvYmplY3QgKz0gJy5kYXR1bSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpZWxkID0gcmVmLmdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWYuZGF0dW0pIHtcbiAgICBvYmplY3QgPSAnZGF0dW0nO1xuICAgIGZpZWxkID0gcmVmLmRhdHVtO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKCdJbnZhbGlkIGZpZWxkIHJlZmVyZW5jZTogJyArIHN0cmluZ1ZhbHVlKHJlZikpO1xuICB9XG5cbiAgaWYgKCFyZWYuc2lnbmFsKSB7XG4gICAgZmllbGQgPSBpc1N0cmluZyhmaWVsZCkgPyBzcGxpdEFjY2Vzc1BhdGgoZmllbGQpLm1hcChzdHJpbmdWYWx1ZSkuam9pbignXVsnKSA6IHJlc29sdmVGaWVsZChmaWVsZCk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0ICsgJ1snICsgZmllbGQgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIHNjYWxlKGVuYywgdmFsdWUpIHtcbiAgY29uc3Qgc2NhbGUgPSBzY2FsZVJlZihlbmMuc2NhbGUpO1xuXG4gIGlmIChlbmMucmFuZ2UgIT0gbnVsbCkge1xuICAgIC8vIHB1bGwgdmFsdWUgZnJvbSBzY2FsZSByYW5nZVxuICAgIHZhbHVlID0gYGxlcnAoX3JhbmdlKCR7c2NhbGV9KSwgJHsrZW5jLnJhbmdlfSlgO1xuICB9IGVsc2Uge1xuICAgIC8vIHJ1biB2YWx1ZSB0aHJvdWdoIHNjYWxlIGFuZC9vciBwdWxsIHNjYWxlIGJhbmR3aWR0aFxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB2YWx1ZSA9IGBfc2NhbGUoJHtzY2FsZX0sICR7dmFsdWV9KWA7XG5cbiAgICBpZiAoZW5jLmJhbmQpIHtcbiAgICAgIHZhbHVlID0gKHZhbHVlID8gdmFsdWUgKyAnKycgOiAnJykgKyBgX2JhbmR3aWR0aCgke3NjYWxlfSlgICsgKCtlbmMuYmFuZCA9PT0gMSA/ICcnIDogJyonICsgcHJvcGVydHkoZW5jLmJhbmQpKTtcblxuICAgICAgaWYgKGVuYy5leHRyYSkge1xuICAgICAgICAvLyBpbmNsdWRlIGxvZ2ljIHRvIGhhbmRsZSBleHRyYW5lb3VzIGVsZW1lbnRzXG4gICAgICAgIHZhbHVlID0gYChkYXR1bS5leHRyYSA/IF9zY2FsZSgke3NjYWxlfSwgZGF0dW0uZXh0cmEudmFsdWUpIDogJHt2YWx1ZX0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSAnMCc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJ1bGUgKGVuYykge1xuICBsZXQgY29kZSA9ICcnO1xuICBlbmMuZm9yRWFjaChydWxlID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGVudHJ5JDEocnVsZSk7XG4gICAgY29kZSArPSBydWxlLnRlc3QgPyBgKCR7cnVsZS50ZXN0fSk/JHt2YWx1ZX06YCA6IHZhbHVlO1xuICB9KTsgLy8gaWYgbm8gZWxzZSBjbGF1c2UsIHRlcm1pbmF0ZSB3aXRoIG51bGwgKCMxMzY2KVxuXG4gIGlmIChwZWVrKGNvZGUpID09PSAnOicpIHtcbiAgICBjb2RlICs9ICdudWxsJztcbiAgfVxuXG4gIHJldHVybiBjb2RlO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVuY29kZSAoZW5jb2RlLCB0eXBlLCByb2xlLCBzdHlsZSwgc2NvcGUsIHBhcmFtcykge1xuICBjb25zdCBlbmMgPSB7fTtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBwYXJhbXMuZW5jb2RlcnMgPSB7XG4gICAgJGVuY29kZTogZW5jXG4gIH07XG4gIGVuY29kZSA9IGFwcGx5RGVmYXVsdHMoZW5jb2RlLCB0eXBlLCByb2xlLCBzdHlsZSwgc2NvcGUuY29uZmlnKTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBlbmNvZGUpIHtcbiAgICBlbmNba2V5XSA9IHBhcnNlQmxvY2soZW5jb2RlW2tleV0sIHR5cGUsIHBhcmFtcywgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VCbG9jayhibG9jaywgbWFya3R5cGUsIHBhcmFtcywgc2NvcGUpIHtcbiAgY29uc3QgY2hhbm5lbHMgPSB7fSxcbiAgICAgICAgZmllbGRzID0ge307XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGJsb2NrKSB7XG4gICAgaWYgKGJsb2NrW25hbWVdICE9IG51bGwpIHtcbiAgICAgIC8vIHNraXAgYW55IG51bGwgZW50cmllc1xuICAgICAgY2hhbm5lbHNbbmFtZV0gPSBwYXJzZSQxKGV4cHIoYmxvY2tbbmFtZV0pLCBzY29wZSwgcGFyYW1zLCBmaWVsZHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgJGV4cHI6IHtcbiAgICAgIG1hcmt0eXBlLFxuICAgICAgY2hhbm5lbHNcbiAgICB9LFxuICAgICRmaWVsZHM6IE9iamVjdC5rZXlzKGZpZWxkcyksXG4gICAgJG91dHB1dDogT2JqZWN0LmtleXMoYmxvY2spXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cHIoZW5jKSB7XG4gIHJldHVybiBpc0FycmF5KGVuYykgPyBydWxlKGVuYykgOiBlbnRyeSQxKGVuYyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlJDEoY29kZSwgc2NvcGUsIHBhcmFtcywgZmllbGRzKSB7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oY29kZSwgc2NvcGUpO1xuICBleHByLiRmaWVsZHMuZm9yRWFjaChuYW1lID0+IGZpZWxkc1tuYW1lXSA9IDEpO1xuICBleHRlbmQocGFyYW1zLCBleHByLiRwYXJhbXMpO1xuICByZXR1cm4gZXhwci4kZXhwcjtcbn1cblxuY29uc3QgT1VURVIgPSAnb3V0ZXInLFxuICAgICAgT1VURVJfSU5WQUxJRCA9IFsndmFsdWUnLCAndXBkYXRlJywgJ2luaXQnLCAncmVhY3QnLCAnYmluZCddO1xuXG5mdW5jdGlvbiBvdXRlckVycm9yKHByZWZpeCwgbmFtZSkge1xuICBlcnJvcihwcmVmaXggKyAnIGZvciBcIm91dGVyXCIgcHVzaDogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduYWwgKHNpZ25hbCwgc2NvcGUpIHtcbiAgY29uc3QgbmFtZSA9IHNpZ25hbC5uYW1lO1xuXG4gIGlmIChzaWduYWwucHVzaCA9PT0gT1VURVIpIHtcbiAgICAvLyBzaWduYWwgbXVzdCBhbHJlYWR5IGJlIGRlZmluZWQsIHJhaXNlIGVycm9yIGlmIG5vdFxuICAgIGlmICghc2NvcGUuc2lnbmFsc1tuYW1lXSkgb3V0ZXJFcnJvcignTm8gcHJpb3Igc2lnbmFsIGRlZmluaXRpb24nLCBuYW1lKTsgLy8gc2lnbmFsIHB1c2ggbXVzdCBub3QgdXNlIHByb3BlcnRpZXMgcmVzZXJ2ZWQgZm9yIHN0YW5kYXJkIGRlZmluaXRpb25cblxuICAgIE9VVEVSX0lOVkFMSUQuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGlmIChzaWduYWxbcHJvcF0gIT09IHVuZGVmaW5lZCkgb3V0ZXJFcnJvcignSW52YWxpZCBwcm9wZXJ0eSAnLCBwcm9wKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZpbmUgYSBuZXcgc2lnbmFsIGluIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgY29uc3Qgb3AgPSBzY29wZS5hZGRTaWduYWwobmFtZSwgc2lnbmFsLnZhbHVlKTtcbiAgICBpZiAoc2lnbmFsLnJlYWN0ID09PSBmYWxzZSkgb3AucmVhY3QgPSBmYWxzZTtcbiAgICBpZiAoc2lnbmFsLmJpbmQpIHNjb3BlLmFkZEJpbmRpbmcobmFtZSwgc2lnbmFsLmJpbmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIEVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCkge1xuICB0aGlzLmlkID0gLTE7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIGlmIChwYXJlbnQpIHRoaXMucGFyZW50ID0gcGFyZW50O1xufVxuZnVuY3Rpb24gZW50cnkodHlwZSwgdmFsdWUsIHBhcmFtcywgcGFyZW50KSB7XG4gIHJldHVybiBuZXcgRW50cnkodHlwZSwgdmFsdWUsIHBhcmFtcywgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIG9wZXJhdG9yKHZhbHVlLCBwYXJhbXMpIHtcbiAgcmV0dXJuIGVudHJ5KCdvcGVyYXRvcicsIHZhbHVlLCBwYXJhbXMpO1xufSAvLyAtLS0tLVxuXG5mdW5jdGlvbiByZWYob3ApIHtcbiAgY29uc3QgcmVmID0ge1xuICAgICRyZWY6IG9wLmlkXG4gIH07IC8vIGlmIG9wZXJhdG9yIG5vdCB5ZXQgcmVnaXN0ZXJlZCwgY2FjaGUgcmVmIHRvIHJlc29sdmUgbGF0ZXJcblxuICBpZiAob3AuaWQgPCAwKSAob3AucmVmcyA9IG9wLnJlZnMgfHwgW10pLnB1c2gocmVmKTtcbiAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIGZpZWxkUmVmJDEoZmllbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPyB7XG4gICAgJGZpZWxkOiBmaWVsZCxcbiAgICAkbmFtZTogbmFtZVxuICB9IDoge1xuICAgICRmaWVsZDogZmllbGRcbiAgfTtcbn1cbmNvbnN0IGtleUZpZWxkUmVmID0gZmllbGRSZWYkMSgna2V5Jyk7XG5mdW5jdGlvbiBjb21wYXJlUmVmKGZpZWxkcywgb3JkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgJGNvbXBhcmU6IGZpZWxkcyxcbiAgICAkb3JkZXI6IG9yZGVyc1xuICB9O1xufVxuZnVuY3Rpb24ga2V5UmVmKGZpZWxkcywgZmxhdCkge1xuICBjb25zdCByZWYgPSB7XG4gICAgJGtleTogZmllbGRzXG4gIH07XG4gIGlmIChmbGF0KSByZWYuJGZsYXQgPSB0cnVlO1xuICByZXR1cm4gcmVmO1xufSAvLyAtLS0tLVxuXG5jb25zdCBBc2NlbmRpbmcgPSAnYXNjZW5kaW5nJztcbmNvbnN0IERlc2NlbmRpbmcgPSAnZGVzY2VuZGluZyc7XG5mdW5jdGlvbiBzb3J0S2V5KHNvcnQpIHtcbiAgcmV0dXJuICFpc09iamVjdChzb3J0KSA/ICcnIDogKHNvcnQub3JkZXIgPT09IERlc2NlbmRpbmcgPyAnLScgOiAnKycpICsgYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpO1xufVxuZnVuY3Rpb24gYWdnckZpZWxkKG9wLCBmaWVsZCkge1xuICByZXR1cm4gKG9wICYmIG9wLnNpZ25hbCA/ICckJyArIG9wLnNpZ25hbCA6IG9wIHx8ICcnKSArIChvcCAmJiBmaWVsZCA/ICdfJyA6ICcnKSArIChmaWVsZCAmJiBmaWVsZC5zaWduYWwgPyAnJCcgKyBmaWVsZC5zaWduYWwgOiBmaWVsZCB8fCAnJyk7XG59IC8vIC0tLS0tXG5cbmNvbnN0IFNjb3BlJDEgPSAnc2NvcGUnO1xuY29uc3QgVmlldyA9ICd2aWV3JztcbmZ1bmN0aW9uIGlzU2lnbmFsKF8pIHtcbiAgcmV0dXJuIF8gJiYgXy5zaWduYWw7XG59XG5mdW5jdGlvbiBpc0V4cHIkMShfKSB7XG4gIHJldHVybiBfICYmIF8uZXhwcjtcbn1cbmZ1bmN0aW9uIGhhc1NpZ25hbChfKSB7XG4gIGlmIChpc1NpZ25hbChfKSkgcmV0dXJuIHRydWU7XG4gIGlmIChpc09iamVjdChfKSkgZm9yIChjb25zdCBrZXkgaW4gXykge1xuICAgIGlmIChoYXNTaWduYWwoX1trZXldKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdmFsdWUoc3BlY1ZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHNwZWNWYWx1ZSAhPSBudWxsID8gc3BlY1ZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gZGVyZWYodikge1xuICByZXR1cm4gdiAmJiB2LnNpZ25hbCB8fCB2O1xufVxuXG5jb25zdCBUaW1lciA9ICd0aW1lcic7XG5mdW5jdGlvbiBwYXJzZVN0cmVhbShzdHJlYW0sIHNjb3BlKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHN0cmVhbS5tZXJnZSA/IG1lcmdlU3RyZWFtIDogc3RyZWFtLnN0cmVhbSA/IG5lc3RlZFN0cmVhbSA6IHN0cmVhbS50eXBlID8gZXZlbnRTdHJlYW0gOiBlcnJvcignSW52YWxpZCBzdHJlYW0gc3BlY2lmaWNhdGlvbjogJyArIHN0cmluZ1ZhbHVlKHN0cmVhbSkpO1xuICByZXR1cm4gbWV0aG9kKHN0cmVhbSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFNvdXJjZShzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSA9PT0gU2NvcGUkMSA/IFZpZXcgOiBzb3VyY2UgfHwgVmlldztcbn1cblxuZnVuY3Rpb24gbWVyZ2VTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBjb25zdCBsaXN0ID0gc3RyZWFtLm1lcmdlLm1hcChzID0+IHBhcnNlU3RyZWFtKHMsIHNjb3BlKSksXG4gICAgICAgIGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgbWVyZ2U6IGxpc3RcbiAgfSwgc3RyZWFtLCBzY29wZSk7XG4gIHJldHVybiBzY29wZS5hZGRTdHJlYW0oZW50cnkpLmlkO1xufVxuXG5mdW5jdGlvbiBuZXN0ZWRTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBjb25zdCBpZCA9IHBhcnNlU3RyZWFtKHN0cmVhbS5zdHJlYW0sIHNjb3BlKSxcbiAgICAgICAgZW50cnkgPSBzdHJlYW1QYXJhbWV0ZXJzKHtcbiAgICBzdHJlYW06IGlkXG4gIH0sIHN0cmVhbSwgc2NvcGUpO1xuICByZXR1cm4gc2NvcGUuYWRkU3RyZWFtKGVudHJ5KS5pZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBsZXQgaWQ7XG5cbiAgaWYgKHN0cmVhbS50eXBlID09PSBUaW1lcikge1xuICAgIGlkID0gc2NvcGUuZXZlbnQoVGltZXIsIHN0cmVhbS50aHJvdHRsZSk7XG4gICAgc3RyZWFtID0ge1xuICAgICAgYmV0d2Vlbjogc3RyZWFtLmJldHdlZW4sXG4gICAgICBmaWx0ZXI6IHN0cmVhbS5maWx0ZXJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGlkID0gc2NvcGUuZXZlbnQoZXZlbnRTb3VyY2Uoc3RyZWFtLnNvdXJjZSksIHN0cmVhbS50eXBlKTtcbiAgfVxuXG4gIGNvbnN0IGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgc3RyZWFtOiBpZFxuICB9LCBzdHJlYW0sIHNjb3BlKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGVudHJ5KS5sZW5ndGggPT09IDEgPyBpZCA6IHNjb3BlLmFkZFN0cmVhbShlbnRyeSkuaWQ7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVBhcmFtZXRlcnMoZW50cnksIHN0cmVhbSwgc2NvcGUpIHtcbiAgbGV0IHBhcmFtID0gc3RyZWFtLmJldHdlZW47XG5cbiAgaWYgKHBhcmFtKSB7XG4gICAgaWYgKHBhcmFtLmxlbmd0aCAhPT0gMikge1xuICAgICAgZXJyb3IoJ1N0cmVhbSBcImJldHdlZW5cIiBwYXJhbWV0ZXIgbXVzdCBoYXZlIDIgZW50cmllczogJyArIHN0cmluZ1ZhbHVlKHN0cmVhbSkpO1xuICAgIH1cblxuICAgIGVudHJ5LmJldHdlZW4gPSBbcGFyc2VTdHJlYW0ocGFyYW1bMF0sIHNjb3BlKSwgcGFyc2VTdHJlYW0ocGFyYW1bMV0sIHNjb3BlKV07XG4gIH1cblxuICBwYXJhbSA9IHN0cmVhbS5maWx0ZXIgPyBbXS5jb25jYXQoc3RyZWFtLmZpbHRlcikgOiBbXTtcblxuICBpZiAoc3RyZWFtLm1hcmt0eXBlIHx8IHN0cmVhbS5tYXJrbmFtZSB8fCBzdHJlYW0ubWFya3JvbGUpIHtcbiAgICAvLyBhZGQgZmlsdGVyIGZvciBtYXJrIHR5cGUsIG5hbWUgYW5kL29yIHJvbGVcbiAgICBwYXJhbS5wdXNoKGZpbHRlck1hcmsoc3RyZWFtLm1hcmt0eXBlLCBzdHJlYW0ubWFya25hbWUsIHN0cmVhbS5tYXJrcm9sZSkpO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5zb3VyY2UgPT09IFNjb3BlJDEpIHtcbiAgICAvLyBhZGQgZmlsdGVyIHRvIGxpbWl0IGV2ZW50cyBmcm9tIHN1Yi1zY29wZSBvbmx5XG4gICAgcGFyYW0ucHVzaCgnaW5TY29wZShldmVudC5pdGVtKScpO1xuICB9XG5cbiAgaWYgKHBhcmFtLmxlbmd0aCkge1xuICAgIGVudHJ5LmZpbHRlciA9IHBhcnNlRXhwcmVzc2lvbignKCcgKyBwYXJhbS5qb2luKCcpJiYoJykgKyAnKScsIHNjb3BlKS4kZXhwcjtcbiAgfVxuXG4gIGlmICgocGFyYW0gPSBzdHJlYW0udGhyb3R0bGUpICE9IG51bGwpIHtcbiAgICBlbnRyeS50aHJvdHRsZSA9ICtwYXJhbTtcbiAgfVxuXG4gIGlmICgocGFyYW0gPSBzdHJlYW0uZGVib3VuY2UpICE9IG51bGwpIHtcbiAgICBlbnRyeS5kZWJvdW5jZSA9ICtwYXJhbTtcbiAgfVxuXG4gIGlmIChzdHJlYW0uY29uc3VtZSkge1xuICAgIGVudHJ5LmNvbnN1bWUgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5O1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJNYXJrKHR5cGUsIG5hbWUsIHJvbGUpIHtcbiAgY29uc3QgaXRlbSA9ICdldmVudC5pdGVtJztcbiAgcmV0dXJuIGl0ZW0gKyAodHlwZSAmJiB0eXBlICE9PSAnKicgPyAnJiYnICsgaXRlbSArICcubWFyay5tYXJrdHlwZT09PVxcJycgKyB0eXBlICsgJ1xcJycgOiAnJykgKyAocm9sZSA/ICcmJicgKyBpdGVtICsgJy5tYXJrLnJvbGU9PT1cXCcnICsgcm9sZSArICdcXCcnIDogJycpICsgKG5hbWUgPyAnJiYnICsgaXRlbSArICcubWFyay5uYW1lPT09XFwnJyArIG5hbWUgKyAnXFwnJyA6ICcnKTtcbn1cblxuY29uc3QgT1BfVkFMVUVfRVhQUiA9IHtcbiAgY29kZTogJ18uJHZhbHVlJyxcbiAgYXN0OiB7XG4gICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgIHZhbHVlOiAndmFsdWUnXG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZVVwZGF0ZSAoc3BlYywgc2NvcGUsIHRhcmdldCkge1xuICBjb25zdCBlbmNvZGUgPSBzcGVjLmVuY29kZSxcbiAgICAgICAgZW50cnkgPSB7XG4gICAgdGFyZ2V0OiB0YXJnZXRcbiAgfTtcbiAgbGV0IGV2ZW50cyA9IHNwZWMuZXZlbnRzLFxuICAgICAgdXBkYXRlID0gc3BlYy51cGRhdGUsXG4gICAgICBzb3VyY2VzID0gW107XG5cbiAgaWYgKCFldmVudHMpIHtcbiAgICBlcnJvcignU2lnbmFsIHVwZGF0ZSBtaXNzaW5nIGV2ZW50cyBzcGVjaWZpY2F0aW9uLicpO1xuICB9IC8vIGludGVycHJldCBhcyBhbiBldmVudCBzZWxlY3RvciBzdHJpbmdcblxuXG4gIGlmIChpc1N0cmluZyhldmVudHMpKSB7XG4gICAgZXZlbnRzID0gcGFyc2VTZWxlY3RvcihldmVudHMsIHNjb3BlLmlzU3Vic2NvcGUoKSA/IFNjb3BlJDEgOiBWaWV3KTtcbiAgfSAvLyBzZXBhcmF0ZSBldmVudCBzdHJlYW1zIGZyb20gc2lnbmFsIHVwZGF0ZXNcblxuXG4gIGV2ZW50cyA9IGFycmF5KGV2ZW50cykuZmlsdGVyKHMgPT4gcy5zaWduYWwgfHwgcy5zY2FsZSA/IChzb3VyY2VzLnB1c2gocyksIDApIDogMSk7IC8vIG1lcmdlIGludGVybmFsIG9wZXJhdG9yIGxpc3RlbmVyc1xuXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBzb3VyY2VzID0gW21lcmdlU291cmNlcyhzb3VyY2VzKV07XG4gIH0gLy8gbWVyZ2UgZXZlbnQgc3RyZWFtcywgaW5jbHVkZSBhcyBzb3VyY2VcblxuXG4gIGlmIChldmVudHMubGVuZ3RoKSB7XG4gICAgc291cmNlcy5wdXNoKGV2ZW50cy5sZW5ndGggPiAxID8ge1xuICAgICAgbWVyZ2U6IGV2ZW50c1xuICAgIH0gOiBldmVudHNbMF0pO1xuICB9XG5cbiAgaWYgKGVuY29kZSAhPSBudWxsKSB7XG4gICAgaWYgKHVwZGF0ZSkgZXJyb3IoJ1NpZ25hbCBlbmNvZGUgYW5kIHVwZGF0ZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLicpO1xuICAgIHVwZGF0ZSA9ICdlbmNvZGUoaXRlbSgpLCcgKyBzdHJpbmdWYWx1ZShlbmNvZGUpICsgJyknO1xuICB9IC8vIHJlc29sdmUgdXBkYXRlIHZhbHVlXG5cblxuICBlbnRyeS51cGRhdGUgPSBpc1N0cmluZyh1cGRhdGUpID8gcGFyc2VFeHByZXNzaW9uKHVwZGF0ZSwgc2NvcGUpIDogdXBkYXRlLmV4cHIgIT0gbnVsbCA/IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUuZXhwciwgc2NvcGUpIDogdXBkYXRlLnZhbHVlICE9IG51bGwgPyB1cGRhdGUudmFsdWUgOiB1cGRhdGUuc2lnbmFsICE9IG51bGwgPyB7XG4gICAgJGV4cHI6IE9QX1ZBTFVFX0VYUFIsXG4gICAgJHBhcmFtczoge1xuICAgICAgJHZhbHVlOiBzY29wZS5zaWduYWxSZWYodXBkYXRlLnNpZ25hbClcbiAgICB9XG4gIH0gOiBlcnJvcignSW52YWxpZCBzaWduYWwgdXBkYXRlIHNwZWNpZmljYXRpb24uJyk7XG5cbiAgaWYgKHNwZWMuZm9yY2UpIHtcbiAgICBlbnRyeS5vcHRpb25zID0ge1xuICAgICAgZm9yY2U6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgc291cmNlcy5mb3JFYWNoKHNvdXJjZSA9PiBzY29wZS5hZGRVcGRhdGUoZXh0ZW5kKHN0cmVhbVNvdXJjZShzb3VyY2UsIHNjb3BlKSwgZW50cnkpKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVNvdXJjZShzdHJlYW0sIHNjb3BlKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzdHJlYW0uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHN0cmVhbS5zaWduYWwpIDogc3RyZWFtLnNjYWxlID8gc2NvcGUuc2NhbGVSZWYoc3RyZWFtLnNjYWxlKSA6IHBhcnNlU3RyZWFtKHN0cmVhbSwgc2NvcGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1lcmdlU291cmNlcyhzb3VyY2VzKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiAnWycgKyBzb3VyY2VzLm1hcChzID0+IHMuc2NhbGUgPyAnc2NhbGUoXCInICsgcy5zY2FsZSArICdcIiknIDogcy5zaWduYWwpICsgJ10nXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmFsVXBkYXRlcyAoc2lnbmFsLCBzY29wZSkge1xuICBjb25zdCBvcCA9IHNjb3BlLmdldFNpZ25hbChzaWduYWwubmFtZSk7XG4gIGxldCBleHByID0gc2lnbmFsLnVwZGF0ZTtcblxuICBpZiAoc2lnbmFsLmluaXQpIHtcbiAgICBpZiAoZXhwcikge1xuICAgICAgZXJyb3IoJ1NpZ25hbHMgY2FuIG5vdCBpbmNsdWRlIGJvdGggaW5pdCBhbmQgdXBkYXRlIGV4cHJlc3Npb25zLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHByID0gc2lnbmFsLmluaXQ7XG4gICAgICBvcC5pbml0b25seSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHIpIHtcbiAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKGV4cHIsIHNjb3BlKTtcbiAgICBvcC51cGRhdGUgPSBleHByLiRleHByO1xuICAgIG9wLnBhcmFtcyA9IGV4cHIuJHBhcmFtcztcbiAgfVxuXG4gIGlmIChzaWduYWwub24pIHtcbiAgICBzaWduYWwub24uZm9yRWFjaChfID0+IHBhcnNlVXBkYXRlKF8sIHNjb3BlLCBvcC5pZCkpO1xuICB9XG59XG5cbmNvbnN0IHRyYW5zZm9ybSA9IG5hbWUgPT4gKHBhcmFtcywgdmFsdWUsIHBhcmVudCkgPT4gZW50cnkobmFtZSwgdmFsdWUsIHBhcmFtcyB8fCB1bmRlZmluZWQsIHBhcmVudCk7XG5cbmNvbnN0IEFnZ3JlZ2F0ZSA9IHRyYW5zZm9ybSgnYWdncmVnYXRlJyk7XG5jb25zdCBBeGlzVGlja3MgPSB0cmFuc2Zvcm0oJ2F4aXN0aWNrcycpO1xuY29uc3QgQm91bmQgPSB0cmFuc2Zvcm0oJ2JvdW5kJyk7XG5jb25zdCBDb2xsZWN0ID0gdHJhbnNmb3JtKCdjb2xsZWN0Jyk7XG5jb25zdCBDb21wYXJlID0gdHJhbnNmb3JtKCdjb21wYXJlJyk7XG5jb25zdCBEYXRhSm9pbiA9IHRyYW5zZm9ybSgnZGF0YWpvaW4nKTtcbmNvbnN0IEVuY29kZSA9IHRyYW5zZm9ybSgnZW5jb2RlJyk7XG5jb25zdCBFeHByZXNzaW9uID0gdHJhbnNmb3JtKCdleHByZXNzaW9uJyk7XG5jb25zdCBGYWNldCA9IHRyYW5zZm9ybSgnZmFjZXQnKTtcbmNvbnN0IEZpZWxkID0gdHJhbnNmb3JtKCdmaWVsZCcpO1xuY29uc3QgS2V5ID0gdHJhbnNmb3JtKCdrZXknKTtcbmNvbnN0IExlZ2VuZEVudHJpZXMgPSB0cmFuc2Zvcm0oJ2xlZ2VuZGVudHJpZXMnKTtcbmNvbnN0IExvYWQgPSB0cmFuc2Zvcm0oJ2xvYWQnKTtcbmNvbnN0IE1hcmsgPSB0cmFuc2Zvcm0oJ21hcmsnKTtcbmNvbnN0IE11bHRpRXh0ZW50ID0gdHJhbnNmb3JtKCdtdWx0aWV4dGVudCcpO1xuY29uc3QgTXVsdGlWYWx1ZXMgPSB0cmFuc2Zvcm0oJ211bHRpdmFsdWVzJyk7XG5jb25zdCBPdmVybGFwID0gdHJhbnNmb3JtKCdvdmVybGFwJyk7XG5jb25zdCBQYXJhbXMgPSB0cmFuc2Zvcm0oJ3BhcmFtcycpO1xuY29uc3QgUHJlRmFjZXQgPSB0cmFuc2Zvcm0oJ3ByZWZhY2V0Jyk7XG5jb25zdCBQcm9qZWN0aW9uID0gdHJhbnNmb3JtKCdwcm9qZWN0aW9uJyk7XG5jb25zdCBQcm94eSA9IHRyYW5zZm9ybSgncHJveHknKTtcbmNvbnN0IFJlbGF5ID0gdHJhbnNmb3JtKCdyZWxheScpO1xuY29uc3QgUmVuZGVyID0gdHJhbnNmb3JtKCdyZW5kZXInKTtcbmNvbnN0IFNjYWxlID0gdHJhbnNmb3JtKCdzY2FsZScpO1xuY29uc3QgU2lldmUgPSB0cmFuc2Zvcm0oJ3NpZXZlJyk7XG5jb25zdCBTb3J0SXRlbXMgPSB0cmFuc2Zvcm0oJ3NvcnRpdGVtcycpO1xuY29uc3QgVmlld0xheW91dCA9IHRyYW5zZm9ybSgndmlld2xheW91dCcpO1xuY29uc3QgVmFsdWVzID0gdHJhbnNmb3JtKCd2YWx1ZXMnKTtcblxubGV0IEZJRUxEX1JFRl9JRCA9IDA7XG5jb25zdCBNVUxUSURPTUFJTl9TT1JUX09QUyA9IHtcbiAgbWluOiAnbWluJyxcbiAgbWF4OiAnbWF4JyxcbiAgY291bnQ6ICdzdW0nXG59O1xuZnVuY3Rpb24gaW5pdFNjYWxlKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHR5cGUgPSBzcGVjLnR5cGUgfHwgJ2xpbmVhcic7XG5cbiAgaWYgKCFpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUodHlwZSkpO1xuICB9XG5cbiAgc2NvcGUuYWRkU2NhbGUoc3BlYy5uYW1lLCB7XG4gICAgdHlwZSxcbiAgICBkb21haW46IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlU2NhbGUoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgcGFyYW1zID0gc2NvcGUuZ2V0U2NhbGUoc3BlYy5uYW1lKS5wYXJhbXM7XG4gIGxldCBrZXk7XG4gIHBhcmFtcy5kb21haW4gPSBwYXJzZVNjYWxlRG9tYWluKHNwZWMuZG9tYWluLCBzcGVjLCBzY29wZSk7XG5cbiAgaWYgKHNwZWMucmFuZ2UgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5yYW5nZSA9IHBhcnNlU2NhbGVSYW5nZShzcGVjLCBzY29wZSwgcGFyYW1zKTtcbiAgfVxuXG4gIGlmIChzcGVjLmludGVycG9sYXRlICE9IG51bGwpIHtcbiAgICBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoc3BlYy5pbnRlcnBvbGF0ZSwgcGFyYW1zKTtcbiAgfVxuXG4gIGlmIChzcGVjLm5pY2UgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5uaWNlID0gcGFyc2VTY2FsZU5pY2Uoc3BlYy5uaWNlKTtcbiAgfVxuXG4gIGlmIChzcGVjLmJpbnMgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5iaW5zID0gcGFyc2VTY2FsZUJpbnMoc3BlYy5iaW5zLCBzY29wZSk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBzcGVjKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHBhcmFtcywga2V5KSB8fCBrZXkgPT09ICduYW1lJykgY29udGludWU7XG4gICAgcGFyYW1zW2tleV0gPSBwYXJzZUxpdGVyYWwoc3BlY1trZXldLCBzY29wZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsKHYsIHNjb3BlKSB7XG4gIHJldHVybiAhaXNPYmplY3QodikgPyB2IDogdi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYodi5zaWduYWwpIDogZXJyb3IoJ1Vuc3VwcG9ydGVkIG9iamVjdDogJyArIHN0cmluZ1ZhbHVlKHYpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheSh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYodi5zaWduYWwpIDogdi5tYXAodiA9PiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpKTtcbn1cblxuZnVuY3Rpb24gZGF0YUxvb2t1cEVycm9yKG5hbWUpIHtcbiAgZXJyb3IoJ0NhbiBub3QgZmluZCBkYXRhIHNldDogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn0gLy8gLS0gU0NBTEUgRE9NQUlOIC0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlRG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgaWYgKCFkb21haW4pIHtcbiAgICBpZiAoc3BlYy5kb21haW5NaW4gIT0gbnVsbCB8fCBzcGVjLmRvbWFpbk1heCAhPSBudWxsKSB7XG4gICAgICBlcnJvcignTm8gc2NhbGUgZG9tYWluIGRlZmluZWQgZm9yIGRvbWFpbk1pbi9kb21haW5NYXggdG8gb3ZlcnJpZGUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuOyAvLyBkZWZhdWx0IGRvbWFpblxuICB9XG5cbiAgcmV0dXJuIGRvbWFpbi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYoZG9tYWluLnNpZ25hbCkgOiAoaXNBcnJheShkb21haW4pID8gZXhwbGljaXREb21haW4gOiBkb21haW4uZmllbGRzID8gbXVsdGlwbGVEb21haW4gOiBzaW5ndWxhckRvbWFpbikoZG9tYWluLCBzcGVjLCBzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGV4cGxpY2l0RG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgcmV0dXJuIGRvbWFpbi5tYXAodiA9PiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpKTtcbn1cblxuZnVuY3Rpb24gc2luZ3VsYXJEb21haW4oZG9tYWluLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShkb21haW4uZGF0YSk7XG4gIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGRvbWFpbi5kYXRhKTtcbiAgcmV0dXJuIGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IGRhdGEudmFsdWVzUmVmKHNjb3BlLCBkb21haW4uZmllbGQsIHBhcnNlU29ydChkb21haW4uc29ydCwgZmFsc2UpKSA6IGlzUXVhbnRpbGUoc3BlYy50eXBlKSA/IGRhdGEuZG9tYWluUmVmKHNjb3BlLCBkb21haW4uZmllbGQpIDogZGF0YS5leHRlbnRSZWYoc2NvcGUsIGRvbWFpbi5maWVsZCk7XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlRG9tYWluKGRvbWFpbiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGF0YSA9IGRvbWFpbi5kYXRhLFxuICAgICAgICBmaWVsZHMgPSBkb21haW4uZmllbGRzLnJlZHVjZSgoZG9tLCBkKSA9PiB7XG4gICAgZCA9IGlzU3RyaW5nKGQpID8ge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGZpZWxkOiBkXG4gICAgfSA6IGlzQXJyYXkoZCkgfHwgZC5zaWduYWwgPyBmaWVsZFJlZihkLCBzY29wZSkgOiBkO1xuICAgIGRvbS5wdXNoKGQpO1xuICAgIHJldHVybiBkb207XG4gIH0sIFtdKTtcbiAgcmV0dXJuIChpc0Rpc2NyZXRlKHNwZWMudHlwZSkgPyBvcmRpbmFsTXVsdGlwbGVEb21haW4gOiBpc1F1YW50aWxlKHNwZWMudHlwZSkgPyBxdWFudGlsZU11bHRpcGxlRG9tYWluIDogbnVtZXJpY011bHRpcGxlRG9tYWluKShkb21haW4sIHNjb3BlLCBmaWVsZHMpO1xufVxuXG5mdW5jdGlvbiBmaWVsZFJlZihkYXRhLCBzY29wZSkge1xuICBjb25zdCBuYW1lID0gJ186dmVnYTpfJyArIEZJRUxEX1JFRl9JRCsrLFxuICAgICAgICBjb2xsID0gQ29sbGVjdCh7fSk7XG5cbiAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBjb2xsLnZhbHVlID0ge1xuICAgICAgJGluZ2VzdDogZGF0YVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZGF0YS5zaWduYWwpIHtcbiAgICBjb25zdCBjb2RlID0gJ3NldGRhdGEoJyArIHN0cmluZ1ZhbHVlKG5hbWUpICsgJywnICsgZGF0YS5zaWduYWwgKyAnKSc7XG4gICAgY29sbC5wYXJhbXMuaW5wdXQgPSBzY29wZS5zaWduYWxSZWYoY29kZSk7XG4gIH1cblxuICBzY29wZS5hZGREYXRhUGlwZWxpbmUobmFtZSwgW2NvbGwsIFNpZXZlKHt9KV0pO1xuICByZXR1cm4ge1xuICAgIGRhdGE6IG5hbWUsXG4gICAgZmllbGQ6ICdkYXRhJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIGNvbnN0IHNvcnQgPSBwYXJzZVNvcnQoZG9tYWluLnNvcnQsIHRydWUpO1xuICBsZXQgYSwgdjsgLy8gZ2V0IHZhbHVlIGNvdW50cyBmb3IgZWFjaCBkb21haW4gZmllbGRcblxuICBjb25zdCBjb3VudHMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBzY29wZS5nZXREYXRhKGYuZGF0YSk7XG4gICAgaWYgKCFkYXRhKSBkYXRhTG9va3VwRXJyb3IoZi5kYXRhKTtcbiAgICByZXR1cm4gZGF0YS5jb3VudHNSZWYoc2NvcGUsIGYuZmllbGQsIHNvcnQpO1xuICB9KTsgLy8gYWdncmVnYXRlIHRoZSByZXN1bHRzIGZyb20gZWFjaCBkb21haW4gZmllbGRcblxuICBjb25zdCBwID0ge1xuICAgIGdyb3VwYnk6IGtleUZpZWxkUmVmLFxuICAgIHB1bHNlOiBjb3VudHNcbiAgfTtcblxuICBpZiAoc29ydCkge1xuICAgIGEgPSBzb3J0Lm9wIHx8ICdjb3VudCc7XG4gICAgdiA9IHNvcnQuZmllbGQgPyBhZ2dyRmllbGQoYSwgc29ydC5maWVsZCkgOiAnY291bnQnO1xuICAgIHAub3BzID0gW01VTFRJRE9NQUlOX1NPUlRfT1BTW2FdXTtcbiAgICBwLmZpZWxkcyA9IFtzY29wZS5maWVsZFJlZih2KV07XG4gICAgcC5hcyA9IFt2XTtcbiAgfVxuXG4gIGEgPSBzY29wZS5hZGQoQWdncmVnYXRlKHApKTsgLy8gY29sbGVjdCBhZ2dyZWdhdGUgb3V0cHV0XG5cbiAgY29uc3QgYyA9IHNjb3BlLmFkZChDb2xsZWN0KHtcbiAgICBwdWxzZTogcmVmKGEpXG4gIH0pKTsgLy8gZXh0cmFjdCB2YWx1ZXMgZm9yIGNvbWJpbmVkIGRvbWFpblxuXG4gIHYgPSBzY29wZS5hZGQoVmFsdWVzKHtcbiAgICBmaWVsZDoga2V5RmllbGRSZWYsXG4gICAgc29ydDogc2NvcGUuc29ydFJlZihzb3J0KSxcbiAgICBwdWxzZTogcmVmKGMpXG4gIH0pKTtcbiAgcmV0dXJuIHJlZih2KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTb3J0KHNvcnQsIG11bHRpZG9tYWluKSB7XG4gIGlmIChzb3J0KSB7XG4gICAgaWYgKCFzb3J0LmZpZWxkICYmICFzb3J0Lm9wKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoc29ydCkpIHNvcnQuZmllbGQgPSAna2V5JztlbHNlIHNvcnQgPSB7XG4gICAgICAgIGZpZWxkOiAna2V5J1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCFzb3J0LmZpZWxkICYmIHNvcnQub3AgIT09ICdjb3VudCcpIHtcbiAgICAgIGVycm9yKCdObyBmaWVsZCBwcm92aWRlZCBmb3Igc29ydCBhZ2dyZWdhdGUgb3A6ICcgKyBzb3J0Lm9wKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpZG9tYWluICYmIHNvcnQuZmllbGQpIHtcbiAgICAgIGlmIChzb3J0Lm9wICYmICFNVUxUSURPTUFJTl9TT1JUX09QU1tzb3J0Lm9wXSkge1xuICAgICAgICBlcnJvcignTXVsdGlwbGUgZG9tYWluIHNjYWxlcyBjYW4gbm90IGJlIHNvcnRlZCB1c2luZyAnICsgc29ydC5vcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNvcnQ7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIC8vIGdldCB2YWx1ZSBhcnJheXMgZm9yIGVhY2ggZG9tYWluIGZpZWxkXG4gIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoZiA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHNjb3BlLmdldERhdGEoZi5kYXRhKTtcbiAgICBpZiAoIWRhdGEpIGRhdGFMb29rdXBFcnJvcihmLmRhdGEpO1xuICAgIHJldHVybiBkYXRhLmRvbWFpblJlZihzY29wZSwgZi5maWVsZCk7XG4gIH0pOyAvLyBjb21iaW5lIHZhbHVlIGFycmF5c1xuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE11bHRpVmFsdWVzKHtcbiAgICB2YWx1ZXM6IHZhbHVlc1xuICB9KSkpO1xufVxuXG5mdW5jdGlvbiBudW1lcmljTXVsdGlwbGVEb21haW4oZG9tYWluLCBzY29wZSwgZmllbGRzKSB7XG4gIC8vIGdldCBleHRlbnRzIGZvciBlYWNoIGRvbWFpbiBmaWVsZFxuICBjb25zdCBleHRlbnRzID0gZmllbGRzLm1hcChmID0+IHtcbiAgICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShmLmRhdGEpO1xuICAgIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGYuZGF0YSk7XG4gICAgcmV0dXJuIGRhdGEuZXh0ZW50UmVmKHNjb3BlLCBmLmZpZWxkKTtcbiAgfSk7IC8vIGNvbWJpbmUgZXh0ZW50c1xuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE11bHRpRXh0ZW50KHtcbiAgICBleHRlbnRzOiBleHRlbnRzXG4gIH0pKSk7XG59IC8vIC0tIFNDQUxFIEJJTlMgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlQmlucyh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgfHwgaXNBcnJheSh2KSA/IHBhcnNlQXJyYXkodiwgc2NvcGUpIDogc2NvcGUub2JqZWN0UHJvcGVydHkodik7XG59IC8vIC0tIFNDQUxFIE5JQ0UgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlTmljZShuaWNlKSB7XG4gIHJldHVybiBpc09iamVjdChuaWNlKSA/IHtcbiAgICBpbnRlcnZhbDogcGFyc2VMaXRlcmFsKG5pY2UuaW50ZXJ2YWwpLFxuICAgIHN0ZXA6IHBhcnNlTGl0ZXJhbChuaWNlLnN0ZXApXG4gIH0gOiBwYXJzZUxpdGVyYWwobmljZSk7XG59IC8vIC0tIFNDQUxFIElOVEVSUE9MQVRJT04gLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUsIHBhcmFtcykge1xuICBwYXJhbXMuaW50ZXJwb2xhdGUgPSBwYXJzZUxpdGVyYWwoaW50ZXJwb2xhdGUudHlwZSB8fCBpbnRlcnBvbGF0ZSk7XG5cbiAgaWYgKGludGVycG9sYXRlLmdhbW1hICE9IG51bGwpIHtcbiAgICBwYXJhbXMuaW50ZXJwb2xhdGVHYW1tYSA9IHBhcnNlTGl0ZXJhbChpbnRlcnBvbGF0ZS5nYW1tYSk7XG4gIH1cbn0gLy8gLS0gU0NBTEUgUkFOR0UgLS0tLS1cblxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcykge1xuICBjb25zdCBjb25maWcgPSBzY29wZS5jb25maWcucmFuZ2U7XG4gIGxldCByYW5nZSA9IHNwZWMucmFuZ2U7XG5cbiAgaWYgKHJhbmdlLnNpZ25hbCkge1xuICAgIHJldHVybiBzY29wZS5zaWduYWxSZWYocmFuZ2Uuc2lnbmFsKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhyYW5nZSkpIHtcbiAgICBpZiAoY29uZmlnICYmIGhhc093blByb3BlcnR5KGNvbmZpZywgcmFuZ2UpKSB7XG4gICAgICBzcGVjID0gZXh0ZW5kKHt9LCBzcGVjLCB7XG4gICAgICAgIHJhbmdlOiBjb25maWdbcmFuZ2VdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJ3dpZHRoJykge1xuICAgICAgcmFuZ2UgPSBbMCwge1xuICAgICAgICBzaWduYWw6ICd3aWR0aCdcbiAgICAgIH1dO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICdoZWlnaHQnKSB7XG4gICAgICByYW5nZSA9IGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IFswLCB7XG4gICAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICAgIH1dIDogW3tcbiAgICAgICAgc2lnbmFsOiAnaGVpZ2h0J1xuICAgICAgfSwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgcmFuZ2UgdmFsdWU6ICcgKyBzdHJpbmdWYWx1ZShyYW5nZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyYW5nZS5zY2hlbWUpIHtcbiAgICBwYXJhbXMuc2NoZW1lID0gaXNBcnJheShyYW5nZS5zY2hlbWUpID8gcGFyc2VBcnJheShyYW5nZS5zY2hlbWUsIHNjb3BlKSA6IHBhcnNlTGl0ZXJhbChyYW5nZS5zY2hlbWUsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuZXh0ZW50KSBwYXJhbXMuc2NoZW1lRXh0ZW50ID0gcGFyc2VBcnJheShyYW5nZS5leHRlbnQsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuY291bnQpIHBhcmFtcy5zY2hlbWVDb3VudCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5jb3VudCwgc2NvcGUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyYW5nZS5zdGVwKSB7XG4gICAgcGFyYW1zLnJhbmdlU3RlcCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5zdGVwLCBzY29wZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzRGlzY3JldGUoc3BlYy50eXBlKSAmJiAhaXNBcnJheShyYW5nZSkpIHtcbiAgICByZXR1cm4gcGFyc2VTY2FsZURvbWFpbihyYW5nZSwgc3BlYywgc2NvcGUpO1xuICB9IGVsc2UgaWYgKCFpc0FycmF5KHJhbmdlKSkge1xuICAgIGVycm9yKCdVbnN1cHBvcnRlZCByYW5nZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUocmFuZ2UpKTtcbiAgfVxuXG4gIHJldHVybiByYW5nZS5tYXAodiA9PiAoaXNBcnJheSh2KSA/IHBhcnNlQXJyYXkgOiBwYXJzZUxpdGVyYWwpKHYsIHNjb3BlKSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUHJvamVjdGlvbiAocHJvaiwgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnLnByb2plY3Rpb24gfHwge30sXG4gICAgICAgIHBhcmFtcyA9IHt9O1xuXG4gIGZvciAoY29uc3QgbmFtZSBpbiBwcm9qKSB7XG4gICAgaWYgKG5hbWUgPT09ICduYW1lJykgY29udGludWU7XG4gICAgcGFyYW1zW25hbWVdID0gcGFyc2VQYXJhbWV0ZXIkMShwcm9qW25hbWVdLCBuYW1lLCBzY29wZSk7XG4gIH0gLy8gYXBwbHkgcHJvamVjdGlvbiBkZWZhdWx0cyBmcm9tIGNvbmZpZ1xuXG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGNvbmZpZykge1xuICAgIGlmIChwYXJhbXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgcGFyYW1zW25hbWVdID0gcGFyc2VQYXJhbWV0ZXIkMShjb25maWdbbmFtZV0sIG5hbWUsIHNjb3BlKTtcbiAgICB9XG4gIH1cblxuICBzY29wZS5hZGRQcm9qZWN0aW9uKHByb2oubmFtZSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIkMShfLCBuYW1lLCBzY29wZSkge1xuICByZXR1cm4gaXNBcnJheShfKSA/IF8ubWFwKF8gPT4gcGFyc2VQYXJhbWV0ZXIkMShfLCBuYW1lLCBzY29wZSkpIDogIWlzT2JqZWN0KF8pID8gXyA6IF8uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKF8uc2lnbmFsKSA6IG5hbWUgPT09ICdmaXQnID8gXyA6IGVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXIgb2JqZWN0OiAnICsgc3RyaW5nVmFsdWUoXykpO1xufVxuXG5jb25zdCBUb3AgPSAndG9wJztcbmNvbnN0IExlZnQgPSAnbGVmdCc7XG5jb25zdCBSaWdodCA9ICdyaWdodCc7XG5jb25zdCBCb3R0b20gPSAnYm90dG9tJztcbmNvbnN0IENlbnRlciA9ICdjZW50ZXInO1xuY29uc3QgVmVydGljYWwgPSAndmVydGljYWwnO1xuY29uc3QgU3RhcnQgPSAnc3RhcnQnO1xuY29uc3QgTWlkZGxlID0gJ21pZGRsZSc7XG5jb25zdCBFbmQgPSAnZW5kJztcbmNvbnN0IEluZGV4ID0gJ2luZGV4JztcbmNvbnN0IExhYmVsID0gJ2xhYmVsJztcbmNvbnN0IE9mZnNldCA9ICdvZmZzZXQnO1xuY29uc3QgUGVyYyA9ICdwZXJjJztcbmNvbnN0IFBlcmMyID0gJ3BlcmMyJztcbmNvbnN0IFZhbHVlID0gJ3ZhbHVlJztcbmNvbnN0IEd1aWRlTGFiZWxTdHlsZSA9ICdndWlkZS1sYWJlbCc7XG5jb25zdCBHdWlkZVRpdGxlU3R5bGUgPSAnZ3VpZGUtdGl0bGUnO1xuY29uc3QgR3JvdXBUaXRsZVN0eWxlID0gJ2dyb3VwLXRpdGxlJztcbmNvbnN0IEdyb3VwU3VidGl0bGVTdHlsZSA9ICdncm91cC1zdWJ0aXRsZSc7XG5jb25zdCBTeW1ib2xzID0gJ3N5bWJvbCc7XG5jb25zdCBHcmFkaWVudCA9ICdncmFkaWVudCc7XG5jb25zdCBEaXNjcmV0ZSA9ICdkaXNjcmV0ZSc7XG5jb25zdCBTaXplID0gJ3NpemUnO1xuY29uc3QgU2hhcGUgPSAnc2hhcGUnO1xuY29uc3QgRmlsbCA9ICdmaWxsJztcbmNvbnN0IFN0cm9rZSA9ICdzdHJva2UnO1xuY29uc3QgU3Ryb2tlV2lkdGggPSAnc3Ryb2tlV2lkdGgnO1xuY29uc3QgU3Ryb2tlRGFzaCA9ICdzdHJva2VEYXNoJztcbmNvbnN0IE9wYWNpdHkgPSAnb3BhY2l0eSc7IC8vIEVuY29kaW5nIGNoYW5uZWxzIHN1cHBvcnRlZCBieSBsZWdlbmRzXG4vLyBJbiBwcmlvcml0eSBvcmRlciBvZiAnY2Fub25pY2FsJyBzY2FsZVxuXG5jb25zdCBMZWdlbmRTY2FsZXMgPSBbU2l6ZSwgU2hhcGUsIEZpbGwsIFN0cm9rZSwgU3Ryb2tlV2lkdGgsIFN0cm9rZURhc2gsIE9wYWNpdHldO1xuY29uc3QgU2tpcCA9IHtcbiAgbmFtZTogMSxcbiAgc3R5bGU6IDEsXG4gIGludGVyYWN0aXZlOiAxXG59O1xuY29uc3QgemVybyA9IHtcbiAgdmFsdWU6IDBcbn07XG5jb25zdCBvbmUgPSB7XG4gIHZhbHVlOiAxXG59O1xuXG5jb25zdCBHcm91cE1hcmsgPSAnZ3JvdXAnO1xuY29uc3QgUmVjdE1hcmsgPSAncmVjdCc7XG5jb25zdCBSdWxlTWFyayA9ICdydWxlJztcbmNvbnN0IFN5bWJvbE1hcmsgPSAnc3ltYm9sJztcbmNvbnN0IFRleHRNYXJrID0gJ3RleHQnO1xuXG5mdW5jdGlvbiBndWlkZUdyb3VwIChtYXJrKSB7XG4gIG1hcmsudHlwZSA9IEdyb3VwTWFyaztcbiAgbWFyay5pbnRlcmFjdGl2ZSA9IG1hcmsuaW50ZXJhY3RpdmUgfHwgZmFsc2U7XG4gIHJldHVybiBtYXJrO1xufVxuXG5mdW5jdGlvbiBsb29rdXAoc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IF8gPSAobmFtZSwgZGZsdCkgPT4gdmFsdWUoc3BlY1tuYW1lXSwgdmFsdWUoY29uZmlnW25hbWVdLCBkZmx0KSk7XG5cbiAgXy5pc1ZlcnRpY2FsID0gcyA9PiBWZXJ0aWNhbCA9PT0gdmFsdWUoc3BlYy5kaXJlY3Rpb24sIGNvbmZpZy5kaXJlY3Rpb24gfHwgKHMgPyBjb25maWcuc3ltYm9sRGlyZWN0aW9uIDogY29uZmlnLmdyYWRpZW50RGlyZWN0aW9uKSk7XG5cbiAgXy5ncmFkaWVudExlbmd0aCA9ICgpID0+IHZhbHVlKHNwZWMuZ3JhZGllbnRMZW5ndGgsIGNvbmZpZy5ncmFkaWVudExlbmd0aCB8fCBjb25maWcuZ3JhZGllbnRXaWR0aCk7XG5cbiAgXy5ncmFkaWVudFRoaWNrbmVzcyA9ICgpID0+IHZhbHVlKHNwZWMuZ3JhZGllbnRUaGlja25lc3MsIGNvbmZpZy5ncmFkaWVudFRoaWNrbmVzcyB8fCBjb25maWcuZ3JhZGllbnRIZWlnaHQpO1xuXG4gIF8uZW50cnlDb2x1bW5zID0gKCkgPT4gdmFsdWUoc3BlYy5jb2x1bW5zLCB2YWx1ZShjb25maWcuY29sdW1ucywgK18uaXNWZXJ0aWNhbCh0cnVlKSkpO1xuXG4gIHJldHVybiBfO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcobmFtZSwgZW5jb2RlKSB7XG4gIGNvbnN0IHYgPSBlbmNvZGUgJiYgKGVuY29kZS51cGRhdGUgJiYgZW5jb2RlLnVwZGF0ZVtuYW1lXSB8fCBlbmNvZGUuZW50ZXIgJiYgZW5jb2RlLmVudGVyW25hbWVdKTtcbiAgcmV0dXJuIHYgJiYgdi5zaWduYWwgPyB2IDogdiA/IHYudmFsdWUgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUobmFtZSwgc2NvcGUsIHN0eWxlKSB7XG4gIGNvbnN0IHMgPSBzY29wZS5jb25maWcuc3R5bGVbc3R5bGVdO1xuICByZXR1cm4gcyAmJiBzW25hbWVdO1xufVxuZnVuY3Rpb24gYW5jaG9yRXhwcihzLCBlLCBtKSB7XG4gIHJldHVybiBgaXRlbS5hbmNob3IgPT09ICcke1N0YXJ0fScgPyAke3N9IDogaXRlbS5hbmNob3IgPT09ICcke0VuZH0nID8gJHtlfSA6ICR7bX1gO1xufVxuY29uc3QgYWxpZ25FeHByJDEgPSBhbmNob3JFeHByKHN0cmluZ1ZhbHVlKExlZnQpLCBzdHJpbmdWYWx1ZShSaWdodCksIHN0cmluZ1ZhbHVlKENlbnRlcikpO1xuZnVuY3Rpb24gdGlja0JhbmQoXykge1xuICBjb25zdCB2ID0gXygndGlja0JhbmQnKTtcblxuICBsZXQgb2Zmc2V0ID0gXygndGlja09mZnNldCcpLFxuICAgICAgYmFuZCxcbiAgICAgIGV4dHJhO1xuXG4gIGlmICghdikge1xuICAgIC8vIGlmIG5vIHRpY2sgYmFuZCBlbnRyeSwgZmFsbCBiYWNrIG9uIG90aGVyIHByb3BlcnRpZXNcbiAgICBiYW5kID0gXygnYmFuZFBvc2l0aW9uJyk7XG4gICAgZXh0cmEgPSBfKCd0aWNrRXh0cmEnKTtcbiAgfSBlbHNlIGlmICh2LnNpZ25hbCkge1xuICAgIC8vIGlmIHNpZ25hbCwgYXVnbWVudCBjb2RlIHRvIGludGVycHJldCB2YWx1ZXNcbiAgICBiYW5kID0ge1xuICAgICAgc2lnbmFsOiBgKCR7di5zaWduYWx9KSA9PT0gJ2V4dGVudCcgPyAxIDogMC41YFxuICAgIH07XG4gICAgZXh0cmEgPSB7XG4gICAgICBzaWduYWw6IGAoJHt2LnNpZ25hbH0pID09PSAnZXh0ZW50J2BcbiAgICB9O1xuXG4gICAgaWYgKCFpc09iamVjdChvZmZzZXQpKSB7XG4gICAgICBvZmZzZXQgPSB7XG4gICAgICAgIHNpZ25hbDogYCgke3Yuc2lnbmFsfSkgPT09ICdleHRlbnQnID8gMCA6ICR7b2Zmc2V0fWBcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHYgPT09ICdleHRlbnQnKSB7XG4gICAgLy8gaWYgY29uc3RhbnQsIHNpbXBseSBzZXQgdmFsdWVzXG4gICAgYmFuZCA9IDE7XG4gICAgZXh0cmEgPSB0cnVlO1xuICAgIG9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYmFuZCA9IDAuNTtcbiAgICBleHRyYSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHRyYSxcbiAgICBiYW5kLFxuICAgIG9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gZXh0ZW5kT2Zmc2V0KHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuICFvZmZzZXQgPyB2YWx1ZSA6ICF2YWx1ZSA/IG9mZnNldCA6ICFpc09iamVjdCh2YWx1ZSkgPyB7XG4gICAgdmFsdWUsXG4gICAgb2Zmc2V0XG4gIH0gOiBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSwge1xuICAgIG9mZnNldDogZXh0ZW5kT2Zmc2V0KHZhbHVlLm9mZnNldCwgb2Zmc2V0KVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ3VpZGVNYXJrIChtYXJrLCBleHRyYXMpIHtcbiAgaWYgKGV4dHJhcykge1xuICAgIG1hcmsubmFtZSA9IGV4dHJhcy5uYW1lO1xuICAgIG1hcmsuc3R5bGUgPSBleHRyYXMuc3R5bGUgfHwgbWFyay5zdHlsZTtcbiAgICBtYXJrLmludGVyYWN0aXZlID0gISFleHRyYXMuaW50ZXJhY3RpdmU7XG4gICAgbWFyay5lbmNvZGUgPSBleHRlbmRFbmNvZGUobWFyay5lbmNvZGUsIGV4dHJhcywgU2tpcCk7XG4gIH0gZWxzZSB7XG4gICAgbWFyay5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG1hcms7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyYWRpZW50IChzcGVjLCBzY2FsZSwgY29uZmlnLCB1c2VyRW5jb2RlKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICAgICAgdGhpY2tuZXNzID0gXy5ncmFkaWVudFRoaWNrbmVzcygpLFxuICAgICAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG5cbiAgbGV0IGVudGVyLCBzdGFydCwgc3RvcCwgd2lkdGgsIGhlaWdodDtcblxuICBpZiAodmVydGljYWwpIHtcbiAgICBzdGFydCA9IFswLCAxXTtcbiAgICBzdG9wID0gWzAsIDBdO1xuICAgIHdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGhlaWdodCA9IGxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IFswLCAwXTtcbiAgICBzdG9wID0gWzEsIDBdO1xuICAgIHdpZHRoID0gbGVuZ3RoO1xuICAgIGhlaWdodCA9IHRoaWNrbmVzcztcbiAgfVxuXG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgeDogemVybyxcbiAgICAgIHk6IHplcm8sXG4gICAgICB3aWR0aDogZW5jb2Rlcih3aWR0aCksXG4gICAgICBoZWlnaHQ6IGVuY29kZXIoaGVpZ2h0KVxuICAgIH0sXG4gICAgdXBkYXRlOiBleHRlbmQoe30sIGVudGVyLCB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICBmaWxsOiB7XG4gICAgICAgIGdyYWRpZW50OiBzY2FsZSxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBzdG9wOiBzdG9wXG4gICAgICB9XG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmFkaWVudFN0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2dyYWRpZW50U3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnZ3JhZGllbnRPcGFjaXR5JylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJlY3RNYXJrLFxuICAgIHJvbGU6IExlZ2VuZEdyYWRpZW50Um9sZSxcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyYWRpZW50RGlzY3JldGUgKHNwZWMsIHNjYWxlLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICB2ZXJ0aWNhbCA9IF8uaXNWZXJ0aWNhbCgpLFxuICAgICAgICB0aGlja25lc3MgPSBfLmdyYWRpZW50VGhpY2tuZXNzKCksXG4gICAgICAgIGxlbmd0aCA9IF8uZ3JhZGllbnRMZW5ndGgoKTtcblxuICBsZXQgdSxcbiAgICAgIHYsXG4gICAgICB1dSxcbiAgICAgIHZ2LFxuICAgICAgYWRqdXN0ID0gJyc7XG4gIHZlcnRpY2FsID8gKHUgPSAneScsIHV1ID0gJ3kyJywgdiA9ICd4JywgdnYgPSAnd2lkdGgnLCBhZGp1c3QgPSAnMS0nKSA6ICh1ID0gJ3gnLCB1dSA9ICd4MicsIHYgPSAneScsIHZ2ID0gJ2hlaWdodCcpO1xuICBjb25zdCBlbnRlciA9IHtcbiAgICBvcGFjaXR5OiB6ZXJvLFxuICAgIGZpbGw6IHtcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGZpZWxkOiBWYWx1ZVxuICAgIH1cbiAgfTtcbiAgZW50ZXJbdV0gPSB7XG4gICAgc2lnbmFsOiBhZGp1c3QgKyAnZGF0dW0uJyArIFBlcmMsXG4gICAgbXVsdDogbGVuZ3RoXG4gIH07XG4gIGVudGVyW3ZdID0gemVybztcbiAgZW50ZXJbdXVdID0ge1xuICAgIHNpZ25hbDogYWRqdXN0ICsgJ2RhdHVtLicgKyBQZXJjMixcbiAgICBtdWx0OiBsZW5ndGhcbiAgfTtcbiAgZW50ZXJbdnZdID0gZW5jb2Rlcih0aGlja25lc3MpO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyLFxuICAgIHVwZGF0ZTogZXh0ZW5kKHt9LCBlbnRlciwge1xuICAgICAgb3BhY2l0eTogb25lXG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmFkaWVudFN0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2dyYWRpZW50U3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnZ3JhZGllbnRPcGFjaXR5JylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJlY3RNYXJrLFxuICAgIHJvbGU6IExlZ2VuZEJhbmRSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmNvbnN0IGFsaWduRXhwciA9IGBkYXR1bS4ke1BlcmN9PD0wP1wiJHtMZWZ0fVwiOmRhdHVtLiR7UGVyY30+PTE/XCIke1JpZ2h0fVwiOlwiJHtDZW50ZXJ9XCJgLFxuICAgICAgYmFzZWxpbmVFeHByID0gYGRhdHVtLiR7UGVyY308PTA/XCIke0JvdHRvbX1cIjpkYXR1bS4ke1BlcmN9Pj0xP1wiJHtUb3B9XCI6XCIke01pZGRsZX1cImA7XG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudExhYmVscyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICAgICAgdGhpY2tuZXNzID0gZW5jb2RlcihfLmdyYWRpZW50VGhpY2tuZXNzKCkpLFxuICAgICAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG5cbiAgbGV0IG92ZXJsYXAgPSBfKCdsYWJlbE92ZXJsYXAnKSxcbiAgICAgIGVudGVyLFxuICAgICAgdXBkYXRlLFxuICAgICAgdSxcbiAgICAgIHYsXG4gICAgICBhZGp1c3QgPSAnJztcblxuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogdmFsdWUoc3BlYy5sYWJlbExpbWl0LCBjb25maWcuZ3JhZGllbnRMYWJlbExpbWl0KVxuICB9KTtcblxuICBpZiAodmVydGljYWwpIHtcbiAgICBlbnRlci5hbGlnbiA9IHtcbiAgICAgIHZhbHVlOiAnbGVmdCdcbiAgICB9O1xuICAgIGVudGVyLmJhc2VsaW5lID0gdXBkYXRlLmJhc2VsaW5lID0ge1xuICAgICAgc2lnbmFsOiBiYXNlbGluZUV4cHJcbiAgICB9O1xuICAgIHUgPSAneSc7XG4gICAgdiA9ICd4JztcbiAgICBhZGp1c3QgPSAnMS0nO1xuICB9IGVsc2Uge1xuICAgIGVudGVyLmFsaWduID0gdXBkYXRlLmFsaWduID0ge1xuICAgICAgc2lnbmFsOiBhbGlnbkV4cHJcbiAgICB9O1xuICAgIGVudGVyLmJhc2VsaW5lID0ge1xuICAgICAgdmFsdWU6ICd0b3AnXG4gICAgfTtcbiAgICB1ID0gJ3gnO1xuICAgIHYgPSAneSc7XG4gIH1cblxuICBlbnRlclt1XSA9IHVwZGF0ZVt1XSA9IHtcbiAgICBzaWduYWw6IGFkanVzdCArICdkYXR1bS4nICsgUGVyYyxcbiAgICBtdWx0OiBsZW5ndGhcbiAgfTtcbiAgZW50ZXJbdl0gPSB1cGRhdGVbdl0gPSB0aGlja25lc3M7XG4gIHRoaWNrbmVzcy5vZmZzZXQgPSB2YWx1ZShzcGVjLmxhYmVsT2Zmc2V0LCBjb25maWcuZ3JhZGllbnRMYWJlbE9mZnNldCkgfHwgMDtcbiAgb3ZlcmxhcCA9IG92ZXJsYXAgPyB7XG4gICAgc2VwYXJhdGlvbjogXygnbGFiZWxTZXBhcmF0aW9uJyksXG4gICAgbWV0aG9kOiBvdmVybGFwLFxuICAgIG9yZGVyOiAnZGF0dW0uJyArIEluZGV4XG4gIH0gOiB1bmRlZmluZWQ7IC8vIHR5cGUsIHJvbGUsIHN0eWxlLCBrZXksIGRhdGFSZWYsIGVuY29kZSwgZXh0cmFzXG5cbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogTGVnZW5kTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZSxcbiAgICBvdmVybGFwXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRTeW1ib2xHcm91cHMgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZiwgY29sdW1ucykge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIGVudHJpZXMgPSB1c2VyRW5jb2RlLmVudHJpZXMsXG4gICAgICAgIGludGVyYWN0aXZlID0gISEoZW50cmllcyAmJiBlbnRyaWVzLmludGVyYWN0aXZlKSxcbiAgICAgICAgbmFtZSA9IGVudHJpZXMgPyBlbnRyaWVzLm5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgIGhlaWdodCA9IF8oJ2NsaXBIZWlnaHQnKSxcbiAgICAgICAgc3ltYm9sT2Zmc2V0ID0gXygnc3ltYm9sT2Zmc2V0JyksXG4gICAgICAgIHZhbHVlUmVmID0ge1xuICAgIGRhdGE6ICd2YWx1ZSdcbiAgfSxcbiAgICAgICAgeFNpZ25hbCA9IGAoJHtjb2x1bW5zfSkgPyBkYXR1bS4ke09mZnNldH0gOiBkYXR1bS4ke1NpemV9YCxcbiAgICAgICAgeUVuY29kZSA9IGhlaWdodCA/IGVuY29kZXIoaGVpZ2h0KSA6IHtcbiAgICBmaWVsZDogU2l6ZVxuICB9LFxuICAgICAgICBpbmRleCA9IGBkYXR1bS4ke0luZGV4fWAsXG4gICAgICAgIG5jb2xzID0gYG1heCgxLCAke2NvbHVtbnN9KWA7XG5cbiAgbGV0IGVuY29kZSwgZW50ZXIsIHVwZGF0ZSwgbnJvd3MsIHNvcnQ7XG4gIHlFbmNvZGUubXVsdCA9IDAuNTsgLy8gLS0gTEVHRU5EIFNZTUJPTFMgLS1cblxuICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHtcbiAgICAgICAgc2lnbmFsOiB4U2lnbmFsLFxuICAgICAgICBtdWx0OiAwLjUsXG4gICAgICAgIG9mZnNldDogc3ltYm9sT2Zmc2V0XG4gICAgICB9LFxuICAgICAgeTogeUVuY29kZVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgbGV0IGJhc2VGaWxsID0gbnVsbCxcbiAgICAgIGJhc2VTdHJva2UgPSBudWxsO1xuXG4gIGlmICghc3BlYy5maWxsKSB7XG4gICAgYmFzZUZpbGwgPSBjb25maWcuc3ltYm9sQmFzZUZpbGxDb2xvcjtcbiAgICBiYXNlU3Ryb2tlID0gY29uZmlnLnN5bWJvbEJhc2VTdHJva2VDb2xvcjtcbiAgfVxuXG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGZpbGw6IF8oJ3N5bWJvbEZpbGxDb2xvcicsIGJhc2VGaWxsKSxcbiAgICBzaGFwZTogXygnc3ltYm9sVHlwZScpLFxuICAgIHNpemU6IF8oJ3N5bWJvbFNpemUnKSxcbiAgICBzdHJva2U6IF8oJ3N5bWJvbFN0cm9rZUNvbG9yJywgYmFzZVN0cm9rZSksXG4gICAgc3Ryb2tlRGFzaDogXygnc3ltYm9sRGFzaCcpLFxuICAgIHN0cm9rZURhc2hPZmZzZXQ6IF8oJ3N5bWJvbERhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VXaWR0aDogXygnc3ltYm9sU3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnc3ltYm9sT3BhY2l0eScpXG4gIH0pO1xuICBMZWdlbmRTY2FsZXMuZm9yRWFjaChzY2FsZSA9PiB7XG4gICAgaWYgKHNwZWNbc2NhbGVdKSB7XG4gICAgICB1cGRhdGVbc2NhbGVdID0gZW50ZXJbc2NhbGVdID0ge1xuICAgICAgICBzY2FsZTogc3BlY1tzY2FsZV0sXG4gICAgICAgIGZpZWxkOiBWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzeW1ib2xzID0gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBTeW1ib2xNYXJrLFxuICAgIHJvbGU6IExlZ2VuZFN5bWJvbFJvbGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiB2YWx1ZVJlZixcbiAgICBjbGlwOiBoZWlnaHQgPyB0cnVlIDogdW5kZWZpbmVkLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlLnN5bWJvbHMpOyAvLyAtLSBMRUdFTkQgTEFCRUxTIC0tXG5cbiAgY29uc3QgbGFiZWxPZmZzZXQgPSBlbmNvZGVyKHN5bWJvbE9mZnNldCk7XG4gIGxhYmVsT2Zmc2V0Lm9mZnNldCA9IF8oJ2xhYmVsT2Zmc2V0Jyk7XG4gIGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgeDoge1xuICAgICAgICBzaWduYWw6IHhTaWduYWwsXG4gICAgICAgIG9mZnNldDogbGFiZWxPZmZzZXRcbiAgICAgIH0sXG4gICAgICB5OiB5RW5jb2RlXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgZmllbGQ6IExhYmVsXG4gICAgICB9LFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnlcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGFsaWduOiBfKCdsYWJlbEFsaWduJyksXG4gICAgYmFzZWxpbmU6IF8oJ2xhYmVsQmFzZWxpbmUnKSxcbiAgICBmaWxsOiBfKCdsYWJlbENvbG9yJyksXG4gICAgZmlsbE9wYWNpdHk6IF8oJ2xhYmVsT3BhY2l0eScpLFxuICAgIGZvbnQ6IF8oJ2xhYmVsRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCdsYWJlbEZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCdsYWJlbEZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ2xhYmVsRm9udFdlaWdodCcpLFxuICAgIGxpbWl0OiBfKCdsYWJlbExpbWl0JylcbiAgfSk7XG4gIGNvbnN0IGxhYmVscyA9IGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogTGVnZW5kTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiB2YWx1ZVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZS5sYWJlbHMpOyAvLyAtLSBMRUdFTkQgRU5UUlkgR1JPVVBTIC0tXG5cbiAgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBub0JvdW5kOiB7XG4gICAgICAgIHZhbHVlOiAhaGVpZ2h0XG4gICAgICB9LFxuICAgICAgLy8gaWdub3JlIHdpZHRoL2hlaWdodCBpbiBib3VuZHMgY2FsY1xuICAgICAgd2lkdGg6IHplcm8sXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/IGVuY29kZXIoaGVpZ2h0KSA6IHplcm8sXG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHJvdzoge1xuICAgICAgICBzaWduYWw6IG51bGxcbiAgICAgIH0sXG4gICAgICBjb2x1bW46IHtcbiAgICAgICAgc2lnbmFsOiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBhbm5vdGF0ZSBhbmQgc29ydCBncm91cHMgdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmdcblxuICBpZiAoXy5pc1ZlcnRpY2FsKHRydWUpKSB7XG4gICAgbnJvd3MgPSBgY2VpbChpdGVtLm1hcmsuaXRlbXMubGVuZ3RoIC8gJHtuY29sc30pYDtcbiAgICB1cGRhdGUucm93LnNpZ25hbCA9IGAke2luZGV4fSUke25yb3dzfWA7XG4gICAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgZmxvb3IoJHtpbmRleH0gLyAke25yb3dzfSlgO1xuICAgIHNvcnQgPSB7XG4gICAgICBmaWVsZDogWydyb3cnLCBpbmRleF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5yb3cuc2lnbmFsID0gYGZsb29yKCR7aW5kZXh9IC8gJHtuY29sc30pYDtcbiAgICB1cGRhdGUuY29sdW1uLnNpZ25hbCA9IGAke2luZGV4fSAlICR7bmNvbHN9YDtcbiAgICBzb3J0ID0ge1xuICAgICAgZmllbGQ6IGluZGV4XG4gICAgfTtcbiAgfSAvLyBoYW5kbGUgemVybyBjb2x1bW4gY2FzZSAoaW1wbGllcyBpbmZpbml0ZSBjb2x1bW5zKVxuXG5cbiAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgKCR7Y29sdW1uc30pPyR7dXBkYXRlLmNvbHVtbi5zaWduYWx9OiR7aW5kZXh9YDsgLy8gZmFjZXQgbGVnZW5kIGVudHJpZXMgaW50byBzdWItZ3JvdXBzXG5cbiAgZGF0YVJlZiA9IHtcbiAgICBmYWNldDoge1xuICAgICAgZGF0YTogZGF0YVJlZixcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBncm91cGJ5OiBJbmRleFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFNjb3BlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGVuY29kZSwgZW50cmllcywgU2tpcCksXG4gICAgbWFya3M6IFtzeW1ib2xzLCBsYWJlbHNdLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc29ydFxuICB9KTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZFN5bWJvbExheW91dChzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpOyAvLyBsYXlvdXQgcGFyYW1ldGVycyBmb3IgbGVnZW5kIGVudHJpZXNcblxuXG4gIHJldHVybiB7XG4gICAgYWxpZ246IF8oJ2dyaWRBbGlnbicpLFxuICAgIGNvbHVtbnM6IF8uZW50cnlDb2x1bW5zKCksXG4gICAgY2VudGVyOiB7XG4gICAgICByb3c6IHRydWUsXG4gICAgICBjb2x1bW46IGZhbHNlXG4gICAgfSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICByb3c6IF8oJ3Jvd1BhZGRpbmcnKSxcbiAgICAgIGNvbHVtbjogXygnY29sdW1uUGFkZGluZycpXG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBpc0wgPSAnaXRlbS5vcmllbnQgPT09IFwibGVmdFwiJyxcbiAgICAgIGlzUiA9ICdpdGVtLm9yaWVudCA9PT0gXCJyaWdodFwiJyxcbiAgICAgIGlzTFIgPSBgKCR7aXNMfSB8fCAke2lzUn0pYCxcbiAgICAgIGlzVkcgPSBgZGF0dW0udmdyYWQgJiYgJHtpc0xSfWAsXG4gICAgICBiYXNlbGluZSA9IGFuY2hvckV4cHIoJ1widG9wXCInLCAnXCJib3R0b21cIicsICdcIm1pZGRsZVwiJyksXG4gICAgICBhbGlnbkZsaXAgPSBhbmNob3JFeHByKCdcInJpZ2h0XCInLCAnXCJsZWZ0XCInLCAnXCJjZW50ZXJcIicpLFxuICAgICAgZXhwckFsaWduID0gYGRhdHVtLnZncmFkICYmICR7aXNSfSA/ICgke2FsaWduRmxpcH0pIDogKCR7aXNMUn0gJiYgIShkYXR1bS52Z3JhZCAmJiAke2lzTH0pKSA/IFwibGVmdFwiIDogJHthbGlnbkV4cHIkMX1gLFxuICAgICAgZXhwckFuY2hvciA9IGBpdGVtLl9hbmNob3IgfHwgKCR7aXNMUn0gPyBcIm1pZGRsZVwiIDogXCJzdGFydFwiKWAsXG4gICAgICBleHByQW5nbGUgPSBgJHtpc1ZHfSA/ICgke2lzTH0gPyAtOTAgOiA5MCkgOiAwYCxcbiAgICAgIGV4cHJCYXNlbGluZSA9IGAke2lzTFJ9ID8gKGRhdHVtLnZncmFkID8gKCR7aXNSfSA/IFwiYm90dG9tXCIgOiBcInRvcFwiKSA6ICR7YmFzZWxpbmV9KSA6IFwidG9wXCJgO1xuZnVuY3Rpb24gbGVnZW5kVGl0bGUgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyk7XG5cbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHg6IHtcbiAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICBncm91cDogJ3BhZGRpbmcnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGZpZWxkOiB7XG4gICAgICAgICAgZ3JvdXA6ICdwYWRkaW5nJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBvcmllbnQ6IF8oJ3RpdGxlT3JpZW50JyksXG4gICAgX2FuY2hvcjogXygndGl0bGVBbmNob3InKSxcbiAgICBhbmNob3I6IHtcbiAgICAgIHNpZ25hbDogZXhwckFuY2hvclxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogZXhwckFuZ2xlXG4gICAgfSxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiBleHByQWxpZ25cbiAgICB9LFxuICAgIGJhc2VsaW5lOiB7XG4gICAgICBzaWduYWw6IGV4cHJCYXNlbGluZVxuICAgIH0sXG4gICAgdGV4dDogc3BlYy50aXRsZSxcbiAgICBmaWxsOiBfKCd0aXRsZUNvbG9yJyksXG4gICAgZmlsbE9wYWNpdHk6IF8oJ3RpdGxlT3BhY2l0eScpLFxuICAgIGZvbnQ6IF8oJ3RpdGxlRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCd0aXRsZUZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCd0aXRsZUZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ3RpdGxlRm9udFdlaWdodCcpLFxuICAgIGxpbWl0OiBfKCd0aXRsZUxpbWl0JyksXG4gICAgbGluZUhlaWdodDogXygndGl0bGVMaW5lSGVpZ2h0JylcbiAgfSwge1xuICAgIC8vIHJlcXVpcmUgdXBkYXRlXG4gICAgYWxpZ246IF8oJ3RpdGxlQWxpZ24nKSxcbiAgICBiYXNlbGluZTogXygndGl0bGVCYXNlbGluZScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBMZWdlbmRUaXRsZVJvbGUsXG4gICAgc3R5bGU6IEd1aWRlVGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gY2xpcCAoY2xpcCwgc2NvcGUpIHtcbiAgbGV0IGV4cHI7XG5cbiAgaWYgKGlzT2JqZWN0KGNsaXApKSB7XG4gICAgaWYgKGNsaXAuc2lnbmFsKSB7XG4gICAgICBleHByID0gY2xpcC5zaWduYWw7XG4gICAgfSBlbHNlIGlmIChjbGlwLnBhdGgpIHtcbiAgICAgIGV4cHIgPSAncGF0aFNoYXBlKCcgKyBwYXJhbShjbGlwLnBhdGgpICsgJyknO1xuICAgIH0gZWxzZSBpZiAoY2xpcC5zcGhlcmUpIHtcbiAgICAgIGV4cHIgPSAnZ2VvU2hhcGUoJyArIHBhcmFtKGNsaXAuc3BoZXJlKSArICcsIHt0eXBlOiBcIlNwaGVyZVwifSknO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHByID8gc2NvcGUuc2lnbmFsUmVmKGV4cHIpIDogISFjbGlwO1xufVxuXG5mdW5jdGlvbiBwYXJhbSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLnNpZ25hbCA/IHZhbHVlLnNpZ25hbCA6IHN0cmluZ1ZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Um9sZSAoc3BlYykge1xuICBjb25zdCByb2xlID0gc3BlYy5yb2xlIHx8ICcnO1xuICByZXR1cm4gIXJvbGUuaW5kZXhPZignYXhpcycpIHx8ICFyb2xlLmluZGV4T2YoJ2xlZ2VuZCcpIHx8ICFyb2xlLmluZGV4T2YoJ3RpdGxlJykgPyByb2xlIDogc3BlYy50eXBlID09PSBHcm91cE1hcmsgPyBTY29wZVJvbGUgOiByb2xlIHx8IE1hcmtSb2xlO1xufVxuXG5mdW5jdGlvbiBkZWZpbml0aW9uIChzcGVjKSB7XG4gIHJldHVybiB7XG4gICAgbWFya3R5cGU6IHNwZWMudHlwZSxcbiAgICBuYW1lOiBzcGVjLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIHJvbGU6IHNwZWMucm9sZSB8fCBnZXRSb2xlKHNwZWMpLFxuICAgIHppbmRleDogK3NwZWMuemluZGV4IHx8IHVuZGVmaW5lZCxcbiAgICBhcmlhOiBzcGVjLmFyaWEsXG4gICAgZGVzY3JpcHRpb246IHNwZWMuZGVzY3JpcHRpb25cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmUgKHNwZWMsIHNjb3BlKSB7XG4gIHJldHVybiBzcGVjICYmIHNwZWMuc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHNwZWMuc2lnbmFsKSA6IHNwZWMgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZGF0YSB0cmFuc2Zvcm0gc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGVmID0gZGVmaW5pdGlvbiQxKHNwZWMudHlwZSk7XG4gIGlmICghZGVmKSBlcnJvcignVW5yZWNvZ25pemVkIHRyYW5zZm9ybSB0eXBlOiAnICsgc3RyaW5nVmFsdWUoc3BlYy50eXBlKSk7XG4gIGNvbnN0IHQgPSBlbnRyeShkZWYudHlwZS50b0xvd2VyQ2FzZSgpLCBudWxsLCBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkpO1xuICBpZiAoc3BlYy5zaWduYWwpIHNjb3BlLmFkZFNpZ25hbChzcGVjLnNpZ25hbCwgc2NvcGUucHJveHkodCkpO1xuICB0Lm1ldGFkYXRhID0gZGVmLm1ldGFkYXRhIHx8IHt9O1xuICByZXR1cm4gdDtcbn1cbi8qKlxuICogUGFyc2UgYWxsIHBhcmFtZXRlcnMgb2YgYSBkYXRhIHRyYW5zZm9ybS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBwYXJhbXMgPSB7fSxcbiAgICAgICAgbiA9IGRlZi5wYXJhbXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgcGRlZiA9IGRlZi5wYXJhbXNbaV07XG4gICAgcGFyYW1zW3BkZWYubmFtZV0gPSBwYXJzZVBhcmFtZXRlcihwZGVmLCBzcGVjLCBzY29wZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuLyoqXG4gKiBQYXJzZSBhIGRhdGEgdHJhbnNmb3JtIHBhcmFtZXRlci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgdHlwZSA9IGRlZi50eXBlLFxuICAgICAgICB2YWx1ZSA9IHNwZWNbZGVmLm5hbWVdO1xuXG4gIGlmICh0eXBlID09PSAnaW5kZXgnKSB7XG4gICAgcmV0dXJuIHBhcnNlSW5kZXhQYXJhbWV0ZXIoZGVmLCBzcGVjLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkZWYucmVxdWlyZWQpIHtcbiAgICAgIGVycm9yKCdNaXNzaW5nIHJlcXVpcmVkICcgKyBzdHJpbmdWYWx1ZShzcGVjLnR5cGUpICsgJyBwYXJhbWV0ZXI6ICcgKyBzdHJpbmdWYWx1ZShkZWYubmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncGFyYW0nKSB7XG4gICAgcmV0dXJuIHBhcnNlU3ViUGFyYW1ldGVycyhkZWYsIHNwZWMsIHNjb3BlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncHJvamVjdGlvbicpIHtcbiAgICByZXR1cm4gc2NvcGUucHJvamVjdGlvblJlZihzcGVjW2RlZi5uYW1lXSk7XG4gIH1cblxuICByZXR1cm4gZGVmLmFycmF5ICYmICFpc1NpZ25hbCh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBwYXJhbWV0ZXJWYWx1ZShkZWYsIHYsIHNjb3BlKSkgOiBwYXJhbWV0ZXJWYWx1ZShkZWYsIHZhbHVlLCBzY29wZSk7XG59XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcmFtZXRlclZhbHVlKGRlZiwgdmFsdWUsIHNjb3BlKSB7XG4gIGNvbnN0IHR5cGUgPSBkZWYudHlwZTtcblxuICBpZiAoaXNTaWduYWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzRXhwcih0eXBlKSA/IGVycm9yKCdFeHByZXNzaW9uIHJlZmVyZW5jZXMgY2FuIG5vdCBiZSBzaWduYWxzLicpIDogaXNGaWVsZCh0eXBlKSA/IHNjb3BlLmZpZWxkUmVmKHZhbHVlKSA6IGlzQ29tcGFyZSh0eXBlKSA/IHNjb3BlLmNvbXBhcmVSZWYodmFsdWUpIDogc2NvcGUuc2lnbmFsUmVmKHZhbHVlLnNpZ25hbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwciA9IGRlZi5leHByIHx8IGlzRmllbGQodHlwZSk7XG4gICAgcmV0dXJuIGV4cHIgJiYgb3V0ZXJFeHByKHZhbHVlKSA/IHNjb3BlLmV4cHJSZWYodmFsdWUuZXhwciwgdmFsdWUuYXMpIDogZXhwciAmJiBvdXRlckZpZWxkKHZhbHVlKSA/IGZpZWxkUmVmJDEodmFsdWUuZmllbGQsIHZhbHVlLmFzKSA6IGlzRXhwcih0eXBlKSA/IHBhcnNlRXhwcmVzc2lvbih2YWx1ZSwgc2NvcGUpIDogaXNEYXRhKHR5cGUpID8gcmVmKHNjb3BlLmdldERhdGEodmFsdWUpLnZhbHVlcykgOiBpc0ZpZWxkKHR5cGUpID8gZmllbGRSZWYkMSh2YWx1ZSkgOiBpc0NvbXBhcmUodHlwZSkgPyBzY29wZS5jb21wYXJlUmVmKHZhbHVlKSA6IHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFBhcnNlIHBhcmFtZXRlciBmb3IgYWNjZXNzaW5nIGFuIGluZGV4IG9mIGFub3RoZXIgZGF0YSBzZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUluZGV4UGFyYW1ldGVyKGRlZiwgc3BlYywgc2NvcGUpIHtcbiAgaWYgKCFpc1N0cmluZyhzcGVjLmZyb20pKSB7XG4gICAgZXJyb3IoJ0xvb2t1cCBcImZyb21cIiBwYXJhbWV0ZXIgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICB9XG5cbiAgcmV0dXJuIHNjb3BlLmdldERhdGEoc3BlYy5mcm9tKS5sb29rdXBSZWYoc2NvcGUsIHNwZWMua2V5KTtcbn1cbi8qKlxuICogUGFyc2UgYSBwYXJhbWV0ZXIgdGhhdCBjb250YWlucyBvbmUgb3IgbW9yZSBzdWItcGFyYW1ldGVyIG9iamVjdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVN1YlBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZSA9IHNwZWNbZGVmLm5hbWVdO1xuXG4gIGlmIChkZWYuYXJyYXkpIHtcbiAgICBpZiAoIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAvLyBzaWduYWxzIG5vdCBhbGxvd2VkIVxuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGFuIGFycmF5IG9mIHN1Yi1wYXJhbWV0ZXJzLiBJbnN0ZWFkOiAnICsgc3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubWFwKHYgPT4gcGFyc2VTdWJQYXJhbWV0ZXIoZGVmLCB2LCBzY29wZSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJzZVN1YlBhcmFtZXRlcihkZWYsIHZhbHVlLCBzY29wZSk7XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYSBzdWItcGFyYW1ldGVyIG9iamVjdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlU3ViUGFyYW1ldGVyKGRlZiwgdmFsdWUsIHNjb3BlKSB7XG4gIGNvbnN0IG4gPSBkZWYucGFyYW1zLmxlbmd0aDtcbiAgbGV0IHBkZWY7IC8vIGxvb3Agb3ZlciBkZWZzIHRvIGZpbmQgbWF0Y2hpbmcga2V5XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBwZGVmID0gZGVmLnBhcmFtc1tpXTtcblxuICAgIGZvciAoY29uc3QgayBpbiBwZGVmLmtleSkge1xuICAgICAgaWYgKHBkZWYua2V5W2tdICE9PSB2YWx1ZVtrXSkge1xuICAgICAgICBwZGVmID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBkZWYpIGJyZWFrO1xuICB9IC8vIHJhaXNlIGVycm9yIGlmIG1hdGNoaW5nIGtleSBub3QgZm91bmRcblxuXG4gIGlmICghcGRlZikgZXJyb3IoJ1Vuc3VwcG9ydGVkIHBhcmFtZXRlcjogJyArIHN0cmluZ1ZhbHVlKHZhbHVlKSk7IC8vIHBhcnNlIHBhcmFtcywgY3JlYXRlIFBhcmFtcyB0cmFuc2Zvcm0sIHJldHVybiByZWZcblxuICBjb25zdCBwYXJhbXMgPSBleHRlbmQocGFyc2VQYXJhbWV0ZXJzKHBkZWYsIHZhbHVlLCBzY29wZSksIHBkZWYua2V5KTtcbiAgcmV0dXJuIHJlZihzY29wZS5hZGQoUGFyYW1zKHBhcmFtcykpKTtcbn0gLy8gLS0gVXRpbGl0aWVzIC0tLS0tXG5cblxuY29uc3Qgb3V0ZXJFeHByID0gXyA9PiBfICYmIF8uZXhwcjtcbmNvbnN0IG91dGVyRmllbGQgPSBfID0+IF8gJiYgXy5maWVsZDtcbmNvbnN0IGlzRGF0YSA9IF8gPT4gXyA9PT0gJ2RhdGEnO1xuY29uc3QgaXNFeHByID0gXyA9PiBfID09PSAnZXhwcic7XG5jb25zdCBpc0ZpZWxkID0gXyA9PiBfID09PSAnZmllbGQnO1xuY29uc3QgaXNDb21wYXJlID0gXyA9PiBfID09PSAnY29tcGFyZSc7XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YSQxIChmcm9tLCBncm91cCwgc2NvcGUpIHtcbiAgbGV0IGZhY2V0LCBrZXksIG9wLCBkYXRhUmVmLCBwYXJlbnQ7IC8vIGlmIG5vIHNvdXJjZSBkYXRhLCBnZW5lcmF0ZSBzaW5nbGV0b24gZGF0dW1cblxuICBpZiAoIWZyb20pIHtcbiAgICBkYXRhUmVmID0gcmVmKHNjb3BlLmFkZChDb2xsZWN0KG51bGwsIFt7fV0pKSk7XG4gIH0gLy8gaWYgZmFjZXRlZCwgcHJvY2VzcyBmYWNldCBzcGVjaWZpY2F0aW9uXG4gIGVsc2UgaWYgKGZhY2V0ID0gZnJvbS5mYWNldCkge1xuICAgIGlmICghZ3JvdXApIGVycm9yKCdPbmx5IGdyb3VwIG1hcmtzIGNhbiBiZSBmYWNldGVkLicpOyAvLyB1c2UgcHJlLWZhY2V0ZWQgc291cmNlIGRhdGEsIGlmIGF2YWlsYWJsZVxuXG4gICAgaWYgKGZhY2V0LmZpZWxkICE9IG51bGwpIHtcbiAgICAgIGRhdGFSZWYgPSBwYXJlbnQgPSBnZXREYXRhUmVmKGZhY2V0LCBzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYXRlIGZhY2V0IGFnZ3JlZ2F0ZXMgaWYgbm8gZGlyZWN0IGRhdGEgc3BlY2lmaWNhdGlvblxuICAgICAgaWYgKCFmcm9tLmRhdGEpIHtcbiAgICAgICAgb3AgPSBwYXJzZVRyYW5zZm9ybShleHRlbmQoe1xuICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgIGdyb3VwYnk6IGFycmF5KGZhY2V0Lmdyb3VwYnkpXG4gICAgICAgIH0sIGZhY2V0LmFnZ3JlZ2F0ZSksIHNjb3BlKTtcbiAgICAgICAgb3AucGFyYW1zLmtleSA9IHNjb3BlLmtleVJlZihmYWNldC5ncm91cGJ5KTtcbiAgICAgICAgb3AucGFyYW1zLnB1bHNlID0gZ2V0RGF0YVJlZihmYWNldCwgc2NvcGUpO1xuICAgICAgICBkYXRhUmVmID0gcGFyZW50ID0gcmVmKHNjb3BlLmFkZChvcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcmVmKHNjb3BlLmdldERhdGEoZnJvbS5kYXRhKS5hZ2dyZWdhdGUpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSwgdHJ1ZSk7XG4gICAgfVxuICB9IC8vIGlmIG5vdCB5ZXQgZGVmaW5lZCwgZ2V0IHNvdXJjZSBkYXRhIHJlZmVyZW5jZVxuXG5cbiAgaWYgKCFkYXRhUmVmKSB7XG4gICAgZGF0YVJlZiA9IGdldERhdGFSZWYoZnJvbSwgc2NvcGUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBwdWxzZTogZGF0YVJlZixcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF0YVJlZihmcm9tLCBzY29wZSkge1xuICByZXR1cm4gZnJvbS4kcmVmID8gZnJvbSA6IGZyb20uZGF0YSAmJiBmcm9tLmRhdGEuJHJlZiA/IGZyb20uZGF0YSA6IHJlZihzY29wZS5nZXREYXRhKGZyb20uZGF0YSkub3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgb3V0cHV0LCB2YWx1ZXMsIGFnZ3IpIHtcbiAgdGhpcy5zY29wZSA9IHNjb3BlOyAvLyBwYXJlbnQgc2NvcGUgb2JqZWN0XG5cbiAgdGhpcy5pbnB1dCA9IGlucHV0OyAvLyBmaXJzdCBvcGVyYXRvciBpbiBwaXBlbGluZSAodHVwbGUgaW5wdXQpXG5cbiAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7IC8vIGxhc3Qgb3BlcmF0b3IgaW4gcGlwZWxpbmUgKHR1cGxlIG91dHB1dClcblxuICB0aGlzLnZhbHVlcyA9IHZhbHVlczsgLy8gb3BlcmF0b3IgZm9yIGFjY2Vzc2luZyB0dXBsZXMgKGJ1dCBub3QgdHVwbGUgZmxvdylcbiAgLy8gbGFzdCBhZ2dyZWdhdGUgaW4gdHJhbnNmb3JtIHBpcGVsaW5lXG5cbiAgdGhpcy5hZ2dyZWdhdGUgPSBhZ2dyOyAvLyBsb29rdXAgdGFibGUgb2YgZmllbGQgaW5kaWNlc1xuXG4gIHRoaXMuaW5kZXggPSB7fTtcbn1cblxuRGF0YVNjb3BlLmZyb21FbnRyaWVzID0gZnVuY3Rpb24gKHNjb3BlLCBlbnRyaWVzKSB7XG4gIGNvbnN0IG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICAgICAgdmFsdWVzID0gZW50cmllc1tuIC0gMV0sXG4gICAgICAgIG91dHB1dCA9IGVudHJpZXNbbiAtIDJdO1xuICBsZXQgaW5wdXQgPSBlbnRyaWVzWzBdLFxuICAgICAgYWdnciA9IG51bGwsXG4gICAgICBpID0gMTtcblxuICBpZiAoaW5wdXQgJiYgaW5wdXQudHlwZSA9PT0gJ2xvYWQnKSB7XG4gICAgaW5wdXQgPSBlbnRyaWVzWzFdO1xuICB9IC8vIGFkZCBvcGVyYXRvciBlbnRyaWVzIHRvIHRoaXMgc2NvcGUsIHdpcmUgdXAgcHVsc2UgY2hhaW5cblxuXG4gIHNjb3BlLmFkZChlbnRyaWVzWzBdKTtcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGVudHJpZXNbaV0ucGFyYW1zLnB1bHNlID0gcmVmKGVudHJpZXNbaSAtIDFdKTtcbiAgICBzY29wZS5hZGQoZW50cmllc1tpXSk7XG4gICAgaWYgKGVudHJpZXNbaV0udHlwZSA9PT0gJ2FnZ3JlZ2F0ZScpIGFnZ3IgPSBlbnRyaWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRhU2NvcGUoc2NvcGUsIGlucHV0LCBvdXRwdXQsIHZhbHVlcywgYWdncik7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEtleShmaWVsZCkge1xuICByZXR1cm4gaXNTdHJpbmcoZmllbGQpID8gZmllbGQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRTb3J0RmllbGQoc2NvcGUsIHAsIHNvcnQpIHtcbiAgY29uc3QgYXMgPSBhZ2dyRmllbGQoc29ydC5vcCwgc29ydC5maWVsZCk7XG4gIGxldCBzO1xuXG4gIGlmIChwLm9wcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcC5hcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChwLmFzW2ldID09PSBhcykgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm9wcyA9IFsnY291bnQnXTtcbiAgICBwLmZpZWxkcyA9IFtudWxsXTtcbiAgICBwLmFzID0gWydjb3VudCddO1xuICB9XG5cbiAgaWYgKHNvcnQub3ApIHtcbiAgICBwLm9wcy5wdXNoKChzID0gc29ydC5vcC5zaWduYWwpID8gc2NvcGUuc2lnbmFsUmVmKHMpIDogc29ydC5vcCk7XG4gICAgcC5maWVsZHMucHVzaChzY29wZS5maWVsZFJlZihzb3J0LmZpZWxkKSk7XG4gICAgcC5hcy5wdXNoKGFzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZShzY29wZSwgZHMsIG5hbWUsIG9wdHlwZSwgZmllbGQsIGNvdW50cywgaW5kZXgpIHtcbiAgY29uc3QgY2FjaGUgPSBkc1tuYW1lXSB8fCAoZHNbbmFtZV0gPSB7fSksXG4gICAgICAgIHNvcnQgPSBzb3J0S2V5KGNvdW50cyk7XG4gIGxldCBrID0gZmllbGRLZXkoZmllbGQpLFxuICAgICAgdixcbiAgICAgIG9wO1xuXG4gIGlmIChrICE9IG51bGwpIHtcbiAgICBzY29wZSA9IGRzLnNjb3BlO1xuICAgIGsgPSBrICsgKHNvcnQgPyAnfCcgKyBzb3J0IDogJycpO1xuICAgIHYgPSBjYWNoZVtrXTtcbiAgfVxuXG4gIGlmICghdikge1xuICAgIGNvbnN0IHBhcmFtcyA9IGNvdW50cyA/IHtcbiAgICAgIGZpZWxkOiBrZXlGaWVsZFJlZixcbiAgICAgIHB1bHNlOiBkcy5jb3VudHNSZWYoc2NvcGUsIGZpZWxkLCBjb3VudHMpXG4gICAgfSA6IHtcbiAgICAgIGZpZWxkOiBzY29wZS5maWVsZFJlZihmaWVsZCksXG4gICAgICBwdWxzZTogcmVmKGRzLm91dHB1dClcbiAgICB9O1xuICAgIGlmIChzb3J0KSBwYXJhbXMuc29ydCA9IHNjb3BlLnNvcnRSZWYoY291bnRzKTtcbiAgICBvcCA9IHNjb3BlLmFkZChlbnRyeShvcHR5cGUsIHVuZGVmaW5lZCwgcGFyYW1zKSk7XG4gICAgaWYgKGluZGV4KSBkcy5pbmRleFtmaWVsZF0gPSBvcDtcbiAgICB2ID0gcmVmKG9wKTtcbiAgICBpZiAoayAhPSBudWxsKSBjYWNoZVtrXSA9IHY7XG4gIH1cblxuICByZXR1cm4gdjtcbn1cblxuRGF0YVNjb3BlLnByb3RvdHlwZSA9IHtcbiAgY291bnRzUmVmKHNjb3BlLCBmaWVsZCwgc29ydCkge1xuICAgIGNvbnN0IGRzID0gdGhpcyxcbiAgICAgICAgICBjYWNoZSA9IGRzLmNvdW50cyB8fCAoZHMuY291bnRzID0ge30pLFxuICAgICAgICAgIGsgPSBmaWVsZEtleShmaWVsZCk7XG4gICAgbGV0IHYsIGEsIHA7XG5cbiAgICBpZiAoayAhPSBudWxsKSB7XG4gICAgICBzY29wZSA9IGRzLnNjb3BlO1xuICAgICAgdiA9IGNhY2hlW2tdO1xuICAgIH1cblxuICAgIGlmICghdikge1xuICAgICAgcCA9IHtcbiAgICAgICAgZ3JvdXBieTogc2NvcGUuZmllbGRSZWYoZmllbGQsICdrZXknKSxcbiAgICAgICAgcHVsc2U6IHJlZihkcy5vdXRwdXQpXG4gICAgICB9O1xuICAgICAgaWYgKHNvcnQgJiYgc29ydC5maWVsZCkgYWRkU29ydEZpZWxkKHNjb3BlLCBwLCBzb3J0KTtcbiAgICAgIGEgPSBzY29wZS5hZGQoQWdncmVnYXRlKHApKTtcbiAgICAgIHYgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgICAgIHB1bHNlOiByZWYoYSlcbiAgICAgIH0pKTtcbiAgICAgIHYgPSB7XG4gICAgICAgIGFnZzogYSxcbiAgICAgICAgcmVmOiByZWYodilcbiAgICAgIH07XG4gICAgICBpZiAoayAhPSBudWxsKSBjYWNoZVtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChzb3J0ICYmIHNvcnQuZmllbGQpIHtcbiAgICAgIGFkZFNvcnRGaWVsZChzY29wZSwgdi5hZ2cucGFyYW1zLCBzb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdi5yZWY7XG4gIH0sXG5cbiAgdHVwbGVzUmVmKCkge1xuICAgIHJldHVybiByZWYodGhpcy52YWx1ZXMpO1xuICB9LFxuXG4gIGV4dGVudFJlZihzY29wZSwgZmllbGQpIHtcbiAgICByZXR1cm4gY2FjaGUoc2NvcGUsIHRoaXMsICdleHRlbnQnLCAnZXh0ZW50JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcblxuICBkb21haW5SZWYoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAnZG9tYWluJywgJ3ZhbHVlcycsIGZpZWxkLCBmYWxzZSk7XG4gIH0sXG5cbiAgdmFsdWVzUmVmKHNjb3BlLCBmaWVsZCwgc29ydCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ3ZhbHMnLCAndmFsdWVzJywgZmllbGQsIHNvcnQgfHwgdHJ1ZSk7XG4gIH0sXG5cbiAgbG9va3VwUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2xvb2t1cCcsICd0dXBsZWluZGV4JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcblxuICBpbmRhdGFSZWYoc2NvcGUsIGZpZWxkKSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAnaW5kYXRhJywgJ3R1cGxlaW5kZXgnLCBmaWVsZCwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gcGFyc2VGYWNldCAoc3BlYywgc2NvcGUsIGdyb3VwKSB7XG4gIGNvbnN0IGZhY2V0ID0gc3BlYy5mcm9tLmZhY2V0LFxuICAgICAgICBuYW1lID0gZmFjZXQubmFtZSxcbiAgICAgICAgZGF0YSA9IGdldERhdGFSZWYoZmFjZXQsIHNjb3BlKTtcbiAgbGV0IG9wO1xuXG4gIGlmICghZmFjZXQubmFtZSkge1xuICAgIGVycm9yKCdGYWNldCBtdXN0IGhhdmUgYSBuYW1lOiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfVxuXG4gIGlmICghZmFjZXQuZGF0YSkge1xuICAgIGVycm9yKCdGYWNldCBtdXN0IHJlZmVyZW5jZSBhIGRhdGEgc2V0OiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfVxuXG4gIGlmIChmYWNldC5maWVsZCkge1xuICAgIG9wID0gc2NvcGUuYWRkKFByZUZhY2V0KHtcbiAgICAgIGZpZWxkOiBzY29wZS5maWVsZFJlZihmYWNldC5maWVsZCksXG4gICAgICBwdWxzZTogZGF0YVxuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChmYWNldC5ncm91cGJ5KSB7XG4gICAgb3AgPSBzY29wZS5hZGQoRmFjZXQoe1xuICAgICAga2V5OiBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSksXG4gICAgICBncm91cDogcmVmKHNjb3BlLnByb3h5KGdyb3VwLnBhcmVudCkpLFxuICAgICAgcHVsc2U6IGRhdGFcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ZhY2V0IG11c3Qgc3BlY2lmeSBncm91cGJ5IG9yIGZpZWxkOiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfSAvLyBpbml0aWFsaXplIGZhY2V0IHN1YnNjb3BlXG5cblxuICBjb25zdCBzdWJzY29wZSA9IHNjb3BlLmZvcmsoKSxcbiAgICAgICAgc291cmNlID0gc3Vic2NvcGUuYWRkKENvbGxlY3QoKSksXG4gICAgICAgIHZhbHVlcyA9IHN1YnNjb3BlLmFkZChTaWV2ZSh7XG4gICAgcHVsc2U6IHJlZihzb3VyY2UpXG4gIH0pKTtcbiAgc3Vic2NvcGUuYWRkRGF0YShuYW1lLCBuZXcgRGF0YVNjb3BlKHN1YnNjb3BlLCBzb3VyY2UsIHNvdXJjZSwgdmFsdWVzKSk7XG4gIHN1YnNjb3BlLmFkZFNpZ25hbCgncGFyZW50JywgbnVsbCk7IC8vIHBhcnNlIGZhY2V0ZWQgc3ViZmxvd1xuXG4gIG9wLnBhcmFtcy5zdWJmbG93ID0ge1xuICAgICRzdWJmbG93OiBzdWJzY29wZS5wYXJzZShzcGVjKS50b1J1bnRpbWUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN1YmZsb3cgKHNwZWMsIHNjb3BlLCBpbnB1dCkge1xuICBjb25zdCBvcCA9IHNjb3BlLmFkZChQcmVGYWNldCh7XG4gICAgcHVsc2U6IGlucHV0LnB1bHNlXG4gIH0pKSxcbiAgICAgICAgc3Vic2NvcGUgPSBzY29wZS5mb3JrKCk7XG4gIHN1YnNjb3BlLmFkZChTaWV2ZSgpKTtcbiAgc3Vic2NvcGUuYWRkU2lnbmFsKCdwYXJlbnQnLCBudWxsKTsgLy8gcGFyc2UgZ3JvdXAgbWFyayBzdWJmbG93XG5cbiAgb3AucGFyYW1zLnN1YmZsb3cgPSB7XG4gICAgJHN1YmZsb3c6IHN1YnNjb3BlLnBhcnNlKHNwZWMpLnRvUnVudGltZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlciAoc3BlYywgc2NvcGUsIG5hbWUpIHtcbiAgY29uc3QgcmVtb3ZlID0gc3BlYy5yZW1vdmUsXG4gICAgICAgIGluc2VydCA9IHNwZWMuaW5zZXJ0LFxuICAgICAgICB0b2dnbGUgPSBzcGVjLnRvZ2dsZSxcbiAgICAgICAgbW9kaWZ5ID0gc3BlYy5tb2RpZnksXG4gICAgICAgIHZhbHVlcyA9IHNwZWMudmFsdWVzLFxuICAgICAgICBvcCA9IHNjb3BlLmFkZChvcGVyYXRvcigpKTtcbiAgY29uc3QgdXBkYXRlID0gJ2lmKCcgKyBzcGVjLnRyaWdnZXIgKyAnLG1vZGlmeShcIicgKyBuYW1lICsgJ1wiLCcgKyBbaW5zZXJ0LCByZW1vdmUsIHRvZ2dsZSwgbW9kaWZ5LCB2YWx1ZXNdLm1hcChfID0+IF8gPT0gbnVsbCA/ICdudWxsJyA6IF8pLmpvaW4oJywnKSArICcpLDApJztcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUsIHNjb3BlKTtcbiAgb3AudXBkYXRlID0gZXhwci4kZXhwcjtcbiAgb3AucGFyYW1zID0gZXhwci4kcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hcmsgKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHJvbGUgPSBnZXRSb2xlKHNwZWMpLFxuICAgICAgICBncm91cCA9IHNwZWMudHlwZSA9PT0gR3JvdXBNYXJrLFxuICAgICAgICBmYWNldCA9IHNwZWMuZnJvbSAmJiBzcGVjLmZyb20uZmFjZXQsXG4gICAgICAgIG92ZXJsYXAgPSBzcGVjLm92ZXJsYXA7XG4gIGxldCBsYXlvdXQgPSBzcGVjLmxheW91dCB8fCByb2xlID09PSBTY29wZVJvbGUgfHwgcm9sZSA9PT0gRnJhbWVSb2xlLFxuICAgICAgb3BzLFxuICAgICAgb3AsXG4gICAgICBzdG9yZSxcbiAgICAgIGVuYyxcbiAgICAgIG5hbWUsXG4gICAgICBsYXlvdXRSZWYsXG4gICAgICBib3VuZFJlZjtcbiAgY29uc3QgbmVzdGVkID0gcm9sZSA9PT0gTWFya1JvbGUgfHwgbGF5b3V0IHx8IGZhY2V0OyAvLyByZXNvbHZlIGlucHV0IGRhdGFcblxuICBjb25zdCBpbnB1dCA9IHBhcnNlRGF0YSQxKHNwZWMuZnJvbSwgZ3JvdXAsIHNjb3BlKTsgLy8gZGF0YSBqb2luIHRvIG1hcCB0dXBsZXMgdG8gdmlzdWFsIGl0ZW1zXG5cbiAgb3AgPSBzY29wZS5hZGQoRGF0YUpvaW4oe1xuICAgIGtleTogaW5wdXQua2V5IHx8IChzcGVjLmtleSA/IGZpZWxkUmVmJDEoc3BlYy5rZXkpIDogdW5kZWZpbmVkKSxcbiAgICBwdWxzZTogaW5wdXQucHVsc2UsXG4gICAgY2xlYW46ICFncm91cFxuICB9KSk7XG4gIGNvbnN0IGpvaW5SZWYgPSByZWYob3ApOyAvLyBjb2xsZWN0IHZpc3VhbCBpdGVtc1xuXG4gIG9wID0gc3RvcmUgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgcHVsc2U6IGpvaW5SZWZcbiAgfSkpOyAvLyBjb25uZWN0IHZpc3VhbCBpdGVtcyB0byBzY2VuZWdyYXBoXG5cbiAgb3AgPSBzY29wZS5hZGQoTWFyayh7XG4gICAgbWFya2RlZjogZGVmaW5pdGlvbihzcGVjKSxcbiAgICBpbnRlcmFjdGl2ZTogaW50ZXJhY3RpdmUoc3BlYy5pbnRlcmFjdGl2ZSwgc2NvcGUpLFxuICAgIGNsaXA6IGNsaXAoc3BlYy5jbGlwLCBzY29wZSksXG4gICAgY29udGV4dDoge1xuICAgICAgJGNvbnRleHQ6IHRydWVcbiAgICB9LFxuICAgIGdyb3Vwczogc2NvcGUubG9va3VwKCksXG4gICAgcGFyZW50OiBzY29wZS5zaWduYWxzLnBhcmVudCA/IHNjb3BlLnNpZ25hbFJlZigncGFyZW50JykgOiBudWxsLFxuICAgIGluZGV4OiBzY29wZS5tYXJrcGF0aCgpLFxuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTtcbiAgY29uc3QgbWFya1JlZiA9IHJlZihvcCk7IC8vIGFkZCB2aXN1YWwgZW5jb2RlcnNcblxuICBvcCA9IGVuYyA9IHNjb3BlLmFkZChFbmNvZGUocGFyc2VFbmNvZGUoc3BlYy5lbmNvZGUsIHNwZWMudHlwZSwgcm9sZSwgc3BlYy5zdHlsZSwgc2NvcGUsIHtcbiAgICBtb2Q6IGZhbHNlLFxuICAgIHB1bHNlOiBtYXJrUmVmXG4gIH0pKSk7IC8vIG1vbml0b3IgcGFyZW50IG1hcmtzIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzXG5cbiAgb3AucGFyYW1zLnBhcmVudCA9IHNjb3BlLmVuY29kZSgpOyAvLyBhZGQgcG9zdC1lbmNvZGluZyB0cmFuc2Zvcm1zLCBpZiBkZWZpbmVkXG5cbiAgaWYgKHNwZWMudHJhbnNmb3JtKSB7XG4gICAgc3BlYy50cmFuc2Zvcm0uZm9yRWFjaChfID0+IHtcbiAgICAgIGNvbnN0IHR4ID0gcGFyc2VUcmFuc2Zvcm0oXywgc2NvcGUpLFxuICAgICAgICAgICAgbWQgPSB0eC5tZXRhZGF0YTtcblxuICAgICAgaWYgKG1kLmdlbmVyYXRlcyB8fCBtZC5jaGFuZ2VzKSB7XG4gICAgICAgIGVycm9yKCdNYXJrIHRyYW5zZm9ybXMgc2hvdWxkIG5vdCBnZW5lcmF0ZSBuZXcgZGF0YS4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtZC5ub21vZCkgZW5jLnBhcmFtcy5tb2QgPSB0cnVlOyAvLyB1cGRhdGUgZW5jb2RlIG1vZCBoYW5kbGluZ1xuXG4gICAgICB0eC5wYXJhbXMucHVsc2UgPSByZWYob3ApO1xuICAgICAgc2NvcGUuYWRkKG9wID0gdHgpO1xuICAgIH0pO1xuICB9IC8vIGlmIGl0ZW0gc29ydCBzcGVjaWZpZWQsIHBlcmZvcm0gcG9zdC1lbmNvZGluZ1xuXG5cbiAgaWYgKHNwZWMuc29ydCkge1xuICAgIG9wID0gc2NvcGUuYWRkKFNvcnRJdGVtcyh7XG4gICAgICBzb3J0OiBzY29wZS5jb21wYXJlUmVmKHNwZWMuc29ydCksXG4gICAgICBwdWxzZTogcmVmKG9wKVxuICAgIH0pKTtcbiAgfVxuXG4gIGNvbnN0IGVuY29kZVJlZiA9IHJlZihvcCk7IC8vIGFkZCB2aWV3IGxheW91dCBvcGVyYXRvciBpZiBuZWVkZWRcblxuICBpZiAoZmFjZXQgfHwgbGF5b3V0KSB7XG4gICAgbGF5b3V0ID0gc2NvcGUuYWRkKFZpZXdMYXlvdXQoe1xuICAgICAgbGF5b3V0OiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLmxheW91dCksXG4gICAgICBsZWdlbmRzOiBzY29wZS5sZWdlbmRzLFxuICAgICAgbWFyazogbWFya1JlZixcbiAgICAgIHB1bHNlOiBlbmNvZGVSZWZcbiAgICB9KSk7XG4gICAgbGF5b3V0UmVmID0gcmVmKGxheW91dCk7XG4gIH0gLy8gY29tcHV0ZSBib3VuZGluZyBib3hlc1xuXG5cbiAgY29uc3QgYm91bmQgPSBzY29wZS5hZGQoQm91bmQoe1xuICAgIG1hcms6IG1hcmtSZWYsXG4gICAgcHVsc2U6IGxheW91dFJlZiB8fCBlbmNvZGVSZWZcbiAgfSkpO1xuICBib3VuZFJlZiA9IHJlZihib3VuZCk7IC8vIGlmIGdyb3VwIG1hcmssIHJlY3Vyc2UgdG8gcGFyc2UgbmVzdGVkIGNvbnRlbnRcblxuICBpZiAoZ3JvdXApIHtcbiAgICAvLyBqdWdnbGUgbGF5b3V0ICYgYm91bmRzIHRvIGVuc3VyZSB0aGV5IHJ1biAqYWZ0ZXIqIGFueSBmYWNldGluZyB0cmFuc2Zvcm1zXG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgb3BzID0gc2NvcGUub3BlcmF0b3JzO1xuICAgICAgb3BzLnBvcCgpO1xuICAgICAgaWYgKGxheW91dCkgb3BzLnBvcCgpO1xuICAgIH1cblxuICAgIHNjb3BlLnB1c2hTdGF0ZShlbmNvZGVSZWYsIGxheW91dFJlZiB8fCBib3VuZFJlZiwgam9pblJlZik7XG4gICAgZmFjZXQgPyBwYXJzZUZhY2V0KHNwZWMsIHNjb3BlLCBpbnB1dCkgLy8gZXhwbGljaXQgZmFjZXRcbiAgICA6IG5lc3RlZCA/IHBhcnNlU3ViZmxvdyhzcGVjLCBzY29wZSwgaW5wdXQpIC8vIHN0YW5kYXJkIG1hcmsgZ3JvdXBcbiAgICA6IHNjb3BlLnBhcnNlKHNwZWMpOyAvLyBndWlkZSBncm91cCwgd2UgY2FuIGF2b2lkIG5lc3RlZCBzY29wZXNcblxuICAgIHNjb3BlLnBvcFN0YXRlKCk7XG5cbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBpZiAobGF5b3V0KSBvcHMucHVzaChsYXlvdXQpO1xuICAgICAgb3BzLnB1c2goYm91bmQpO1xuICAgIH1cbiAgfSAvLyBpZiByZXF1ZXN0ZWQsIGFkZCBvdmVybGFwIHJlbW92YWwgdHJhbnNmb3JtXG5cblxuICBpZiAob3ZlcmxhcCkge1xuICAgIGJvdW5kUmVmID0gcGFyc2VPdmVybGFwKG92ZXJsYXAsIGJvdW5kUmVmLCBzY29wZSk7XG4gIH0gLy8gcmVuZGVyIC8gc2lldmUgaXRlbXNcblxuXG4gIGNvbnN0IHJlbmRlciA9IHNjb3BlLmFkZChSZW5kZXIoe1xuICAgIHB1bHNlOiBib3VuZFJlZlxuICB9KSksXG4gICAgICAgIHNpZXZlID0gc2NvcGUuYWRkKFNpZXZlKHtcbiAgICBwdWxzZTogcmVmKHJlbmRlcilcbiAgfSwgdW5kZWZpbmVkLCBzY29wZS5wYXJlbnQoKSkpOyAvLyBpZiBtYXJrIGlzIG5hbWVkLCBtYWtlIGFjY2Vzc2libGUgYXMgcmVhY3RpdmUgZ2VvbWV0cnlcbiAgLy8gYWRkIHRyaWdnZXIgdXBkYXRlcyBpZiBkZWZpbmVkXG5cbiAgaWYgKHNwZWMubmFtZSAhPSBudWxsKSB7XG4gICAgbmFtZSA9IHNwZWMubmFtZTtcbiAgICBzY29wZS5hZGREYXRhKG5hbWUsIG5ldyBEYXRhU2NvcGUoc2NvcGUsIHN0b3JlLCByZW5kZXIsIHNpZXZlKSk7XG4gICAgaWYgKHNwZWMub24pIHNwZWMub24uZm9yRWFjaChvbiA9PiB7XG4gICAgICBpZiAob24uaW5zZXJ0IHx8IG9uLnJlbW92ZSB8fCBvbi50b2dnbGUpIHtcbiAgICAgICAgZXJyb3IoJ01hcmtzIG9ubHkgc3VwcG9ydCBtb2RpZnkgdHJpZ2dlcnMuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlVHJpZ2dlcihvbiwgc2NvcGUsIG5hbWUpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlT3ZlcmxhcChvdmVybGFwLCBzb3VyY2UsIHNjb3BlKSB7XG4gIGNvbnN0IG1ldGhvZCA9IG92ZXJsYXAubWV0aG9kLFxuICAgICAgICBib3VuZCA9IG92ZXJsYXAuYm91bmQsXG4gICAgICAgIHNlcCA9IG92ZXJsYXAuc2VwYXJhdGlvbjtcbiAgY29uc3QgcGFyYW1zID0ge1xuICAgIHNlcGFyYXRpb246IGlzU2lnbmFsKHNlcCkgPyBzY29wZS5zaWduYWxSZWYoc2VwLnNpZ25hbCkgOiBzZXAsXG4gICAgbWV0aG9kOiBpc1NpZ25hbChtZXRob2QpID8gc2NvcGUuc2lnbmFsUmVmKG1ldGhvZC5zaWduYWwpIDogbWV0aG9kLFxuICAgIHB1bHNlOiBzb3VyY2VcbiAgfTtcblxuICBpZiAob3ZlcmxhcC5vcmRlcikge1xuICAgIHBhcmFtcy5zb3J0ID0gc2NvcGUuY29tcGFyZVJlZih7XG4gICAgICBmaWVsZDogb3ZlcmxhcC5vcmRlclxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGJvdW5kKSB7XG4gICAgY29uc3QgdG9sID0gYm91bmQudG9sZXJhbmNlO1xuICAgIHBhcmFtcy5ib3VuZFRvbGVyYW5jZSA9IGlzU2lnbmFsKHRvbCkgPyBzY29wZS5zaWduYWxSZWYodG9sLnNpZ25hbCkgOiArdG9sO1xuICAgIHBhcmFtcy5ib3VuZFNjYWxlID0gc2NvcGUuc2NhbGVSZWYoYm91bmQuc2NhbGUpO1xuICAgIHBhcmFtcy5ib3VuZE9yaWVudCA9IGJvdW5kLm9yaWVudDtcbiAgfVxuXG4gIHJldHVybiByZWYoc2NvcGUuYWRkKE92ZXJsYXAocGFyYW1zKSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUxlZ2VuZCAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnLmxlZ2VuZCxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgbGVnZW5kRW5jb2RlID0gZW5jb2RlLmxlZ2VuZCB8fCB7fSxcbiAgICAgICAgbmFtZSA9IGxlZ2VuZEVuY29kZS5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaW50ZXJhY3RpdmUgPSBsZWdlbmRFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgICAgIHN0eWxlID0gbGVnZW5kRW5jb2RlLnN0eWxlLFxuICAgICAgICBzY2FsZXMgPSB7fTtcblxuICBsZXQgc2NhbGUgPSAwLFxuICAgICAgZW50cnlMYXlvdXQsXG4gICAgICBwYXJhbXMsXG4gICAgICBjaGlsZHJlbjsgLy8gcmVzb2x2ZSBzY2FsZXMgYW5kICdjYW5vbmljYWwnIHNjYWxlIG5hbWVcblxuICBMZWdlbmRTY2FsZXMuZm9yRWFjaChzID0+IHNwZWNbc10gPyAoc2NhbGVzW3NdID0gc3BlY1tzXSwgc2NhbGUgPSBzY2FsZSB8fCBzcGVjW3NdKSA6IDApO1xuICBpZiAoIXNjYWxlKSBlcnJvcignTWlzc2luZyB2YWxpZCBzY2FsZSBmb3IgbGVnZW5kLicpOyAvLyByZXNvbHZlIGxlZ2VuZCB0eXBlIChzeW1ib2wsIGdyYWRpZW50LCBvciBkaXNjcmV0ZSBncmFkaWVudClcblxuICBjb25zdCB0eXBlID0gbGVnZW5kVHlwZShzcGVjLCBzY29wZS5zY2FsZVR5cGUoc2NhbGUpKTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGxlZ2VuZCBncm91cFxuXG4gIGNvbnN0IGRhdHVtID0ge1xuICAgIHRpdGxlOiBzcGVjLnRpdGxlICE9IG51bGwsXG4gICAgc2NhbGVzOiBzY2FsZXMsXG4gICAgdHlwZTogdHlwZSxcbiAgICB2Z3JhZDogdHlwZSAhPT0gJ3N5bWJvbCcgJiYgXy5pc1ZlcnRpY2FsKClcbiAgfTtcbiAgY29uc3QgZGF0YVJlZiA9IHJlZihzY29wZS5hZGQoQ29sbGVjdChudWxsLCBbZGF0dW1dKSkpOyAvLyBlbmNvZGluZyBwcm9wZXJ0aWVzIGZvciBsZWdlbmQgZW50cnkgc3ViLWdyb3VwXG5cbiAgY29uc3QgZW50cnlFbmNvZGUgPSB7XG4gICAgZW50ZXI6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBkYXRhIHNvdXJjZSBmb3IgbGVnZW5kIHZhbHVlc1xuXG4gIGNvbnN0IGVudHJ5UmVmID0gcmVmKHNjb3BlLmFkZChMZWdlbmRFbnRyaWVzKHBhcmFtcyA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBzY29wZS5zY2FsZVJlZihzY2FsZSksXG4gICAgY291bnQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KF8oJ3RpY2tDb3VudCcpKSxcbiAgICBsaW1pdDogc2NvcGUucHJvcGVydHkoXygnc3ltYm9sTGltaXQnKSksXG4gICAgdmFsdWVzOiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLnZhbHVlcyksXG4gICAgbWluc3RlcDogc2NvcGUucHJvcGVydHkoc3BlYy50aWNrTWluU3RlcCksXG4gICAgZm9ybWF0VHlwZTogc2NvcGUucHJvcGVydHkoc3BlYy5mb3JtYXRUeXBlKSxcbiAgICBmb3JtYXRTcGVjaWZpZXI6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0KVxuICB9KSkpOyAvLyBjb250aW51b3VzIGdyYWRpZW50IGxlZ2VuZFxuXG4gIGlmICh0eXBlID09PSBHcmFkaWVudCkge1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZEdyYWRpZW50KHNwZWMsIHNjYWxlLCBjb25maWcsIGVuY29kZS5ncmFkaWVudCksIGxlZ2VuZEdyYWRpZW50TGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgZW50cnlSZWYpXTsgLy8gYWRqdXN0IGRlZmF1bHQgdGljayBjb3VudCBiYXNlZCBvbiB0aGUgZ3JhZGllbnQgbGVuZ3RoXG5cbiAgICBwYXJhbXMuY291bnQgPSBwYXJhbXMuY291bnQgfHwgc2NvcGUuc2lnbmFsUmVmKGBtYXgoMiwyKmZsb29yKCgke2RlcmVmKF8uZ3JhZGllbnRMZW5ndGgoKSl9KS8xMDApKWApO1xuICB9IC8vIGRpc2NyZXRlIGdyYWRpZW50IGxlZ2VuZFxuICBlbHNlIGlmICh0eXBlID09PSBEaXNjcmV0ZSkge1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZEdyYWRpZW50RGlzY3JldGUoc3BlYywgc2NhbGUsIGNvbmZpZywgZW5jb2RlLmdyYWRpZW50LCBlbnRyeVJlZiksIGxlZ2VuZEdyYWRpZW50TGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgZW50cnlSZWYpXTtcbiAgfSAvLyBzeW1ib2wgbGVnZW5kXG4gIGVsc2Uge1xuICAgIC8vIGRldGVybWluZSBsZWdlbmQgc3ltYm9sIGdyb3VwIGxheW91dFxuICAgIGVudHJ5TGF5b3V0ID0gbGVnZW5kU3ltYm9sTGF5b3V0KHNwZWMsIGNvbmZpZyk7XG4gICAgY2hpbGRyZW4gPSBbbGVnZW5kU3ltYm9sR3JvdXBzKHNwZWMsIGNvbmZpZywgZW5jb2RlLCBlbnRyeVJlZiwgZGVyZWYoZW50cnlMYXlvdXQuY29sdW1ucykpXTsgLy8gcGFzcyBzeW1ib2wgc2l6ZSBpbmZvcm1hdGlvbiB0byBsZWdlbmQgZW50cnkgZ2VuZXJhdG9yXG5cbiAgICBwYXJhbXMuc2l6ZSA9IHNpemVFeHByZXNzaW9uKHNwZWMsIHNjb3BlLCBjaGlsZHJlblswXS5tYXJrcyk7XG4gIH0gLy8gZ2VuZXJhdGUgbGVnZW5kIG1hcmtzXG5cblxuICBjaGlsZHJlbiA9IFtndWlkZUdyb3VwKHtcbiAgICByb2xlOiBMZWdlbmRFbnRyeVJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGVudHJ5RW5jb2RlLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBsYXlvdXQ6IGVudHJ5TGF5b3V0LFxuICAgIGludGVyYWN0aXZlXG4gIH0pXTsgLy8gaW5jbHVkZSBsZWdlbmQgdGl0bGUgaWYgZGVmaW5lZFxuXG4gIGlmIChkYXR1bS50aXRsZSkge1xuICAgIGNoaWxkcmVuLnB1c2gobGVnZW5kVGl0bGUoc3BlYywgY29uZmlnLCBlbmNvZGUudGl0bGUsIGRhdGFSZWYpKTtcbiAgfSAvLyBwYXJzZSBsZWdlbmQgc3BlY2lmaWNhdGlvblxuXG5cbiAgcmV0dXJuIHBhcnNlTWFyayhndWlkZUdyb3VwKHtcbiAgICByb2xlOiBMZWdlbmRSb2xlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlOiBleHRlbmRFbmNvZGUoYnVpbGRMZWdlbmRFbmNvZGUoXywgc3BlYywgY29uZmlnKSwgbGVnZW5kRW5jb2RlLCBTa2lwKSxcbiAgICBtYXJrczogY2hpbGRyZW4sXG4gICAgYXJpYTogXygnYXJpYScpLFxuICAgIGRlc2NyaXB0aW9uOiBfKCdkZXNjcmlwdGlvbicpLFxuICAgIHppbmRleDogXygnemluZGV4JyksXG4gICAgbmFtZSxcbiAgICBpbnRlcmFjdGl2ZSxcbiAgICBzdHlsZVxuICB9KSwgc2NvcGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRUeXBlKHNwZWMsIHNjYWxlVHlwZSkge1xuICBsZXQgdHlwZSA9IHNwZWMudHlwZSB8fCBTeW1ib2xzO1xuXG4gIGlmICghc3BlYy50eXBlICYmIHNjYWxlQ291bnQoc3BlYykgPT09IDEgJiYgKHNwZWMuZmlsbCB8fCBzcGVjLnN0cm9rZSkpIHtcbiAgICB0eXBlID0gaXNDb250aW51b3VzKHNjYWxlVHlwZSkgPyBHcmFkaWVudCA6IGlzRGlzY3JldGl6aW5nKHNjYWxlVHlwZSkgPyBEaXNjcmV0ZSA6IFN5bWJvbHM7XG4gIH1cblxuICByZXR1cm4gdHlwZSAhPT0gR3JhZGllbnQgPyB0eXBlIDogaXNEaXNjcmV0aXppbmcoc2NhbGVUeXBlKSA/IERpc2NyZXRlIDogR3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ291bnQoc3BlYykge1xuICByZXR1cm4gTGVnZW5kU2NhbGVzLnJlZHVjZSgoY291bnQsIHR5cGUpID0+IGNvdW50ICsgKHNwZWNbdHlwZV0gPyAxIDogMCksIDApO1xufVxuXG5mdW5jdGlvbiBidWlsZExlZ2VuZEVuY29kZShfLCBzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSxcbiAgICBwYWRkaW5nOiBfKCdwYWRkaW5nJyksXG4gICAgdGl0bGVQYWRkaW5nOiBfKCd0aXRsZVBhZGRpbmcnKSxcbiAgICBjb3JuZXJSYWRpdXM6IF8oJ2Nvcm5lclJhZGl1cycpLFxuICAgIGZpbGw6IF8oJ2ZpbGxDb2xvcicpLFxuICAgIHN0cm9rZTogXygnc3Ryb2tlQ29sb3InKSxcbiAgICBzdHJva2VXaWR0aDogY29uZmlnLnN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2g6IGNvbmZpZy5zdHJva2VEYXNoLFxuICAgIHg6IF8oJ2xlZ2VuZFgnKSxcbiAgICB5OiBfKCdsZWdlbmRZJyksXG4gICAgLy8gYWNjZXNzaWJpbGl0eSBzdXBwb3J0XG4gICAgZm9ybWF0OiBzcGVjLmZvcm1hdCxcbiAgICBmb3JtYXRUeXBlOiBzcGVjLmZvcm1hdFR5cGVcbiAgfSk7XG4gIHJldHVybiBlbmNvZGU7XG59XG5cbmZ1bmN0aW9uIHNpemVFeHByZXNzaW9uKHNwZWMsIHNjb3BlLCBtYXJrcykge1xuICBjb25zdCBzaXplID0gZGVyZWYoZ2V0Q2hhbm5lbCgnc2l6ZScsIHNwZWMsIG1hcmtzKSksXG4gICAgICAgIHN0cm9rZVdpZHRoID0gZGVyZWYoZ2V0Q2hhbm5lbCgnc3Ryb2tlV2lkdGgnLCBzcGVjLCBtYXJrcykpLFxuICAgICAgICBmb250U2l6ZSA9IGRlcmVmKGdldEZvbnRTaXplKG1hcmtzWzFdLmVuY29kZSwgc2NvcGUsIEd1aWRlTGFiZWxTdHlsZSkpO1xuICByZXR1cm4gcGFyc2VFeHByZXNzaW9uKGBtYXgoY2VpbChzcXJ0KCR7c2l6ZX0pKyR7c3Ryb2tlV2lkdGh9KSwke2ZvbnRTaXplfSlgLCBzY29wZSk7XG59XG5cbmZ1bmN0aW9uIGdldENoYW5uZWwobmFtZSwgc3BlYywgbWFya3MpIHtcbiAgcmV0dXJuIHNwZWNbbmFtZV0gPyBgc2NhbGUoXCIke3NwZWNbbmFtZV19XCIsZGF0dW0pYCA6IGdldEVuY29kaW5nKG5hbWUsIG1hcmtzWzBdLmVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGdldEZvbnRTaXplKGVuY29kZSwgc2NvcGUsIHN0eWxlKSB7XG4gIHJldHVybiBnZXRFbmNvZGluZygnZm9udFNpemUnLCBlbmNvZGUpIHx8IGdldFN0eWxlKCdmb250U2l6ZScsIHNjb3BlLCBzdHlsZSk7XG59XG5cbmNvbnN0IGFuZ2xlRXhwciA9IGBpdGVtLm9yaWVudD09PVwiJHtMZWZ0fVwiPy05MDppdGVtLm9yaWVudD09PVwiJHtSaWdodH1cIj85MDowYDtcbmZ1bmN0aW9uIHBhcnNlVGl0bGUgKHNwZWMsIHNjb3BlKSB7XG4gIHNwZWMgPSBpc1N0cmluZyhzcGVjKSA/IHtcbiAgICB0ZXh0OiBzcGVjXG4gIH0gOiBzcGVjO1xuXG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgc2NvcGUuY29uZmlnLnRpdGxlKSxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIHVzZXJFbmNvZGUgPSBlbmNvZGUuZ3JvdXAgfHwge30sXG4gICAgICAgIG5hbWUgPSB1c2VyRW5jb2RlLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBpbnRlcmFjdGl2ZSA9IHVzZXJFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgICAgIHN0eWxlID0gdXNlckVuY29kZS5zdHlsZSxcbiAgICAgICAgY2hpbGRyZW4gPSBbXTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGdyb3VwIHRpdGxlXG5cblxuICBjb25zdCBkYXR1bSA9IHt9LFxuICAgICAgICBkYXRhUmVmID0gcmVmKHNjb3BlLmFkZChDb2xsZWN0KG51bGwsIFtkYXR1bV0pKSk7IC8vIGluY2x1ZGUgdGl0bGUgdGV4dFxuXG4gIGNoaWxkcmVuLnB1c2goYnVpbGRUaXRsZShzcGVjLCBfLCB0aXRsZUVuY29kZShzcGVjKSwgZGF0YVJlZikpOyAvLyBpbmNsdWRlIHN1YnRpdGxlIHRleHRcblxuICBpZiAoc3BlYy5zdWJ0aXRsZSkge1xuICAgIGNoaWxkcmVuLnB1c2goYnVpbGRTdWJUaXRsZShzcGVjLCBfLCBlbmNvZGUuc3VidGl0bGUsIGRhdGFSZWYpKTtcbiAgfSAvLyBwYXJzZSB0aXRsZSBzcGVjaWZpY2F0aW9uXG5cblxuICByZXR1cm4gcGFyc2VNYXJrKGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFRpdGxlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZ3JvdXBFbmNvZGUoXywgdXNlckVuY29kZSksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn0gLy8gcHJvdmlkZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGl0bGUgY3VzdG9tIGVuY29kZTtcbi8vIHRoZSB0b3AtbGV2ZWwgZW5jb2RlIGJsb2NrIGhhcyBiZWVuICpkZXByZWNhdGVkKi5cblxuZnVuY3Rpb24gdGl0bGVFbmNvZGUoc3BlYykge1xuICBjb25zdCBlbmNvZGUgPSBzcGVjLmVuY29kZTtcbiAgcmV0dXJuIGVuY29kZSAmJiBlbmNvZGUudGl0bGUgfHwgZXh0ZW5kKHtcbiAgICBuYW1lOiBzcGVjLm5hbWUsXG4gICAgaW50ZXJhY3RpdmU6IHNwZWMuaW50ZXJhY3RpdmUsXG4gICAgc3R5bGU6IHNwZWMuc3R5bGVcbiAgfSwgZW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBFbmNvZGUoXywgdXNlckVuY29kZSkge1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHt9LFxuICAgIHVwZGF0ZToge31cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgb3JpZW50OiBfKCdvcmllbnQnKSxcbiAgICBhbmNob3I6IF8oJ2FuY2hvcicpLFxuICAgIGFsaWduOiB7XG4gICAgICBzaWduYWw6IGFsaWduRXhwciQxXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgc2lnbmFsOiBhbmdsZUV4cHJcbiAgICB9LFxuICAgIGxpbWl0OiBfKCdsaW1pdCcpLFxuICAgIGZyYW1lOiBfKCdmcmFtZScpLFxuICAgIG9mZnNldDogXygnb2Zmc2V0JykgfHwgMCxcbiAgICBwYWRkaW5nOiBfKCdzdWJ0aXRsZVBhZGRpbmcnKVxuICB9KTtcbiAgcmV0dXJuIGV4dGVuZEVuY29kZShlbmNvZGUsIHVzZXJFbmNvZGUsIFNraXApO1xufVxuXG5mdW5jdGlvbiBidWlsZFRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICB2YWx1ZTogMFxuICB9LFxuICAgICAgICB0ZXh0ID0gc3BlYy50ZXh0LFxuICAgICAgICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgb3BhY2l0eToge1xuICAgICAgICB2YWx1ZTogMVxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgdGV4dDogdGV4dCxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmFsaWduJ1xuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbmdsZSdcbiAgICB9LFxuICAgIGxpbWl0OiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAubGltaXQnXG4gICAgfSxcbiAgICBiYXNlbGluZTogJ3RvcCcsXG4gICAgZHg6IF8oJ2R4JyksXG4gICAgZHk6IF8oJ2R5JyksXG4gICAgZmlsbDogXygnY29sb3InKSxcbiAgICBmb250OiBfKCdmb250JyksXG4gICAgZm9udFNpemU6IF8oJ2ZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCdmb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdmb250V2VpZ2h0JyksXG4gICAgbGluZUhlaWdodDogXygnbGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyB1cGRhdGVcbiAgICBhbGlnbjogXygnYWxpZ24nKSxcbiAgICBhbmdsZTogXygnYW5nbGUnKSxcbiAgICBiYXNlbGluZTogXygnYmFzZWxpbmUnKVxuICB9KTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogVGl0bGVUZXh0Um9sZSxcbiAgICBzdHlsZTogR3JvdXBUaXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBidWlsZFN1YlRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICB2YWx1ZTogMFxuICB9LFxuICAgICAgICB0ZXh0ID0gc3BlYy5zdWJ0aXRsZSxcbiAgICAgICAgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHtcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgdmFsdWU6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHRleHQ6IHRleHQsXG4gICAgYWxpZ246IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbGlnbidcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAuYW5nbGUnXG4gICAgfSxcbiAgICBsaW1pdDoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmxpbWl0J1xuICAgIH0sXG4gICAgYmFzZWxpbmU6ICd0b3AnLFxuICAgIGR4OiBfKCdkeCcpLFxuICAgIGR5OiBfKCdkeScpLFxuICAgIGZpbGw6IF8oJ3N1YnRpdGxlQ29sb3InKSxcbiAgICBmb250OiBfKCdzdWJ0aXRsZUZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnc3VidGl0bGVGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnc3VidGl0bGVGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdzdWJ0aXRsZUZvbnRXZWlnaHQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCdzdWJ0aXRsZUxpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgYWxpZ246IF8oJ2FsaWduJyksXG4gICAgYW5nbGU6IF8oJ2FuZ2xlJyksXG4gICAgYmFzZWxpbmU6IF8oJ2Jhc2VsaW5lJylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IFRpdGxlU3VidGl0bGVSb2xlLFxuICAgIHN0eWxlOiBHcm91cFN1YnRpdGxlU3R5bGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0YShkYXRhLCBzY29wZSkge1xuICBjb25zdCB0cmFuc2Zvcm1zID0gW107XG5cbiAgaWYgKGRhdGEudHJhbnNmb3JtKSB7XG4gICAgZGF0YS50cmFuc2Zvcm0uZm9yRWFjaCh0eCA9PiB7XG4gICAgICB0cmFuc2Zvcm1zLnB1c2gocGFyc2VUcmFuc2Zvcm0odHgsIHNjb3BlKSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoZGF0YS5vbikge1xuICAgIGRhdGEub24uZm9yRWFjaChvbiA9PiB7XG4gICAgICBwYXJzZVRyaWdnZXIob24sIHNjb3BlLCBkYXRhLm5hbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgc2NvcGUuYWRkRGF0YVBpcGVsaW5lKGRhdGEubmFtZSwgYW5hbHl6ZShkYXRhLCBzY29wZSwgdHJhbnNmb3JtcykpO1xufVxuLyoqXG4gKiBBbmFseXplIGEgZGF0YSBwaXBlbGluZSwgYWRkIG5lZWRlZCBvcGVyYXRvcnMuXG4gKi9cblxuZnVuY3Rpb24gYW5hbHl6ZShkYXRhLCBzY29wZSwgb3BzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuICBsZXQgc291cmNlID0gbnVsbCxcbiAgICAgIG1vZGlmeSA9IGZhbHNlLFxuICAgICAgZ2VuZXJhdGUgPSBmYWxzZSxcbiAgICAgIHVwc3RyZWFtLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgbTtcblxuICBpZiAoZGF0YS52YWx1ZXMpIHtcbiAgICAvLyBoYXJkLXdpcmVkIGlucHV0IGRhdGEgc2V0XG4gICAgaWYgKGlzU2lnbmFsKGRhdGEudmFsdWVzKSB8fCBoYXNTaWduYWwoZGF0YS5mb3JtYXQpKSB7XG4gICAgICAvLyBpZiBlaXRoZXIgdmFsdWVzIGlzIHNpZ25hbCBvciBmb3JtYXQgaGFzIHNpZ25hbCwgdXNlIGR5bmFtaWMgbG9hZGVyXG4gICAgICBvdXRwdXQucHVzaChsb2FkKHNjb3BlLCBkYXRhKSk7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIGluZ2VzdCB1cG9uIGRhdGFmbG93IGluaXRcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3Qoe1xuICAgICAgICAkaW5nZXN0OiBkYXRhLnZhbHVlcyxcbiAgICAgICAgJGZvcm1hdDogZGF0YS5mb3JtYXRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YS51cmwpIHtcbiAgICAvLyBsb2FkIGRhdGEgZnJvbSBleHRlcm5hbCBzb3VyY2VcbiAgICBpZiAoaGFzU2lnbmFsKGRhdGEudXJsKSB8fCBoYXNTaWduYWwoZGF0YS5mb3JtYXQpKSB7XG4gICAgICAvLyBpZiBlaXRoZXIgdXJsIG9yIGZvcm1hdCBoYXMgc2lnbmFsLCB1c2UgZHluYW1pYyBsb2FkZXJcbiAgICAgIG91dHB1dC5wdXNoKGxvYWQoc2NvcGUsIGRhdGEpKTtcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3QoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSwgcmVxdWVzdCBsb2FkIHVwb24gZGF0YWZsb3cgaW5pdFxuICAgICAgb3V0cHV0LnB1c2goc291cmNlID0gY29sbGVjdCh7XG4gICAgICAgICRyZXF1ZXN0OiBkYXRhLnVybCxcbiAgICAgICAgJGZvcm1hdDogZGF0YS5mb3JtYXRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YS5zb3VyY2UpIHtcbiAgICAvLyBkZXJpdmVzIGZyb20gb25lIG9yIG1vcmUgb3RoZXIgZGF0YSBzZXRzXG4gICAgc291cmNlID0gdXBzdHJlYW0gPSBhcnJheShkYXRhLnNvdXJjZSkubWFwKGQgPT4gcmVmKHNjb3BlLmdldERhdGEoZCkub3V0cHV0KSk7XG4gICAgb3V0cHV0LnB1c2gobnVsbCk7IC8vIHBvcHVsYXRlIGxhdGVyXG4gIH0gLy8gc2NhbiBkYXRhIHRyYW5zZm9ybXMsIGFkZCBjb2xsZWN0b3JzIGFzIG5lZWRlZFxuXG5cbiAgZm9yIChpID0gMCwgbiA9IG9wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB0ID0gb3BzW2ldO1xuICAgIG0gPSB0Lm1ldGFkYXRhO1xuXG4gICAgaWYgKCFzb3VyY2UgJiYgIW0uc291cmNlKSB7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKHQpO1xuICAgIGlmIChtLmdlbmVyYXRlcykgZ2VuZXJhdGUgPSB0cnVlO1xuICAgIGlmIChtLm1vZGlmaWVzICYmICFnZW5lcmF0ZSkgbW9kaWZ5ID0gdHJ1ZTtcbiAgICBpZiAobS5zb3VyY2UpIHNvdXJjZSA9IHQ7ZWxzZSBpZiAobS5jaGFuZ2VzKSBzb3VyY2UgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVwc3RyZWFtKSB7XG4gICAgbiA9IHVwc3RyZWFtLmxlbmd0aCAtIDE7XG4gICAgb3V0cHV0WzBdID0gUmVsYXkoe1xuICAgICAgZGVyaXZlOiBtb2RpZnksXG4gICAgICBwdWxzZTogbiA/IHVwc3RyZWFtIDogdXBzdHJlYW1bMF1cbiAgICB9KTtcblxuICAgIGlmIChtb2RpZnkgfHwgbikge1xuICAgICAgLy8gY29sbGVjdCBkZXJpdmVkIGFuZCBtdWx0aS1wdWxzZSB0dXBsZXNcbiAgICAgIG91dHB1dC5zcGxpY2UoMSwgMCwgY29sbGVjdCgpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNvdXJjZSkgb3V0cHV0LnB1c2goY29sbGVjdCgpKTtcbiAgb3V0cHV0LnB1c2goU2lldmUoe30pKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gY29sbGVjdCh2YWx1ZXMpIHtcbiAgY29uc3QgcyA9IENvbGxlY3Qoe30sIHZhbHVlcyk7XG4gIHMubWV0YWRhdGEgPSB7XG4gICAgc291cmNlOiB0cnVlXG4gIH07XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBsb2FkKHNjb3BlLCBkYXRhKSB7XG4gIHJldHVybiBMb2FkKHtcbiAgICB1cmw6IGRhdGEudXJsID8gc2NvcGUucHJvcGVydHkoZGF0YS51cmwpIDogdW5kZWZpbmVkLFxuICAgIGFzeW5jOiBkYXRhLmFzeW5jID8gc2NvcGUucHJvcGVydHkoZGF0YS5hc3luYykgOiB1bmRlZmluZWQsXG4gICAgdmFsdWVzOiBkYXRhLnZhbHVlcyA/IHNjb3BlLnByb3BlcnR5KGRhdGEudmFsdWVzKSA6IHVuZGVmaW5lZCxcbiAgICBmb3JtYXQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KGRhdGEuZm9ybWF0KVxuICB9KTtcbn1cblxuY29uc3QgaXNYID0gb3JpZW50ID0+IG9yaWVudCA9PT0gQm90dG9tIHx8IG9yaWVudCA9PT0gVG9wOyAvLyBnZXQgc2lnbiBjb2VmZmljaWVudCBiYXNlZCBvbiBheGlzIG9yaWVudFxuXG5cbmNvbnN0IGdldFNpZ24gPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZMZWZ0VG9wRXhwcihvcmllbnQuc2lnbmFsLCBhLCBiKSA6IG9yaWVudCA9PT0gTGVmdCB8fCBvcmllbnQgPT09IFRvcCA/IGEgOiBiOyAvLyBjb25kaXRpb24gb24gYXhpcyB4LWRpcmVjdGlvblxuXG5jb25zdCBpZlggPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZYRW5jKG9yaWVudC5zaWduYWwsIGEsIGIpIDogaXNYKG9yaWVudCkgPyBhIDogYjsgLy8gY29uZGl0aW9uIG9uIGF4aXMgeS1kaXJlY3Rpb25cblxuY29uc3QgaWZZID0gKG9yaWVudCwgYSwgYikgPT4gaXNTaWduYWwob3JpZW50KSA/IGlmWUVuYyhvcmllbnQuc2lnbmFsLCBhLCBiKSA6IGlzWChvcmllbnQpID8gYiA6IGE7XG5jb25zdCBpZlRvcCA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZlRvcEV4cHIob3JpZW50LnNpZ25hbCwgYSwgYikgOiBvcmllbnQgPT09IFRvcCA/IHtcbiAgdmFsdWU6IGFcbn0gOiB7XG4gIHZhbHVlOiBiXG59O1xuY29uc3QgaWZSaWdodCA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZlJpZ2h0RXhwcihvcmllbnQuc2lnbmFsLCBhLCBiKSA6IG9yaWVudCA9PT0gUmlnaHQgPyB7XG4gIHZhbHVlOiBhXG59IDoge1xuICB2YWx1ZTogYlxufTtcblxuY29uc3QgaWZYRW5jID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRW5jKGAkeyRvcmllbnR9ID09PSAnJHtUb3B9JyB8fCAkeyRvcmllbnR9ID09PSAnJHtCb3R0b219J2AsIGEsIGIpO1xuXG5jb25zdCBpZllFbmMgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFbmMoYCR7JG9yaWVudH0gIT09ICcke1RvcH0nICYmICR7JG9yaWVudH0gIT09ICcke0JvdHRvbX0nYCwgYSwgYik7XG5cbmNvbnN0IGlmTGVmdFRvcEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtMZWZ0fScgfHwgJHskb3JpZW50fSA9PT0gJyR7VG9wfSdgLCBhLCBiKTtcblxuY29uc3QgaWZUb3BFeHByID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRXhwcihgJHskb3JpZW50fSA9PT0gJyR7VG9wfSdgLCBhLCBiKTtcblxuY29uc3QgaWZSaWdodEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtSaWdodH0nYCwgYSwgYik7XG5cbmNvbnN0IGlmRW5jID0gKHRlc3QsIGEsIGIpID0+IHtcbiAgLy8gZW5zdXJlIGlucHV0cyBhcmUgZW5jb2RlciBvYmplY3RzIChvciBudWxsKVxuICBhID0gYSAhPSBudWxsID8gZW5jb2RlcihhKSA6IGE7XG4gIGIgPSBiICE9IG51bGwgPyBlbmNvZGVyKGIpIDogYjtcblxuICBpZiAoaXNTaW1wbGUoYSkgJiYgaXNTaW1wbGUoYikpIHtcbiAgICAvLyBpZiBwb3NzaWJsZSBnZW5lcmF0ZSBzaW1wbGUgc2lnbmFsIGV4cHJlc3Npb25cbiAgICBhID0gYSA/IGEuc2lnbmFsIHx8IHN0cmluZ1ZhbHVlKGEudmFsdWUpIDogbnVsbDtcbiAgICBiID0gYiA/IGIuc2lnbmFsIHx8IHN0cmluZ1ZhbHVlKGIudmFsdWUpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgc2lnbmFsOiBgJHt0ZXN0fSA/ICgke2F9KSA6ICgke2J9KWBcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIG90aGVyd2lzZSBnZW5lcmF0ZSBydWxlIHNldFxuICAgIHJldHVybiBbZXh0ZW5kKHtcbiAgICAgIHRlc3RcbiAgICB9LCBhKV0uY29uY2F0KGIgfHwgW10pO1xuICB9XG59O1xuXG5jb25zdCBpc1NpbXBsZSA9IGVuYyA9PiBlbmMgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlbmMpLmxlbmd0aCA9PT0gMTtcblxuY29uc3QgaWZFeHByID0gKHRlc3QsIGEsIGIpID0+ICh7XG4gIHNpZ25hbDogYCR7dGVzdH0gPyAoJHt0b0V4cHIoYSl9KSA6ICgke3RvRXhwcihiKX0pYFxufSk7XG5cbmNvbnN0IGlmT3JpZW50ID0gKCRvcmllbnQsIHQsIGIsIGwsIHIpID0+ICh7XG4gIHNpZ25hbDogKGwgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtMZWZ0fScgPyAoJHt0b0V4cHIobCl9KSA6IGAgOiAnJykgKyAoYiAhPSBudWxsID8gYCR7JG9yaWVudH0gPT09ICcke0JvdHRvbX0nID8gKCR7dG9FeHByKGIpfSkgOiBgIDogJycpICsgKHIgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtSaWdodH0nID8gKCR7dG9FeHByKHIpfSkgOiBgIDogJycpICsgKHQgIT0gbnVsbCA/IGAkeyRvcmllbnR9ID09PSAnJHtUb3B9JyA/ICgke3RvRXhwcih0KX0pIDogYCA6ICcnKSArICcobnVsbCknXG59KTtcblxuY29uc3QgdG9FeHByID0gdiA9PiBpc1NpZ25hbCh2KSA/IHYuc2lnbmFsIDogdiA9PSBudWxsID8gbnVsbCA6IHN0cmluZ1ZhbHVlKHYpO1xuXG5jb25zdCBtdWx0ID0gKHNpZ24sIHZhbHVlKSA9PiB2YWx1ZSA9PT0gMCA/IDAgOiBpc1NpZ25hbChzaWduKSA/IHtcbiAgc2lnbmFsOiBgKCR7c2lnbi5zaWduYWx9KSAqICR7dmFsdWV9YFxufSA6IHtcbiAgdmFsdWU6IHNpZ24gKiB2YWx1ZVxufTtcbmNvbnN0IHBhdGNoID0gKHZhbHVlLCBiYXNlKSA9PiB7XG4gIGNvbnN0IHMgPSB2YWx1ZS5zaWduYWw7XG4gIHJldHVybiBzICYmIHMuZW5kc1dpdGgoJyhudWxsKScpID8ge1xuICAgIHNpZ25hbDogcy5zbGljZSgwLCAtNikgKyBiYXNlLnNpZ25hbFxuICB9IDogdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBmYWxsYmFjayhwcm9wLCBjb25maWcsIGF4aXNDb25maWcsIHN0eWxlKSB7XG4gIGxldCBzdHlsZVByb3A7XG5cbiAgaWYgKGNvbmZpZyAmJiBoYXNPd25Qcm9wZXJ0eShjb25maWcsIHByb3ApKSB7XG4gICAgcmV0dXJuIGNvbmZpZ1twcm9wXTtcbiAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShheGlzQ29uZmlnLCBwcm9wKSkge1xuICAgIHJldHVybiBheGlzQ29uZmlnW3Byb3BdO1xuICB9IGVsc2UgaWYgKHByb3Auc3RhcnRzV2l0aCgndGl0bGUnKSkge1xuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAndGl0bGVDb2xvcic6XG4gICAgICAgIHN0eWxlUHJvcCA9ICdmaWxsJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RpdGxlRm9udCc6XG4gICAgICBjYXNlICd0aXRsZUZvbnRTaXplJzpcbiAgICAgIGNhc2UgJ3RpdGxlRm9udFdlaWdodCc6XG4gICAgICAgIHN0eWxlUHJvcCA9IHByb3BbNV0udG9Mb3dlckNhc2UoKSArIHByb3Auc2xpY2UoNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlW0d1aWRlVGl0bGVTdHlsZV1bc3R5bGVQcm9wXTtcbiAgfSBlbHNlIGlmIChwcm9wLnN0YXJ0c1dpdGgoJ2xhYmVsJykpIHtcbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgJ2xhYmVsQ29sb3InOlxuICAgICAgICBzdHlsZVByb3AgPSAnZmlsbCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsYWJlbEZvbnQnOlxuICAgICAgY2FzZSAnbGFiZWxGb250U2l6ZSc6XG4gICAgICAgIHN0eWxlUHJvcCA9IHByb3BbNV0udG9Mb3dlckNhc2UoKSArIHByb3Auc2xpY2UoNik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlW0d1aWRlTGFiZWxTdHlsZV1bc3R5bGVQcm9wXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBrZXlzKG9iamVjdHMpIHtcbiAgY29uc3QgbWFwID0ge307XG5cbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGlmICghb2JqKSBjb250aW51ZTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikgbWFwW2tleV0gPSAxO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59XG5cbmZ1bmN0aW9uIGF4aXNDb25maWcgKHNwZWMsIHNjb3BlKSB7XG4gIHZhciBjb25maWcgPSBzY29wZS5jb25maWcsXG4gICAgICBzdHlsZSA9IGNvbmZpZy5zdHlsZSxcbiAgICAgIGF4aXMgPSBjb25maWcuYXhpcyxcbiAgICAgIGJhbmQgPSBzY29wZS5zY2FsZVR5cGUoc3BlYy5zY2FsZSkgPT09ICdiYW5kJyAmJiBjb25maWcuYXhpc0JhbmQsXG4gICAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICAgIHh5LFxuICAgICAgb3IsXG4gICAgICBrZXk7XG5cbiAgaWYgKGlzU2lnbmFsKG9yaWVudCkpIHtcbiAgICBjb25zdCB4eUtleXMgPSBrZXlzKFtjb25maWcuYXhpc1gsIGNvbmZpZy5heGlzWV0pLFxuICAgICAgICAgIG9yaWVudEtleXMgPSBrZXlzKFtjb25maWcuYXhpc1RvcCwgY29uZmlnLmF4aXNCb3R0b20sIGNvbmZpZy5heGlzTGVmdCwgY29uZmlnLmF4aXNSaWdodF0pO1xuICAgIHh5ID0ge307XG5cbiAgICBmb3IgKGtleSBvZiB4eUtleXMpIHtcbiAgICAgIHh5W2tleV0gPSBpZlgob3JpZW50LCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzWCwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzWSwgYXhpcywgc3R5bGUpKTtcbiAgICB9XG5cbiAgICBvciA9IHt9O1xuXG4gICAgZm9yIChrZXkgb2Ygb3JpZW50S2V5cykge1xuICAgICAgb3Jba2V5XSA9IGlmT3JpZW50KG9yaWVudC5zaWduYWwsIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNUb3AsIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc0JvdHRvbSwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzTGVmdCwgYXhpcywgc3R5bGUpLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzUmlnaHQsIGF4aXMsIHN0eWxlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHh5ID0gb3JpZW50ID09PSBUb3AgfHwgb3JpZW50ID09PSBCb3R0b20gPyBjb25maWcuYXhpc1ggOiBjb25maWcuYXhpc1k7XG4gICAgb3IgPSBjb25maWdbJ2F4aXMnICsgb3JpZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBvcmllbnQuc2xpY2UoMSldO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0geHkgfHwgb3IgfHwgYmFuZCA/IGV4dGVuZCh7fSwgYXhpcywgeHksIG9yLCBiYW5kKSA6IGF4aXM7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGF4aXNEb21haW4gKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50O1xuXG4gIGxldCBlbnRlciwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygnZG9tYWluQ29sb3InKSxcbiAgICBzdHJva2VDYXA6IF8oJ2RvbWFpbkNhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ2RvbWFpbkRhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCdkb21haW5EYXNoT2Zmc2V0JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2RvbWFpbldpZHRoJyksXG4gICAgc3Ryb2tlT3BhY2l0eTogXygnZG9tYWluT3BhY2l0eScpXG4gIH0pO1xuICBjb25zdCBwb3MwID0gcG9zaXRpb24oc3BlYywgMCk7XG4gIGNvbnN0IHBvczEgPSBwb3NpdGlvbihzcGVjLCAxKTtcbiAgZW50ZXIueCA9IHVwZGF0ZS54ID0gaWZYKG9yaWVudCwgcG9zMCwgemVybyk7XG4gIGVudGVyLngyID0gdXBkYXRlLngyID0gaWZYKG9yaWVudCwgcG9zMSk7XG4gIGVudGVyLnkgPSB1cGRhdGUueSA9IGlmWShvcmllbnQsIHBvczAsIHplcm8pO1xuICBlbnRlci55MiA9IHVwZGF0ZS55MiA9IGlmWShvcmllbnQsIHBvczEpO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSdWxlTWFyayxcbiAgICByb2xlOiBBeGlzRG9tYWluUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb24oc3BlYywgcG9zKSB7XG4gIHJldHVybiB7XG4gICAgc2NhbGU6IHNwZWMuc2NhbGUsXG4gICAgcmFuZ2U6IHBvc1xuICB9O1xufVxuXG5mdW5jdGlvbiBheGlzR3JpZCAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICAgIHZzY2FsZSA9IHNwZWMuZ3JpZFNjYWxlLFxuICAgICAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIDEsIC0xKSxcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUoc3BlYy5vZmZzZXQsIHNpZ24pO1xuXG4gIGxldCBlbnRlciwgZXhpdCwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IGV4aXQgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBzdHJva2U6IF8oJ2dyaWRDb2xvcicpLFxuICAgIHN0cm9rZUNhcDogXygnZ3JpZENhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ2dyaWREYXNoJyksXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXygnZ3JpZERhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VPcGFjaXR5OiBfKCdncmlkT3BhY2l0eScpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmlkV2lkdGgnKVxuICB9KTtcbiAgY29uc3QgdGlja1BvcyA9IHtcbiAgICBzY2FsZTogc3BlYy5zY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogYmFuZC5iYW5kLFxuICAgIGV4dHJhOiBiYW5kLmV4dHJhLFxuICAgIG9mZnNldDogYmFuZC5vZmZzZXQsXG4gICAgcm91bmQ6IF8oJ3RpY2tSb3VuZCcpXG4gIH07XG4gIGNvbnN0IHN6ID0gaWZYKG9yaWVudCwge1xuICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgfSwge1xuICAgIHNpZ25hbDogJ3dpZHRoJ1xuICB9KTtcbiAgY29uc3QgZ3JpZFN0YXJ0ID0gdnNjYWxlID8ge1xuICAgIHNjYWxlOiB2c2NhbGUsXG4gICAgcmFuZ2U6IDAsXG4gICAgbXVsdDogc2lnbixcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9IDoge1xuICAgIHZhbHVlOiAwLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIGNvbnN0IGdyaWRFbmQgPSB2c2NhbGUgPyB7XG4gICAgc2NhbGU6IHZzY2FsZSxcbiAgICByYW5nZTogMSxcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0gOiBleHRlbmQoc3osIHtcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0pO1xuICBlbnRlci54ID0gdXBkYXRlLnggPSBpZlgob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci55ID0gdXBkYXRlLnkgPSBpZlkob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci54MiA9IHVwZGF0ZS54MiA9IGlmWShvcmllbnQsIGdyaWRFbmQpO1xuICBlbnRlci55MiA9IHVwZGF0ZS55MiA9IGlmWChvcmllbnQsIGdyaWRFbmQpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgZXhpdC55ID0gaWZZKG9yaWVudCwgdGlja1Bvcyk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJ1bGVNYXJrLFxuICAgIHJvbGU6IEF4aXNHcmlkUm9sZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBvZmZzZXRWYWx1ZShvZmZzZXQsIHNpZ24pIHtcbiAgaWYgKHNpZ24gPT09IDEpIDsgZWxzZSBpZiAoIWlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBpc1NpZ25hbChzaWduKSA/IHtcbiAgICAgIHNpZ25hbDogYCgke3NpZ24uc2lnbmFsfSkgKiAoJHtvZmZzZXQgfHwgMH0pYFxuICAgIH0gOiBzaWduICogKG9mZnNldCB8fCAwKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW50cnkgPSBvZmZzZXQgPSBleHRlbmQoe30sIG9mZnNldCk7XG5cbiAgICB3aGlsZSAoZW50cnkubXVsdCAhPSBudWxsKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KGVudHJ5Lm11bHQpKSB7XG4gICAgICAgIGVudHJ5Lm11bHQgPSBpc1NpZ25hbChzaWduKSAvLyBubyBvZmZzZXQgaWYgc2lnbiA9PT0gMVxuICAgICAgICA/IHtcbiAgICAgICAgICBzaWduYWw6IGAoJHtlbnRyeS5tdWx0fSkgKiAoJHtzaWduLnNpZ25hbH0pYFxuICAgICAgICB9IDogZW50cnkubXVsdCAqIHNpZ247XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnRyeSA9IGVudHJ5Lm11bHQgPSBleHRlbmQoe30sIGVudHJ5Lm11bHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVudHJ5Lm11bHQgPSBzaWduO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gYXhpc1RpY2tzIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYsIHNpemUsIGJhbmQpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgICAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAtMSwgMSk7XG5cbiAgbGV0IGVudGVyLCBleGl0LCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZVxuICAgIH0sXG4gICAgZXhpdDogZXhpdCA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygndGlja0NvbG9yJyksXG4gICAgc3Ryb2tlQ2FwOiBfKCd0aWNrQ2FwJyksXG4gICAgc3Ryb2tlRGFzaDogXygndGlja0Rhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCd0aWNrRGFzaE9mZnNldCcpLFxuICAgIHN0cm9rZU9wYWNpdHk6IF8oJ3RpY2tPcGFjaXR5JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ3RpY2tXaWR0aCcpXG4gIH0pO1xuICBjb25zdCB0aWNrU2l6ZSA9IGVuY29kZXIoc2l6ZSk7XG4gIHRpY2tTaXplLm11bHQgPSBzaWduO1xuICBjb25zdCB0aWNrUG9zID0ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIGZpZWxkOiBWYWx1ZSxcbiAgICBiYW5kOiBiYW5kLmJhbmQsXG4gICAgZXh0cmE6IGJhbmQuZXh0cmEsXG4gICAgb2Zmc2V0OiBiYW5kLm9mZnNldCxcbiAgICByb3VuZDogXygndGlja1JvdW5kJylcbiAgfTtcbiAgdXBkYXRlLnkgPSBlbnRlci55ID0gaWZYKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS55MiA9IGVudGVyLnkyID0gaWZYKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgdXBkYXRlLnggPSBlbnRlci54ID0gaWZZKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS54MiA9IGVudGVyLngyID0gaWZZKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnkgPSBpZlkob3JpZW50LCB0aWNrUG9zKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogUnVsZU1hcmssXG4gICAgcm9sZTogQXhpc1RpY2tSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoRXhwcihzY2FsZSwgdGhyZXNob2xkLCBhLCBiLCBjKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiAnZmx1c2gocmFuZ2UoXCInICsgc2NhbGUgKyAnXCIpLCAnICsgJ3NjYWxlKFwiJyArIHNjYWxlICsgJ1wiLCBkYXR1bS52YWx1ZSksICcgKyB0aHJlc2hvbGQgKyAnLCcgKyBhICsgJywnICsgYiArICcsJyArIGMgKyAnKSdcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXhpc0xhYmVscyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBzaXplLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICAgICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgICAgIHNjYWxlID0gc3BlYy5zY2FsZSxcbiAgICAgICAgc2lnbiA9IGdldFNpZ24ob3JpZW50LCAtMSwgMSksXG4gICAgICAgIGZsdXNoID0gZGVyZWYoXygnbGFiZWxGbHVzaCcpKSxcbiAgICAgICAgZmx1c2hPZmZzZXQgPSBkZXJlZihfKCdsYWJlbEZsdXNoT2Zmc2V0JykpLFxuICAgICAgICBsYWJlbEFsaWduID0gXygnbGFiZWxBbGlnbicpLFxuICAgICAgICBsYWJlbEJhc2VsaW5lID0gXygnbGFiZWxCYXNlbGluZScpO1xuXG4gIGxldCBmbHVzaE9uID0gZmx1c2ggPT09IDAgfHwgISFmbHVzaCxcbiAgICAgIHVwZGF0ZTtcbiAgY29uc3QgdGlja1NpemUgPSBlbmNvZGVyKHNpemUpO1xuICB0aWNrU2l6ZS5tdWx0ID0gc2lnbjtcbiAgdGlja1NpemUub2Zmc2V0ID0gZW5jb2RlcihfKCdsYWJlbFBhZGRpbmcnKSB8fCAwKTtcbiAgdGlja1NpemUub2Zmc2V0Lm11bHQgPSBzaWduO1xuICBjb25zdCB0aWNrUG9zID0ge1xuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogMC41LFxuICAgIG9mZnNldDogZXh0ZW5kT2Zmc2V0KGJhbmQub2Zmc2V0LCBfKCdsYWJlbE9mZnNldCcpKVxuICB9O1xuICBjb25zdCBhbGlnbiA9IGlmWChvcmllbnQsIGZsdXNoT24gPyBmbHVzaEV4cHIoc2NhbGUsIGZsdXNoLCAnXCJsZWZ0XCInLCAnXCJyaWdodFwiJywgJ1wiY2VudGVyXCInKSA6IHtcbiAgICB2YWx1ZTogJ2NlbnRlcidcbiAgfSwgaWZSaWdodChvcmllbnQsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBiYXNlbGluZSA9IGlmWChvcmllbnQsIGlmVG9wKG9yaWVudCwgJ2JvdHRvbScsICd0b3AnKSwgZmx1c2hPbiA/IGZsdXNoRXhwcihzY2FsZSwgZmx1c2gsICdcInRvcFwiJywgJ1wiYm90dG9tXCInLCAnXCJtaWRkbGVcIicpIDoge1xuICAgIHZhbHVlOiAnbWlkZGxlJ1xuICB9KTtcbiAgY29uc3Qgb2Zmc2V0RXhwciA9IGZsdXNoRXhwcihzY2FsZSwgZmx1c2gsIGAtKCR7Zmx1c2hPZmZzZXR9KWAsIGZsdXNoT2Zmc2V0LCAwKTtcbiAgZmx1c2hPbiA9IGZsdXNoT24gJiYgZmx1c2hPZmZzZXQ7XG4gIGNvbnN0IGVudGVyID0ge1xuICAgIG9wYWNpdHk6IHplcm8sXG4gICAgeDogaWZYKG9yaWVudCwgdGlja1BvcywgdGlja1NpemUpLFxuICAgIHk6IGlmWShvcmllbnQsIHRpY2tQb3MsIHRpY2tTaXplKVxuICB9O1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyLFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgdGV4dDoge1xuICAgICAgICBmaWVsZDogTGFiZWxcbiAgICAgIH0sXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueSxcbiAgICAgIGFsaWduLFxuICAgICAgYmFzZWxpbmVcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICB4OiBlbnRlci54LFxuICAgICAgeTogZW50ZXIueVxuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZHg6ICFsYWJlbEFsaWduICYmIGZsdXNoT24gPyBpZlgob3JpZW50LCBvZmZzZXRFeHByKSA6IG51bGwsXG4gICAgZHk6ICFsYWJlbEJhc2VsaW5lICYmIGZsdXNoT24gPyBpZlkob3JpZW50LCBvZmZzZXRFeHByKSA6IG51bGxcbiAgfSk7XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGFuZ2xlOiBfKCdsYWJlbEFuZ2xlJyksXG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ2xhYmVsRm9udFdlaWdodCcpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBsaW1pdDogXygnbGFiZWxMaW1pdCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ2xhYmVsTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICBhbGlnbjogbGFiZWxBbGlnbixcbiAgICBiYXNlbGluZTogbGFiZWxCYXNlbGluZVxuICB9KTtcblxuICBjb25zdCBib3VuZCA9IF8oJ2xhYmVsQm91bmQnKTtcblxuICBsZXQgb3ZlcmxhcCA9IF8oJ2xhYmVsT3ZlcmxhcCcpOyAvLyBpZiBvdmVybGFwIG1ldGhvZCBvciBib3VuZCBkZWZpbmVkLCByZXF1ZXN0IGxhYmVsIG92ZXJsYXAgcmVtb3ZhbFxuXG5cbiAgb3ZlcmxhcCA9IG92ZXJsYXAgfHwgYm91bmQgPyB7XG4gICAgc2VwYXJhdGlvbjogXygnbGFiZWxTZXBhcmF0aW9uJyksXG4gICAgbWV0aG9kOiBvdmVybGFwLFxuICAgIG9yZGVyOiAnZGF0dW0uaW5kZXgnLFxuICAgIGJvdW5kOiBib3VuZCA/IHtcbiAgICAgIHNjYWxlLFxuICAgICAgb3JpZW50LFxuICAgICAgdG9sZXJhbmNlOiBib3VuZFxuICAgIH0gOiBudWxsXG4gIH0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHVwZGF0ZS5hbGlnbiAhPT0gYWxpZ24pIHtcbiAgICB1cGRhdGUuYWxpZ24gPSBwYXRjaCh1cGRhdGUuYWxpZ24sIGFsaWduKTtcbiAgfVxuXG4gIGlmICh1cGRhdGUuYmFzZWxpbmUgIT09IGJhc2VsaW5lKSB7XG4gICAgdXBkYXRlLmJhc2VsaW5lID0gcGF0Y2godXBkYXRlLmJhc2VsaW5lLCBiYXNlbGluZSk7XG4gIH1cblxuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBBeGlzTGFiZWxSb2xlLFxuICAgIHN0eWxlOiBHdWlkZUxhYmVsU3R5bGUsXG4gICAga2V5OiBWYWx1ZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZSxcbiAgICBvdmVybGFwXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBheGlzVGl0bGUgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZikge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIG9yaWVudCA9IHNwZWMub3JpZW50LFxuICAgICAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIC0xLCAxKTtcblxuICBsZXQgZW50ZXIsIHVwZGF0ZTtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICBhbmNob3I6IGVuY29kZXIoXygndGl0bGVBbmNob3InLCBudWxsKSksXG4gICAgICBhbGlnbjoge1xuICAgICAgICBzaWduYWw6IGFsaWduRXhwciQxXG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IGV4dGVuZCh7fSwgZW50ZXIsIHtcbiAgICAgIG9wYWNpdHk6IG9uZSxcbiAgICAgIHRleHQ6IGVuY29kZXIoc3BlYy50aXRsZSlcbiAgICB9KSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBjb25zdCB0aXRsZVBvcyA9IHtcbiAgICBzaWduYWw6IGBsZXJwKHJhbmdlKFwiJHtzcGVjLnNjYWxlfVwiKSwgJHthbmNob3JFeHByKDAsIDEsIDAuNSl9KWBcbiAgfTtcbiAgdXBkYXRlLnggPSBpZlgob3JpZW50LCB0aXRsZVBvcyk7XG4gIHVwZGF0ZS55ID0gaWZZKG9yaWVudCwgdGl0bGVQb3MpO1xuICBlbnRlci5hbmdsZSA9IGlmWChvcmllbnQsIHplcm8sIG11bHQoc2lnbiwgOTApKTtcbiAgZW50ZXIuYmFzZWxpbmUgPSBpZlgob3JpZW50LCBpZlRvcChvcmllbnQsIEJvdHRvbSwgVG9wKSwge1xuICAgIHZhbHVlOiBCb3R0b21cbiAgfSk7XG4gIHVwZGF0ZS5hbmdsZSA9IGVudGVyLmFuZ2xlO1xuICB1cGRhdGUuYmFzZWxpbmUgPSBlbnRlci5iYXNlbGluZTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZmlsbDogXygndGl0bGVDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCd0aXRsZU9wYWNpdHknKSxcbiAgICBmb250OiBfKCd0aXRsZUZvbnQnKSxcbiAgICBmb250U2l6ZTogXygndGl0bGVGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygndGl0bGVGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCd0aXRsZUZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogXygndGl0bGVMaW1pdCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ3RpdGxlTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyByZXF1aXJlIHVwZGF0ZVxuICAgIGFsaWduOiBfKCd0aXRsZUFsaWduJyksXG4gICAgYW5nbGU6IF8oJ3RpdGxlQW5nbGUnKSxcbiAgICBiYXNlbGluZTogXygndGl0bGVCYXNlbGluZScpXG4gIH0pO1xuICBhdXRvTGF5b3V0KF8sIG9yaWVudCwgZW5jb2RlLCB1c2VyRW5jb2RlKTtcbiAgZW5jb2RlLnVwZGF0ZS5hbGlnbiA9IHBhdGNoKGVuY29kZS51cGRhdGUuYWxpZ24sIGVudGVyLmFsaWduKTtcbiAgZW5jb2RlLnVwZGF0ZS5hbmdsZSA9IHBhdGNoKGVuY29kZS51cGRhdGUuYW5nbGUsIGVudGVyLmFuZ2xlKTtcbiAgZW5jb2RlLnVwZGF0ZS5iYXNlbGluZSA9IHBhdGNoKGVuY29kZS51cGRhdGUuYmFzZWxpbmUsIGVudGVyLmJhc2VsaW5lKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogQXhpc1RpdGxlUm9sZSxcbiAgICBzdHlsZTogR3VpZGVUaXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBhdXRvTGF5b3V0KF8sIG9yaWVudCwgZW5jb2RlLCB1c2VyRW5jb2RlKSB7XG4gIGNvbnN0IGF1dG8gPSAodmFsdWUsIGRpbSkgPT4gdmFsdWUgIT0gbnVsbCA/IChlbmNvZGUudXBkYXRlW2RpbV0gPSBwYXRjaChlbmNvZGVyKHZhbHVlKSwgZW5jb2RlLnVwZGF0ZVtkaW1dKSwgZmFsc2UpIDogIWhhcyhkaW0sIHVzZXJFbmNvZGUpID8gdHJ1ZSA6IGZhbHNlO1xuXG4gIGNvbnN0IGF1dG9ZID0gYXV0byhfKCd0aXRsZVgnKSwgJ3gnKSxcbiAgICAgICAgYXV0b1ggPSBhdXRvKF8oJ3RpdGxlWScpLCAneScpO1xuICBlbmNvZGUuZW50ZXIuYXV0byA9IGF1dG9YID09PSBhdXRvWSA/IGVuY29kZXIoYXV0b1gpIDogaWZYKG9yaWVudCwgZW5jb2RlcihhdXRvWCksIGVuY29kZXIoYXV0b1kpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBeGlzIChzcGVjLCBzY29wZSkge1xuICBjb25zdCBjb25maWcgPSBheGlzQ29uZmlnKHNwZWMsIHNjb3BlKSxcbiAgICAgICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgICAgIGF4aXNFbmNvZGUgPSBlbmNvZGUuYXhpcyB8fCB7fSxcbiAgICAgICAgbmFtZSA9IGF4aXNFbmNvZGUubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIGludGVyYWN0aXZlID0gYXhpc0VuY29kZS5pbnRlcmFjdGl2ZSxcbiAgICAgICAgc3R5bGUgPSBheGlzRW5jb2RlLnN0eWxlLFxuICAgICAgICBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgICAgIGJhbmQgPSB0aWNrQmFuZChfKTsgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGF4aXMgZ3JvdXBcblxuXG4gIGNvbnN0IGRhdHVtID0ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIHRpY2tzOiAhIV8oJ3RpY2tzJyksXG4gICAgbGFiZWxzOiAhIV8oJ2xhYmVscycpLFxuICAgIGdyaWQ6ICEhXygnZ3JpZCcpLFxuICAgIGRvbWFpbjogISFfKCdkb21haW4nKSxcbiAgICB0aXRsZTogc3BlYy50aXRsZSAhPSBudWxsXG4gIH07XG4gIGNvbnN0IGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3Qoe30sIFtkYXR1bV0pKSk7IC8vIGRhdGEgc291cmNlIGZvciBheGlzIHRpY2tzXG5cbiAgY29uc3QgdGlja3NSZWYgPSByZWYoc2NvcGUuYWRkKEF4aXNUaWNrcyh7XG4gICAgc2NhbGU6IHNjb3BlLnNjYWxlUmVmKHNwZWMuc2NhbGUpLFxuICAgIGV4dHJhOiBzY29wZS5wcm9wZXJ0eShiYW5kLmV4dHJhKSxcbiAgICBjb3VudDogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy50aWNrQ291bnQpLFxuICAgIHZhbHVlczogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy52YWx1ZXMpLFxuICAgIG1pbnN0ZXA6IHNjb3BlLnByb3BlcnR5KHNwZWMudGlja01pblN0ZXApLFxuICAgIGZvcm1hdFR5cGU6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0VHlwZSksXG4gICAgZm9ybWF0U3BlY2lmaWVyOiBzY29wZS5wcm9wZXJ0eShzcGVjLmZvcm1hdClcbiAgfSkpKTsgLy8gZ2VuZXJhdGUgYXhpcyBtYXJrc1xuXG4gIGNvbnN0IGNoaWxkcmVuID0gW107XG4gIGxldCBzaXplOyAvLyBpbmNsdWRlIGF4aXMgZ3JpZGxpbmVzIGlmIHJlcXVlc3RlZFxuXG4gIGlmIChkYXR1bS5ncmlkKSB7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzR3JpZChzcGVjLCBjb25maWcsIGVuY29kZS5ncmlkLCB0aWNrc1JlZiwgYmFuZCkpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyB0aWNrcyBpZiByZXF1ZXN0ZWRcblxuXG4gIGlmIChkYXR1bS50aWNrcykge1xuICAgIHNpemUgPSBfKCd0aWNrU2l6ZScpO1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc1RpY2tzKHNwZWMsIGNvbmZpZywgZW5jb2RlLnRpY2tzLCB0aWNrc1JlZiwgc2l6ZSwgYmFuZCkpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyBsYWJlbHMgaWYgcmVxdWVzdGVkXG5cblxuICBpZiAoZGF0dW0ubGFiZWxzKSB7XG4gICAgc2l6ZSA9IGRhdHVtLnRpY2tzID8gc2l6ZSA6IDA7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzTGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgdGlja3NSZWYsIHNpemUsIGJhbmQpKTtcbiAgfSAvLyBpbmNsdWRlIGF4aXMgZG9tYWluIHBhdGggaWYgcmVxdWVzdGVkXG5cblxuICBpZiAoZGF0dW0uZG9tYWluKSB7XG4gICAgY2hpbGRyZW4ucHVzaChheGlzRG9tYWluKHNwZWMsIGNvbmZpZywgZW5jb2RlLmRvbWFpbiwgZGF0YVJlZikpO1xuICB9IC8vIGluY2x1ZGUgYXhpcyB0aXRsZSBpZiBkZWZpbmVkXG5cblxuICBpZiAoZGF0dW0udGl0bGUpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNUaXRsZShzcGVjLCBjb25maWcsIGVuY29kZS50aXRsZSwgZGF0YVJlZikpO1xuICB9IC8vIHBhcnNlIGF4aXMgc3BlY2lmaWNhdGlvblxuXG5cbiAgcmV0dXJuIHBhcnNlTWFyayhndWlkZUdyb3VwKHtcbiAgICByb2xlOiBBeGlzUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGJ1aWxkQXhpc0VuY29kZShfLCBzcGVjKSwgYXhpc0VuY29kZSwgU2tpcCksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRBeGlzRW5jb2RlKF8sIHNwZWMpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSB8fCAwLFxuICAgIHBvc2l0aW9uOiB2YWx1ZShzcGVjLnBvc2l0aW9uLCAwKSxcbiAgICB0aXRsZVBhZGRpbmc6IF8oJ3RpdGxlUGFkZGluZycpLFxuICAgIG1pbkV4dGVudDogXygnbWluRXh0ZW50JyksXG4gICAgbWF4RXh0ZW50OiBfKCdtYXhFeHRlbnQnKSxcbiAgICByYW5nZToge1xuICAgICAgc2lnbmFsOiBgYWJzKHNwYW4ocmFuZ2UoXCIke3NwZWMuc2NhbGV9XCIpKSlgXG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IF8oJ3RyYW5zbGF0ZScpLFxuICAgIC8vIGFjY2Vzc2liaWxpdHkgc3VwcG9ydFxuICAgIGZvcm1hdDogc3BlYy5mb3JtYXQsXG4gICAgZm9ybWF0VHlwZTogc3BlYy5mb3JtYXRUeXBlXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNjb3BlIChzcGVjLCBzY29wZSwgcHJlcHJvY2Vzc2VkKSB7XG4gIGNvbnN0IHNpZ25hbHMgPSBhcnJheShzcGVjLnNpZ25hbHMpLFxuICAgICAgICBzY2FsZXMgPSBhcnJheShzcGVjLnNjYWxlcyk7IC8vIHBhcnNlIHNpZ25hbCBkZWZpbml0aW9ucywgaWYgbm90IGFscmVhZHkgcHJlcHJvY2Vzc2VkXG5cbiAgaWYgKCFwcmVwcm9jZXNzZWQpIHNpZ25hbHMuZm9yRWFjaChfID0+IHBhcnNlU2lnbmFsKF8sIHNjb3BlKSk7IC8vIHBhcnNlIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uIGRlZmluaXRpb25zXG5cbiAgYXJyYXkoc3BlYy5wcm9qZWN0aW9ucykuZm9yRWFjaChfID0+IHBhcnNlUHJvamVjdGlvbihfLCBzY29wZSkpOyAvLyBpbml0aWFsaXplIHNjYWxlIHJlZmVyZW5jZXNcblxuICBzY2FsZXMuZm9yRWFjaChfID0+IGluaXRTY2FsZShfLCBzY29wZSkpOyAvLyBwYXJzZSBkYXRhIHNvdXJjZXNcblxuICBhcnJheShzcGVjLmRhdGEpLmZvckVhY2goXyA9PiBwYXJzZURhdGEoXywgc2NvcGUpKTsgLy8gcGFyc2Ugc2NhbGUgZGVmaW5pdGlvbnNcblxuICBzY2FsZXMuZm9yRWFjaChfID0+IHBhcnNlU2NhbGUoXywgc2NvcGUpKTsgLy8gcGFyc2Ugc2lnbmFsIHVwZGF0ZXNcblxuICAocHJlcHJvY2Vzc2VkIHx8IHNpZ25hbHMpLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbFVwZGF0ZXMoXywgc2NvcGUpKTsgLy8gcGFyc2UgYXhpcyBkZWZpbml0aW9uc1xuXG4gIGFycmF5KHNwZWMuYXhlcykuZm9yRWFjaChfID0+IHBhcnNlQXhpcyhfLCBzY29wZSkpOyAvLyBwYXJzZSBtYXJrIGRlZmluaXRpb25zXG5cbiAgYXJyYXkoc3BlYy5tYXJrcykuZm9yRWFjaChfID0+IHBhcnNlTWFyayhfLCBzY29wZSkpOyAvLyBwYXJzZSBsZWdlbmQgZGVmaW5pdGlvbnNcblxuICBhcnJheShzcGVjLmxlZ2VuZHMpLmZvckVhY2goXyA9PiBwYXJzZUxlZ2VuZChfLCBzY29wZSkpOyAvLyBwYXJzZSB0aXRsZSwgaWYgZGVmaW5lZFxuXG4gIGlmIChzcGVjLnRpdGxlKSBwYXJzZVRpdGxlKHNwZWMudGl0bGUsIHNjb3BlKTsgLy8gcGFyc2UgY29sbGVjdGVkIGxhbWJkYSAoYW5vbnltb3VzKSBleHByZXNzaW9uc1xuXG4gIHNjb3BlLnBhcnNlTGFtYmRhcygpO1xuICByZXR1cm4gc2NvcGU7XG59XG5cbmNvbnN0IHJvb3RFbmNvZGUgPSBzcGVjID0+IGV4dGVuZEVuY29kZSh7XG4gIGVudGVyOiB7XG4gICAgeDoge1xuICAgICAgdmFsdWU6IDBcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfVxuICB9LFxuICB1cGRhdGU6IHtcbiAgICB3aWR0aDoge1xuICAgICAgc2lnbmFsOiAnd2lkdGgnXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICB9XG4gIH1cbn0sIHNwZWMpO1xuXG5mdW5jdGlvbiBwYXJzZVZpZXcoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgY29uZmlnID0gc2NvcGUuY29uZmlnOyAvLyBhZGQgc2NlbmVncmFwaCByb290XG5cbiAgY29uc3Qgcm9vdCA9IHJlZihzY29wZS5yb290ID0gc2NvcGUuYWRkKG9wZXJhdG9yKCkpKTsgLy8gcGFyc2UgdG9wLWxldmVsIHNpZ25hbCBkZWZpbml0aW9uc1xuXG4gIGNvbnN0IHNpZ25hbHMgPSBjb2xsZWN0U2lnbmFscyhzcGVjLCBjb25maWcpO1xuICBzaWduYWxzLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbChfLCBzY29wZSkpOyAvLyBhc3NpZ24gZGVzY3JpcHRpb24sIGV2ZW50LCBsZWdlbmQsIGFuZCBsb2NhbGUgY29uZmlndXJhdGlvblxuXG4gIHNjb3BlLmRlc2NyaXB0aW9uID0gc3BlYy5kZXNjcmlwdGlvbiB8fCBjb25maWcuZGVzY3JpcHRpb247XG4gIHNjb3BlLmV2ZW50Q29uZmlnID0gY29uZmlnLmV2ZW50cztcbiAgc2NvcGUubGVnZW5kcyA9IHNjb3BlLm9iamVjdFByb3BlcnR5KGNvbmZpZy5sZWdlbmQgJiYgY29uZmlnLmxlZ2VuZC5sYXlvdXQpO1xuICBzY29wZS5sb2NhbGUgPSBjb25maWcubG9jYWxlOyAvLyBzdG9yZSByb290IGdyb3VwIGl0ZW1cblxuICBjb25zdCBpbnB1dCA9IHNjb3BlLmFkZChDb2xsZWN0KCkpOyAvLyBlbmNvZGUgcm9vdCBncm91cCBpdGVtXG5cbiAgY29uc3QgZW5jb2RlID0gc2NvcGUuYWRkKEVuY29kZShwYXJzZUVuY29kZShyb290RW5jb2RlKHNwZWMuZW5jb2RlKSwgR3JvdXBNYXJrLCBGcmFtZVJvbGUsIHNwZWMuc3R5bGUsIHNjb3BlLCB7XG4gICAgcHVsc2U6IHJlZihpbnB1dClcbiAgfSkpKTsgLy8gcGVyZm9ybSB2aWV3IGxheW91dFxuXG4gIGNvbnN0IHBhcmVudCA9IHNjb3BlLmFkZChWaWV3TGF5b3V0KHtcbiAgICBsYXlvdXQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KHNwZWMubGF5b3V0KSxcbiAgICBsZWdlbmRzOiBzY29wZS5sZWdlbmRzLFxuICAgIGF1dG9zaXplOiBzY29wZS5zaWduYWxSZWYoJ2F1dG9zaXplJyksXG4gICAgbWFyazogcm9vdCxcbiAgICBwdWxzZTogcmVmKGVuY29kZSlcbiAgfSkpO1xuICBzY29wZS5vcGVyYXRvcnMucG9wKCk7IC8vIHBhcnNlIHJlbWFpbmRlciBvZiBzcGVjaWZpY2F0aW9uXG5cbiAgc2NvcGUucHVzaFN0YXRlKHJlZihlbmNvZGUpLCByZWYocGFyZW50KSwgbnVsbCk7XG4gIHBhcnNlU2NvcGUoc3BlYywgc2NvcGUsIHNpZ25hbHMpO1xuICBzY29wZS5vcGVyYXRvcnMucHVzaChwYXJlbnQpOyAvLyBib3VuZCAvIHJlbmRlciAvIHNpZXZlIHJvb3QgaXRlbVxuXG4gIGxldCBvcCA9IHNjb3BlLmFkZChCb3VuZCh7XG4gICAgbWFyazogcm9vdCxcbiAgICBwdWxzZTogcmVmKHBhcmVudClcbiAgfSkpO1xuICBvcCA9IHNjb3BlLmFkZChSZW5kZXIoe1xuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTtcbiAgb3AgPSBzY29wZS5hZGQoU2lldmUoe1xuICAgIHB1bHNlOiByZWYob3ApXG4gIH0pKTsgLy8gdHJhY2sgbWV0YWRhdGEgZm9yIHJvb3QgaXRlbVxuXG4gIHNjb3BlLmFkZERhdGEoJ3Jvb3QnLCBuZXcgRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgaW5wdXQsIG9wKSk7XG4gIHJldHVybiBzY29wZTtcbn1cblxuZnVuY3Rpb24gc2lnbmFsT2JqZWN0KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaWduYWwgPyB7XG4gICAgbmFtZSxcbiAgICB1cGRhdGU6IHZhbHVlLnNpZ25hbFxuICB9IDoge1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfTtcbn1cbi8qKlxuICogQ29sbGVjdCB0b3AtbGV2ZWwgc2lnbmFscywgbWVyZ2luZyB2YWx1ZXMgYXMgbmVlZGVkLiBTaWduYWxzXG4gKiBkZWZpbmVkIGluIHRoZSBjb25maWcgc2lnbmFscyBhcnJheXMgYXJlIGFkZGVkIG9ubHkgaWYgdGhhdFxuICogc2lnbmFsIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWQgaW4gdGhlIHNwZWNpZmljYXRpb24uXG4gKiBCdWlsdC1pbiBzaWduYWxzIChhdXRvc2l6ZSwgYmFja2dyb3VuZCwgcGFkZGluZywgd2lkdGgsIGhlaWdodClcbiAqIHJlY2VpdmUgc3BlY2lhbCB0cmVhdG1lbnQuIFRoZXkgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZVxuICogdG9wLWxldmVsIHNwZWMgcHJvcGVydHksIG9yLCBpZiB1bmRlZmluZWQgaW4gdGhlIHNwZWMsIHVzaW5nXG4gKiB0aGUgY29ycmVzcG9uZGluZyB0b3AtbGV2ZWwgY29uZmlnIHByb3BlcnR5LiBJZiB0aGlzIHByb3BlcnR5XG4gKiBpcyBhIHNpZ25hbCByZWZlcmVuY2Ugb2JqZWN0LCB0aGUgc2lnbmFsIGV4cHJlc3Npb24gbWFwcyB0byB0aGVcbiAqIHNpZ25hbCAndXBkYXRlJyBwcm9wZXJ0eS4gSWYgdGhlIHNwZWMncyB0b3AtbGV2ZWwgc2lnbmFsIGFycmF5XG4gKiBjb250YWlucyBhbiBlbnRyeSB0aGF0IG1hdGNoZXMgYSBidWlsdC1pbiBzaWduYWwsIHRoYXQgZW50cnlcbiAqIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGJ1aWx0LWluIHNwZWNpZmljYXRpb24sIHBvdGVudGlhbGx5XG4gKiBvdmVyd3JpdGluZyBleGlzdGluZyAndmFsdWUnIG9yICd1cGRhdGUnIHByb3BlcnRpZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBjb2xsZWN0U2lnbmFscyhzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgXyA9IG5hbWUgPT4gdmFsdWUoc3BlY1tuYW1lXSwgY29uZmlnW25hbWVdKSxcbiAgICAgICAgc2lnbmFscyA9IFtzaWduYWxPYmplY3QoJ2JhY2tncm91bmQnLCBfKCdiYWNrZ3JvdW5kJykpLCBzaWduYWxPYmplY3QoJ2F1dG9zaXplJywgcGFyc2VBdXRvc2l6ZShfKCdhdXRvc2l6ZScpKSksIHNpZ25hbE9iamVjdCgncGFkZGluZycsIHBhcnNlUGFkZGluZyhfKCdwYWRkaW5nJykpKSwgc2lnbmFsT2JqZWN0KCd3aWR0aCcsIF8oJ3dpZHRoJykgfHwgMCksIHNpZ25hbE9iamVjdCgnaGVpZ2h0JywgXygnaGVpZ2h0JykgfHwgMCldLFxuICAgICAgICBwcmUgPSBzaWduYWxzLnJlZHVjZSgocCwgcykgPT4gKHBbcy5uYW1lXSA9IHMsIHApLCB7fSksXG4gICAgICAgIG1hcCA9IHt9OyAvLyBhZGQgc3BlYyBzaWduYWwgYXJyYXlcblxuXG4gIGFycmF5KHNwZWMuc2lnbmFscykuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkocHJlLCBzLm5hbWUpKSB7XG4gICAgICAvLyBtZXJnZSBpZiBidWlsdC1pbiBzaWduYWxcbiAgICAgIHMgPSBleHRlbmQocHJlW3MubmFtZV0sIHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UgYWRkIHRvIHNpZ25hbCBsaXN0XG4gICAgICBzaWduYWxzLnB1c2gocyk7XG4gICAgfVxuXG4gICAgbWFwW3MubmFtZV0gPSBzO1xuICB9KTsgLy8gYWRkIGNvbmZpZyBzaWduYWwgYXJyYXlcblxuICBhcnJheShjb25maWcuc2lnbmFscykuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG1hcCwgcy5uYW1lKSAmJiAhaGFzT3duUHJvcGVydHkocHJlLCBzLm5hbWUpKSB7XG4gICAgICAvLyBhZGQgdG8gc2lnbmFsIGxpc3QgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgICAgc2lnbmFscy5wdXNoKHMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaWduYWxzO1xufVxuXG5mdW5jdGlvbiBTY29wZShjb25maWcsIG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgdGhpcy5maWVsZCA9IHt9O1xuICB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgdGhpcy5sYW1iZGFzID0ge307XG4gIHRoaXMuc2NhbGVzID0ge307XG4gIHRoaXMuZXZlbnRzID0ge307XG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLnN0cmVhbXMgPSBbXTtcbiAgdGhpcy51cGRhdGVzID0gW107XG4gIHRoaXMub3BlcmF0b3JzID0gW107XG4gIHRoaXMuZXZlbnRDb25maWcgPSBudWxsO1xuICB0aGlzLmxvY2FsZSA9IG51bGw7XG4gIHRoaXMuX2lkID0gMDtcbiAgdGhpcy5fc3ViaWQgPSAwO1xuICB0aGlzLl9uZXh0c3ViID0gWzBdO1xuICB0aGlzLl9wYXJlbnQgPSBbXTtcbiAgdGhpcy5fZW5jb2RlID0gW107XG4gIHRoaXMuX2xvb2t1cCA9IFtdO1xuICB0aGlzLl9tYXJrcGF0aCA9IFtdO1xufVxuXG5mdW5jdGlvbiBTdWJzY29wZShzY29wZSkge1xuICB0aGlzLmNvbmZpZyA9IHNjb3BlLmNvbmZpZztcbiAgdGhpcy5vcHRpb25zID0gc2NvcGUub3B0aW9ucztcbiAgdGhpcy5sZWdlbmRzID0gc2NvcGUubGVnZW5kcztcbiAgdGhpcy5maWVsZCA9IE9iamVjdC5jcmVhdGUoc2NvcGUuZmllbGQpO1xuICB0aGlzLnNpZ25hbHMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLnNpZ25hbHMpO1xuICB0aGlzLmxhbWJkYXMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmxhbWJkYXMpO1xuICB0aGlzLnNjYWxlcyA9IE9iamVjdC5jcmVhdGUoc2NvcGUuc2NhbGVzKTtcbiAgdGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmV2ZW50cyk7XG4gIHRoaXMuZGF0YSA9IE9iamVjdC5jcmVhdGUoc2NvcGUuZGF0YSk7XG4gIHRoaXMuc3RyZWFtcyA9IFtdO1xuICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgdGhpcy5vcGVyYXRvcnMgPSBbXTtcbiAgdGhpcy5faWQgPSAwO1xuICB0aGlzLl9zdWJpZCA9ICsrc2NvcGUuX25leHRzdWJbMF07XG4gIHRoaXMuX25leHRzdWIgPSBzY29wZS5fbmV4dHN1YjtcbiAgdGhpcy5fcGFyZW50ID0gc2NvcGUuX3BhcmVudC5zbGljZSgpO1xuICB0aGlzLl9lbmNvZGUgPSBzY29wZS5fZW5jb2RlLnNsaWNlKCk7XG4gIHRoaXMuX2xvb2t1cCA9IHNjb3BlLl9sb29rdXAuc2xpY2UoKTtcbiAgdGhpcy5fbWFya3BhdGggPSBzY29wZS5fbWFya3BhdGg7XG59XG5cblNjb3BlLnByb3RvdHlwZSA9IFN1YnNjb3BlLnByb3RvdHlwZSA9IHtcbiAgcGFyc2Uoc3BlYykge1xuICAgIHJldHVybiBwYXJzZVNjb3BlKHNwZWMsIHRoaXMpO1xuICB9LFxuXG4gIGZvcmsoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY29wZSh0aGlzKTtcbiAgfSxcblxuICBpc1N1YnNjb3BlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJpZCA+IDA7XG4gIH0sXG5cbiAgdG9SdW50aW1lKCkge1xuICAgIHRoaXMuZmluaXNoKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgb3BlcmF0b3JzOiB0aGlzLm9wZXJhdG9ycyxcbiAgICAgIHN0cmVhbXM6IHRoaXMuc3RyZWFtcyxcbiAgICAgIHVwZGF0ZXM6IHRoaXMudXBkYXRlcyxcbiAgICAgIGJpbmRpbmdzOiB0aGlzLmJpbmRpbmdzLFxuICAgICAgZXZlbnRDb25maWc6IHRoaXMuZXZlbnRDb25maWcsXG4gICAgICBsb2NhbGU6IHRoaXMubG9jYWxlXG4gICAgfTtcbiAgfSxcblxuICBpZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3N1YmlkID8gdGhpcy5fc3ViaWQgKyAnOicgOiAwKSArIHRoaXMuX2lkKys7XG4gIH0sXG5cbiAgYWRkKG9wKSB7XG4gICAgdGhpcy5vcGVyYXRvcnMucHVzaChvcCk7XG4gICAgb3AuaWQgPSB0aGlzLmlkKCk7IC8vIGlmIHByZS1yZWdpc3RyYXRpb24gcmVmZXJlbmNlcyBleGlzdCwgcmVzb2x2ZSB0aGVtIG5vd1xuXG4gICAgaWYgKG9wLnJlZnMpIHtcbiAgICAgIG9wLnJlZnMuZm9yRWFjaChyZWYgPT4ge1xuICAgICAgICByZWYuJHJlZiA9IG9wLmlkO1xuICAgICAgfSk7XG4gICAgICBvcC5yZWZzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3A7XG4gIH0sXG5cbiAgcHJveHkob3ApIHtcbiAgICBjb25zdCB2cmVmID0gb3AgaW5zdGFuY2VvZiBFbnRyeSA/IHJlZihvcCkgOiBvcDtcbiAgICByZXR1cm4gdGhpcy5hZGQoUHJveHkoe1xuICAgICAgdmFsdWU6IHZyZWZcbiAgICB9KSk7XG4gIH0sXG5cbiAgYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuc3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgc3RyZWFtLmlkID0gdGhpcy5pZCgpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG5cbiAgYWRkVXBkYXRlKHVwZGF0ZSkge1xuICAgIHRoaXMudXBkYXRlcy5wdXNoKHVwZGF0ZSk7XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfSxcblxuICAvLyBBcHBseSBtZXRhZGF0YVxuICBmaW5pc2goKSB7XG4gICAgbGV0IG5hbWUsIGRzOyAvLyBhbm5vdGF0ZSByb290XG5cbiAgICBpZiAodGhpcy5yb290KSB0aGlzLnJvb3Qucm9vdCA9IHRydWU7IC8vIGFubm90YXRlIHNpZ25hbHNcblxuICAgIGZvciAobmFtZSBpbiB0aGlzLnNpZ25hbHMpIHtcbiAgICAgIHRoaXMuc2lnbmFsc1tuYW1lXS5zaWduYWwgPSBuYW1lO1xuICAgIH0gLy8gYW5ub3RhdGUgc2NhbGVzXG5cblxuICAgIGZvciAobmFtZSBpbiB0aGlzLnNjYWxlcykge1xuICAgICAgdGhpcy5zY2FsZXNbbmFtZV0uc2NhbGUgPSBuYW1lO1xuICAgIH0gLy8gYW5ub3RhdGUgZGF0YSBzZXRzXG5cblxuICAgIGZ1bmN0aW9uIGFubm90YXRlKG9wLCBuYW1lLCB0eXBlKSB7XG4gICAgICBsZXQgZGF0YSwgbGlzdDtcblxuICAgICAgaWYgKG9wKSB7XG4gICAgICAgIGRhdGEgPSBvcC5kYXRhIHx8IChvcC5kYXRhID0ge30pO1xuICAgICAgICBsaXN0ID0gZGF0YVtuYW1lXSB8fCAoZGF0YVtuYW1lXSA9IFtdKTtcbiAgICAgICAgbGlzdC5wdXNoKHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobmFtZSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgIGRzID0gdGhpcy5kYXRhW25hbWVdO1xuICAgICAgYW5ub3RhdGUoZHMuaW5wdXQsIG5hbWUsICdpbnB1dCcpO1xuICAgICAgYW5ub3RhdGUoZHMub3V0cHV0LCBuYW1lLCAnb3V0cHV0Jyk7XG4gICAgICBhbm5vdGF0ZShkcy52YWx1ZXMsIG5hbWUsICd2YWx1ZXMnKTtcblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBkcy5pbmRleCkge1xuICAgICAgICBhbm5vdGF0ZShkcy5pbmRleFtmaWVsZF0sIG5hbWUsICdpbmRleDonICsgZmllbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgcHVzaFN0YXRlKGVuY29kZSwgcGFyZW50LCBsb29rdXApIHtcbiAgICB0aGlzLl9lbmNvZGUucHVzaChyZWYodGhpcy5hZGQoU2lldmUoe1xuICAgICAgcHVsc2U6IGVuY29kZVxuICAgIH0pKSkpO1xuXG4gICAgdGhpcy5fcGFyZW50LnB1c2gocGFyZW50KTtcblxuICAgIHRoaXMuX2xvb2t1cC5wdXNoKGxvb2t1cCA/IHJlZih0aGlzLnByb3h5KGxvb2t1cCkpIDogbnVsbCk7XG5cbiAgICB0aGlzLl9tYXJrcGF0aC5wdXNoKC0xKTtcbiAgfSxcblxuICBwb3BTdGF0ZSgpIHtcbiAgICB0aGlzLl9lbmNvZGUucG9wKCk7XG5cbiAgICB0aGlzLl9wYXJlbnQucG9wKCk7XG5cbiAgICB0aGlzLl9sb29rdXAucG9wKCk7XG5cbiAgICB0aGlzLl9tYXJrcGF0aC5wb3AoKTtcbiAgfSxcblxuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fcGFyZW50KTtcbiAgfSxcblxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fZW5jb2RlKTtcbiAgfSxcblxuICBsb29rdXAoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fbG9va3VwKTtcbiAgfSxcblxuICBtYXJrcGF0aCgpIHtcbiAgICBjb25zdCBwID0gdGhpcy5fbWFya3BhdGg7XG4gICAgcmV0dXJuICsrcFtwLmxlbmd0aCAtIDFdO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgZmllbGRSZWYoZmllbGQsIG5hbWUpIHtcbiAgICBpZiAoaXNTdHJpbmcoZmllbGQpKSByZXR1cm4gZmllbGRSZWYkMShmaWVsZCwgbmFtZSk7XG5cbiAgICBpZiAoIWZpZWxkLnNpZ25hbCkge1xuICAgICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIGZpZWxkIHJlZmVyZW5jZTogJyArIHN0cmluZ1ZhbHVlKGZpZWxkKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcyA9IGZpZWxkLnNpZ25hbDtcbiAgICBsZXQgZiA9IHRoaXMuZmllbGRbc107XG5cbiAgICBpZiAoIWYpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5zaWduYWxSZWYocylcbiAgICAgIH07XG4gICAgICBpZiAobmFtZSkgcGFyYW1zLmFzID0gbmFtZTtcbiAgICAgIHRoaXMuZmllbGRbc10gPSBmID0gcmVmKHRoaXMuYWRkKEZpZWxkKHBhcmFtcykpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZjtcbiAgfSxcblxuICBjb21wYXJlUmVmKGNtcCkge1xuICAgIGxldCBzaWduYWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrID0gXyA9PiBpc1NpZ25hbChfKSA/IChzaWduYWwgPSB0cnVlLCB0aGlzLnNpZ25hbFJlZihfLnNpZ25hbCkpIDogaXNFeHByJDEoXykgPyAoc2lnbmFsID0gdHJ1ZSwgdGhpcy5leHByUmVmKF8uZXhwcikpIDogXztcblxuICAgIGNvbnN0IGZpZWxkcyA9IGFycmF5KGNtcC5maWVsZCkubWFwKGNoZWNrKSxcbiAgICAgICAgICBvcmRlcnMgPSBhcnJheShjbXAub3JkZXIpLm1hcChjaGVjayk7XG4gICAgcmV0dXJuIHNpZ25hbCA/IHJlZih0aGlzLmFkZChDb21wYXJlKHtcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgb3JkZXJzOiBvcmRlcnNcbiAgICB9KSkpIDogY29tcGFyZVJlZihmaWVsZHMsIG9yZGVycyk7XG4gIH0sXG5cbiAga2V5UmVmKGZpZWxkcywgZmxhdCkge1xuICAgIGxldCBzaWduYWwgPSBmYWxzZTtcblxuICAgIGNvbnN0IGNoZWNrID0gXyA9PiBpc1NpZ25hbChfKSA/IChzaWduYWwgPSB0cnVlLCByZWYoc2lnW18uc2lnbmFsXSkpIDogXztcblxuICAgIGNvbnN0IHNpZyA9IHRoaXMuc2lnbmFscztcbiAgICBmaWVsZHMgPSBhcnJheShmaWVsZHMpLm1hcChjaGVjayk7XG4gICAgcmV0dXJuIHNpZ25hbCA/IHJlZih0aGlzLmFkZChLZXkoe1xuICAgICAgZmllbGRzOiBmaWVsZHMsXG4gICAgICBmbGF0OiBmbGF0XG4gICAgfSkpKSA6IGtleVJlZihmaWVsZHMsIGZsYXQpO1xuICB9LFxuXG4gIHNvcnRSZWYoc29ydCkge1xuICAgIGlmICghc29ydCkgcmV0dXJuIHNvcnQ7IC8vIGluY2x1ZGluZyBpZCBlbnN1cmVzIHN0YWJsZSBzb3J0aW5nXG5cbiAgICBjb25zdCBhID0gYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpLFxuICAgICAgICAgIG8gPSBzb3J0Lm9yZGVyIHx8IEFzY2VuZGluZztcbiAgICByZXR1cm4gby5zaWduYWwgPyByZWYodGhpcy5hZGQoQ29tcGFyZSh7XG4gICAgICBmaWVsZHM6IGEsXG4gICAgICBvcmRlcnM6IHRoaXMuc2lnbmFsUmVmKG8uc2lnbmFsKVxuICAgIH0pKSkgOiBjb21wYXJlUmVmKGEsIG8pO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgZXZlbnQoc291cmNlLCB0eXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlICsgJzonICsgdHlwZTtcblxuICAgIGlmICghdGhpcy5ldmVudHNba2V5XSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmlkKCk7XG4gICAgICB0aGlzLnN0cmVhbXMucHVzaCh7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ldmVudHNba2V5XSA9IGlkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmV2ZW50c1trZXldO1xuICB9LFxuXG4gIC8vIC0tLS1cbiAgaGFzT3duU2lnbmFsKG5hbWUpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkodGhpcy5zaWduYWxzLCBuYW1lKTtcbiAgfSxcblxuICBhZGRTaWduYWwobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNPd25TaWduYWwobmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgc2lnbmFsIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3AgPSB2YWx1ZSBpbnN0YW5jZW9mIEVudHJ5ID8gdmFsdWUgOiB0aGlzLmFkZChvcGVyYXRvcih2YWx1ZSkpO1xuICAgIHJldHVybiB0aGlzLnNpZ25hbHNbbmFtZV0gPSBvcDtcbiAgfSxcblxuICBnZXRTaWduYWwobmFtZSkge1xuICAgIGlmICghdGhpcy5zaWduYWxzW25hbWVdKSB7XG4gICAgICBlcnJvcignVW5yZWNvZ25pemVkIHNpZ25hbCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNpZ25hbHNbbmFtZV07XG4gIH0sXG5cbiAgc2lnbmFsUmVmKHMpIHtcbiAgICBpZiAodGhpcy5zaWduYWxzW3NdKSB7XG4gICAgICByZXR1cm4gcmVmKHRoaXMuc2lnbmFsc1tzXSk7XG4gICAgfSBlbHNlIGlmICghaGFzT3duUHJvcGVydHkodGhpcy5sYW1iZGFzLCBzKSkge1xuICAgICAgdGhpcy5sYW1iZGFzW3NdID0gdGhpcy5hZGQob3BlcmF0b3IobnVsbCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZWYodGhpcy5sYW1iZGFzW3NdKTtcbiAgfSxcblxuICBwYXJzZUxhbWJkYXMoKSB7XG4gICAgY29uc3QgY29kZSA9IE9iamVjdC5rZXlzKHRoaXMubGFtYmRhcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNvZGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzID0gY29kZVtpXSxcbiAgICAgICAgICAgIGUgPSBwYXJzZUV4cHJlc3Npb24ocywgdGhpcyksXG4gICAgICAgICAgICBvcCA9IHRoaXMubGFtYmRhc1tzXTtcbiAgICAgIG9wLnBhcmFtcyA9IGUuJHBhcmFtcztcbiAgICAgIG9wLnVwZGF0ZSA9IGUuJGV4cHI7XG4gICAgfVxuICB9LFxuXG4gIHByb3BlcnR5KHNwZWMpIHtcbiAgICByZXR1cm4gc3BlYyAmJiBzcGVjLnNpZ25hbCA/IHRoaXMuc2lnbmFsUmVmKHNwZWMuc2lnbmFsKSA6IHNwZWM7XG4gIH0sXG5cbiAgb2JqZWN0UHJvcGVydHkoc3BlYykge1xuICAgIHJldHVybiAhc3BlYyB8fCAhaXNPYmplY3Qoc3BlYykgPyBzcGVjIDogdGhpcy5zaWduYWxSZWYoc3BlYy5zaWduYWwgfHwgcHJvcGVydHlMYW1iZGEoc3BlYykpO1xuICB9LFxuXG4gIGV4cHJSZWYoY29kZSwgbmFtZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIGV4cHI6IHBhcnNlRXhwcmVzc2lvbihjb2RlLCB0aGlzKVxuICAgIH07XG4gICAgaWYgKG5hbWUpIHBhcmFtcy5leHByLiRuYW1lID0gbmFtZTtcbiAgICByZXR1cm4gcmVmKHRoaXMuYWRkKEV4cHJlc3Npb24ocGFyYW1zKSkpO1xuICB9LFxuXG4gIGFkZEJpbmRpbmcobmFtZSwgYmluZCkge1xuICAgIGlmICghdGhpcy5iaW5kaW5ncykge1xuICAgICAgZXJyb3IoJ05lc3RlZCBzaWduYWxzIGRvIG5vdCBzdXBwb3J0IGJpbmRpbmc6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKGV4dGVuZCh7XG4gICAgICBzaWduYWw6IG5hbWVcbiAgICB9LCBiaW5kKSk7XG4gIH0sXG5cbiAgLy8gLS0tLVxuICBhZGRTY2FsZVByb2oobmFtZSwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHRoaXMuc2NhbGVzLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBzY2FsZSBvciBwcm9qZWN0aW9uIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZXNbbmFtZV0gPSB0aGlzLmFkZCh0cmFuc2Zvcm0pO1xuICB9LFxuXG4gIGFkZFNjYWxlKG5hbWUsIHBhcmFtcykge1xuICAgIHRoaXMuYWRkU2NhbGVQcm9qKG5hbWUsIFNjYWxlKHBhcmFtcykpO1xuICB9LFxuXG4gIGFkZFByb2plY3Rpb24obmFtZSwgcGFyYW1zKSB7XG4gICAgdGhpcy5hZGRTY2FsZVByb2oobmFtZSwgUHJvamVjdGlvbihwYXJhbXMpKTtcbiAgfSxcblxuICBnZXRTY2FsZShuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnNjYWxlc1tuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNjYWxlc1tuYW1lXTtcbiAgfSxcblxuICBzY2FsZVJlZihuYW1lKSB7XG4gICAgcmV0dXJuIHJlZih0aGlzLmdldFNjYWxlKG5hbWUpKTtcbiAgfSxcblxuICBzY2FsZVR5cGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldFNjYWxlKG5hbWUpLnBhcmFtcy50eXBlO1xuICB9LFxuXG4gIHByb2plY3Rpb25SZWYobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlUmVmKG5hbWUpO1xuICB9LFxuXG4gIHByb2plY3Rpb25UeXBlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZVR5cGUobmFtZSk7XG4gIH0sXG5cbiAgLy8gLS0tLVxuICBhZGREYXRhKG5hbWUsIGRhdGFTY29wZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh0aGlzLmRhdGEsIG5hbWUpKSB7XG4gICAgICBlcnJvcignRHVwbGljYXRlIGRhdGEgc2V0IG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YVtuYW1lXSA9IGRhdGFTY29wZTtcbiAgfSxcblxuICBnZXREYXRhKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVtuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VuZGVmaW5lZCBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRhdGFbbmFtZV07XG4gIH0sXG5cbiAgYWRkRGF0YVBpcGVsaW5lKG5hbWUsIGVudHJpZXMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodGhpcy5kYXRhLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZERhdGEobmFtZSwgRGF0YVNjb3BlLmZyb21FbnRyaWVzKHRoaXMsIGVudHJpZXMpKTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBwcm9wZXJ0eUxhbWJkYShzcGVjKSB7XG4gIHJldHVybiAoaXNBcnJheShzcGVjKSA/IGFycmF5TGFtYmRhIDogb2JqZWN0TGFtYmRhKShzcGVjKTtcbn1cblxuZnVuY3Rpb24gYXJyYXlMYW1iZGEoYXJyYXkpIHtcbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IGNvZGUgPSAnWyc7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2ldO1xuICAgIGNvZGUgKz0gKGkgPiAwID8gJywnIDogJycpICsgKGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLnNpZ25hbCB8fCBwcm9wZXJ0eUxhbWJkYSh2YWx1ZSkgOiBzdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGNvZGUgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIG9iamVjdExhbWJkYShvYmopIHtcbiAgbGV0IGNvZGUgPSAneycsXG4gICAgICBpID0gMCxcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIHZhbHVlID0gb2JqW2tleV07XG4gICAgY29kZSArPSAoKytpID4gMSA/ICcsJyA6ICcnKSArIHN0cmluZ1ZhbHVlKGtleSkgKyAnOicgKyAoaXNPYmplY3QodmFsdWUpID8gdmFsdWUuc2lnbmFsIHx8IHByb3BlcnR5TGFtYmRhKHZhbHVlKSA6IHN0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gY29kZSArICd9Jztcbn1cblxuLyoqXG4gKiBTdGFuZGFyZCBjb25maWd1cmF0aW9uIGRlZmF1bHRzIGZvciBWZWdhIHNwZWNpZmljYXRpb24gcGFyc2luZy5cbiAqIFVzZXJzIGNhbiBwcm92aWRlIHRoZWlyIG93biAoc3ViLSlzZXQgb2YgdGhlc2UgZGVmYXVsdCB2YWx1ZXNcbiAqIGJ5IHBhc3NpbmcgaW4gYSBjb25maWcgb2JqZWN0IHRvIHRoZSB0b3AtbGV2ZWwgcGFyc2UgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBkZWZhdWx0cyAoKSB7XG4gIGNvbnN0IGRlZmF1bHRGb250ID0gJ3NhbnMtc2VyaWYnLFxuICAgICAgICBkZWZhdWx0U3ltYm9sU2l6ZSA9IDMwLFxuICAgICAgICBkZWZhdWx0U3Ryb2tlV2lkdGggPSAyLFxuICAgICAgICBkZWZhdWx0Q29sb3IgPSAnIzRjNzhhOCcsXG4gICAgICAgIGJsYWNrID0gJyMwMDAnLFxuICAgICAgICBncmF5ID0gJyM4ODgnLFxuICAgICAgICBsaWdodEdyYXkgPSAnI2RkZCc7XG4gIHJldHVybiB7XG4gICAgLy8gZGVmYXVsdCB2aXN1YWxpemF0aW9uIGRlc2NyaXB0aW9uXG4gICAgZGVzY3JpcHRpb246ICdWZWdhIHZpc3VhbGl6YXRpb24nLFxuICAgIC8vIGRlZmF1bHQgcGFkZGluZyBhcm91bmQgdmlzdWFsaXphdGlvblxuICAgIHBhZGRpbmc6IDAsXG4gICAgLy8gZGVmYXVsdCBmb3IgYXV0b21hdGljIHNpemluZzsgb3B0aW9uczogJ25vbmUnLCAncGFkJywgJ2ZpdCdcbiAgICAvLyBvciBwcm92aWRlIGFuIG9iamVjdCAoZS5nLiwgeyd0eXBlJzogJ3BhZCcsICdyZXNpemUnOiB0cnVlfSlcbiAgICBhdXRvc2l6ZTogJ3BhZCcsXG4gICAgLy8gZGVmYXVsdCB2aWV3IGJhY2tncm91bmQgY29sb3JcbiAgICAvLyBjb3ZlcnMgdGhlIGVudGlyZSB2aWV3IGNvbXBvbmVudFxuICAgIGJhY2tncm91bmQ6IG51bGwsXG4gICAgLy8gZGVmYXVsdCBldmVudCBoYW5kbGluZyBjb25maWd1cmF0aW9uXG4gICAgLy8gcHJldmVudERlZmF1bHQgZm9yIHZpZXctc291cmNlZCBldmVudCB0eXBlcyBleGNlcHQgJ3doZWVsJ1xuICAgIGV2ZW50czoge1xuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWxsb3c6IFsnd2hlZWwnXVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIHRvcC1sZXZlbCBncm91cCBtYXJrc1xuICAgIC8vIGFjY2VwdHMgbWFyayBwcm9wZXJ0aWVzIChmaWxsLCBzdHJva2UsIGV0YylcbiAgICAvLyBjb3ZlcnMgdGhlIGRhdGEgcmVjdGFuZ2xlIHdpdGhpbiBncm91cCB3aWR0aC9oZWlnaHRcbiAgICBncm91cDogbnVsbCxcbiAgICAvLyBkZWZhdWx0cyBmb3IgYmFzaWMgbWFyayB0eXBlc1xuICAgIC8vIGVhY2ggc3Vic2V0IGFjY2VwdHMgbWFyayBwcm9wZXJ0aWVzIChmaWxsLCBzdHJva2UsIGV0YylcbiAgICBtYXJrOiBudWxsLFxuICAgIGFyYzoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBhcmVhOiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIGltYWdlOiBudWxsLFxuICAgIGxpbmU6IHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdENvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aFxuICAgIH0sXG4gICAgcGF0aDoge1xuICAgICAgc3Ryb2tlOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIHJlY3Q6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgcnVsZToge1xuICAgICAgc3Ryb2tlOiBibGFja1xuICAgIH0sXG4gICAgc2hhcGU6IHtcbiAgICAgIHN0cm9rZTogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBzeW1ib2w6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvcixcbiAgICAgIHNpemU6IDY0XG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICBmaWxsOiBibGFjayxcbiAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgZm9udFNpemU6IDExXG4gICAgfSxcbiAgICB0cmFpbDoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yLFxuICAgICAgc2l6ZTogZGVmYXVsdFN0cm9rZVdpZHRoXG4gICAgfSxcbiAgICAvLyBzdHlsZSBkZWZpbml0aW9uc1xuICAgIHN0eWxlOiB7XG4gICAgICAvLyBheGlzICYgbGVnZW5kIGxhYmVsc1xuICAgICAgJ2d1aWRlLWxhYmVsJzoge1xuICAgICAgICBmaWxsOiBibGFjayxcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxMFxuICAgICAgfSxcbiAgICAgIC8vIGF4aXMgJiBsZWdlbmQgdGl0bGVzXG4gICAgICAnZ3VpZGUtdGl0bGUnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDExLFxuICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgIH0sXG4gICAgICAvLyBoZWFkZXJzLCBpbmNsdWRpbmcgY2hhcnQgdGl0bGVcbiAgICAgICdncm91cC10aXRsZSc6IHtcbiAgICAgICAgZmlsbDogYmxhY2ssXG4gICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICBmb250U2l6ZTogMTMsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgfSxcbiAgICAgIC8vIGNoYXJ0IHN1YnRpdGxlXG4gICAgICAnZ3JvdXAtc3VidGl0bGUnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDEyXG4gICAgICB9LFxuICAgICAgLy8gZGVmYXVsdHMgZm9yIHN0eWxlZCBwb2ludCBtYXJrcyBpbiBWZWdhLUxpdGVcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIHNpemU6IGRlZmF1bHRTeW1ib2xTaXplLFxuICAgICAgICBzdHJva2VXaWR0aDogZGVmYXVsdFN0cm9rZVdpZHRoLFxuICAgICAgICBzaGFwZTogJ2NpcmNsZSdcbiAgICAgIH0sXG4gICAgICBjaXJjbGU6IHtcbiAgICAgICAgc2l6ZTogZGVmYXVsdFN5bWJvbFNpemUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGhcbiAgICAgIH0sXG4gICAgICBzcXVhcmU6IHtcbiAgICAgICAgc2l6ZTogZGVmYXVsdFN5bWJvbFNpemUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGgsXG4gICAgICAgIHNoYXBlOiAnc3F1YXJlJ1xuICAgICAgfSxcbiAgICAgIC8vIGRlZmF1bHRzIGZvciBzdHlsZWQgZ3JvdXAgbWFya3MgaW4gVmVnYS1MaXRlXG4gICAgICBjZWxsOiB7XG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIHN0cm9rZTogbGlnaHRHcmF5XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgb3JpZW50OiAndG9wJyxcbiAgICAgIGFuY2hvcjogJ21pZGRsZScsXG4gICAgICBvZmZzZXQ6IDQsXG4gICAgICBzdWJ0aXRsZVBhZGRpbmc6IDNcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBheGVzXG4gICAgYXhpczoge1xuICAgICAgbWluRXh0ZW50OiAwLFxuICAgICAgbWF4RXh0ZW50OiAyMDAsXG4gICAgICBiYW5kUG9zaXRpb246IDAuNSxcbiAgICAgIGRvbWFpbjogdHJ1ZSxcbiAgICAgIGRvbWFpbldpZHRoOiAxLFxuICAgICAgZG9tYWluQ29sb3I6IGdyYXksXG4gICAgICBncmlkOiBmYWxzZSxcbiAgICAgIGdyaWRXaWR0aDogMSxcbiAgICAgIGdyaWRDb2xvcjogbGlnaHRHcmF5LFxuICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgbGFiZWxBbmdsZTogMCxcbiAgICAgIGxhYmVsTGltaXQ6IDE4MCxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgbGFiZWxQYWRkaW5nOiAyLFxuICAgICAgdGlja3M6IHRydWUsXG4gICAgICB0aWNrQ29sb3I6IGdyYXksXG4gICAgICB0aWNrT2Zmc2V0OiAwLFxuICAgICAgdGlja1JvdW5kOiB0cnVlLFxuICAgICAgdGlja1NpemU6IDUsXG4gICAgICB0aWNrV2lkdGg6IDEsXG4gICAgICB0aXRsZVBhZGRpbmc6IDRcbiAgICB9LFxuICAgIC8vIGNvcnJlY3Rpb24gZm9yIGNlbnRlcmluZyBiaWFzXG4gICAgYXhpc0JhbmQ6IHtcbiAgICAgIHRpY2tPZmZzZXQ6IC0wLjVcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBjYXJ0b2dyYXBoaWMgcHJvamVjdGlvblxuICAgIHByb2plY3Rpb246IHtcbiAgICAgIHR5cGU6ICdtZXJjYXRvcidcbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBsZWdlbmRzXG4gICAgbGVnZW5kOiB7XG4gICAgICBvcmllbnQ6ICdyaWdodCcsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgZ3JpZEFsaWduOiAnZWFjaCcsXG4gICAgICBjb2x1bW5QYWRkaW5nOiAxMCxcbiAgICAgIHJvd1BhZGRpbmc6IDIsXG4gICAgICBzeW1ib2xEaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gICAgICBncmFkaWVudERpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgIGdyYWRpZW50TGVuZ3RoOiAyMDAsXG4gICAgICBncmFkaWVudFRoaWNrbmVzczogMTYsXG4gICAgICBncmFkaWVudFN0cm9rZUNvbG9yOiBsaWdodEdyYXksXG4gICAgICBncmFkaWVudFN0cm9rZVdpZHRoOiAwLFxuICAgICAgZ3JhZGllbnRMYWJlbE9mZnNldDogMixcbiAgICAgIGxhYmVsQWxpZ246ICdsZWZ0JyxcbiAgICAgIGxhYmVsQmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgbGFiZWxMaW1pdDogMTYwLFxuICAgICAgbGFiZWxPZmZzZXQ6IDQsXG4gICAgICBsYWJlbE92ZXJsYXA6IHRydWUsXG4gICAgICBzeW1ib2xMaW1pdDogMzAsXG4gICAgICBzeW1ib2xUeXBlOiAnY2lyY2xlJyxcbiAgICAgIHN5bWJvbFNpemU6IDEwMCxcbiAgICAgIHN5bWJvbE9mZnNldDogMCxcbiAgICAgIHN5bWJvbFN0cm9rZVdpZHRoOiAxLjUsXG4gICAgICBzeW1ib2xCYXNlRmlsbENvbG9yOiAndHJhbnNwYXJlbnQnLFxuICAgICAgc3ltYm9sQmFzZVN0cm9rZUNvbG9yOiBncmF5LFxuICAgICAgdGl0bGVMaW1pdDogMTgwLFxuICAgICAgdGl0bGVPcmllbnQ6ICd0b3AnLFxuICAgICAgdGl0bGVQYWRkaW5nOiA1LFxuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIG9mZnNldDogMTgsXG4gICAgICAgIGRpcmVjdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnXG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgZGlyZWN0aW9uOiAndmVydGljYWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciBzY2FsZSByYW5nZXNcbiAgICByYW5nZToge1xuICAgICAgY2F0ZWdvcnk6IHtcbiAgICAgICAgc2NoZW1lOiAndGFibGVhdTEwJ1xuICAgICAgfSxcbiAgICAgIG9yZGluYWw6IHtcbiAgICAgICAgc2NoZW1lOiAnYmx1ZXMnXG4gICAgICB9LFxuICAgICAgaGVhdG1hcDoge1xuICAgICAgICBzY2hlbWU6ICd5ZWxsb3dncmVlbmJsdWUnXG4gICAgICB9LFxuICAgICAgcmFtcDoge1xuICAgICAgICBzY2hlbWU6ICdibHVlcydcbiAgICAgIH0sXG4gICAgICBkaXZlcmdpbmc6IHtcbiAgICAgICAgc2NoZW1lOiAnYmx1ZW9yYW5nZScsXG4gICAgICAgIGV4dGVudDogWzEsIDBdXG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAndHJpYW5nbGUtdXAnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS1yaWdodCcsICd0cmlhbmdsZS1kb3duJywgJ3RyaWFuZ2xlLWxlZnQnXVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2UgKHNwZWMsIGNvbmZpZywgb3B0aW9ucykge1xuICBpZiAoIWlzT2JqZWN0KHNwZWMpKSB7XG4gICAgZXJyb3IoJ0lucHV0IFZlZ2Egc3BlY2lmaWNhdGlvbiBtdXN0IGJlIGFuIG9iamVjdC4nKTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKGRlZmF1bHRzKCksIGNvbmZpZywgc3BlYy5jb25maWcpO1xuICByZXR1cm4gcGFyc2VWaWV3KHNwZWMsIG5ldyBTY29wZShjb25maWcsIG9wdGlvbnMpKS50b1J1bnRpbWUoKTtcbn1cblxuZXhwb3J0IHsgQXhpc0RvbWFpblJvbGUsIEF4aXNHcmlkUm9sZSwgQXhpc0xhYmVsUm9sZSwgQXhpc1JvbGUsIEF4aXNUaWNrUm9sZSwgQXhpc1RpdGxlUm9sZSwgRGF0YVNjb3BlLCBGcmFtZVJvbGUsIExlZ2VuZEVudHJ5Um9sZSwgTGVnZW5kTGFiZWxSb2xlLCBMZWdlbmRSb2xlLCBMZWdlbmRTeW1ib2xSb2xlLCBMZWdlbmRUaXRsZVJvbGUsIE1hcmtSb2xlLCBTY29wZSwgU2NvcGVSb2xlLCBkZWZhdWx0cyBhcyBjb25maWcsIHBhcnNlLCBwYXJzZVNpZ25hbCBhcyBzaWduYWwsIHBhcnNlU2lnbmFsVXBkYXRlcyBhcyBzaWduYWxVcGRhdGVzLCBwYXJzZVN0cmVhbSBhcyBzdHJlYW0gfTtcbiIsImltcG9ydCB7IGdlb1BhdGgsIGdlb0FsYmVycywgZ2VvQWxiZXJzVXNhLCBnZW9BemltdXRoYWxFcXVhbEFyZWEsIGdlb0F6aW11dGhhbEVxdWlkaXN0YW50LCBnZW9Db25pY0NvbmZvcm1hbCwgZ2VvQ29uaWNFcXVhbEFyZWEsIGdlb0NvbmljRXF1aWRpc3RhbnQsIGdlb0VxdWFsRWFydGgsIGdlb0VxdWlyZWN0YW5ndWxhciwgZ2VvR25vbW9uaWMsIGdlb0lkZW50aXR5LCBnZW9NZXJjYXRvciwgZ2VvTmF0dXJhbEVhcnRoMSwgZ2VvT3J0aG9ncmFwaGljLCBnZW9TdGVyZW9ncmFwaGljLCBnZW9UcmFuc3ZlcnNlTWVyY2F0b3IgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgZ2VvTW9sbHdlaWRlIH0gZnJvbSAnZDMtZ2VvLXByb2plY3Rpb24nO1xuXG5jb25zdCBkZWZhdWx0UGF0aCA9IGdlb1BhdGgoKTtcbmNvbnN0IHByb2plY3Rpb25Qcm9wZXJ0aWVzID0gWy8vIHN0YW5kYXJkIHByb3BlcnRpZXMgaW4gZDMtZ2VvXG4nY2xpcEFuZ2xlJywgJ2NsaXBFeHRlbnQnLCAnc2NhbGUnLCAndHJhbnNsYXRlJywgJ2NlbnRlcicsICdyb3RhdGUnLCAncGFyYWxsZWxzJywgJ3ByZWNpc2lvbicsICdyZWZsZWN0WCcsICdyZWZsZWN0WScsIC8vIGV4dGVuZGVkIHByb3BlcnRpZXMgaW4gZDMtZ2VvLXByb2plY3Rpb25zXG4nY29lZmZpY2llbnQnLCAnZGlzdGFuY2UnLCAnZnJhY3Rpb24nLCAnbG9iZXMnLCAncGFyYWxsZWwnLCAncmFkaXVzJywgJ3JhdGlvJywgJ3NwYWNpbmcnLCAndGlsdCddO1xuLyoqXG4gKiBBdWdtZW50IHByb2plY3Rpb25zIHdpdGggdGhlaXIgdHlwZSBhbmQgYSBjb3B5IG1ldGhvZC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgY29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3Rpb24oKSB7XG4gICAgY29uc3QgcCA9IGNvbnN0cnVjdG9yKCk7XG4gICAgcC50eXBlID0gdHlwZTtcbiAgICBwLnBhdGggPSBnZW9QYXRoKCkucHJvamVjdGlvbihwKTtcblxuICAgIHAuY29weSA9IHAuY29weSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBjID0gcHJvamVjdGlvbigpO1xuICAgICAgcHJvamVjdGlvblByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKHBbcHJvcF0pIGNbcHJvcF0ocFtwcm9wXSgpKTtcbiAgICAgIH0pO1xuICAgICAgYy5wYXRoLnBvaW50UmFkaXVzKHAucGF0aC5wb2ludFJhZGl1cygpKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGlvbih0eXBlLCBwcm9qKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Rpb24gdHlwZSBtdXN0IGJlIGEgbmFtZSBzdHJpbmcuJyk7XG4gIH1cblxuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHByb2plY3Rpb25zW3R5cGVdID0gY3JlYXRlKHR5cGUsIHByb2opO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcm9qZWN0aW9uc1t0eXBlXSB8fCBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQcm9qZWN0aW9uUGF0aChwcm9qKSB7XG4gIHJldHVybiBwcm9qICYmIHByb2oucGF0aCB8fCBkZWZhdWx0UGF0aDtcbn1cbmNvbnN0IHByb2plY3Rpb25zID0ge1xuICAvLyBiYXNlIGQzLWdlbyBwcm9qZWN0aW9uIHR5cGVzXG4gIGFsYmVyczogZ2VvQWxiZXJzLFxuICBhbGJlcnN1c2E6IGdlb0FsYmVyc1VzYSxcbiAgYXppbXV0aGFsZXF1YWxhcmVhOiBnZW9BemltdXRoYWxFcXVhbEFyZWEsXG4gIGF6aW11dGhhbGVxdWlkaXN0YW50OiBnZW9BemltdXRoYWxFcXVpZGlzdGFudCxcbiAgY29uaWNjb25mb3JtYWw6IGdlb0NvbmljQ29uZm9ybWFsLFxuICBjb25pY2VxdWFsYXJlYTogZ2VvQ29uaWNFcXVhbEFyZWEsXG4gIGNvbmljZXF1aWRpc3RhbnQ6IGdlb0NvbmljRXF1aWRpc3RhbnQsXG4gIGVxdWFsRWFydGg6IGdlb0VxdWFsRWFydGgsXG4gIGVxdWlyZWN0YW5ndWxhcjogZ2VvRXF1aXJlY3Rhbmd1bGFyLFxuICBnbm9tb25pYzogZ2VvR25vbW9uaWMsXG4gIGlkZW50aXR5OiBnZW9JZGVudGl0eSxcbiAgbWVyY2F0b3I6IGdlb01lcmNhdG9yLFxuICBtb2xsd2VpZGU6IGdlb01vbGx3ZWlkZSxcbiAgbmF0dXJhbEVhcnRoMTogZ2VvTmF0dXJhbEVhcnRoMSxcbiAgb3J0aG9ncmFwaGljOiBnZW9PcnRob2dyYXBoaWMsXG4gIHN0ZXJlb2dyYXBoaWM6IGdlb1N0ZXJlb2dyYXBoaWMsXG4gIHRyYW5zdmVyc2VtZXJjYXRvcjogZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yXG59O1xuXG5mb3IgKGNvbnN0IGtleSBpbiBwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9uKGtleSwgcHJvamVjdGlvbnNba2V5XSk7XG59XG5cbmV4cG9ydCB7IGdldFByb2plY3Rpb25QYXRoLCBwcm9qZWN0aW9uLCBwcm9qZWN0aW9uUHJvcGVydGllcyB9O1xuIiwiaW1wb3J0IHsgcmVncmVzc2lvbkxvZXNzLCBzYW1wbGVDdXJ2ZSwgcmVncmVzc2lvbkxpbmVhciwgcmVncmVzc2lvbkxvZywgcmVncmVzc2lvbkV4cCwgcmVncmVzc2lvblBvdywgcmVncmVzc2lvblF1YWQsIHJlZ3Jlc3Npb25Qb2x5IH0gZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmltcG9ydCB7IFRyYW5zZm9ybSwgaW5nZXN0IH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cywgYWNjZXNzb3JOYW1lLCBoYXNPd25Qcm9wZXJ0eSwgZXJyb3IsIGV4dGVudCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbiAoZGF0YSwgZ3JvdXBieSkge1xuICB2YXIgZ3JvdXBzID0gW10sXG4gICAgICBnZXQgPSBmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBmKHQpO1xuICB9LFxuICAgICAgbWFwLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0LFxuICAgICAgayxcbiAgICAgIGc7IC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuXG5cbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobWFwID0ge30sIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSBkYXRhW2ldO1xuICAgICAgayA9IGdyb3VwYnkubWFwKGdldCk7XG4gICAgICBnID0gbWFwW2tdO1xuXG4gICAgICBpZiAoIWcpIHtcbiAgICAgICAgbWFwW2tdID0gZyA9IFtdO1xuICAgICAgICBnLmRpbXMgPSBrO1xuICAgICAgICBncm91cHMucHVzaChnKTtcbiAgICAgIH1cblxuICAgICAgZy5wdXNoKHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncm91cHM7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBsb2NhbGx5LXdlaWdodGVkIHJlZ3Jlc3Npb24gZml0cyBmb3Igb25lIG9yIG1vcmUgZGF0YSBncm91cHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLnggLSBBbiBhY2Nlc3NvciBmb3IgdGhlIHByZWRpY3RvciBkYXRhIGZpZWxkLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueSAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdGVkIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5iYW5kd2lkdGg9MC4zXSAtIFRoZSBsb2VzcyBiYW5kd2lkdGguXG4gKi9cblxuZnVuY3Rpb24gTG9lc3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Mb2Vzcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMb2VzcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjNcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhMb2VzcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKCkgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgICAgICBuYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICAgICAgbSA9IG5hbWVzLmxlbmd0aCxcbiAgICAgICAgICAgIGFzID0gXy5hcyB8fCBbYWNjZXNzb3JOYW1lKF8ueCksIGFjY2Vzc29yTmFtZShfLnkpXSxcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICAgIHJlZ3Jlc3Npb25Mb2VzcyhnLCBfLngsIF8ueSwgXy5iYW5kd2lkdGggfHwgMC4zKS5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB7fTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICB0W25hbWVzW2ldXSA9IGcuZGltc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0W2FzWzBdXSA9IHBbMF07XG4gICAgICAgICAgdFthc1sxXV0gPSBwWzFdO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgTWV0aG9kcyA9IHtcbiAgbGluZWFyOiByZWdyZXNzaW9uTGluZWFyLFxuICBsb2c6IHJlZ3Jlc3Npb25Mb2csXG4gIGV4cDogcmVncmVzc2lvbkV4cCxcbiAgcG93OiByZWdyZXNzaW9uUG93LFxuICBxdWFkOiByZWdyZXNzaW9uUXVhZCxcbiAgcG9seTogcmVncmVzc2lvblBvbHlcbn07XG5cbmNvbnN0IGRlZ3JlZXNPZkZyZWVkb20gPSAobWV0aG9kLCBvcmRlcikgPT4gbWV0aG9kID09PSAncG9seScgPyBvcmRlciA6IG1ldGhvZCA9PT0gJ3F1YWQnID8gMiA6IDE7XG4vKipcbiAqIENvbXB1dGUgcmVncmVzc2lvbiBmaXRzIGZvciBvbmUgb3IgbW9yZSBkYXRhIGdyb3Vwcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdG9yIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy55IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0ZWQgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1ldGhvZD0nbGluZWFyJ10gLSBUaGUgcmVncmVzc2lvbiBtZXRob2QgdG8gYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuZXh0ZW50XSAtIFRoZSBkb21haW4gZXh0ZW50IG92ZXIgd2hpY2ggdG8gcGxvdCB0aGUgcmVncmVzc2lvbiBsaW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMub3JkZXI9M10gLSBUaGUgcG9seW5vbWlhbCBvcmRlci4gT25seSBhcHBsaWVzIHRvIHRoZSAncG9seScgbWV0aG9kLlxuICovXG5cblxuZnVuY3Rpb24gUmVncmVzc2lvbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblJlZ3Jlc3Npb24uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUmVncmVzc2lvbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtZXRob2QnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnbGluZWFyJyxcbiAgICAndmFsdWVzJzogT2JqZWN0LmtleXMoTWV0aG9kcylcbiAgfSwge1xuICAgICduYW1lJzogJ29yZGVyJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogM1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3BhcmFtcycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKFJlZ3Jlc3Npb24sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24oc291cmNlLCBfLmdyb3VwYnkpLFxuICAgICAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAgICAgIG1ldGhvZCA9IF8ubWV0aG9kIHx8ICdsaW5lYXInLFxuICAgICAgICAgICAgb3JkZXIgPSBfLm9yZGVyIHx8IDMsXG4gICAgICAgICAgICBkb2YgPSBkZWdyZWVzT2ZGcmVlZG9tKG1ldGhvZCwgb3JkZXIpLFxuICAgICAgICAgICAgYXMgPSBfLmFzIHx8IFthY2Nlc3Nvck5hbWUoXy54KSwgYWNjZXNzb3JOYW1lKF8ueSldLFxuICAgICAgICAgICAgZml0ID0gTWV0aG9kc1ttZXRob2RdLFxuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBsZXQgZG9tYWluID0gXy5leHRlbnQ7XG5cbiAgICAgIGlmICghaGFzT3duUHJvcGVydHkoTWV0aG9kcywgbWV0aG9kKSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCByZWdyZXNzaW9uIG1ldGhvZDogJyArIG1ldGhvZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkb21haW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSAnbG9nJyAmJiBkb21haW5bMF0gPD0gMCkge1xuICAgICAgICAgIHB1bHNlLmRhdGFmbG93Lndhcm4oJ0lnbm9yaW5nIGV4dGVudCB3aXRoIHZhbHVlcyA8PSAwIGZvciBsb2cgcmVncmVzc2lvbi4nKTtcbiAgICAgICAgICBkb21haW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdyb3Vwcy5mb3JFYWNoKGcgPT4ge1xuICAgICAgICBjb25zdCBuID0gZy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG4gPD0gZG9mKSB7XG4gICAgICAgICAgcHVsc2UuZGF0YWZsb3cud2FybignU2tpcHBpbmcgcmVncmVzc2lvbiB3aXRoIG1vcmUgcGFyYW1ldGVycyB0aGFuIGRhdGEgcG9pbnRzLicpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gZml0KGcsIF8ueCwgXy55LCBvcmRlcik7XG5cbiAgICAgICAgaWYgKF8ucGFyYW1zKSB7XG4gICAgICAgICAgLy8gaWYgcGFyYW1ldGVyIHZlY3RvcnMgcmVxdWVzdGVkIHJldHVybiB0aG9zZVxuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh7XG4gICAgICAgICAgICBrZXlzOiBnLmRpbXMsXG4gICAgICAgICAgICBjb2VmOiBtb2RlbC5jb2VmLFxuICAgICAgICAgICAgclNxdWFyZWQ6IG1vZGVsLnJTcXVhcmVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRvbSA9IGRvbWFpbiB8fCBleHRlbnQoZywgXy54KSxcbiAgICAgICAgICAgICAgYWRkID0gcCA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdFtuYW1lc1tpXV0gPSBnLmRpbXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFthc1swXV0gPSBwWzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gcFsxXTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3QodCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdsaW5lYXInKSB7XG4gICAgICAgICAgLy8gZm9yIGxpbmVhciByZWdyZXNzaW9uIHdlIG9ubHkgbmVlZCB0aGUgZW5kIHBvaW50c1xuICAgICAgICAgIGRvbS5mb3JFYWNoKHggPT4gYWRkKFt4LCBtb2RlbC5wcmVkaWN0KHgpXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSByZXR1cm4gdHJlbmQgbGluZSBzYW1wbGUgcG9pbnRzXG4gICAgICAgICAgc2FtcGxlQ3VydmUobW9kZWwucHJlZGljdCwgZG9tLCAyNSwgMjAwKS5mb3JFYWNoKGFkZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmV4cG9ydCB7IExvZXNzIGFzIGxvZXNzLCBSZWdyZXNzaW9uIGFzIHJlZ3Jlc3Npb24gfTtcbiIsImltcG9ydCB7IHRvU2V0LCBzdHJpbmdWYWx1ZSwgZXJyb3IsIGlzQXJyYXksIGlzT2JqZWN0LCBoYXNPd25Qcm9wZXJ0eSwgYWNjZXNzb3IsIGtleSwgZmllbGQsIGFycmF5LCBjb21wYXJlLCB0cnV0aHkgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgdHVwbGVpZCB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuXG4vKipcbiAqIFBhcnNlIGEgc2VyaWFsaXplZCBkYXRhZmxvdyBzcGVjaWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3BlYykge1xuICBjb25zdCBjdHggPSB0aGlzLFxuICAgICAgICBvcGVyYXRvcnMgPSBzcGVjLm9wZXJhdG9ycyB8fCBbXTsgLy8gcGFyc2UgYmFja2dyb3VuZFxuXG4gIGlmIChzcGVjLmJhY2tncm91bmQpIHtcbiAgICBjdHguYmFja2dyb3VuZCA9IHNwZWMuYmFja2dyb3VuZDtcbiAgfSAvLyBwYXJzZSBldmVudCBjb25maWd1cmF0aW9uXG5cblxuICBpZiAoc3BlYy5ldmVudENvbmZpZykge1xuICAgIGN0eC5ldmVudENvbmZpZyA9IHNwZWMuZXZlbnRDb25maWc7XG4gIH0gLy8gcGFyc2UgbG9jYWxlIGNvbmZpZ3VyYXRpb25cblxuXG4gIGlmIChzcGVjLmxvY2FsZSkge1xuICAgIGN0eC5sb2NhbGUgPSBzcGVjLmxvY2FsZTtcbiAgfSAvLyBwYXJzZSBvcGVyYXRvcnNcblxuXG4gIG9wZXJhdG9ycy5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZU9wZXJhdG9yKGVudHJ5KSk7IC8vIHBhcnNlIG9wZXJhdG9yIHBhcmFtZXRlcnNcblxuICBvcGVyYXRvcnMuZm9yRWFjaChlbnRyeSA9PiBjdHgucGFyc2VPcGVyYXRvclBhcmFtZXRlcnMoZW50cnkpKTsgLy8gcGFyc2Ugc3RyZWFtc1xuXG4gIChzcGVjLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZW50cnkgPT4gY3R4LnBhcnNlU3RyZWFtKGVudHJ5KSk7IC8vIHBhcnNlIHVwZGF0ZXNcblxuICAoc3BlYy51cGRhdGVzIHx8IFtdKS5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZVVwZGF0ZShlbnRyeSkpO1xuICByZXR1cm4gY3R4LnJlc29sdmUoKTtcbn1cblxuY29uc3QgU2tpcCA9IHRvU2V0KFsncnVsZSddKSxcbiAgICAgIFN3YXAgPSB0b1NldChbJ2dyb3VwJywgJ2ltYWdlJywgJ3JlY3QnXSk7XG5mdW5jdGlvbiBhZGp1c3RTcGF0aWFsKGVuY29kZSwgbWFya3R5cGUpIHtcbiAgbGV0IGNvZGUgPSAnJztcbiAgaWYgKFNraXBbbWFya3R5cGVdKSByZXR1cm4gY29kZTtcblxuICBpZiAoZW5jb2RlLngyKSB7XG4gICAgaWYgKGVuY29kZS54KSB7XG4gICAgICBpZiAoU3dhcFttYXJrdHlwZV0pIHtcbiAgICAgICAgY29kZSArPSAnaWYoby54Pm8ueDIpJD1vLngsby54PW8ueDIsby54Mj0kOyc7XG4gICAgICB9XG5cbiAgICAgIGNvZGUgKz0gJ28ud2lkdGg9by54Mi1vLng7JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSAnby54PW8ueDItKG8ud2lkdGh8fDApOyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuY29kZS54Yykge1xuICAgIGNvZGUgKz0gJ28ueD1vLnhjLShvLndpZHRofHwwKS8yOyc7XG4gIH1cblxuICBpZiAoZW5jb2RlLnkyKSB7XG4gICAgaWYgKGVuY29kZS55KSB7XG4gICAgICBpZiAoU3dhcFttYXJrdHlwZV0pIHtcbiAgICAgICAgY29kZSArPSAnaWYoby55Pm8ueTIpJD1vLnksby55PW8ueTIsby55Mj0kOyc7XG4gICAgICB9XG5cbiAgICAgIGNvZGUgKz0gJ28uaGVpZ2h0PW8ueTItby55Oyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gJ28ueT1vLnkyLShvLmhlaWdodHx8MCk7JztcbiAgICB9XG4gIH1cblxuICBpZiAoZW5jb2RlLnljKSB7XG4gICAgY29kZSArPSAnby55PW8ueWMtKG8uaGVpZ2h0fHwwKS8yOyc7XG4gIH1cblxuICByZXR1cm4gY29kZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbFR5cGUodHlwZSkge1xuICByZXR1cm4gKHR5cGUgKyAnJykudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGlzT3BlcmF0b3IodHlwZSkge1xuICByZXR1cm4gY2Fub25pY2FsVHlwZSh0eXBlKSA9PT0gJ29wZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzQ29sbGVjdCh0eXBlKSB7XG4gIHJldHVybiBjYW5vbmljYWxUeXBlKHR5cGUpID09PSAnY29sbGVjdCc7XG59XG5cbmZ1bmN0aW9uIGV4cHJlc3Npb24oY3R4LCBhcmdzLCBjb2RlKSB7XG4gIC8vIHdyYXAgY29kZSBpbiByZXR1cm4gc3RhdGVtZW50IGlmIGV4cHJlc3Npb24gZG9lcyBub3QgdGVybWluYXRlXG4gIGlmIChjb2RlW2NvZGUubGVuZ3RoIC0gMV0gIT09ICc7Jykge1xuICAgIGNvZGUgPSAncmV0dXJuKCcgKyBjb2RlICsgJyk7JztcbiAgfVxuXG4gIGNvbnN0IGZuID0gRnVuY3Rpb24oLi4uYXJncy5jb25jYXQoY29kZSkpO1xuICByZXR1cm4gY3R4ICYmIGN0eC5mdW5jdGlvbnMgPyBmbi5iaW5kKGN0eC5mdW5jdGlvbnMpIDogZm47XG59IC8vIGdlbmVyYXRlIGNvZGUgZm9yIGNvbXBhcmluZyBhIHNpbmdsZSBmaWVsZFxuXG5cbmZ1bmN0aW9uIF9jb21wYXJlKHUsIHYsIGx0LCBndCkge1xuICByZXR1cm4gXCIoKHUgPSBcIi5jb25jYXQodSwgXCIpIDwgKHYgPSBcIikuY29uY2F0KHYsIFwiKSB8fCB1ID09IG51bGwpICYmIHYgIT0gbnVsbCA/IFwiKS5jb25jYXQobHQsIFwiXFxuICA6ICh1ID4gdiB8fCB2ID09IG51bGwpICYmIHUgIT0gbnVsbCA/IFwiKS5jb25jYXQoZ3QsIFwiXFxuICA6ICgodiA9IHYgaW5zdGFuY2VvZiBEYXRlID8gK3YgOiB2KSwgKHUgPSB1IGluc3RhbmNlb2YgRGF0ZSA/ICt1IDogdSkpICE9PSB1ICYmIHYgPT09IHYgPyBcIikuY29uY2F0KGx0LCBcIlxcbiAgOiB2ICE9PSB2ICYmIHUgPT09IHUgPyBcIikuY29uY2F0KGd0LCBcIiA6IFwiKTtcbn1cblxudmFyIGV4cHJlc3Npb25Db2RlZ2VuID0ge1xuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB1c2VkIHRvIHVwZGF0ZSBhbiBvcGVyYXRvciB2YWx1ZS5cbiAgICovXG4gIG9wZXJhdG9yOiAoY3R4LCBleHByKSA9PiBleHByZXNzaW9uKGN0eCwgWydfJ10sIGV4cHIuY29kZSksXG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gcHJvdmlkZWQgYXMgYW4gb3BlcmF0b3IgcGFyYW1ldGVyIHZhbHVlLlxuICAgKi9cbiAgcGFyYW1ldGVyOiAoY3R4LCBleHByKSA9PiBleHByZXNzaW9uKGN0eCwgWydkYXR1bScsICdfJ10sIGV4cHIuY29kZSksXG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYXBwbGllZCB0byBhbiBldmVudCBzdHJlYW0uXG4gICAqL1xuICBldmVudDogKGN0eCwgZXhwcikgPT4gZXhwcmVzc2lvbihjdHgsIFsnZXZlbnQnXSwgZXhwci5jb2RlKSxcblxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiB1c2VkIHRvIGhhbmRsZSBhbiBldmVudC1kcml2ZW4gb3BlcmF0b3IgdXBkYXRlLlxuICAgKi9cbiAgaGFuZGxlcjogKGN0eCwgZXhwcikgPT4ge1xuICAgIGNvbnN0IGNvZGUgPSBcInZhciBkYXR1bT1ldmVudC5pdGVtJiZldmVudC5pdGVtLmRhdHVtO3JldHVybiBcIi5jb25jYXQoZXhwci5jb2RlLCBcIjtcIik7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24oY3R4LCBbJ18nLCAnZXZlbnQnXSwgY29kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdGhhdCBwZXJmb3JtcyB2aXN1YWwgZW5jb2RpbmcuXG4gICAqL1xuICBlbmNvZGU6IChjdHgsIGVuY29kZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcmt0eXBlLFxuICAgICAgY2hhbm5lbHNcbiAgICB9ID0gZW5jb2RlO1xuICAgIGxldCBjb2RlID0gJ3ZhciBvPWl0ZW0sZGF0dW09by5kYXR1bSxtPTAsJDsnO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIGNoYW5uZWxzKSB7XG4gICAgICBjb25zdCBvID0gJ29bJyArIHN0cmluZ1ZhbHVlKG5hbWUpICsgJ10nO1xuICAgICAgY29kZSArPSBcIiQ9XCIuY29uY2F0KGNoYW5uZWxzW25hbWVdLmNvZGUsIFwiO2lmKFwiKS5jb25jYXQobywgXCIhPT0kKVwiKS5jb25jYXQobywgXCI9JCxtPTE7XCIpO1xuICAgIH1cblxuICAgIGNvZGUgKz0gYWRqdXN0U3BhdGlhbChjaGFubmVscywgbWFya3R5cGUpO1xuICAgIGNvZGUgKz0gJ3JldHVybiBtOyc7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24oY3R4LCBbJ2l0ZW0nLCAnXyddLCBjb2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogT3B0aW1pemVkIGNvZGUgZ2VuZXJhdG9ycyBmb3IgYWNjZXNzIGFuZCBjb21wYXJpc29uLlxuICAgKi9cbiAgY29kZWdlbjoge1xuICAgIGdldChwYXRoKSB7XG4gICAgICBjb25zdCByZWYgPSBcIltcIi5jb25jYXQocGF0aC5tYXAoc3RyaW5nVmFsdWUpLmpvaW4oJ11bJyksIFwiXVwiKTtcbiAgICAgIGNvbnN0IGdldCA9IEZ1bmN0aW9uKCdfJywgXCJyZXR1cm4gX1wiLmNvbmNhdChyZWYsIFwiO1wiKSk7XG4gICAgICBnZXQucGF0aCA9IHJlZjtcbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSxcblxuICAgIGNvbXBhcmF0b3IoZmllbGRzLCBvcmRlcnMpIHtcbiAgICAgIGxldCB0O1xuXG4gICAgICBjb25zdCBtYXAgPSAoZiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBvID0gb3JkZXJzW2ldO1xuICAgICAgICBsZXQgdSwgdjtcblxuICAgICAgICBpZiAoZi5wYXRoKSB7XG4gICAgICAgICAgdSA9IFwiYVwiLmNvbmNhdChmLnBhdGgpO1xuICAgICAgICAgIHYgPSBcImJcIi5jb25jYXQoZi5wYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAodCA9IHQgfHwge30pWydmJyArIGldID0gZjtcbiAgICAgICAgICB1ID0gXCJ0aGlzLmZcIi5jb25jYXQoaSwgXCIoYSlcIik7XG4gICAgICAgICAgdiA9IFwidGhpcy5mXCIuY29uY2F0KGksIFwiKGIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb21wYXJlKHUsIHYsIC1vLCBvKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGZuID0gRnVuY3Rpb24oJ2EnLCAnYicsICd2YXIgdSwgdjsgcmV0dXJuICcgKyBmaWVsZHMubWFwKG1hcCkuam9pbignJykgKyAnMDsnKTtcbiAgICAgIHJldHVybiB0ID8gZm4uYmluZCh0KSA6IGZuO1xuICAgIH1cblxuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgZGF0YWZsb3cgb3BlcmF0b3IuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VPcGVyYXRvcihzcGVjKSB7XG4gIGNvbnN0IGN0eCA9IHRoaXM7XG5cbiAgaWYgKGlzT3BlcmF0b3Ioc3BlYy50eXBlKSB8fCAhc3BlYy50eXBlKSB7XG4gICAgY3R4Lm9wZXJhdG9yKHNwZWMsIHNwZWMudXBkYXRlID8gY3R4Lm9wZXJhdG9yRXhwcmVzc2lvbihzcGVjLnVwZGF0ZSkgOiBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudHJhbnNmb3JtKHNwZWMsIHNwZWMudHlwZSk7XG4gIH1cbn1cbi8qKlxuICogUGFyc2UgYW5kIGFzc2lnbiBvcGVyYXRvciBwYXJhbWV0ZXJzLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlT3BlcmF0b3JQYXJhbWV0ZXJzKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcztcblxuICBpZiAoc3BlYy5wYXJhbXMpIHtcbiAgICBjb25zdCBvcCA9IGN0eC5nZXQoc3BlYy5pZCk7XG4gICAgaWYgKCFvcCkgZXJyb3IoJ0ludmFsaWQgb3BlcmF0b3IgaWQ6ICcgKyBzcGVjLmlkKTtcbiAgICBjdHguZGF0YWZsb3cuY29ubmVjdChvcCwgb3AucGFyYW1ldGVycyhjdHgucGFyc2VQYXJhbWV0ZXJzKHNwZWMucGFyYW1zKSwgc3BlYy5yZWFjdCwgc3BlYy5pbml0b25seSkpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBzZXQgb2Ygb3BlcmF0b3IgcGFyYW1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoc3BlYywgcGFyYW1zKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgY29uc3QgY3R4ID0gdGhpcztcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzcGVjKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzcGVjW2tleV07XG4gICAgcGFyYW1zW2tleV0gPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IHBhcnNlUGFyYW1ldGVyKHYsIGN0eCwgcGFyYW1zKSkgOiBwYXJzZVBhcmFtZXRlcih2YWx1ZSwgY3R4LCBwYXJhbXMpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHNwZWMsIGN0eCwgcGFyYW1zKSB7XG4gIGlmICghc3BlYyB8fCAhaXNPYmplY3Qoc3BlYykpIHJldHVybiBzcGVjO1xuXG4gIGZvciAobGV0IGkgPSAwLCBuID0gUEFSU0VSUy5sZW5ndGgsIHA7IGkgPCBuOyArK2kpIHtcbiAgICBwID0gUEFSU0VSU1tpXTtcblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShzcGVjLCBwLmtleSkpIHtcbiAgICAgIHJldHVybiBwLnBhcnNlKHNwZWMsIGN0eCwgcGFyYW1zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3BlYztcbn1cbi8qKiBSZWZlcmVuY2UgcGFyc2Vycy4gKi9cblxuXG52YXIgUEFSU0VSUyA9IFt7XG4gIGtleTogJyRyZWYnLFxuICBwYXJzZTogZ2V0T3BlcmF0b3Jcbn0sIHtcbiAga2V5OiAnJGtleScsXG4gIHBhcnNlOiBnZXRLZXlcbn0sIHtcbiAga2V5OiAnJGV4cHInLFxuICBwYXJzZTogZ2V0RXhwcmVzc2lvblxufSwge1xuICBrZXk6ICckZmllbGQnLFxuICBwYXJzZTogZ2V0RmllbGRcbn0sIHtcbiAga2V5OiAnJGVuY29kZScsXG4gIHBhcnNlOiBnZXRFbmNvZGVcbn0sIHtcbiAga2V5OiAnJGNvbXBhcmUnLFxuICBwYXJzZTogZ2V0Q29tcGFyZVxufSwge1xuICBrZXk6ICckY29udGV4dCcsXG4gIHBhcnNlOiBnZXRDb250ZXh0XG59LCB7XG4gIGtleTogJyRzdWJmbG93JyxcbiAgcGFyc2U6IGdldFN1YmZsb3dcbn0sIHtcbiAga2V5OiAnJHR1cGxlaWQnLFxuICBwYXJzZTogZ2V0VHVwbGVJZFxufV07XG4vKipcbiAqIFJlc29sdmUgYW4gb3BlcmF0b3IgcmVmZXJlbmNlLlxuICovXG5cbmZ1bmN0aW9uIGdldE9wZXJhdG9yKF8sIGN0eCkge1xuICByZXR1cm4gY3R4LmdldChfLiRyZWYpIHx8IGVycm9yKCdPcGVyYXRvciBub3QgZGVmaW5lZDogJyArIF8uJHJlZik7XG59XG4vKipcbiAqIFJlc29sdmUgYW4gZXhwcmVzc2lvbiByZWZlcmVuY2UuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFeHByZXNzaW9uKF8sIGN0eCwgcGFyYW1zKSB7XG4gIGlmIChfLiRwYXJhbXMpIHtcbiAgICAvLyBwYXJzZSBleHByZXNzaW9uIHBhcmFtZXRlcnNcbiAgICBjdHgucGFyc2VQYXJhbWV0ZXJzKF8uJHBhcmFtcywgcGFyYW1zKTtcbiAgfVxuXG4gIGNvbnN0IGsgPSAnZTonICsgXy4kZXhwci5jb2RlICsgJ18nICsgXy4kbmFtZTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gYWNjZXNzb3IoY3R4LnBhcmFtZXRlckV4cHJlc3Npb24oXy4kZXhwciksIF8uJGZpZWxkcywgXy4kbmFtZSkpO1xufVxuLyoqXG4gKiBSZXNvbHZlIGEga2V5IGFjY2Vzc29yIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEtleShfLCBjdHgpIHtcbiAgY29uc3QgayA9ICdrOicgKyBfLiRrZXkgKyAnXycgKyAhIV8uJGZsYXQ7XG4gIHJldHVybiBjdHguZm5ba10gfHwgKGN0eC5mbltrXSA9IGtleShfLiRrZXksIF8uJGZsYXQsIGN0eC5leHByLmNvZGVnZW4pKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhIGZpZWxkIGFjY2Vzc29yIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEZpZWxkKF8sIGN0eCkge1xuICBpZiAoIV8uJGZpZWxkKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgayA9ICdmOicgKyBfLiRmaWVsZCArICdfJyArIF8uJG5hbWU7XG4gIHJldHVybiBjdHguZm5ba10gfHwgKGN0eC5mbltrXSA9IGZpZWxkKF8uJGZpZWxkLCBfLiRuYW1lLCBjdHguZXhwci5jb2RlZ2VuKSk7XG59XG4vKipcbiAqIFJlc29sdmUgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBhcmUoXywgY3R4KSB7XG4gIC8vIEFzIG9mIFZlZ2EgNS41LjMsICR0dXBsZWlkIHNvcnQgaXMgbm8gbG9uZ2VyIHVzZWQuXG4gIC8vIEtlZXAgaGVyZSBmb3Igbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgY29uc3QgayA9ICdjOicgKyBfLiRjb21wYXJlICsgJ18nICsgXy4kb3JkZXIsXG4gICAgICAgIGMgPSBhcnJheShfLiRjb21wYXJlKS5tYXAoXyA9PiBfICYmIF8uJHR1cGxlaWQgPyB0dXBsZWlkIDogXyk7XG4gIHJldHVybiBjdHguZm5ba10gfHwgKGN0eC5mbltrXSA9IGNvbXBhcmUoYywgXy4kb3JkZXIsIGN0eC5leHByLmNvZGVnZW4pKTtcbn1cbi8qKlxuICogUmVzb2x2ZSBhbiBlbmNvZGUgb3BlcmF0b3IgcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RW5jb2RlKF8sIGN0eCkge1xuICBjb25zdCBzcGVjID0gXy4kZW5jb2RlLFxuICAgICAgICBlbmNvZGUgPSB7fTtcblxuICBmb3IgKGNvbnN0IG5hbWUgaW4gc3BlYykge1xuICAgIGNvbnN0IGVuYyA9IHNwZWNbbmFtZV07XG4gICAgZW5jb2RlW25hbWVdID0gYWNjZXNzb3IoY3R4LmVuY29kZUV4cHJlc3Npb24oZW5jLiRleHByKSwgZW5jLiRmaWVsZHMpO1xuICAgIGVuY29kZVtuYW1lXS5vdXRwdXQgPSBlbmMuJG91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBlbmNvZGU7XG59XG4vKipcbiAqIFJlc29sdmUgYSBjb250ZXh0IHJlZmVyZW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbnRleHQoXywgY3R4KSB7XG4gIHJldHVybiBjdHg7XG59XG4vKipcbiAqIFJlc29sdmUgYSByZWN1cnNpdmUgc3ViZmxvdyBzcGVjaWZpY2F0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3ViZmxvdyhfLCBjdHgpIHtcbiAgY29uc3Qgc3BlYyA9IF8uJHN1YmZsb3c7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YWZsb3csIGtleSwgcGFyZW50KSB7XG4gICAgY29uc3Qgc3ViY3R4ID0gY3R4LmZvcmsoKS5wYXJzZShzcGVjKSxcbiAgICAgICAgICBvcCA9IHN1YmN0eC5nZXQoc3BlYy5vcGVyYXRvcnNbMF0uaWQpLFxuICAgICAgICAgIHAgPSBzdWJjdHguc2lnbmFscy5wYXJlbnQ7XG4gICAgaWYgKHApIHAuc2V0KHBhcmVudCk7XG5cbiAgICBvcC5kZXRhY2hTdWJmbG93ID0gKCkgPT4gY3R4LmRldGFjaChzdWJjdHgpO1xuXG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuLyoqXG4gKiBSZXNvbHZlIGEgdHVwbGUgaWQgcmVmZXJlbmNlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0VHVwbGVJZCgpIHtcbiAgcmV0dXJuIHR1cGxlaWQ7XG59XG5cbi8qKlxuICogUGFyc2UgYW4gZXZlbnQgc3RyZWFtIHNwZWNpZmljYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJlYW0gKHNwZWMpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgICBmaWx0ZXIgPSBzcGVjLmZpbHRlciAhPSBudWxsID8gY3R4LmV2ZW50RXhwcmVzc2lvbihzcGVjLmZpbHRlcikgOiB1bmRlZmluZWQsXG4gICAgICBzdHJlYW0gPSBzcGVjLnN0cmVhbSAhPSBudWxsID8gY3R4LmdldChzcGVjLnN0cmVhbSkgOiB1bmRlZmluZWQsXG4gICAgICBhcmdzO1xuXG4gIGlmIChzcGVjLnNvdXJjZSkge1xuICAgIHN0cmVhbSA9IGN0eC5ldmVudHMoc3BlYy5zb3VyY2UsIHNwZWMudHlwZSwgZmlsdGVyKTtcbiAgfSBlbHNlIGlmIChzcGVjLm1lcmdlKSB7XG4gICAgYXJncyA9IHNwZWMubWVyZ2UubWFwKF8gPT4gY3R4LmdldChfKSk7XG4gICAgc3RyZWFtID0gYXJnc1swXS5tZXJnZS5hcHBseShhcmdzWzBdLCBhcmdzLnNsaWNlKDEpKTtcbiAgfVxuXG4gIGlmIChzcGVjLmJldHdlZW4pIHtcbiAgICBhcmdzID0gc3BlYy5iZXR3ZWVuLm1hcChfID0+IGN0eC5nZXQoXykpO1xuICAgIHN0cmVhbSA9IHN0cmVhbS5iZXR3ZWVuKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICB9XG5cbiAgaWYgKHNwZWMuZmlsdGVyKSB7XG4gICAgc3RyZWFtID0gc3RyZWFtLmZpbHRlcihmaWx0ZXIpO1xuICB9XG5cbiAgaWYgKHNwZWMudGhyb3R0bGUgIT0gbnVsbCkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS50aHJvdHRsZSgrc3BlYy50aHJvdHRsZSk7XG4gIH1cblxuICBpZiAoc3BlYy5kZWJvdW5jZSAhPSBudWxsKSB7XG4gICAgc3RyZWFtID0gc3RyZWFtLmRlYm91bmNlKCtzcGVjLmRlYm91bmNlKTtcbiAgfVxuXG4gIGlmIChzdHJlYW0gPT0gbnVsbCkge1xuICAgIGVycm9yKCdJbnZhbGlkIHN0cmVhbSBkZWZpbml0aW9uOiAnICsgSlNPTi5zdHJpbmdpZnkoc3BlYykpO1xuICB9XG5cbiAgaWYgKHNwZWMuY29uc3VtZSkgc3RyZWFtLmNvbnN1bWUodHJ1ZSk7XG4gIGN0eC5zdHJlYW0oc3BlYywgc3RyZWFtKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBldmVudC1kcml2ZW4gb3BlcmF0b3IgdXBkYXRlLlxuICovXG5cbmZ1bmN0aW9uIHBhcnNlVXBkYXRlIChzcGVjKSB7XG4gIHZhciBjdHggPSB0aGlzLFxuICAgICAgc3JjaWQgPSBpc09iamVjdChzcmNpZCA9IHNwZWMuc291cmNlKSA/IHNyY2lkLiRyZWYgOiBzcmNpZCxcbiAgICAgIHNvdXJjZSA9IGN0eC5nZXQoc3JjaWQpLFxuICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgIHVwZGF0ZSA9IHNwZWMudXBkYXRlLFxuICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICBpZiAoIXNvdXJjZSkgZXJyb3IoJ1NvdXJjZSBub3QgZGVmaW5lZDogJyArIHNwZWMuc291cmNlKTtcbiAgdGFyZ2V0ID0gc3BlYy50YXJnZXQgJiYgc3BlYy50YXJnZXQuJGV4cHIgPyBjdHguZXZlbnRFeHByZXNzaW9uKHNwZWMudGFyZ2V0LiRleHByKSA6IGN0eC5nZXQoc3BlYy50YXJnZXQpO1xuXG4gIGlmICh1cGRhdGUgJiYgdXBkYXRlLiRleHByKSB7XG4gICAgaWYgKHVwZGF0ZS4kcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBjdHgucGFyc2VQYXJhbWV0ZXJzKHVwZGF0ZS4kcGFyYW1zKTtcbiAgICB9XG5cbiAgICB1cGRhdGUgPSBjdHguaGFuZGxlckV4cHJlc3Npb24odXBkYXRlLiRleHByKTtcbiAgfVxuXG4gIGN0eC51cGRhdGUoc3BlYywgc291cmNlLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zKTtcbn1cblxuY29uc3QgU0tJUCA9IHtcbiAgc2tpcDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgICBzdGF0ZSA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnNpZ25hbHMpIHtcbiAgICB2YXIgc2lnbmFscyA9IHN0YXRlLnNpZ25hbHMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjdHguc2lnbmFscykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3Qgb3AgPSBjdHguc2lnbmFsc1trZXldO1xuXG4gICAgICBpZiAob3B0aW9ucy5zaWduYWxzKGtleSwgb3ApKSB7XG4gICAgICAgIHNpZ25hbHNba2V5XSA9IG9wLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgIHZhciBkYXRhID0gc3RhdGUuZGF0YSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGN0eC5kYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gY3R4LmRhdGFba2V5XTtcblxuICAgICAgaWYgKG9wdGlvbnMuZGF0YShrZXksIGRhdGFzZXQpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGRhdGFzZXQuaW5wdXQudmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY3R4LnN1YmNvbnRleHQgJiYgb3B0aW9ucy5yZWN1cnNlICE9PSBmYWxzZSkge1xuICAgIHN0YXRlLnN1YmNvbnRleHQgPSBjdHguc3ViY29udGV4dC5tYXAoY3R4ID0+IGN0eC5nZXRTdGF0ZShvcHRpb25zKSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICAgIGRmID0gY3R4LmRhdGFmbG93LFxuICAgICAgZGF0YSA9IHN0YXRlLmRhdGEsXG4gICAgICBzaWduYWxzID0gc3RhdGUuc2lnbmFscztcbiAgT2JqZWN0LmtleXMoc2lnbmFscyB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGRmLnVwZGF0ZShjdHguc2lnbmFsc1trZXldLCBzaWduYWxzW2tleV0sIFNLSVApO1xuICB9KTtcbiAgT2JqZWN0LmtleXMoZGF0YSB8fCB7fSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGRmLnB1bHNlKGN0eC5kYXRhW2tleV0uaW5wdXQsIGRmLmNoYW5nZXNldCgpLnJlbW92ZSh0cnV0aHkpLmluc2VydChkYXRhW2tleV0pKTtcbiAgfSk7XG4gIChzdGF0ZS5zdWJjb250ZXh0IHx8IFtdKS5mb3JFYWNoKChzdWJzdGF0ZSwgaSkgPT4ge1xuICAgIGNvbnN0IHN1YmN0eCA9IGN0eC5zdWJjb250ZXh0W2ldO1xuICAgIGlmIChzdWJjdHgpIHN1YmN0eC5zZXRTdGF0ZShzdWJzdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnRleHQgb2JqZWN0cyBzdG9yZSB0aGUgY3VycmVudCBwYXJzZSBzdGF0ZS5cbiAqIEVuYWJsZXMgbG9va3VwIG9mIHBhcnNlZCBvcGVyYXRvcnMsIGV2ZW50IHN0cmVhbXMsIGFjY2Vzc29ycywgZXRjLlxuICogUHJvdmlkZXMgYSAnZm9yaycgbWV0aG9kIGZvciBjcmVhdGluZyBjaGlsZCBjb250ZXh0cyBmb3Igc3ViZmxvd3MuXG4gKi9cblxuZnVuY3Rpb24gY29udGV4dCAoZGYsIHRyYW5zZm9ybXMsIGZ1bmN0aW9ucywgZXhwcikge1xuICByZXR1cm4gbmV3IENvbnRleHQoZGYsIHRyYW5zZm9ybXMsIGZ1bmN0aW9ucywgZXhwcik7XG59XG5cbmZ1bmN0aW9uIENvbnRleHQoZGYsIHRyYW5zZm9ybXMsIGZ1bmN0aW9ucywgZXhwcikge1xuICB0aGlzLmRhdGFmbG93ID0gZGY7XG4gIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXM7XG4gIHRoaXMuZXZlbnRzID0gZGYuZXZlbnRzLmJpbmQoZGYpO1xuICB0aGlzLmV4cHIgPSBleHByIHx8IGV4cHJlc3Npb25Db2RlZ2VuLCB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgdGhpcy5ub2RlcyA9IHt9O1xuICB0aGlzLmRhdGEgPSB7fTtcbiAgdGhpcy5mbiA9IHt9O1xuXG4gIGlmIChmdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IE9iamVjdC5jcmVhdGUoZnVuY3Rpb25zKTtcbiAgICB0aGlzLmZ1bmN0aW9ucy5jb250ZXh0ID0gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBTdWJjb250ZXh0KGN0eCkge1xuICB0aGlzLmRhdGFmbG93ID0gY3R4LmRhdGFmbG93O1xuICB0aGlzLnRyYW5zZm9ybXMgPSBjdHgudHJhbnNmb3JtcztcbiAgdGhpcy5ldmVudHMgPSBjdHguZXZlbnRzO1xuICB0aGlzLmV4cHIgPSBjdHguZXhwcjtcbiAgdGhpcy5zaWduYWxzID0gT2JqZWN0LmNyZWF0ZShjdHguc2lnbmFscyk7XG4gIHRoaXMuc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShjdHguc2NhbGVzKTtcbiAgdGhpcy5ub2RlcyA9IE9iamVjdC5jcmVhdGUoY3R4Lm5vZGVzKTtcbiAgdGhpcy5kYXRhID0gT2JqZWN0LmNyZWF0ZShjdHguZGF0YSk7XG4gIHRoaXMuZm4gPSBPYmplY3QuY3JlYXRlKGN0eC5mbik7XG5cbiAgaWYgKGN0eC5mdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IE9iamVjdC5jcmVhdGUoY3R4LmZ1bmN0aW9ucyk7XG4gICAgdGhpcy5mdW5jdGlvbnMuY29udGV4dCA9IHRoaXM7XG4gIH1cbn1cblxuQ29udGV4dC5wcm90b3R5cGUgPSBTdWJjb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgZm9yaygpIHtcbiAgICBjb25zdCBjdHggPSBuZXcgU3ViY29udGV4dCh0aGlzKTtcbiAgICAodGhpcy5zdWJjb250ZXh0IHx8ICh0aGlzLnN1YmNvbnRleHQgPSBbXSkpLnB1c2goY3R4KTtcbiAgICByZXR1cm4gY3R4O1xuICB9LFxuXG4gIGRldGFjaChjdHgpIHtcbiAgICB0aGlzLnN1YmNvbnRleHQgPSB0aGlzLnN1YmNvbnRleHQuZmlsdGVyKGMgPT4gYyAhPT0gY3R4KTsgLy8gZGlzY29ubmVjdCBhbGwgbm9kZXMgaW4gdGhlIHN1YmNvbnRleHRcbiAgICAvLyB3aXBlIG91dCB0YXJnZXRzIGZpcnN0IGZvciBiZXR0ZXIgZWZmaWNpZW5jeVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN0eC5ub2Rlcyk7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSBjdHgubm9kZXNba2V5XS5fdGFyZ2V0cyA9IG51bGw7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSBjdHgubm9kZXNba2V5XS5kZXRhY2goKTtcblxuICAgIGN0eC5ub2RlcyA9IG51bGw7XG4gIH0sXG5cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXNbaWRdO1xuICB9LFxuXG4gIHNldChpZCwgbm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzW2lkXSA9IG5vZGU7XG4gIH0sXG5cbiAgYWRkKHNwZWMsIG9wKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcyxcbiAgICAgICAgICBkZiA9IGN0eC5kYXRhZmxvdyxcbiAgICAgICAgICBkYXRhID0gc3BlYy52YWx1ZTtcbiAgICBjdHguc2V0KHNwZWMuaWQsIG9wKTtcblxuICAgIGlmIChpc0NvbGxlY3Qoc3BlYy50eXBlKSAmJiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS4kaW5nZXN0KSB7XG4gICAgICAgIGRmLmluZ2VzdChvcCwgZGF0YS4kaW5nZXN0LCBkYXRhLiRmb3JtYXQpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLiRyZXF1ZXN0KSB7XG4gICAgICAgIGRmLnByZWxvYWQob3AsIGRhdGEuJHJlcXVlc3QsIGRhdGEuJGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZi5wdWxzZShvcCwgZGYuY2hhbmdlc2V0KCkuaW5zZXJ0KGRhdGEpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3BlYy5yb290KSB7XG4gICAgICBjdHgucm9vdCA9IG9wO1xuICAgIH1cblxuICAgIGlmIChzcGVjLnBhcmVudCkge1xuICAgICAgbGV0IHAgPSBjdHguZ2V0KHNwZWMucGFyZW50LiRyZWYpO1xuXG4gICAgICBpZiAocCkge1xuICAgICAgICBkZi5jb25uZWN0KHAsIFtvcF0pO1xuICAgICAgICBvcC50YXJnZXRzKCkuYWRkKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGN0eC51bnJlc29sdmVkID0gY3R4LnVucmVzb2x2ZWQgfHwgW10pLnB1c2goKCkgPT4ge1xuICAgICAgICAgIHAgPSBjdHguZ2V0KHNwZWMucGFyZW50LiRyZWYpO1xuICAgICAgICAgIGRmLmNvbm5lY3QocCwgW29wXSk7XG4gICAgICAgICAgb3AudGFyZ2V0cygpLmFkZChwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwZWMuc2lnbmFsKSB7XG4gICAgICBjdHguc2lnbmFsc1tzcGVjLnNpZ25hbF0gPSBvcDtcbiAgICB9XG5cbiAgICBpZiAoc3BlYy5zY2FsZSkge1xuICAgICAgY3R4LnNjYWxlc1tzcGVjLnNjYWxlXSA9IG9wO1xuICAgIH1cblxuICAgIGlmIChzcGVjLmRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzcGVjLmRhdGEpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhW25hbWVdIHx8IChjdHguZGF0YVtuYW1lXSA9IHt9KTtcbiAgICAgICAgc3BlYy5kYXRhW25hbWVdLmZvckVhY2gocm9sZSA9PiBkYXRhW3JvbGVdID0gb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZXNvbHZlKCkge1xuICAgICh0aGlzLnVucmVzb2x2ZWQgfHwgW10pLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgZGVsZXRlIHRoaXMudW5yZXNvbHZlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvcGVyYXRvcihzcGVjLCB1cGRhdGUpIHtcbiAgICB0aGlzLmFkZChzcGVjLCB0aGlzLmRhdGFmbG93LmFkZChzcGVjLnZhbHVlLCB1cGRhdGUpKTtcbiAgfSxcblxuICB0cmFuc2Zvcm0oc3BlYywgdHlwZSkge1xuICAgIHRoaXMuYWRkKHNwZWMsIHRoaXMuZGF0YWZsb3cuYWRkKHRoaXMudHJhbnNmb3Jtc1tjYW5vbmljYWxUeXBlKHR5cGUpXSkpO1xuICB9LFxuXG4gIHN0cmVhbShzcGVjLCBzdHJlYW0pIHtcbiAgICB0aGlzLnNldChzcGVjLmlkLCBzdHJlYW0pO1xuICB9LFxuXG4gIHVwZGF0ZShzcGVjLCBzdHJlYW0sIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMpIHtcbiAgICB0aGlzLmRhdGFmbG93Lm9uKHN0cmVhbSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgc3BlYy5vcHRpb25zKTtcbiAgfSxcblxuICAvLyBleHByZXNzaW9uIHBhcnNpbmdcbiAgb3BlcmF0b3JFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLm9wZXJhdG9yKHRoaXMsIGV4cHIpO1xuICB9LFxuXG4gIHBhcmFtZXRlckV4cHJlc3Npb24oZXhwcikge1xuICAgIHJldHVybiB0aGlzLmV4cHIucGFyYW1ldGVyKHRoaXMsIGV4cHIpO1xuICB9LFxuXG4gIGV2ZW50RXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5ldmVudCh0aGlzLCBleHByKTtcbiAgfSxcblxuICBoYW5kbGVyRXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5oYW5kbGVyKHRoaXMsIGV4cHIpO1xuICB9LFxuXG4gIGVuY29kZUV4cHJlc3Npb24oZW5jb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5lbmNvZGUodGhpcywgZW5jb2RlKTtcbiAgfSxcblxuICAvLyBwYXJzZSBtZXRob2RzXG4gIHBhcnNlLFxuICBwYXJzZU9wZXJhdG9yLFxuICBwYXJzZU9wZXJhdG9yUGFyYW1ldGVycyxcbiAgcGFyc2VQYXJhbWV0ZXJzLFxuICBwYXJzZVN0cmVhbSxcbiAgcGFyc2VVcGRhdGUsXG4gIC8vIHN0YXRlIG1ldGhvZHNcbiAgZ2V0U3RhdGUsXG4gIHNldFN0YXRlXG59O1xuXG5leHBvcnQgeyBjb250ZXh0IH07XG4iLCJpbXBvcnQgeyB0b051bWJlciwgcGVlaywgaGFzT3duUHJvcGVydHksIHRvU2V0LCBhcnJheSwgY29uc3RhbnQsIGlzTnVtYmVyLCBzcGFuLCBpc09iamVjdCwgaXNTdHJpbmcsIGVycm9yLCBpc0FycmF5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGJpc2VjdFJpZ2h0LCByYW5nZSwgYmlzZWN0IH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgc2NhbGVPcmRpbmFsLCB0aWNrRm9ybWF0IGFzIHRpY2tGb3JtYXQkMSwgc2NhbGVJZGVudGl0eSwgc2NhbGVMaW5lYXIsIHNjYWxlTG9nLCBzY2FsZVBvdywgc2NhbGVTcXJ0LCBzY2FsZVN5bWxvZywgc2NhbGVUaW1lLCBzY2FsZVV0Yywgc2NhbGVTZXF1ZW50aWFsLCBzY2FsZVNlcXVlbnRpYWxMb2csIHNjYWxlU2VxdWVudGlhbFBvdywgc2NhbGVTZXF1ZW50aWFsU3FydCwgc2NhbGVTZXF1ZW50aWFsU3ltbG9nLCBzY2FsZURpdmVyZ2luZywgc2NhbGVEaXZlcmdpbmdMb2csIHNjYWxlRGl2ZXJnaW5nUG93LCBzY2FsZURpdmVyZ2luZ1NxcnQsIHNjYWxlRGl2ZXJnaW5nU3ltbG9nLCBzY2FsZVF1YW50aWxlLCBzY2FsZVF1YW50aXplLCBzY2FsZVRocmVzaG9sZCB9IGZyb20gJ2QzLXNjYWxlJztcbmV4cG9ydCB7IHNjYWxlSW1wbGljaXQgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgKiBhcyAkIGZyb20gJ2QzLWludGVycG9sYXRlJztcbmltcG9ydCB7IHBpZWNld2lzZSB9IGZyb20gJ2QzLWludGVycG9sYXRlJztcbmltcG9ydCB7IHRpbWVJbnRlcnZhbCwgdXRjSW50ZXJ2YWwgfSBmcm9tICd2ZWdhLXRpbWUnO1xuXG5mdW5jdGlvbiBiYW5kU3BhY2UgKGNvdW50LCBwYWRkaW5nSW5uZXIsIHBhZGRpbmdPdXRlcikge1xuICBjb25zdCBzcGFjZSA9IGNvdW50IC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMjtcbiAgcmV0dXJuIGNvdW50ID8gc3BhY2UgPiAwID8gc3BhY2UgOiAxIDogMDtcbn1cblxuY29uc3QgSWRlbnRpdHkgPSAnaWRlbnRpdHknO1xuY29uc3QgTGluZWFyID0gJ2xpbmVhcic7XG5jb25zdCBMb2cgPSAnbG9nJztcbmNvbnN0IFBvdyA9ICdwb3cnO1xuY29uc3QgU3FydCA9ICdzcXJ0JztcbmNvbnN0IFN5bWxvZyA9ICdzeW1sb2cnO1xuY29uc3QgVGltZSA9ICd0aW1lJztcbmNvbnN0IFVUQyA9ICd1dGMnO1xuY29uc3QgU2VxdWVudGlhbCA9ICdzZXF1ZW50aWFsJztcbmNvbnN0IERpdmVyZ2luZyA9ICdkaXZlcmdpbmcnO1xuY29uc3QgUXVhbnRpbGUgPSAncXVhbnRpbGUnO1xuY29uc3QgUXVhbnRpemUgPSAncXVhbnRpemUnO1xuY29uc3QgVGhyZXNob2xkID0gJ3RocmVzaG9sZCc7XG5jb25zdCBPcmRpbmFsID0gJ29yZGluYWwnO1xuY29uc3QgUG9pbnQgPSAncG9pbnQnO1xuY29uc3QgQmFuZCA9ICdiYW5kJztcbmNvbnN0IEJpbk9yZGluYWwgPSAnYmluLW9yZGluYWwnOyAvLyBjYXRlZ29yaWVzXG5cbmNvbnN0IENvbnRpbnVvdXMgPSAnY29udGludW91cyc7XG5jb25zdCBEaXNjcmV0ZSA9ICdkaXNjcmV0ZSc7XG5jb25zdCBEaXNjcmV0aXppbmcgPSAnZGlzY3JldGl6aW5nJztcbmNvbnN0IEludGVycG9sYXRpbmcgPSAnaW50ZXJwb2xhdGluZyc7XG5jb25zdCBUZW1wb3JhbCA9ICd0ZW1wb3JhbCc7XG5cbmZ1bmN0aW9uIGludmVydFJhbmdlIChzY2FsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKF8pIHtcbiAgICBsZXQgbG8gPSBfWzBdLFxuICAgICAgICBoaSA9IF9bMV0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoaGkgPCBsbykge1xuICAgICAgdCA9IGxvO1xuICAgICAgbG8gPSBoaTtcbiAgICAgIGhpID0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NjYWxlLmludmVydChsbyksIHNjYWxlLmludmVydChoaSldO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZlcnRSYW5nZUV4dGVudCAoc2NhbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xuICAgIGxldCBsbyA9IF9bMF0sXG4gICAgICAgIGhpID0gX1sxXSxcbiAgICAgICAgbWluID0gLTEsXG4gICAgICAgIG1heCxcbiAgICAgICAgdCxcbiAgICAgICAgaSxcbiAgICAgICAgbjtcblxuICAgIGlmIChoaSA8IGxvKSB7XG4gICAgICB0ID0gbG87XG4gICAgICBsbyA9IGhpO1xuICAgICAgaGkgPSB0O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSByYW5nZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChyYW5nZVtpXSA+PSBsbyAmJiByYW5nZVtpXSA8PSBoaSkge1xuICAgICAgICBpZiAobWluIDwgMCkgbWluID0gaTtcbiAgICAgICAgbWF4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluIDwgMCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBsbyA9IHNjYWxlLmludmVydEV4dGVudChyYW5nZVttaW5dKTtcbiAgICBoaSA9IHNjYWxlLmludmVydEV4dGVudChyYW5nZVttYXhdKTtcbiAgICByZXR1cm4gW2xvWzBdID09PSB1bmRlZmluZWQgPyBsb1sxXSA6IGxvWzBdLCBoaVsxXSA9PT0gdW5kZWZpbmVkID8gaGlbMF0gOiBoaVsxXV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJhbmQoKSB7XG4gIGNvbnN0IHNjYWxlID0gc2NhbGVPcmRpbmFsKCkudW5rbm93bih1bmRlZmluZWQpLFxuICAgICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlO1xuICBsZXQgcmFuZ2UkMSA9IFswLCAxXSxcbiAgICAgIHN0ZXAsXG4gICAgICBiYW5kd2lkdGgsXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgcGFkZGluZ0lubmVyID0gMCxcbiAgICAgIHBhZGRpbmdPdXRlciA9IDAsXG4gICAgICBhbGlnbiA9IDAuNTtcbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBjb25zdCBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgICAgIHJldmVyc2UgPSByYW5nZSQxWzFdIDwgcmFuZ2UkMVswXSxcbiAgICAgICAgICBzdG9wID0gcmFuZ2UkMVsxIC0gcmV2ZXJzZV0sXG4gICAgICAgICAgc3BhY2UgPSBiYW5kU3BhY2UobiwgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIpO1xuICAgIGxldCBzdGFydCA9IHJhbmdlJDFbcmV2ZXJzZSAtIDBdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChzcGFjZSB8fCAxKTtcblxuICAgIGlmIChyb3VuZCkge1xuICAgICAgc3RlcCA9IE1hdGguZmxvb3Ioc3RlcCk7XG4gICAgfVxuXG4gICAgc3RhcnQgKz0gKHN0b3AgLSBzdGFydCAtIHN0ZXAgKiAobiAtIHBhZGRpbmdJbm5lcikpICogYWxpZ247XG4gICAgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcblxuICAgIGlmIChyb3VuZCkge1xuICAgICAgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KTtcbiAgICAgIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZXMgPSByYW5nZShuKS5tYXAoaSA9PiBzdGFydCArIHN0ZXAgKiBpKTtcbiAgICByZXR1cm4gb3JkaW5hbFJhbmdlKHJldmVyc2UgPyB2YWx1ZXMucmV2ZXJzZSgpIDogdmFsdWVzKTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGRvbWFpbihfKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkb21haW4oKTtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByYW5nZSQxID0gWytfWzBdLCArX1sxXV07XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmFuZ2UkMS5zbGljZSgpO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24gKF8pIHtcbiAgICByYW5nZSQxID0gWytfWzBdLCArX1sxXV07XG4gICAgcm91bmQgPSB0cnVlO1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH07XG5cbiAgc2NhbGUuYmFuZHdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBiYW5kd2lkdGg7XG4gIH07XG5cbiAgc2NhbGUuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcblxuICBzY2FsZS5yb3VuZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJvdW5kID0gISFfO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvdW5kO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcGFkZGluZ0lubmVyID0gcGFkZGluZ091dGVyO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmdJbm5lcjtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ0lubmVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcGFkZGluZ0lubmVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmdJbm5lcjtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ091dGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmdPdXRlcjtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUuYWxpZ24gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBhbGlnbiA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9XG4gIH07XG5cbiAgc2NhbGUuaW52ZXJ0UmFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgIC8vIGJhaWwgaWYgcmFuZ2UgaGFzIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlc1xuICAgIGlmIChfWzBdID09IG51bGwgfHwgX1sxXSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgcmV2ZXJzZSA9IHJhbmdlJDFbMV0gPCByYW5nZSQxWzBdLFxuICAgICAgICAgIHZhbHVlcyA9IHJldmVyc2UgPyBvcmRpbmFsUmFuZ2UoKS5yZXZlcnNlKCkgOiBvcmRpbmFsUmFuZ2UoKSxcbiAgICAgICAgICBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgbGV0IGxvID0gK19bMF0sXG4gICAgICAgIGhpID0gK19bMV0sXG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIHQ7IC8vIGJhaWwgaWYgZWl0aGVyIHJhbmdlIGVuZHBvaW50IGlzIGludmFsaWRcblxuICAgIGlmIChsbyAhPT0gbG8gfHwgaGkgIT09IGhpKSByZXR1cm47IC8vIG9yZGVyIHJhbmdlIGlucHV0cywgYmFpbCBpZiBvdXRzaWRlIG9mIHNjYWxlIHJhbmdlXG5cbiAgICBpZiAoaGkgPCBsbykge1xuICAgICAgdCA9IGxvO1xuICAgICAgbG8gPSBoaTtcbiAgICAgIGhpID0gdDtcbiAgICB9XG5cbiAgICBpZiAoaGkgPCB2YWx1ZXNbMF0gfHwgbG8gPiByYW5nZSQxWzEgLSByZXZlcnNlXSkgcmV0dXJuOyAvLyBiaW5hcnkgc2VhcmNoIHRvIGluZGV4IGludG8gc2NhbGUgcmFuZ2VcblxuICAgIGEgPSBNYXRoLm1heCgwLCBiaXNlY3RSaWdodCh2YWx1ZXMsIGxvKSAtIDEpO1xuICAgIGIgPSBsbyA9PT0gaGkgPyBhIDogYmlzZWN0UmlnaHQodmFsdWVzLCBoaSkgLSAxOyAvLyBpbmNyZW1lbnQgaW5kZXggYSBpZiBsbyBpcyB3aXRoaW4gcGFkZGluZyBnYXBcblxuICAgIGlmIChsbyAtIHZhbHVlc1thXSA+IGJhbmR3aWR0aCArIDFlLTEwKSArK2E7XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgLy8gbWFwICsgc3dhcFxuICAgICAgdCA9IGE7XG4gICAgICBhID0gbiAtIGI7XG4gICAgICBiID0gbiAtIHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgPiBiID8gdW5kZWZpbmVkIDogZG9tYWluKCkuc2xpY2UoYSwgYiArIDEpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzY2FsZS5pbnZlcnRSYW5nZShbXywgX10pO1xuICAgIHJldHVybiB2YWx1ZSA/IHZhbHVlWzBdIDogdmFsdWU7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmFuZCgpLmRvbWFpbihkb21haW4oKSkucmFuZ2UocmFuZ2UkMSkucm91bmQocm91bmQpLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gcmVzY2FsZSgpO1xufVxuXG5mdW5jdGlvbiBwb2ludGlzaChzY2FsZSkge1xuICBjb25zdCBjb3B5ID0gc2NhbGUuY29weTtcbiAgc2NhbGUucGFkZGluZyA9IHNjYWxlLnBhZGRpbmdPdXRlcjtcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdJbm5lcjtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHJldHVybiBwb2ludGlzaChiYW5kKCkucGFkZGluZ0lubmVyKDEpKTtcbn1cblxudmFyIG1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXA7XG5mdW5jdGlvbiBudW1iZXJzKF8pIHtcbiAgcmV0dXJuIG1hcC5jYWxsKF8sIHRvTnVtYmVyKTtcbn1cblxuY29uc3Qgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIHNjYWxlQmluT3JkaW5hbCgpIHtcbiAgbGV0IGRvbWFpbiA9IFtdLFxuICAgICAgcmFuZ2UgPSBbXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCB8fCB4ICE9PSB4ID8gdW5kZWZpbmVkIDogcmFuZ2VbKGJpc2VjdChkb21haW4sIHgpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZG9tYWluID0gbnVtYmVycyhfKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIH1cbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJhbmdlID0gc2xpY2UuY2FsbChfKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmdlLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbiAoY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiB0aWNrRm9ybWF0JDEoZG9tYWluWzBdLCBwZWVrKGRvbWFpbiksIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50LCBzcGVjaWZpZXIpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNjYWxlQmluT3JkaW5hbCgpLmRvbWFpbihzY2FsZS5kb21haW4oKSkucmFuZ2Uoc2NhbGUucmFuZ2UoKSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5jb25zdCBzY2FsZXMgPSB7fTtcbi8qKlxuICogQXVnbWVudCBzY2FsZXMgd2l0aCB0aGVpciB0eXBlIGFuZCBuZWVkZWQgaW52ZXJzZSBtZXRob2RzLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCBjb25zdHJ1Y3RvciwgbWV0YWRhdGEpIHtcbiAgY29uc3QgY3RyID0gZnVuY3Rpb24gc2NhbGUoKSB7XG4gICAgY29uc3QgcyA9IGNvbnN0cnVjdG9yKCk7XG5cbiAgICBpZiAoIXMuaW52ZXJ0UmFuZ2UpIHtcbiAgICAgIHMuaW52ZXJ0UmFuZ2UgPSBzLmludmVydCA/IGludmVydFJhbmdlKHMpIDogcy5pbnZlcnRFeHRlbnQgPyBpbnZlcnRSYW5nZUV4dGVudChzKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBzO1xuICB9O1xuXG4gIGN0ci5tZXRhZGF0YSA9IHRvU2V0KGFycmF5KG1ldGFkYXRhKSk7XG4gIHJldHVybiBjdHI7XG59XG5cbmZ1bmN0aW9uIHNjYWxlKHR5cGUsIHNjYWxlLCBtZXRhZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBzY2FsZXNbdHlwZV0gPSBjcmVhdGUodHlwZSwgc2NhbGUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNWYWxpZFNjYWxlVHlwZSh0eXBlKSA/IHNjYWxlc1t0eXBlXSA6IHVuZGVmaW5lZDtcbiAgfVxufSAvLyBpZGVudGl0eSBzY2FsZVxuXG5zY2FsZShJZGVudGl0eSwgc2NhbGVJZGVudGl0eSk7IC8vIGNvbnRpbnVvdXMgc2NhbGVzXG5cbnNjYWxlKExpbmVhciwgc2NhbGVMaW5lYXIsIENvbnRpbnVvdXMpO1xuc2NhbGUoTG9nLCBzY2FsZUxvZywgW0NvbnRpbnVvdXMsIExvZ10pO1xuc2NhbGUoUG93LCBzY2FsZVBvdywgQ29udGludW91cyk7XG5zY2FsZShTcXJ0LCBzY2FsZVNxcnQsIENvbnRpbnVvdXMpO1xuc2NhbGUoU3ltbG9nLCBzY2FsZVN5bWxvZywgQ29udGludW91cyk7XG5zY2FsZShUaW1lLCBzY2FsZVRpbWUsIFtDb250aW51b3VzLCBUZW1wb3JhbF0pO1xuc2NhbGUoVVRDLCBzY2FsZVV0YywgW0NvbnRpbnVvdXMsIFRlbXBvcmFsXSk7IC8vIHNlcXVlbnRpYWwgc2NhbGVzXG5cbnNjYWxlKFNlcXVlbnRpYWwsIHNjYWxlU2VxdWVudGlhbCwgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTsgLy8gYmFja3dhcmRzIGNvbXBhdFxuXG5zY2FsZShcIlwiLmNvbmNhdChTZXF1ZW50aWFsLCBcIi1cIikuY29uY2F0KExpbmVhciksIHNjYWxlU2VxdWVudGlhbCwgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KFNlcXVlbnRpYWwsIFwiLVwiKS5jb25jYXQoTG9nKSwgc2NhbGVTZXF1ZW50aWFsTG9nLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZywgTG9nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChTZXF1ZW50aWFsLCBcIi1cIikuY29uY2F0KFBvdyksIHNjYWxlU2VxdWVudGlhbFBvdywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KFNlcXVlbnRpYWwsIFwiLVwiKS5jb25jYXQoU3FydCksIHNjYWxlU2VxdWVudGlhbFNxcnQsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChTZXF1ZW50aWFsLCBcIi1cIikuY29uY2F0KFN5bWxvZyksIHNjYWxlU2VxdWVudGlhbFN5bWxvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTsgLy8gZGl2ZXJnaW5nIHNjYWxlc1xuXG5zY2FsZShcIlwiLmNvbmNhdChEaXZlcmdpbmcsIFwiLVwiKS5jb25jYXQoTGluZWFyKSwgc2NhbGVEaXZlcmdpbmcsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShcIlwiLmNvbmNhdChEaXZlcmdpbmcsIFwiLVwiKS5jb25jYXQoTG9nKSwgc2NhbGVEaXZlcmdpbmdMb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nLCBMb2ddKTtcbnNjYWxlKFwiXCIuY29uY2F0KERpdmVyZ2luZywgXCItXCIpLmNvbmNhdChQb3cpLCBzY2FsZURpdmVyZ2luZ1BvdywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKFwiXCIuY29uY2F0KERpdmVyZ2luZywgXCItXCIpLmNvbmNhdChTcXJ0KSwgc2NhbGVEaXZlcmdpbmdTcXJ0LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoXCJcIi5jb25jYXQoRGl2ZXJnaW5nLCBcIi1cIikuY29uY2F0KFN5bWxvZyksIHNjYWxlRGl2ZXJnaW5nU3ltbG9nLCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pOyAvLyBkaXNjcmV0aXppbmcgc2NhbGVzXG5cbnNjYWxlKFF1YW50aWxlLCBzY2FsZVF1YW50aWxlLCBbRGlzY3JldGl6aW5nLCBRdWFudGlsZV0pO1xuc2NhbGUoUXVhbnRpemUsIHNjYWxlUXVhbnRpemUsIERpc2NyZXRpemluZyk7XG5zY2FsZShUaHJlc2hvbGQsIHNjYWxlVGhyZXNob2xkLCBEaXNjcmV0aXppbmcpOyAvLyBkaXNjcmV0ZSBzY2FsZXNcblxuc2NhbGUoQmluT3JkaW5hbCwgc2NhbGVCaW5PcmRpbmFsLCBbRGlzY3JldGUsIERpc2NyZXRpemluZ10pO1xuc2NhbGUoT3JkaW5hbCwgc2NhbGVPcmRpbmFsLCBEaXNjcmV0ZSk7XG5zY2FsZShCYW5kLCBiYW5kLCBEaXNjcmV0ZSk7XG5zY2FsZShQb2ludCwgcG9pbnQsIERpc2NyZXRlKTtcbmZ1bmN0aW9uIGlzVmFsaWRTY2FsZVR5cGUodHlwZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkoc2NhbGVzLCB0eXBlKTtcbn1cblxuZnVuY3Rpb24gaGFzVHlwZShrZXksIHR5cGUpIHtcbiAgY29uc3QgcyA9IHNjYWxlc1trZXldO1xuICByZXR1cm4gcyAmJiBzLm1ldGFkYXRhW3R5cGVdO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVvdXMoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgQ29udGludW91cyk7XG59XG5mdW5jdGlvbiBpc0Rpc2NyZXRlKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIERpc2NyZXRlKTtcbn1cbmZ1bmN0aW9uIGlzRGlzY3JldGl6aW5nKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIERpc2NyZXRpemluZyk7XG59XG5mdW5jdGlvbiBpc0xvZ2FyaXRobWljKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIExvZyk7XG59XG5mdW5jdGlvbiBpc1RlbXBvcmFsKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIFRlbXBvcmFsKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJwb2xhdGluZyhrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBJbnRlcnBvbGF0aW5nKTtcbn1cbmZ1bmN0aW9uIGlzUXVhbnRpbGUoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgUXVhbnRpbGUpO1xufVxuXG5jb25zdCBzY2FsZVByb3BzID0gWydjbGFtcCcsICdiYXNlJywgJ2NvbnN0YW50JywgJ2V4cG9uZW50J107XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVJhbmdlKGludGVycG9sYXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgc3RhcnQgPSByYW5nZVswXSxcbiAgICAgICAgc3BhbiA9IHBlZWsocmFuZ2UpIC0gc3RhcnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBpbnRlcnBvbGF0b3Ioc3RhcnQgKyBpICogc3Bhbik7XG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9ycyhjb2xvcnMsIHR5cGUsIGdhbW1hKSB7XG4gIHJldHVybiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUodHlwZSB8fCAncmdiJywgZ2FtbWEpLCBjb2xvcnMpO1xufVxuZnVuY3Rpb24gcXVhbnRpemVJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yLCBjb3VudCkge1xuICBjb25zdCBzYW1wbGVzID0gbmV3IEFycmF5KGNvdW50KSxcbiAgICAgICAgbiA9IGNvdW50ICsgMTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50Oykgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcigrK2kgLyBuKTtcblxuICByZXR1cm4gc2FtcGxlcztcbn1cbmZ1bmN0aW9uIHNjYWxlQ29weShzY2FsZSkge1xuICBjb25zdCB0ID0gc2NhbGUudHlwZSxcbiAgICAgICAgcyA9IHNjYWxlLmNvcHkoKTtcbiAgcy50eXBlID0gdDtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBzY2FsZUZyYWN0aW9uKHNjYWxlJDEsIG1pbiwgbWF4KSB7XG4gIGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuICBsZXQgaSwgdCwgcztcblxuICBpZiAoIWRlbHRhIHx8ICFOdW1iZXIuaXNGaW5pdGUoZGVsdGEpKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50KDAuNSk7XG4gIH0gZWxzZSB7XG4gICAgaSA9ICh0ID0gc2NhbGUkMS50eXBlKS5pbmRleE9mKCctJyk7XG4gICAgdCA9IGkgPCAwID8gdCA6IHQuc2xpY2UoaSArIDEpO1xuICAgIHMgPSBzY2FsZSh0KSgpLmRvbWFpbihbbWluLCBtYXhdKS5yYW5nZShbMCwgMV0pO1xuICAgIHNjYWxlUHJvcHMuZm9yRWFjaChtID0+IHNjYWxlJDFbbV0gPyBzW21dKHNjYWxlJDFbbV0oKSkgOiAwKTtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUodHlwZSwgZ2FtbWEpIHtcbiAgY29uc3QgaW50ZXJwID0gJFttZXRob2QodHlwZSldO1xuICByZXR1cm4gZ2FtbWEgIT0gbnVsbCAmJiBpbnRlcnAgJiYgaW50ZXJwLmdhbW1hID8gaW50ZXJwLmdhbW1hKGdhbW1hKSA6IGludGVycDtcbn1cblxuZnVuY3Rpb24gbWV0aG9kKHR5cGUpIHtcbiAgcmV0dXJuICdpbnRlcnBvbGF0ZScgKyB0eXBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy0nKS5tYXAocyA9PiBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpKS5qb2luKCcnKTtcbn1cblxuY29uc3QgY29udGludW91cyA9IHtcbiAgYmx1ZXM6ICdjZmUxZjJiZWQ4ZWNhOGNlZTU4ZmMxZGU3NGIyZDc1YmEzY2Y0NTkyYzYzMTgxYmQyMDZmYjIxMjVjYTQwYTRhOTAnLFxuICBncmVlbnM6ICdkM2VlY2RjMGU2YmFhYmRkYTU5NGQzOTE3YmM3N2Q2MGJhNmM0NmFiNWUzMjlhNTEyMDg5NDMwZTc3MzUwMzY0MjknLFxuICBncmV5czogJ2UyZTJlMmQ0ZDRkNGM0YzRjNGIxYjFiMTlkOWQ5ZDg4ODg4ODc1NzU3NTYyNjI2MjRkNGQ0ZDM1MzUzNTFlMWUxZScsXG4gIG9yYW5nZXM6ICdmZGQ4YjNmZGM5OThmZGI4N2JmZGE1NWVmYzkyNDRmODdmMmNmMDZiMThlNDU4MGJkMTQ5MDRiOTNkMDI5ZjMzMDMnLFxuICBwdXJwbGVzOiAnZTJlMWVmZDRkNGU4YzRjNWUwYjRiM2Q2YTNhMGNjOTI4ZWMzODI3Y2I5NzU2NmFlNjg0ZWEyNWMzNjk2NTAxZjhjJyxcbiAgcmVkczogJ2ZkYzliNGZjYjQ5YWZjOWU4MGZjODc2N2ZhNzA1MWY2NTczZmVjM2YyZmRjMmEyNWM4MWIxZGIyMTIxODk3MGIxMycsXG4gIGJsdWVHcmVlbjogJ2Q1ZWZlZGMxZThlMGE3ZGRkMThiZDJiZTcwYzZhOTU4YmE5MTQ0YWQ3NzMxOWM1ZDIwODk0NjBlNzczNjAzNjQyOScsXG4gIGJsdWVQdXJwbGU6ICdjY2RkZWNiYWQwZTRhOGMyZGQ5YWIwZDQ5MTljYzk4ZDg1YmU4YjZkYjI4YTU1YTY4NzNjOTk4MjIyODc3MzBmNzEnLFxuICBncmVlbkJsdWU6ICdkM2VlY2VjNWU4YzNiMWUxYmI5YmQ4YmI4MmNlYzI2OWMyY2E1MWIyY2QzYzlmYzcyODhhYmQxNjc1YjEwYjYwYTEnLFxuICBvcmFuZ2VSZWQ6ICdmZGRjYWZmZGNmOWJmZGMxOGFmZGFkNzdmYjk1NjJmNjdkNTNlZTY1NDVlMjQ5MzJkMzJkMWViZjEzMGRhNzA0MDMnLFxuICBwdXJwbGVCbHVlOiAnZGJkYWViYzhjZWU0YjFjM2RlOTdiN2Q4N2JhY2QxNWI5ZmM5M2E5MGMwMWU3ZmI3MGI3MGFiMDU2MTk5MDQ1MjgxJyxcbiAgcHVycGxlQmx1ZUdyZWVuOiAnZGJkOGVhYzhjZWU0YjBjM2RlOTNiN2Q4NzJhY2QxNTQ5ZmM4Mzg5MmJiMWM4OGEzMDk3Zjg3MDI3MzZiMDE2MzUzJyxcbiAgcHVycGxlUmVkOiAnZGNjOWUyZDNiM2Q3Y2U5ZWNjZDE4NmMwZGE2YmIyZTE0ZGEwZTIzMTg5ZDkxZTZmYzYxMTU5YWIwNzQ5OGYwMjNhJyxcbiAgcmVkUHVycGxlOiAnZmNjZmNjZmNiZWMwZmFhOWI4Zjk4ZmFmZjU3MWE1ZWM1MzlkZGIzNjk1YzQxYjhhYTkwODgwOGQwMTc5NzAwMTc0JyxcbiAgeWVsbG93R3JlZW46ICdlNGY0YWNkMWVjYTBiOWUyOTQ5ZWQ2ODg4MGM5N2M2MmJiNmU0N2FhNWUzMjk3NTAyMDgzNDQwZTcyM2IwMzYwMzQnLFxuICB5ZWxsb3dPcmFuZ2VCcm93bjogJ2ZlZWFhMWZlZGQ4NGZlY2M2M2ZlYjc0NmZjYTAzMWY2ODkyMWViNzIxNWRiNWUwYmM1NGMwNWFiM2QwMzhmMzIwNCcsXG4gIHllbGxvd09yYW5nZVJlZDogJ2ZlZTA4N2ZlZDE2ZmZlYmQ1OWZlYTg0OWZkOTAzZWZjNzMzNWY5NTIyYmVlMzQyM2RlMWIyMGNhMGIyMmFmMDIyNScsXG4gIGJsdWVPcmFuZ2U6ICcxMzRiODUyZjc4YjM1ZGEyY2I5ZGNhZTFkMmU1ZWZmMmYwZWJmY2UwYmFmYmJmNzRlODkzMmZjNTY5MGQ5OTRhMDcnLFxuICBicm93bkJsdWVHcmVlbjogJzcwNDEwOGEwNjUxYWM3OTU0OGUzYzc4YWYzZTZjNmVlZjFlYWM5ZTllNDhlZDFjNzRkYTc5ZTE4N2E3MjAyNTE0NycsXG4gIHB1cnBsZUdyZWVuOiAnNWIxNjY3ODM0NzkyYTY3ZmI2YzlhZWQzZTZkNmU4ZWZmMGVmZDllZmQ1YWVkZGE5NzFiYjc1MzY4ZTQ5MGU1ZTI5JyxcbiAgcHVycGxlT3JhbmdlOiAnNDExNDY5NjY0Nzk2OGY4M2I3YjliNGQ2ZGFkYmViZjNlZWVhZmNlMGJhZmJiZjc0ZTg5MzJmYzU2OTBkOTk0YTA3JyxcbiAgcmVkQmx1ZTogJzhjMGQyNWJmMzYzYWRmNzQ1ZWY0YWU5MWZiZGJjOWYyZWZlZWQyZTVlZjlkY2FlMTVkYTJjYjJmNzhiMzEzNGI4NScsXG4gIHJlZEdyZXk6ICc4YzBkMjViZjM2M2FkZjc0NWVmNGFlOTFmY2RjY2JmYWY0ZjFlMmUyZTJjMGMwYzA5Njk2OTY2NDY0NjQzNDM0MzQnLFxuICB5ZWxsb3dHcmVlbkJsdWU6ICdlZmY5YmRkYmYxYjRiZGU1YjU5NGQ1Yjk2OWM1YmU0NWI0YzIyYzllYzAyMTgyYjgyMTYzYWEyMzQ3OWMxYzMxODUnLFxuICByZWRZZWxsb3dCbHVlOiAnYTUwMDI2ZDQzMjJjZjE2ZTQzZmNhYzY0ZmVkZDkwZmFmOGMxZGNmMWVjYWJkNmU4NzVhYmQwNGE3NGI0MzEzNjk1JyxcbiAgcmVkWWVsbG93R3JlZW46ICdhNTAwMjZkNDMyMmNmMTZlNDNmY2FjNjNmZWRkOGRmOWY3YWVkN2VlOGVhNGQ4NmU2NGJjNjEyMjk2NGYwMDY4MzcnLFxuICBwaW5rWWVsbG93R3JlZW46ICc4ZTAxNTJjMDI2N2VkZDcyYWRmMGIzZDZmYWRkZWRmNWYzZWZlMWYyY2FiNmRlODc4MGJiNDc0ZjkxMjUyNzY0MTknLFxuICBzcGVjdHJhbDogJzllMDE0MmQxM2M0YmYwNzA0YWZjYWM2M2ZlZGQ4ZGZiZjhiMGUwZjNhMWE5ZGRhMjY5YmRhOTQyODhiNTVlNGZhMicsXG4gIHZpcmlkaXM6ICc0NDAxNTQ0NzBlNjE0ODFhNmM0ODI1NzU0NzJmN2Q0NDNhODM0MTQ0ODczZDRlOGEzOTU2OGMzNTYwOGQzMTY4OGUyZDcwOGUyYTc4OGUyNzgxOGUyMzg4OGUyMTkxOGQxZjk4OGIxZmEwODgyMmE4ODQyYWIwN2YzNWI3Nzk0M2JmNzE1NGM1Njg2NmNjNWQ3YWQxNTE4ZmQ3NDRhNWRiMzZiY2RmMjdkMmUyMWJlOWU1MWFmZGU3MjUnLFxuICBtYWdtYTogJzAwMDAwNDA0MDQxMzBiMDkyNDE1MGUzNzIwMTE0YjJjMTE2MDNiMGY3MDRhMTA3OTU3MTU3ZTY1MWE4MDcyMWY4MTdmMjQ4MjhjMjk4MTlhMmU4MGE4MzI3ZGI2Mzc3YWM0M2M3NWQxNDI2ZmRlNDk2OGU5NTQ2MmYxNjA1ZGY3NmY1Y2ZhN2Y1ZWZjOGY2NWZlOWY2ZGZlYWY3OGZlYmY4NGZlY2U5MWZkZGVhMGZjZWRhZmZjZmRiZicsXG4gIGluZmVybm86ICcwMDAwMDQwNDAzMTMwYzA4MjYxNzBjM2IyNDBjNGYzMzBhNWY0MjBhNjg1MDBkNmM1ZDEyNmU2YjE3NmU3ODFjNmQ4NjIxNmI5MzI2NjdhMTJiNjJhZTMwNWNiYjM3NTVjNzNlNGNkMjQ2NDRkZDUxM2FlNjVjMzBlZDY5MjVmMzc3MWFmODg1MGZmYjk1MDZmY2E1MGFmY2I1MTlmYWM2MmRmNmQ2NDVmMmU2NjFmM2Y0ODRmY2ZmYTQnLFxuICBwbGFzbWE6ICcwZDA4ODcyMzA2OTAzMzA1OTc0MjAzOWQ1MDAyYTI1ZDAxYTY2YTAwYTg3ODAxYTg4NDA1YTc5MDBkYTQ5YzE3OWVhNzIxOThiMTJhOTBiYTM0ODhjMzNkODBjYjQ3NzlkMzUxNzFkYTVhNjllMTY0NjJlNzZlNWJlZDc5NTNmMjgzNGNmNjhmNDRmYTlhM2RmY2E2MzZmZGIzMmZmZWMwMjlmY2NlMjVmOWRjMjRmNWVhMjdmMGY5MjEnLFxuICBjaXZpZGlzOiAnMDAyMDUxMDAyMzU4MDAyNjVkMDAyOTYxMDEyYjY1MDQyZTY3MDgzMTY5MGQzNDZiMTEzNjZjMTYzOTZkMWMzYzZlMjEzZjZlMjY0MjZlMmM0NTZlMzE0NzZlMzc0YTZlM2M0ZDZlNDI1MDZlNDc1MzZkNGM1NjZkNTE1ODZlNTU1YjZlNWE1ZTZlNWU2MTZlNjI2NDZmNjY2NzZmNmE2YTcwNmU2ZDcxNzI3MDcxNzU3MzcyNzk3NjczN2M3OTc0N2Y3Yzc1ODI3Zjc1ODY4Mjc2ODk4NTc3OGM4ODc3OTA4Yjc4OTM4ZTc4OTY5MTc4OWE5NDc4OWU5Nzc4YTE5Yjc4YTU5ZTc3YTlhMTc3YWVhNTc1YjJhODc0YjZhYjczYmJhZjcxYzBiMjZmYzViNjZkYzliOTZhY2ViZDY4ZDNjMDY1ZDhjNDYyZGRjODVmZTJjYjVjZTdjZjU4ZWJkMzU1ZjBkNjUyZjNkYTRmZjdkZTRjZmFlMjQ5ZmNlNjQ3JyxcbiAgcmFpbmJvdzogJzZlNDBhYTg4M2ViMWE0M2RiM2JmM2NhZmQ4M2ZhNGVlNDM5NWZlNGI4M2ZmNTc2ZWZmNjY1OWZmNzg0N2ZmOGMzOGYzYTEzMGUyYjcyZmNmY2MzNmJlZTA0NGFmZjA1YjhmZjQ1NzZmZjY1YjUyZjY2NzNhZjI3ODI4ZWE4ZDFkZGZhMzE5ZDBiODFjYmVjYjIzYWJkODJmOTZlMDNkODJlMTRjNmVkYjVhNWRkMDY2NGRiZjZlNDBhYScsXG4gIHNpbmVib3c6ICdmZjQwNDBmYzU4MmFmNDcyMThlNzhkMGJkNWE3MDNiZmJmMDBhN2Q1MDM4ZGU3MGI3MmY0MTg1OGZjMmE0MGZmNDAyYWZjNTgxOGY0NzIwYmU3OGQwM2Q1YTcwMGJmYmYwM2E3ZDUwYjhkZTcxODcyZjQyYTU4ZmM0MDQwZmY1ODJhZmM3MjE4ZjQ4ZDBiZTdhNzAzZDViZjAwYmZkNTAzYTdlNzBiOGRmNDE4NzJmYzJhNThmZjQwNDAnLFxuICB0dXJibzogJzIzMTcxYjMyMjA0YTNlMmE3MTQ1MzQ5MzQ5M2VhZTRiNDljNTRhNTNkNzQ4NWVlNDQ1NjllZTQwNzRmNTNjN2ZmODM3OGFmOTMyOTVmNzJlOWZmNDJiYTllZjI4YjNlOTI2YmNlMTI1YzVkOTI1Y2RjZjI3ZDVjNjI5ZGNiYzJkZTNiMjMyZTlhNzM4ZWU5ZDNmZjM5MzQ3ZjY4OTUwZjk4MDVhZmM3NzY1ZmQ2ZTcwZmU2NjdjZmQ1ZTg4ZmM1Nzk1ZmI1MWExZjg0YmFkZjU0NWI5ZjE0MGM1ZWMzY2QwZTYzN2RhZTAzNGU0ZDkzMWVjZDEyZWY0YzkyYmZhYzAyOWZmYjYyNmZmYWQyNGZmYTIyM2ZmOTgyMWZmOGQxZmZmODIxZGZmNzcxY2ZkNmMxYWY3NjExOGYwNTYxNmU4NGIxNGRmNDExMWQ1MzgwZmNiMmYwZGMwMjYwYWI2MWYwN2FjMTgwNWEzMTMwMjliMGYwMDk1MGMwMDkxMGIwMCcsXG4gIGJyb3duczogJ2VlZGJiZGVjY2E5NmU5Yjk3YWU0YTg2NWRjOTg1NmQxODk1NGM3Nzg0Y2MwNjczZmI4NTUzNmFkNDQzMzlmMzYzMicsXG4gIHRlYWxCbHVlczogJ2JjZTRkODlkZDNkMTgxYzNjYjY1YjNjMjQ1YTJiOTM2OGZhZTM0N2RhMDMwNmE5MzJjNTk4NScsXG4gIHRlYWxzOiAnYmJkZmRmYTJkNGQ1OGFjOWM5NzViY2JiNjFiMGFmNGRhNWE0Mzc5OTk4MmI4YjhjMWU3ZjdmMTI3MjczMDA2NjY3JyxcbiAgd2FybUdyZXlzOiAnZGNkNGQwY2VjNWMxYzBiOGI0YjNhYWE3YTU5Yzk5OTg5MDhjOGI4MjdmN2U3NjczNzI2ODY2NjY1YzVhNTk1MDRlJyxcbiAgZ29sZEdyZWVuOiAnZjRkMTY2ZDVjYTYwYjZjMzVjOThiYjU5N2NiMjU3NjBhNjU2NGI5YzUzM2Y4ZjRmMzM4MzRhMjU3NzQwMTQ2YzM2JyxcbiAgZ29sZE9yYW5nZTogJ2Y0ZDE2NmY4YmU1Y2Y4YWE0Y2Y1OTgzYmYzODUyYWVmNzAxYmUyNjIxZmQ2NTMyMmM1NDkyM2IxNDIyMzllM2EyNicsXG4gIGdvbGRSZWQ6ICdmNGQxNjZmNmJlNTlmOWFhNTFmYzk2NGVmNjgzNGJlZTczNGFlNTYyNDlkYjUyNDdjZjQyNDRjNDMxNDFiNzFkM2UnLFxuICBsaWdodEdyZXlSZWQ6ICdlZmU5ZTZlMWRhZDdkNWNiYzhjOGJkYjliYmFlYTljZDk2N2RkYzdiNDNlMTVmMTlkZjQwMTFkYzAwMGInLFxuICBsaWdodEdyZXlUZWFsOiAnZTRlYWVhZDZkY2RkYzhjZWQyYjdjMmM3YTZiNGJjNjRiMGJmMjJhNmMzMjI5NWMxMWY4NWJlMTg3NmJjJyxcbiAgbGlnaHRNdWx0aTogJ2UwZjFmMmM0ZTlkMGIwZGU5ZmQwZTE4MWY2ZTA3MmY2YzA1M2YzOTkzZWY3NzQ0MGVmNGEzYycsXG4gIGxpZ2h0T3JhbmdlOiAnZjJlN2RhZjdkNWJhZjljNDk5ZmFiMTg0ZmE5YzczZjY4OTY3ZWY3ODYwZTg2NDViZGU1MTViZDQzZDViJyxcbiAgbGlnaHRUZWFsQmx1ZTogJ2UzZTllMGMwZGNjZjlhY2VjYTdhYmZjODU5YWZjMDM4OWZiOTMyOGRhZDJmN2NhMDI3NmI5NTI1NTk4OCcsXG4gIGRhcmtCbHVlOiAnMzIzMjMyMmQ0NjY4MWE1YzkzMDA3NGFmMDA4Y2JmMDVhN2NlMjVjMGRkMzhkYWVkNTBmM2ZhZmZmZmZmJyxcbiAgZGFya0dvbGQ6ICczYzNjM2M1ODRiMzc3MjVlMzQ4Yzc2MzFhZThiMmJjZmE0MjRlY2MzMWVmOWRlMzBmZmYxODRmZmZmZmYnLFxuICBkYXJrR3JlZW46ICczYTNhM2EyMTU3NDgwMDZmNGQwNDg5NDI0ODllNDI3NmIzNDBhNmM2M2RkMmQ4MzZmZmViMmNmZmZmYWEnLFxuICBkYXJrTXVsdGk6ICczNzM3MzcxZjUyODcxOTdkOGMyOWE4Njk5NWNlM2ZmZmU4MDBmZmZmZmYnLFxuICBkYXJrUmVkOiAnMzQzNDM0NzAzNjMzOWUzYzM4Y2M0MDM3ZTc1ZDFlZWM4NjIwZWVhYjI5ZjBjZTMyZmZlYjJjJ1xufTtcbmNvbnN0IGRpc2NyZXRlID0ge1xuICBjYXRlZ29yeTEwOiAnMWY3N2I0ZmY3ZjBlMmNhMDJjZDYyNzI4OTQ2N2JkOGM1NjRiZTM3N2MyN2Y3ZjdmYmNiZDIyMTdiZWNmJyxcbiAgY2F0ZWdvcnkyMDogJzFmNzdiNGFlYzdlOGZmN2YwZWZmYmI3ODJjYTAyYzk4ZGY4YWQ2MjcyOGZmOTg5Njk0NjdiZGM1YjBkNThjNTY0YmM0OWM5NGUzNzdjMmY3YjZkMjdmN2Y3ZmM3YzdjN2JjYmQyMmRiZGI4ZDE3YmVjZjllZGFlNScsXG4gIGNhdGVnb3J5MjBiOiAnMzkzYjc5NTI1NGEzNmI2ZWNmOWM5ZWRlNjM3OTM5OGNhMjUyYjVjZjZiY2VkYjljOGM2ZDMxYmQ5ZTM5ZTdiYTUyZTdjYjk0ODQzYzM5YWQ0OTRhZDY2MTZiZTc5NjljN2I0MTczYTU1MTk0Y2U2ZGJkZGU5ZWQ2JyxcbiAgY2F0ZWdvcnkyMGM6ICczMTgyYmQ2YmFlZDY5ZWNhZTFjNmRiZWZlNjU1MGRmZDhkM2NmZGFlNmJmZGQwYTIzMWEzNTQ3NGM0NzZhMWQ5OWJjN2U5YzA3NTZiYjE5ZTlhYzhiY2JkZGNkYWRhZWI2MzYzNjM5Njk2OTZiZGJkYmRkOWQ5ZDknLFxuICB0YWJsZWF1MTA6ICc0Yzc4YThmNTg1MThlNDU3NTY3MmI3YjI1NGEyNGJlZWNhM2JiMjc5YTJmZjlkYTY5ZDc1NWRiYWIwYWMnLFxuICB0YWJsZWF1MjA6ICc0Yzc4YTg5ZWNhZTlmNTg1MThmZmJmNzk1NGEyNGI4OGQyN2FiNzlhMjBmMmNmNWI0Mzk4OTQ4M2JjYjZlNDU3NTZmZjlkOTg3OTcwNmViYWIwYWNkNjcxOTVmY2JmZDJiMjc5YTJkNmE1Yzk5ZTc2NWZkOGI1YTUnLFxuICBhY2NlbnQ6ICc3ZmM5N2ZiZWFlZDRmZGMwODZmZmZmOTkzODZjYjBmMDAyN2ZiZjViMTc2NjY2NjYnLFxuICBkYXJrMjogJzFiOWU3N2Q5NWYwMjc1NzBiM2U3Mjk4YTY2YTYxZWU2YWIwMmE2NzYxZDY2NjY2NicsXG4gIHBhaXJlZDogJ2E2Y2VlMzFmNzhiNGIyZGY4YTMzYTAyY2ZiOWE5OWUzMWExY2ZkYmY2ZmZmN2YwMGNhYjJkNjZhM2Q5YWZmZmY5OWIxNTkyOCcsXG4gIHBhc3RlbDE6ICdmYmI0YWViM2NkZTNjY2ViYzVkZWNiZTRmZWQ5YTZmZmZmY2NlNWQ4YmRmZGRhZWNmMmYyZjInLFxuICBwYXN0ZWwyOiAnYjNlMmNkZmRjZGFjY2JkNWU4ZjRjYWU0ZTZmNWM5ZmZmMmFlZjFlMmNjY2NjY2NjJyxcbiAgc2V0MTogJ2U0MWExYzM3N2ViODRkYWY0YTk4NGVhM2ZmN2YwMGZmZmYzM2E2NTYyOGY3ODFiZjk5OTk5OScsXG4gIHNldDI6ICc2NmMyYTVmYzhkNjI4ZGEwY2JlNzhhYzNhNmQ4NTRmZmQ5MmZlNWM0OTRiM2IzYjMnLFxuICBzZXQzOiAnOGRkM2M3ZmZmZmIzYmViYWRhZmI4MDcyODBiMWQzZmRiNDYyYjNkZTY5ZmNjZGU1ZDlkOWQ5YmM4MGJkY2NlYmM1ZmZlZDZmJ1xufTtcblxuZnVuY3Rpb24gY29sb3JzKHBhbGV0dGUpIHtcbiAgY29uc3QgbiA9IHBhbGV0dGUubGVuZ3RoIC8gNiB8IDAsXG4gICAgICAgIGMgPSBuZXcgQXJyYXkobik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOykge1xuICAgIGNbaV0gPSAnIycgKyBwYWxldHRlLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBhcHBseShfLCBmKSB7XG4gIGZvciAoY29uc3QgayBpbiBfKSBzY2hlbWUoaywgZihfW2tdKSk7XG59XG5cbmNvbnN0IHNjaGVtZXMgPSB7fTtcbmFwcGx5KGRpc2NyZXRlLCBjb2xvcnMpO1xuYXBwbHkoY29udGludW91cywgXyA9PiBpbnRlcnBvbGF0ZUNvbG9ycyhjb2xvcnMoXykpKTtcbmZ1bmN0aW9uIHNjaGVtZShuYW1lLCBzY2hlbWUpIHtcbiAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHNjaGVtZXNbbmFtZV0gPSBzY2hlbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNjaGVtZXNbbmFtZV07XG4gIH1cbn1cblxuY29uc3QgU3ltYm9sTGVnZW5kID0gJ3N5bWJvbCc7XG5jb25zdCBEaXNjcmV0ZUxlZ2VuZCA9ICdkaXNjcmV0ZSc7XG5jb25zdCBHcmFkaWVudExlZ2VuZCA9ICdncmFkaWVudCc7XG5cbmNvbnN0IGRlZmF1bHRGb3JtYXR0ZXIgPSB2YWx1ZSA9PiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IFN0cmluZyh2KSkgOiBTdHJpbmcodmFsdWUpO1xuXG5jb25zdCBhc2NlbmRpbmcgPSAoYSwgYikgPT4gYVsxXSAtIGJbMV07XG5cbmNvbnN0IGRlc2NlbmRpbmcgPSAoYSwgYikgPT4gYlsxXSAtIGFbMV07XG4vKipcbiAqIERldGVybWluZSB0aGUgdGljayBjb3VudCBvciBpbnRlcnZhbCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gY291bnQgLSBUaGUgZGVzaXJlZCB0aWNrIGNvdW50IG9yIGludGVydmFsIHNwZWNpZmllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5TdGVwIC0gVGhlIGRlc2lyZWQgbWluaW11bSBzdGVwIGJldHdlZW4gdGljayB2YWx1ZXMuXG4gKiBAcmV0dXJuIHsqfSAtIFRoZSB0aWNrIGNvdW50IG9yIGludGVydmFsIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gdGlja0NvdW50KHNjYWxlLCBjb3VudCwgbWluU3RlcCkge1xuICBsZXQgc3RlcDtcblxuICBpZiAoaXNOdW1iZXIoY291bnQpKSB7XG4gICAgaWYgKHNjYWxlLmJpbnMpIHtcbiAgICAgIGNvdW50ID0gTWF0aC5tYXgoY291bnQsIHNjYWxlLmJpbnMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBpZiAobWluU3RlcCAhPSBudWxsKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCBNYXRoLmZsb29yKHNwYW4oc2NhbGUuZG9tYWluKCkpIC8gbWluU3RlcCB8fCAxKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2JqZWN0KGNvdW50KSkge1xuICAgIHN0ZXAgPSBjb3VudC5zdGVwO1xuICAgIGNvdW50ID0gY291bnQuaW50ZXJ2YWw7XG4gIH1cblxuICBpZiAoaXNTdHJpbmcoY291bnQpKSB7XG4gICAgY291bnQgPSBzY2FsZS50eXBlID09PSBUaW1lID8gdGltZUludGVydmFsKGNvdW50KSA6IHNjYWxlLnR5cGUgPT0gVVRDID8gdXRjSW50ZXJ2YWwoY291bnQpIDogZXJyb3IoJ09ubHkgdGltZSBhbmQgdXRjIHNjYWxlcyBhY2NlcHQgaW50ZXJ2YWwgc3RyaW5ncy4nKTtcbiAgICBpZiAoc3RlcCkgY291bnQgPSBjb3VudC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn1cbi8qKlxuICogRmlsdGVyIGEgc2V0IG9mIGNhbmRpZGF0ZSB0aWNrIHZhbHVlcywgZW5zdXJpbmcgdGhhdCBvbmx5IHRpY2sgdmFsdWVzXG4gKiB0aGF0IGxpZSB3aXRoaW4gdGhlIHNjYWxlIHJhbmdlIGFyZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHRpY2tzIC0gVGhlIGNhbmRpZGF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gY291bnQgLSBUaGUgdGljayBjb3VudCBvciBpbnRlcnZhbCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PCo+fSAtIFRoZSBmaWx0ZXJlZCB0aWNrIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZFRpY2tzKHNjYWxlLCB0aWNrcywgY291bnQpIHtcbiAgbGV0IHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgIGxvID0gcmFuZ2VbMF0sXG4gICAgICBoaSA9IHBlZWsocmFuZ2UpLFxuICAgICAgY21wID0gYXNjZW5kaW5nO1xuXG4gIGlmIChsbyA+IGhpKSB7XG4gICAgcmFuZ2UgPSBoaTtcbiAgICBoaSA9IGxvO1xuICAgIGxvID0gcmFuZ2U7XG4gICAgY21wID0gZGVzY2VuZGluZztcbiAgfVxuXG4gIGxvID0gTWF0aC5mbG9vcihsbyk7XG4gIGhpID0gTWF0aC5jZWlsKGhpKTsgLy8gZmlsdGVyIHRpY2tzIHRvIHZhbGlkIHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlXG4gIC8vIGFkZGl0aW9uYWxseSBzb3J0IHRpY2tzIGluIHJhbmdlIG9yZGVyICgjMjU3OSlcblxuICB0aWNrcyA9IHRpY2tzLm1hcCh2ID0+IFt2LCBzY2FsZSh2KV0pLmZpbHRlcihfID0+IGxvIDw9IF9bMV0gJiYgX1sxXSA8PSBoaSkuc29ydChjbXApLm1hcChfID0+IF9bMF0pO1xuXG4gIGlmIChjb3VudCA+IDAgJiYgdGlja3MubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGVuZHBvaW50cyA9IFt0aWNrc1swXSwgcGVlayh0aWNrcyldO1xuXG4gICAgd2hpbGUgKHRpY2tzLmxlbmd0aCA+IGNvdW50ICYmIHRpY2tzLmxlbmd0aCA+PSAzKSB7XG4gICAgICB0aWNrcyA9IHRpY2tzLmZpbHRlcigoXywgaSkgPT4gIShpICUgMikpO1xuICAgIH1cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPCAzKSB7XG4gICAgICB0aWNrcyA9IGVuZHBvaW50cztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG4vKipcbiAqIEdlbmVyYXRlIHRpY2sgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gc2NhbGUgYW5kIGFwcHJveGltYXRlIHRpY2sgY291bnQgb3JcbiAqIGludGVydmFsIHZhbHVlLiBJZiB0aGUgc2NhbGUgaGFzIGEgJ3RpY2tzJyBtZXRob2QsIGl0IHdpbGwgYmUgdXNlZCB0b1xuICogZ2VuZXJhdGUgdGhlIHRpY2tzLCB3aXRoIHRoZSBjb3VudCBhcmd1bWVudCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuIElmIHRoZVxuICogc2NhbGUgbGFja3MgYSAndGlja3MnIG1ldGhvZCwgdGhlIGZ1bGwgc2NhbGUgZG9tYWluIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZSAtIFRoZSBzY2FsZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFtjb3VudF0gLSBUaGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGRlc2lyZWQgdGlja3MuXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gLSBUaGUgZ2VuZXJhdGVkIHRpY2sgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHRpY2tWYWx1ZXMoc2NhbGUsIGNvdW50KSB7XG4gIHJldHVybiBzY2FsZS5iaW5zID8gdmFsaWRUaWNrcyhzY2FsZSwgc2NhbGUuYmlucykgOiBzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzKGNvdW50KSA6IHNjYWxlLmRvbWFpbigpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGxhYmVsIGZvcm1hdCBmdW5jdGlvbiBmb3IgYSBzY2FsZS4gSWYgdGhlIHNjYWxlIGhhcyBhXG4gKiAndGlja0Zvcm1hdCcgbWV0aG9kLCBpdCB3aWxsIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGZvcm1hdHRlciwgd2l0aCB0aGVcbiAqIGNvdW50IGFuZCBzcGVjaWZpZXIgYXJndW1lbnRzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzLiBJZiB0aGUgc2NhbGUgbGFja3MgYVxuICogJ3RpY2tGb3JtYXQnIG1ldGhvZCwgdGhlIHJldHVybmVkIGZvcm1hdHRlciBwZXJmb3JtcyBzaW1wbGUgc3RyaW5nIGNvZXJjaW9uLlxuICogSWYgdGhlIGlucHV0IHNjYWxlIGlzIGEgbG9nYXJpdGhtaWMgc2NhbGUgYW5kIHRoZSBmb3JtYXQgc3BlY2lmaWVyIGRvZXMgbm90XG4gKiBpbmRpY2F0ZSBhIGRlc2lyZWQgZGVjaW1hbCBwcmVjaXNpb24sIGEgc3BlY2lhbCB2YXJpYWJsZSBwcmVjaXNpb24gZm9ybWF0dGVyXG4gKiB0aGF0IGF1dG9tYXRpY2FsbHkgdHJpbXMgdHJhaWxpbmcgemVyb2VzIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGUgLSBUaGUgc2NhbGUgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIHRoZSBsYWJlbCBmb3JtYXR0ZXIuXG4gKiBAcGFyYW0geyp9IFtjb3VudF0gLSBUaGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGRlc2lyZWQgdGlja3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NwZWNpZmllcl0gLSBUaGUgZm9ybWF0IHNwZWNpZmllci4gTXVzdCBiZSBhIGxlZ2FsIGQzXG4gKiAgIHNwZWNpZmllciBzdHJpbmcgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZm9ybWF0I2Zvcm1hdFNwZWNpZmllcikgb3JcbiAqICAgdGltZSBtdWx0aS1mb3JtYXQgc3BlY2lmaWVyIG9iamVjdC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCopOnN0cmluZ30gLSBUaGUgZ2VuZXJhdGVkIGxhYmVsIGZvcm1hdHRlci5cbiAqL1xuXG5mdW5jdGlvbiB0aWNrRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIG5vU2tpcCkge1xuICBjb25zdCB0eXBlID0gc2NhbGUudHlwZTtcbiAgbGV0IGZvcm1hdCA9IGRlZmF1bHRGb3JtYXR0ZXI7XG5cbiAgaWYgKHR5cGUgPT09IFRpbWUgfHwgZm9ybWF0VHlwZSA9PT0gVGltZSkge1xuICAgIGZvcm1hdCA9IGxvY2FsZS50aW1lRm9ybWF0KHNwZWNpZmllcik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVVRDIHx8IGZvcm1hdFR5cGUgPT09IFVUQykge1xuICAgIGZvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQoc3BlY2lmaWVyKTtcbiAgfSBlbHNlIGlmIChpc0xvZ2FyaXRobWljKHR5cGUpKSB7XG4gICAgY29uc3QgdmFyZm10ID0gbG9jYWxlLmZvcm1hdEZsb2F0KHNwZWNpZmllcik7XG5cbiAgICBpZiAobm9Ta2lwIHx8IHNjYWxlLmJpbnMpIHtcbiAgICAgIGZvcm1hdCA9IHZhcmZtdDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGVzdCA9IHRpY2tMb2coc2NhbGUsIGNvdW50LCBmYWxzZSk7XG5cbiAgICAgIGZvcm1hdCA9IF8gPT4gdGVzdChfKSA/IHZhcmZtdChfKSA6ICcnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzY2FsZS50aWNrRm9ybWF0KSB7XG4gICAgLy8gaWYgZDMgc2NhbGUgaGFzIHRpY2tGb3JtYXQsIGl0IG11c3QgYmUgY29udGludW91c1xuICAgIGNvbnN0IGQgPSBzY2FsZS5kb21haW4oKTtcbiAgICBmb3JtYXQgPSBsb2NhbGUuZm9ybWF0U3BhbihkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50LCBzcGVjaWZpZXIpO1xuICB9IGVsc2UgaWYgKHNwZWNpZmllcikge1xuICAgIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXQoc3BlY2lmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiB0aWNrTG9nKHNjYWxlLCBjb3VudCwgdmFsdWVzKSB7XG4gIGNvbnN0IHRpY2tzID0gdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpLFxuICAgICAgICBiYXNlID0gc2NhbGUuYmFzZSgpLFxuICAgICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICAgIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyB0aWNrcy5sZW5ndGgpOyAvLyBhcHBseSBkMy1zY2FsZSdzIGxvZyBmb3JtYXQgZmlsdGVyIGNyaXRlcmlhXG5cbiAgY29uc3QgdGVzdCA9IGQgPT4ge1xuICAgIGxldCBpID0gZCAvIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coZCkgLyBsb2diKSk7XG4gICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgIHJldHVybiBpIDw9IGs7XG4gIH07XG5cbiAgcmV0dXJuIHZhbHVlcyA/IHRpY2tzLmZpbHRlcih0ZXN0KSA6IHRlc3Q7XG59XG5cbmNvbnN0IHN5bWJvbHMgPSB7XG4gIFtRdWFudGlsZV06ICdxdWFudGlsZXMnLFxuICBbUXVhbnRpemVdOiAndGhyZXNob2xkcycsXG4gIFtUaHJlc2hvbGRdOiAnZG9tYWluJ1xufTtcbmNvbnN0IGZvcm1hdHMgPSB7XG4gIFtRdWFudGlsZV06ICdxdWFudGlsZXMnLFxuICBbUXVhbnRpemVdOiAnZG9tYWluJ1xufTtcbmZ1bmN0aW9uIGxhYmVsVmFsdWVzKHNjYWxlLCBjb3VudCkge1xuICByZXR1cm4gc2NhbGUuYmlucyA/IGJpblZhbHVlcyhzY2FsZS5iaW5zKSA6IHNjYWxlLnR5cGUgPT09IExvZyA/IHRpY2tMb2coc2NhbGUsIGNvdW50LCB0cnVlKSA6IHN5bWJvbHNbc2NhbGUudHlwZV0gPyB0aHJlc2hvbGRWYWx1ZXMoc2NhbGVbc3ltYm9sc1tzY2FsZS50eXBlXV0oKSkgOiB0aWNrVmFsdWVzKHNjYWxlLCBjb3VudCk7XG59XG5mdW5jdGlvbiB0aHJlc2hvbGRGb3JtYXQobG9jYWxlLCBzY2FsZSwgc3BlY2lmaWVyKSB7XG4gIGNvbnN0IF8gPSBzY2FsZVtmb3JtYXRzW3NjYWxlLnR5cGVdXSgpLFxuICAgICAgICBuID0gXy5sZW5ndGg7XG5cbiAgbGV0IGQgPSBuID4gMSA/IF9bMV0gLSBfWzBdIDogX1swXSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgIGQgPSBNYXRoLm1pbihkLCBfW2ldIC0gX1tpIC0gMV0pO1xuICB9IC8vIHRpY2tDb3VudCA9IDMgdGlja3MgdGltZXMgMTAgZm9yIGluY3JlYXNlZCByZXNvbHV0aW9uXG5cblxuICByZXR1cm4gbG9jYWxlLmZvcm1hdFNwYW4oMCwgZCwgMyAqIDEwLCBzcGVjaWZpZXIpO1xufVxuXG5mdW5jdGlvbiB0aHJlc2hvbGRWYWx1ZXModGhyZXNob2xkcykge1xuICBjb25zdCB2YWx1ZXMgPSBbLUluZmluaXR5XS5jb25jYXQodGhyZXNob2xkcyk7XG4gIHZhbHVlcy5tYXggPSArSW5maW5pdHk7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIGJpblZhbHVlcyhiaW5zKSB7XG4gIGNvbnN0IHZhbHVlcyA9IGJpbnMuc2xpY2UoMCwgLTEpO1xuICB2YWx1ZXMubWF4ID0gcGVlayhiaW5zKTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuY29uc3QgaXNEaXNjcmV0ZVJhbmdlID0gc2NhbGUgPT4gc3ltYm9sc1tzY2FsZS50eXBlXSB8fCBzY2FsZS5iaW5zO1xuXG5mdW5jdGlvbiBsYWJlbEZvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgdHlwZSwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlLCBub1NraXApIHtcbiAgY29uc3QgZm9ybWF0ID0gZm9ybWF0c1tzY2FsZS50eXBlXSAmJiBmb3JtYXRUeXBlICE9PSBUaW1lICYmIGZvcm1hdFR5cGUgIT09IFVUQyA/IHRocmVzaG9sZEZvcm1hdChsb2NhbGUsIHNjYWxlLCBzcGVjaWZpZXIpIDogdGlja0Zvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlLCBub1NraXApO1xuICByZXR1cm4gdHlwZSA9PT0gU3ltYm9sTGVnZW5kICYmIGlzRGlzY3JldGVSYW5nZShzY2FsZSkgPyBmb3JtYXRSYW5nZShmb3JtYXQpIDogdHlwZSA9PT0gRGlzY3JldGVMZWdlbmQgPyBmb3JtYXREaXNjcmV0ZShmb3JtYXQpIDogZm9ybWF0UG9pbnQoZm9ybWF0KTtcbn1cblxuY29uc3QgZm9ybWF0UmFuZ2UgPSBmb3JtYXQgPT4gKHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgY29uc3QgbGltaXQgPSBnZXQoYXJyYXlbaW5kZXggKyAxXSwgZ2V0KGFycmF5Lm1heCwgK0luZmluaXR5KSksXG4gICAgICAgIGxvID0gZm9ybWF0VmFsdWUodmFsdWUsIGZvcm1hdCksXG4gICAgICAgIGhpID0gZm9ybWF0VmFsdWUobGltaXQsIGZvcm1hdCk7XG4gIHJldHVybiBsbyAmJiBoaSA/IGxvICsgJyBcXHUyMDEzICcgKyBoaSA6IGhpID8gJzwgJyArIGhpIDogJ1xcdTIyNjUgJyArIGxvO1xufTtcblxuY29uc3QgZ2V0ID0gKHZhbHVlLCBkZmx0KSA9PiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZmx0O1xuXG5jb25zdCBmb3JtYXREaXNjcmV0ZSA9IGZvcm1hdCA9PiAodmFsdWUsIGluZGV4KSA9PiBpbmRleCA/IGZvcm1hdCh2YWx1ZSkgOiBudWxsO1xuXG5jb25zdCBmb3JtYXRQb2ludCA9IGZvcm1hdCA9PiB2YWx1ZSA9PiBmb3JtYXQodmFsdWUpO1xuXG5jb25zdCBmb3JtYXRWYWx1ZSA9ICh2YWx1ZSwgZm9ybWF0KSA9PiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gZm9ybWF0KHZhbHVlKSA6IG51bGw7XG5cbmZ1bmN0aW9uIGxhYmVsRnJhY3Rpb24oc2NhbGUpIHtcbiAgY29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIGNvdW50ID0gZG9tYWluLmxlbmd0aCAtIDE7XG4gIGxldCBsbyA9ICtkb21haW5bMF0sXG4gICAgICBoaSA9ICtwZWVrKGRvbWFpbiksXG4gICAgICBzcGFuID0gaGkgLSBsbztcblxuICBpZiAoc2NhbGUudHlwZSA9PT0gVGhyZXNob2xkKSB7XG4gICAgY29uc3QgYWRqdXN0ID0gY291bnQgPyBzcGFuIC8gY291bnQgOiAwLjE7XG4gICAgbG8gLT0gYWRqdXN0O1xuICAgIGhpICs9IGFkanVzdDtcbiAgICBzcGFuID0gaGkgLSBsbztcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA9PiAodmFsdWUgLSBsbykgLyBzcGFuO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQobG9jYWxlLCBzY2FsZSwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBmb3JtYXRUeXBlIHx8IHNjYWxlLnR5cGU7IC8vIHJlcGxhY2UgYWJicmV2aWF0ZWQgdGltZSBzcGVjaWZpZXJzIHRvIGltcHJvdmUgc2NyZWVuIHJlYWRlciBleHBlcmllbmNlXG5cbiAgaWYgKGlzU3RyaW5nKHNwZWNpZmllcikgJiYgaXNUZW1wb3JhbCh0eXBlKSkge1xuICAgIHNwZWNpZmllciA9IHNwZWNpZmllci5yZXBsYWNlKC8lYS9nLCAnJUEnKS5yZXBsYWNlKC8lYi9nLCAnJUInKTtcbiAgfVxuXG4gIHJldHVybiAhc3BlY2lmaWVyICYmIHR5cGUgPT09IFRpbWUgPyBsb2NhbGUudGltZUZvcm1hdCgnJUEsICVkICVCICVZLCAlWCcpIDogIXNwZWNpZmllciAmJiB0eXBlID09PSBVVEMgPyBsb2NhbGUudXRjRm9ybWF0KCclQSwgJWQgJUIgJVksICVYIFVUQycpIDogbGFiZWxGb3JtYXQobG9jYWxlLCBzY2FsZSwgNSwgbnVsbCwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZG9tYWluQ2FwdGlvbihsb2NhbGUsIHNjYWxlLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICBjb25zdCBtYXggPSBNYXRoLm1heCgzLCBvcHQubWF4bGVuIHx8IDcpLFxuICAgICAgICBmbXQgPSBmb3JtYXQobG9jYWxlLCBzY2FsZSwgb3B0LmZvcm1hdCwgb3B0LmZvcm1hdFR5cGUpOyAvLyBpZiBzY2FsZSBicmVha3MgZG9tYWluIGludG8gYmlucywgZGVzY3JpYmUgYm91bmRhcmllc1xuXG4gIGlmIChpc0Rpc2NyZXRpemluZyhzY2FsZS50eXBlKSkge1xuICAgIGNvbnN0IHYgPSBsYWJlbFZhbHVlcyhzY2FsZSkuc2xpY2UoMSkubWFwKGZtdCksXG4gICAgICAgICAgbiA9IHYubGVuZ3RoO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChuLCBcIiBib3VuZGFyXCIpLmNvbmNhdChuID09PSAxID8gJ3knIDogJ2llcycsIFwiOiBcIikuY29uY2F0KHYuam9pbignLCAnKSk7XG4gIH0gLy8gaWYgc2NhbGUgZG9tYWluIGlzIGRpc2NyZXRlLCBsaXN0IHZhbHVlc1xuICBlbHNlIGlmIChpc0Rpc2NyZXRlKHNjYWxlLnR5cGUpKSB7XG4gICAgICBjb25zdCBkID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgICAgICBuID0gZC5sZW5ndGgsXG4gICAgICAgICAgICB2ID0gbiA+IG1heCA/IGQuc2xpY2UoMCwgbWF4IC0gMikubWFwKGZtdCkuam9pbignLCAnKSArICcsIGVuZGluZyB3aXRoICcgKyBkLnNsaWNlKC0xKS5tYXAoZm10KSA6IGQubWFwKGZtdCkuam9pbignLCAnKTtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChuLCBcIiB2YWx1ZVwiKS5jb25jYXQobiA9PT0gMSA/ICcnIDogJ3MnLCBcIjogXCIpLmNvbmNhdCh2KTtcbiAgICB9IC8vIGlmIHNjYWxlIGRvbWFpbiBpcyBjb250aW51b3VzLCBkZXNjcmliZSB2YWx1ZSByYW5nZVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkID0gc2NhbGUuZG9tYWluKCk7XG4gICAgICAgIHJldHVybiBcInZhbHVlcyBmcm9tIFwiLmNvbmNhdChmbXQoZFswXSksIFwiIHRvIFwiKS5jb25jYXQoZm10KHBlZWsoZCkpKTtcbiAgICAgIH1cbn1cblxuZXhwb3J0IHsgQmFuZCwgQmluT3JkaW5hbCwgRGlzY3JldGVMZWdlbmQsIERpdmVyZ2luZywgR3JhZGllbnRMZWdlbmQsIElkZW50aXR5LCBMaW5lYXIsIExvZywgT3JkaW5hbCwgUG9pbnQsIFBvdywgUXVhbnRpbGUsIFF1YW50aXplLCBTZXF1ZW50aWFsLCBTcXJ0LCBTeW1ib2xMZWdlbmQsIFN5bWxvZywgVGhyZXNob2xkLCBUaW1lLCBVVEMsIGJhbmRTcGFjZSwgZG9tYWluQ2FwdGlvbiwgaW50ZXJwb2xhdGUsIGludGVycG9sYXRlQ29sb3JzLCBpbnRlcnBvbGF0ZVJhbmdlLCBpc0NvbnRpbnVvdXMsIGlzRGlzY3JldGUsIGlzRGlzY3JldGl6aW5nLCBpc0ludGVycG9sYXRpbmcsIGlzTG9nYXJpdGhtaWMsIGlzUXVhbnRpbGUsIGlzVGVtcG9yYWwsIGlzVmFsaWRTY2FsZVR5cGUsIGxhYmVsRm9ybWF0LCBsYWJlbEZyYWN0aW9uLCBsYWJlbFZhbHVlcywgcXVhbnRpemVJbnRlcnBvbGF0b3IsIHNjYWxlLCBzY2FsZUNvcHksIHNjYWxlRnJhY3Rpb24sIHNjaGVtZSwgdGlja0NvdW50LCB0aWNrRm9ybWF0LCB0aWNrVmFsdWVzLCB2YWxpZFRpY2tzIH07XG4iLCJpbXBvcnQgeyBoYXNPd25Qcm9wZXJ0eSwgaXNGdW5jdGlvbiwgaW5oZXJpdHMsIHRydXRoeSwgbHJ1Q2FjaGUsIGlzQXJyYXksIGVycm9yLCB0b1NldCwgYXJyYXksIHBlZWssIGV4dGVuZCwgaXNOdW1iZXIsIGlzT2JqZWN0IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGN1cnZlQmFzaXMsIGN1cnZlQmFzaXNDbG9zZWQsIGN1cnZlQmFzaXNPcGVuLCBjdXJ2ZUJ1bmRsZSwgY3VydmVDYXJkaW5hbCwgY3VydmVDYXJkaW5hbE9wZW4sIGN1cnZlQ2FyZGluYWxDbG9zZWQsIGN1cnZlQ2F0bXVsbFJvbSwgY3VydmVDYXRtdWxsUm9tQ2xvc2VkLCBjdXJ2ZUNhdG11bGxSb21PcGVuLCBjdXJ2ZUxpbmVhciwgY3VydmVMaW5lYXJDbG9zZWQsIGN1cnZlTW9ub3RvbmVZLCBjdXJ2ZU1vbm90b25lWCwgY3VydmVOYXR1cmFsLCBjdXJ2ZVN0ZXAsIGN1cnZlU3RlcEFmdGVyLCBjdXJ2ZVN0ZXBCZWZvcmUsIGFyYyBhcyBhcmMkMiwgYXJlYSBhcyBhcmVhJDIsIGxpbmUgYXMgbGluZSQyLCBzeW1ib2wgYXMgc3ltYm9sJDIgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBwYXRoIGFzIHBhdGgkMyB9IGZyb20gJ2QzLXBhdGgnO1xuaW1wb3J0IHsgaW1hZ2UgYXMgaW1hZ2UkMSwgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuaW1wb3J0IHsgbG9hZGVyIH0gZnJvbSAndmVnYS1sb2FkZXInO1xuaW1wb3J0IHsgaXNEaXNjcmV0ZSwgZG9tYWluQ2FwdGlvbiB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuXG5sZXQgZ3JhZGllbnRfaWQgPSAwO1xuZnVuY3Rpb24gcmVzZXRTVkdHcmFkaWVudElkKCkge1xuICBncmFkaWVudF9pZCA9IDA7XG59XG5jb25zdCBwYXR0ZXJuUHJlZml4ID0gJ3BfJztcbmZ1bmN0aW9uIGlzR3JhZGllbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmdyYWRpZW50O1xufVxuZnVuY3Rpb24gZ3JhZGllbnRSZWYoZywgZGVmcywgYmFzZSkge1xuICBjb25zdCB0eXBlID0gZy5ncmFkaWVudDtcbiAgbGV0IGlkID0gZy5pZCxcbiAgICAgIHByZWZpeCA9IHR5cGUgPT09ICdyYWRpYWwnID8gcGF0dGVyblByZWZpeCA6ICcnOyAvLyBjaGVjayBpZCwgYXNzaWduIGRlZmF1bHQgdmFsdWVzIGFzIG5lZWRlZFxuXG4gIGlmICghaWQpIHtcbiAgICBpZCA9IGcuaWQgPSAnZ3JhZGllbnRfJyArIGdyYWRpZW50X2lkKys7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgIGcueDEgPSBnZXQoZy54MSwgMC41KTtcbiAgICAgIGcueTEgPSBnZXQoZy55MSwgMC41KTtcbiAgICAgIGcucjEgPSBnZXQoZy5yMSwgMCk7XG4gICAgICBnLngyID0gZ2V0KGcueDIsIDAuNSk7XG4gICAgICBnLnkyID0gZ2V0KGcueTIsIDAuNSk7XG4gICAgICBnLnIyID0gZ2V0KGcucjIsIDAuNSk7XG4gICAgICBwcmVmaXggPSBwYXR0ZXJuUHJlZml4O1xuICAgIH0gZWxzZSB7XG4gICAgICBnLngxID0gZ2V0KGcueDEsIDApO1xuICAgICAgZy55MSA9IGdldChnLnkxLCAwKTtcbiAgICAgIGcueDIgPSBnZXQoZy54MiwgMSk7XG4gICAgICBnLnkyID0gZ2V0KGcueTIsIDApO1xuICAgIH1cbiAgfSAvLyByZWdpc3RlciBkZWZpbml0aW9uXG5cblxuICBkZWZzW2lkXSA9IGc7IC8vIHJldHVybiB1cmwgcmVmZXJlbmNlXG5cbiAgcmV0dXJuICd1cmwoJyArIChiYXNlIHx8ICcnKSArICcjJyArIHByZWZpeCArIGlkICsgJyknO1xufVxuXG5mdW5jdGlvbiBnZXQodmFsLCBkZWYpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsID8gdmFsIDogZGVmO1xufVxuXG5mdW5jdGlvbiBHcmFkaWVudCAocDAsIHAxKSB7XG4gIHZhciBzdG9wcyA9IFtdLFxuICAgICAgZ3JhZGllbnQ7XG4gIHJldHVybiBncmFkaWVudCA9IHtcbiAgICBncmFkaWVudDogJ2xpbmVhcicsXG4gICAgeDE6IHAwID8gcDBbMF0gOiAwLFxuICAgIHkxOiBwMCA/IHAwWzFdIDogMCxcbiAgICB4MjogcDEgPyBwMVswXSA6IDEsXG4gICAgeTI6IHAxID8gcDFbMV0gOiAwLFxuICAgIHN0b3BzOiBzdG9wcyxcbiAgICBzdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgbG9va3VwID0ge1xuICAnYmFzaXMnOiB7XG4gICAgY3VydmU6IGN1cnZlQmFzaXNcbiAgfSxcbiAgJ2Jhc2lzLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVCYXNpc0Nsb3NlZFxuICB9LFxuICAnYmFzaXMtb3Blbic6IHtcbiAgICBjdXJ2ZTogY3VydmVCYXNpc09wZW5cbiAgfSxcbiAgJ2J1bmRsZSc6IHtcbiAgICBjdXJ2ZTogY3VydmVCdW5kbGUsXG4gICAgdGVuc2lvbjogJ2JldGEnLFxuICAgIHZhbHVlOiAwLjg1XG4gIH0sXG4gICdjYXJkaW5hbCc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXJkaW5hbCxcbiAgICB0ZW5zaW9uOiAndGVuc2lvbicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgJ2NhcmRpbmFsLW9wZW4nOiB7XG4gICAgY3VydmU6IGN1cnZlQ2FyZGluYWxPcGVuLFxuICAgIHRlbnNpb246ICd0ZW5zaW9uJyxcbiAgICB2YWx1ZTogMFxuICB9LFxuICAnY2FyZGluYWwtY2xvc2VkJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxuICAgIHRlbnNpb246ICd0ZW5zaW9uJyxcbiAgICB2YWx1ZTogMFxuICB9LFxuICAnY2F0bXVsbC1yb20nOiB7XG4gICAgY3VydmU6IGN1cnZlQ2F0bXVsbFJvbSxcbiAgICB0ZW5zaW9uOiAnYWxwaGEnLFxuICAgIHZhbHVlOiAwLjVcbiAgfSxcbiAgJ2NhdG11bGwtcm9tLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxuICAgIHRlbnNpb246ICdhbHBoYScsXG4gICAgdmFsdWU6IDAuNVxuICB9LFxuICAnY2F0bXVsbC1yb20tb3Blbic6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXRtdWxsUm9tT3BlbixcbiAgICB0ZW5zaW9uOiAnYWxwaGEnLFxuICAgIHZhbHVlOiAwLjVcbiAgfSxcbiAgJ2xpbmVhcic6IHtcbiAgICBjdXJ2ZTogY3VydmVMaW5lYXJcbiAgfSxcbiAgJ2xpbmVhci1jbG9zZWQnOiB7XG4gICAgY3VydmU6IGN1cnZlTGluZWFyQ2xvc2VkXG4gIH0sXG4gICdtb25vdG9uZSc6IHtcbiAgICBob3Jpem9udGFsOiBjdXJ2ZU1vbm90b25lWSxcbiAgICB2ZXJ0aWNhbDogY3VydmVNb25vdG9uZVhcbiAgfSxcbiAgJ25hdHVyYWwnOiB7XG4gICAgY3VydmU6IGN1cnZlTmF0dXJhbFxuICB9LFxuICAnc3RlcCc6IHtcbiAgICBjdXJ2ZTogY3VydmVTdGVwXG4gIH0sXG4gICdzdGVwLWFmdGVyJzoge1xuICAgIGN1cnZlOiBjdXJ2ZVN0ZXBBZnRlclxuICB9LFxuICAnc3RlcC1iZWZvcmUnOiB7XG4gICAgY3VydmU6IGN1cnZlU3RlcEJlZm9yZVxuICB9XG59O1xuZnVuY3Rpb24gY3VydmVzKHR5cGUsIG9yaWVudGF0aW9uLCB0ZW5zaW9uKSB7XG4gIHZhciBlbnRyeSA9IGhhc093blByb3BlcnR5KGxvb2t1cCwgdHlwZSkgJiYgbG9va3VwW3R5cGVdLFxuICAgICAgY3VydmUgPSBudWxsO1xuXG4gIGlmIChlbnRyeSkge1xuICAgIGN1cnZlID0gZW50cnkuY3VydmUgfHwgZW50cnlbb3JpZW50YXRpb24gfHwgJ3ZlcnRpY2FsJ107XG5cbiAgICBpZiAoZW50cnkudGVuc2lvbiAmJiB0ZW5zaW9uICE9IG51bGwpIHtcbiAgICAgIGN1cnZlID0gY3VydmVbZW50cnkudGVuc2lvbl0odGVuc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnZlO1xufVxuXG4vLyBQYXRoIHBhcnNpbmcgYW5kIHJlbmRlcmluZyBjb2RlIGFkYXB0ZWQgZnJvbSBmYWJyaWMuanMgLS0gVGhhbmtzIVxuY29uc3QgY21kbGVuID0ge1xuICBtOiAyLFxuICBsOiAyLFxuICBoOiAxLFxuICB2OiAxLFxuICBjOiA2LFxuICBzOiA0LFxuICBxOiA0LFxuICB0OiAyLFxuICBhOiA3XG59LFxuICAgICAgcmVnZXhwID0gWy8oW01MSFZDU1FUQVptbGh2Y3NxdGF6XSkvZywgLyMjIy8sIC8oXFwuXFxkKykoXFwuXFxkKS9nLCAvKFxcZCkoWy0rXSkvZywgL1xcc3wsfCMjIy9dO1xuZnVuY3Rpb24gcGF0aFBhcnNlIChwYXRoc3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgY3VyciwgY2h1bmtzLCBwYXJzZWQsIHBhcmFtLCBjbWQsIGxlbiwgaSwgaiwgbiwgbTsgLy8gRmlyc3QsIGJyZWFrIHBhdGggaW50byBjb21tYW5kIHNlcXVlbmNlXG5cbiAgY29uc3QgcGF0aCA9IHBhdGhzdHIuc2xpY2UoKS5yZXBsYWNlKHJlZ2V4cFswXSwgJyMjIyQxJykuc3BsaXQocmVnZXhwWzFdKS5zbGljZSgxKTsgLy8gTmV4dCwgcGFyc2UgZWFjaCBjb21tYW5kIGluIHR1cm5cblxuICBmb3IgKGkgPSAwLCBuID0gcGF0aC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjdXJyID0gcGF0aFtpXTtcbiAgICBjaHVua3MgPSBjdXJyLnNsaWNlKDEpLnRyaW0oKS5yZXBsYWNlKHJlZ2V4cFsyXSwgJyQxIyMjJDInKS5yZXBsYWNlKHJlZ2V4cFszXSwgJyQxIyMjJDInKS5zcGxpdChyZWdleHBbNF0pO1xuICAgIGNtZCA9IGN1cnIuY2hhckF0KDApO1xuICAgIHBhcnNlZCA9IFtjbWRdO1xuXG4gICAgZm9yIChqID0gMCwgbSA9IGNodW5rcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgIGlmICgocGFyYW0gPSArY2h1bmtzW2pdKSA9PT0gcGFyYW0pIHtcbiAgICAgICAgLy8gbm90IE5hTlxuICAgICAgICBwYXJzZWQucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gY21kbGVuW2NtZC50b0xvd2VyQ2FzZSgpXTtcblxuICAgIGlmIChwYXJzZWQubGVuZ3RoIC0gMSA+IGxlbikge1xuICAgICAgY29uc3QgbSA9IHBhcnNlZC5sZW5ndGg7XG4gICAgICBqID0gMTtcbiAgICAgIHJlc3VsdC5wdXNoKFtjbWRdLmNvbmNhdChwYXJzZWQuc2xpY2UoaiwgaiArPSBsZW4pKSk7IC8vIGhhbmRsZSBpbXBsaWNpdCBsaW5lVG8gKCMyODAzKVxuXG4gICAgICBjbWQgPSBjbWQgPT09ICdNJyA/ICdMJyA6IGNtZCA9PT0gJ20nID8gJ2wnIDogY21kO1xuXG4gICAgICBmb3IgKDsgaiA8IG07IGogKz0gbGVuKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtjbWRdLmNvbmNhdChwYXJzZWQuc2xpY2UoaiwgaiArIGxlbikpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5jb25zdCBEZWdUb1JhZCA9IE1hdGguUEkgLyAxODA7XG5jb25zdCBFcHNpbG9uID0gMWUtMTQ7XG5jb25zdCBIYWxmUGkgPSBNYXRoLlBJIC8gMjtcbmNvbnN0IFRhdSA9IE1hdGguUEkgKiAyO1xuY29uc3QgSGFsZlNxcnQzID0gTWF0aC5zcXJ0KDMpIC8gMjtcblxudmFyIHNlZ21lbnRDYWNoZSA9IHt9O1xudmFyIGJlemllckNhY2hlID0ge307XG52YXIgam9pbiA9IFtdLmpvaW47IC8vIENvcGllZCBmcm9tIElua3NjYXBlIHN2Z3RvcGRmLCB0aGFua3MhXG5cbmZ1bmN0aW9uIHNlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgY29uc3Qga2V5ID0gam9pbi5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgaWYgKHNlZ21lbnRDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRDYWNoZVtrZXldO1xuICB9XG5cbiAgY29uc3QgdGggPSByb3RhdGVYICogRGVnVG9SYWQ7XG4gIGNvbnN0IHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgY29uc3QgY29zX3RoID0gTWF0aC5jb3ModGgpO1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIGNvbnN0IHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgY29uc3QgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICBsZXQgcGwgPSBweCAqIHB4IC8gKHJ4ICogcngpICsgcHkgKiBweSAvIChyeSAqIHJ5KTtcblxuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG5cbiAgY29uc3QgYTAwID0gY29zX3RoIC8gcng7XG4gIGNvbnN0IGEwMSA9IHNpbl90aCAvIHJ4O1xuICBjb25zdCBhMTAgPSAtc2luX3RoIC8gcnk7XG4gIGNvbnN0IGExMSA9IGNvc190aCAvIHJ5O1xuICBjb25zdCB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIGNvbnN0IHkwID0gYTEwICogb3ggKyBhMTEgKiBveTtcbiAgY29uc3QgeDEgPSBhMDAgKiB4ICsgYTAxICogeTtcbiAgY29uc3QgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcbiAgY29uc3QgZCA9ICh4MSAtIHgwKSAqICh4MSAtIHgwKSArICh5MSAtIHkwKSAqICh5MSAtIHkwKTtcbiAgbGV0IHNmYWN0b3Jfc3EgPSAxIC8gZCAtIDAuMjU7XG4gIGlmIChzZmFjdG9yX3NxIDwgMCkgc2ZhY3Rvcl9zcSA9IDA7XG4gIGxldCBzZmFjdG9yID0gTWF0aC5zcXJ0KHNmYWN0b3Jfc3EpO1xuICBpZiAoc3dlZXAgPT0gbGFyZ2UpIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgY29uc3QgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxIC0geTApO1xuICBjb25zdCB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEgLSB4MCk7XG4gIGNvbnN0IHRoMCA9IE1hdGguYXRhbjIoeTAgLSB5YywgeDAgLSB4Yyk7XG4gIGNvbnN0IHRoMSA9IE1hdGguYXRhbjIoeTEgLSB5YywgeDEgLSB4Yyk7XG4gIGxldCB0aF9hcmMgPSB0aDEgLSB0aDA7XG5cbiAgaWYgKHRoX2FyYyA8IDAgJiYgc3dlZXAgPT09IDEpIHtcbiAgICB0aF9hcmMgKz0gVGF1O1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT09IDApIHtcbiAgICB0aF9hcmMgLT0gVGF1O1xuICB9XG5cbiAgY29uc3Qgc2VncyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoSGFsZlBpICsgMC4wMDEpKSk7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnczsgKytpKSB7XG4gICAgY29uc3QgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgY29uc3QgdGgzID0gdGgwICsgKGkgKyAxKSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnRDYWNoZVtrZXldID0gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmV6aWVyKHBhcmFtcykge1xuICBjb25zdCBrZXkgPSBqb2luLmNhbGwocGFyYW1zKTtcblxuICBpZiAoYmV6aWVyQ2FjaGVba2V5XSkge1xuICAgIHJldHVybiBiZXppZXJDYWNoZVtrZXldO1xuICB9XG5cbiAgdmFyIGN4ID0gcGFyYW1zWzBdLFxuICAgICAgY3kgPSBwYXJhbXNbMV0sXG4gICAgICB0aDAgPSBwYXJhbXNbMl0sXG4gICAgICB0aDEgPSBwYXJhbXNbM10sXG4gICAgICByeCA9IHBhcmFtc1s0XSxcbiAgICAgIHJ5ID0gcGFyYW1zWzVdLFxuICAgICAgc2luX3RoID0gcGFyYW1zWzZdLFxuICAgICAgY29zX3RoID0gcGFyYW1zWzddO1xuICBjb25zdCBhMDAgPSBjb3NfdGggKiByeDtcbiAgY29uc3QgYTAxID0gLXNpbl90aCAqIHJ5O1xuICBjb25zdCBhMTAgPSBzaW5fdGggKiByeDtcbiAgY29uc3QgYTExID0gY29zX3RoICogcnk7XG4gIGNvbnN0IGNvc190aDAgPSBNYXRoLmNvcyh0aDApO1xuICBjb25zdCBzaW5fdGgwID0gTWF0aC5zaW4odGgwKTtcbiAgY29uc3QgY29zX3RoMSA9IE1hdGguY29zKHRoMSk7XG4gIGNvbnN0IHNpbl90aDEgPSBNYXRoLnNpbih0aDEpO1xuICBjb25zdCB0aF9oYWxmID0gMC41ICogKHRoMSAtIHRoMCk7XG4gIGNvbnN0IHNpbl90aF9oMiA9IE1hdGguc2luKHRoX2hhbGYgKiAwLjUpO1xuICBjb25zdCB0ID0gOCAvIDMgKiBzaW5fdGhfaDIgKiBzaW5fdGhfaDIgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgY29uc3QgeDEgPSBjeCArIGNvc190aDAgLSB0ICogc2luX3RoMDtcbiAgY29uc3QgeTEgPSBjeSArIHNpbl90aDAgKyB0ICogY29zX3RoMDtcbiAgY29uc3QgeDMgPSBjeCArIGNvc190aDE7XG4gIGNvbnN0IHkzID0gY3kgKyBzaW5fdGgxO1xuICBjb25zdCB4MiA9IHgzICsgdCAqIHNpbl90aDE7XG4gIGNvbnN0IHkyID0geTMgLSB0ICogY29zX3RoMTtcbiAgcmV0dXJuIGJlemllckNhY2hlW2tleV0gPSBbYTAwICogeDEgKyBhMDEgKiB5MSwgYTEwICogeDEgKyBhMTEgKiB5MSwgYTAwICogeDIgKyBhMDEgKiB5MiwgYTEwICogeDIgKyBhMTEgKiB5MiwgYTAwICogeDMgKyBhMDEgKiB5MywgYTEwICogeDMgKyBhMTEgKiB5M107XG59XG5cbmNvbnN0IHRlbXAgPSBbJ2wnLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcblxuZnVuY3Rpb24gc2NhbGUkMShjdXJyZW50LCBzWCwgc1kpIHtcbiAgY29uc3QgYyA9IHRlbXBbMF0gPSBjdXJyZW50WzBdO1xuXG4gIGlmIChjID09PSAnYScgfHwgYyA9PT0gJ0EnKSB7XG4gICAgdGVtcFsxXSA9IHNYICogY3VycmVudFsxXTtcbiAgICB0ZW1wWzJdID0gc1kgKiBjdXJyZW50WzJdO1xuICAgIHRlbXBbM10gPSBjdXJyZW50WzNdO1xuICAgIHRlbXBbNF0gPSBjdXJyZW50WzRdO1xuICAgIHRlbXBbNV0gPSBjdXJyZW50WzVdO1xuICAgIHRlbXBbNl0gPSBzWCAqIGN1cnJlbnRbNl07XG4gICAgdGVtcFs3XSA9IHNZICogY3VycmVudFs3XTtcbiAgfSBlbHNlIGlmIChjID09PSAnaCcgfHwgYyA9PT0gJ0gnKSB7XG4gICAgdGVtcFsxXSA9IHNYICogY3VycmVudFsxXTtcbiAgfSBlbHNlIGlmIChjID09PSAndicgfHwgYyA9PT0gJ1YnKSB7XG4gICAgdGVtcFsxXSA9IHNZICogY3VycmVudFsxXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMSwgbiA9IGN1cnJlbnQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ZW1wW2ldID0gKGkgJSAyID09IDEgPyBzWCA6IHNZKSAqIGN1cnJlbnRbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRlbXA7XG59XG5cbmZ1bmN0aW9uIHBhdGhSZW5kZXIgKGNvbnRleHQsIHBhdGgsIGwsIHQsIHNYLCBzWSkge1xuICB2YXIgY3VycmVudCxcbiAgICAgIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgeCA9IDAsXG4gICAgICAvLyBjdXJyZW50IHhcbiAgeSA9IDAsXG4gICAgICAvLyBjdXJyZW50IHlcbiAgY29udHJvbFggPSAwLFxuICAgICAgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgY29udHJvbFkgPSAwLFxuICAgICAgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgdGVtcFgsXG4gICAgICB0ZW1wWSxcbiAgICAgIHRlbXBDb250cm9sWCxcbiAgICAgIHRlbXBDb250cm9sWTtcbiAgaWYgKGwgPT0gbnVsbCkgbCA9IDA7XG4gIGlmICh0ID09IG51bGwpIHQgPSAwO1xuICBpZiAoc1ggPT0gbnVsbCkgc1ggPSAxO1xuICBpZiAoc1kgPT0gbnVsbCkgc1kgPSBzWDtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXRoLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBpZiAoc1ggIT09IDEgfHwgc1kgIT09IDEpIHtcbiAgICAgIGN1cnJlbnQgPSBzY2FsZSQxKGN1cnJlbnQsIHNYLCBzWSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7XG4gICAgICAvLyBmaXJzdCBsZXR0ZXJcbiAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6XG4gICAgICAgIC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzpcbiAgICAgICAgLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6XG4gICAgICAgIC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6XG4gICAgICAgIC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6XG4gICAgICAgIC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4ICsgY3VycmVudFsxXSArIGwsIC8vIHgxXG4gICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCwgLy8geTFcbiAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICBjb250cm9sWSArIHQsIC8vIHkyXG4gICAgICAgIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRbMV0gKyBsLCBjdXJyZW50WzJdICsgdCwgY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTsgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcblxuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGNvbnRyb2xYICsgbCwgY29udHJvbFkgKyB0LCB4ICsgY3VycmVudFsxXSArIGwsIHkgKyBjdXJyZW50WzJdICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpOyAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZVxuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBwb2ludC5cblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07IC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG5cbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgY3VycmVudFsxXSArIGwsIGN1cnJlbnRbMl0gKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZOyAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mXG4gICAgICAgIC8vIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZVxuICAgICAgICAvLyB0byB0aGUgY3VycmVudCBwb2ludC5cblxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnRbMV0gKyBsLCBjdXJyZW50WzJdICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzpcbiAgICAgICAgLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07IC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG5cbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBkcmF3QXJjKGNvbnRleHQsIHggKyBsLCB5ICsgdCwgW2N1cnJlbnRbMV0sIGN1cnJlbnRbMl0sIGN1cnJlbnRbM10sIGN1cnJlbnRbNF0sIGN1cnJlbnRbNV0sIGN1cnJlbnRbNl0gKyB4ICsgbCwgY3VycmVudFs3XSArIHkgKyB0XSk7XG4gICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGRyYXdBcmMoY29udGV4dCwgeCArIGwsIHkgKyB0LCBbY3VycmVudFsxXSwgY3VycmVudFsyXSwgY3VycmVudFszXSwgY3VycmVudFs0XSwgY3VycmVudFs1XSwgY3VycmVudFs2XSArIGwsIGN1cnJlbnRbN10gKyB0XSk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QXJjKGNvbnRleHQsIHgsIHksIGNvb3Jkcykge1xuICBjb25zdCBzZWcgPSBzZWdtZW50cyhjb29yZHNbNV0sIC8vIGVuZCB4XG4gIGNvb3Jkc1s2XSwgLy8gZW5kIHlcbiAgY29vcmRzWzBdLCAvLyByYWRpdXMgeFxuICBjb29yZHNbMV0sIC8vIHJhZGl1cyB5XG4gIGNvb3Jkc1szXSwgLy8gbGFyZ2UgZmxhZ1xuICBjb29yZHNbNF0sIC8vIHN3ZWVwIGZsYWdcbiAgY29vcmRzWzJdLCAvLyByb3RhdGlvblxuICB4LCB5KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGJleiA9IGJlemllcihzZWdbaV0pO1xuICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhiZXpbMF0sIGJlelsxXSwgYmV6WzJdLCBiZXpbM10sIGJlels0XSwgYmV6WzVdKTtcbiAgfVxufVxuXG5jb25zdCBUYW4zMCA9IDAuNTc3MzUwMjY5MTg5NjI1NztcbmNvbnN0IGJ1aWx0aW5zID0ge1xuICAnY2lyY2xlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgVGF1KTtcbiAgICB9XG4gIH0sXG4gICdjcm9zcyc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIHMgPSByIC8gMi41O1xuICAgICAgY29udGV4dC5tb3ZlVG8oLXIsIC1zKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1yLCBzKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCBzKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCBzKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIC1zKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIC1zKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgLXMpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICdkaWFtb25kJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1yLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgcik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3NxdWFyZSc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgICAgeCA9IC13IC8gMjtcbiAgICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgICB9XG4gIH0sXG4gICdhcnJvdyc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIHMgPSByIC8gNyxcbiAgICAgICAgICB0ID0gciAvIDIuNSxcbiAgICAgICAgICB2ID0gciAvIDg7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtcywgcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIC12KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHQsIC12KTtcbiAgICAgIGNvbnRleHQubGluZVRvKDAsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC10LCAtdik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgLXYpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd3ZWRnZSc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByLFxuICAgICAgICAgIG8gPSBoIC0gciAqIFRhbjMwLFxuICAgICAgICAgIGIgPSByIC8gNDtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtYiwgaCAtIG8pO1xuICAgICAgY29udGV4dC5saW5lVG8oYiwgaCAtIG8pO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZSc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByLFxuICAgICAgICAgIG8gPSBoIC0gciAqIFRhbjMwO1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLWggLSBvKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1yLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlLXVwJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAtaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCBoKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUtZG93bic6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByO1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgLWgpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgLWgpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS1yaWdodCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICAgIGggPSBIYWxmU3FydDMgKiByO1xuICAgICAgY29udGV4dC5tb3ZlVG8oaCwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtaCwgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLWgsIHIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS1sZWZ0Jzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgICAgaCA9IEhhbGZTcXJ0MyAqIHI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtaCwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhoLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhoLCByKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAnc3Ryb2tlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1yLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIDApO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHN5bWJvbHMoXykge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkoYnVpbHRpbnMsIF8pID8gYnVpbHRpbnNbX10gOiBjdXN0b21TeW1ib2woXyk7XG59XG52YXIgY3VzdG9tID0ge307XG5cbmZ1bmN0aW9uIGN1c3RvbVN5bWJvbChwYXRoKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkoY3VzdG9tLCBwYXRoKSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhdGhQYXJzZShwYXRoKTtcbiAgICBjdXN0b21bcGF0aF0gPSB7XG4gICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICBwYXRoUmVuZGVyKGNvbnRleHQsIHBhcnNlZCwgMCwgMCwgTWF0aC5zcXJ0KHNpemUpIC8gMik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjdXN0b21bcGF0aF07XG59XG5cbmNvbnN0IEMgPSAwLjQ0ODA4NDk3NTUwNjsgLy8gQyA9IDEgLSBjXG5cbmZ1bmN0aW9uIHJlY3RhbmdsZVgoZCkge1xuICByZXR1cm4gZC54O1xufVxuXG5mdW5jdGlvbiByZWN0YW5nbGVZKGQpIHtcbiAgcmV0dXJuIGQueTtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ2xlV2lkdGgoZCkge1xuICByZXR1cm4gZC53aWR0aDtcbn1cblxuZnVuY3Rpb24gcmVjdGFuZ2xlSGVpZ2h0KGQpIHtcbiAgcmV0dXJuIGQuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBudW1iZXIoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdmdW5jdGlvbicgPyBfIDogKCkgPT4gK187XG59XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG59XG5cbmZ1bmN0aW9uIHZnX3JlY3QgKCkge1xuICB2YXIgeCA9IHJlY3RhbmdsZVgsXG4gICAgICB5ID0gcmVjdGFuZ2xlWSxcbiAgICAgIHdpZHRoID0gcmVjdGFuZ2xlV2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0YW5nbGVIZWlnaHQsXG4gICAgICBjclRMID0gbnVtYmVyKDApLFxuICAgICAgY3JUUiA9IGNyVEwsXG4gICAgICBjckJMID0gY3JUTCxcbiAgICAgIGNyQlIgPSBjclRMLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVjdGFuZ2xlKF8sIHgwLCB5MCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHgxID0geDAgIT0gbnVsbCA/IHgwIDogK3guY2FsbCh0aGlzLCBfKSxcbiAgICAgICAgeTEgPSB5MCAhPSBudWxsID8geTAgOiAreS5jYWxsKHRoaXMsIF8pLFxuICAgICAgICB3ID0gK3dpZHRoLmNhbGwodGhpcywgXyksXG4gICAgICAgIGggPSAraGVpZ2h0LmNhbGwodGhpcywgXyksXG4gICAgICAgIHMgPSBNYXRoLm1pbih3LCBoKSAvIDIsXG4gICAgICAgIHRsID0gY2xhbXAoK2NyVEwuY2FsbCh0aGlzLCBfKSwgMCwgcyksXG4gICAgICAgIHRyID0gY2xhbXAoK2NyVFIuY2FsbCh0aGlzLCBfKSwgMCwgcyksXG4gICAgICAgIGJsID0gY2xhbXAoK2NyQkwuY2FsbCh0aGlzLCBfKSwgMCwgcyksXG4gICAgICAgIGJyID0gY2xhbXAoK2NyQlIuY2FsbCh0aGlzLCBfKSwgMCwgcyk7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCQzKCk7XG5cbiAgICBpZiAodGwgPD0gMCAmJiB0ciA8PSAwICYmIGJsIDw9IDAgJiYgYnIgPD0gMCkge1xuICAgICAgY29udGV4dC5yZWN0KHgxLCB5MSwgdywgaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4MiA9IHgxICsgdyxcbiAgICAgICAgICB5MiA9IHkxICsgaDtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgxICsgdGwsIHkxKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgyIC0gdHIsIHkxKTtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MiAtIEMgKiB0ciwgeTEsIHgyLCB5MSArIEMgKiB0ciwgeDIsIHkxICsgdHIpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDIsIHkyIC0gYnIpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgyLCB5MiAtIEMgKiBiciwgeDIgLSBDICogYnIsIHkyLCB4MiAtIGJyLCB5Mik7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MSArIGJsLCB5Mik7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDEgKyBDICogYmwsIHkyLCB4MSwgeTIgLSBDICogYmwsIHgxLCB5MiAtIGJsKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSArIHRsKTtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSwgeTEgKyBDICogdGwsIHgxICsgQyAqIHRsLCB5MSwgeDEgKyB0bCwgeTEpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIHJldHVybiBidWZmZXIgKyAnJyB8fCBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJlY3RhbmdsZS54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IG51bWJlcihfKTtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfTtcblxuICByZWN0YW5nbGUueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHkgPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geTtcbiAgICB9XG4gIH07XG5cbiAgcmVjdGFuZ2xlLndpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgd2lkdGggPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9O1xuXG4gIHJlY3RhbmdsZS5oZWlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBoZWlnaHQgPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cbiAgfTtcblxuICByZWN0YW5nbGUuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24gKHRsLCB0ciwgYnIsIGJsKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNyVEwgPSBudW1iZXIodGwpO1xuICAgICAgY3JUUiA9IHRyICE9IG51bGwgPyBudW1iZXIodHIpIDogY3JUTDtcbiAgICAgIGNyQlIgPSBiciAhPSBudWxsID8gbnVtYmVyKGJyKSA6IGNyVEw7XG4gICAgICBjckJMID0gYmwgIT0gbnVsbCA/IG51bWJlcihibCkgOiBjclRSO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyVEw7XG4gICAgfVxuICB9O1xuXG4gIHJlY3RhbmdsZS5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiByZWN0YW5nbGU7XG59XG5cbmZ1bmN0aW9uIHZnX3RyYWlsICgpIHtcbiAgdmFyIHgsXG4gICAgICB5LFxuICAgICAgc2l6ZSxcbiAgICAgIGRlZmluZWQsXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIHJlYWR5LFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHIxO1xuXG4gIGZ1bmN0aW9uIHBvaW50KHgyLCB5MiwgdzIpIHtcbiAgICBjb25zdCByMiA9IHcyIC8gMjtcblxuICAgIGlmIChyZWFkeSkge1xuICAgICAgdmFyIHV4ID0geTEgLSB5MixcbiAgICAgICAgICB1eSA9IHgyIC0geDE7XG5cbiAgICAgIGlmICh1eCB8fCB1eSkge1xuICAgICAgICAvLyBnZXQgbm9ybWFsIHZlY3RvclxuICAgICAgICB2YXIgdWQgPSBNYXRoLnNxcnQodXggKiB1eCArIHV5ICogdXkpLFxuICAgICAgICAgICAgcnggPSAodXggLz0gdWQpICogcjEsXG4gICAgICAgICAgICByeSA9ICh1eSAvPSB1ZCkgKiByMSxcbiAgICAgICAgICAgIHQgPSBNYXRoLmF0YW4yKHV5LCB1eCk7IC8vIGRyYXcgc2VnbWVudFxuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgxIC0gcngsIHkxIC0gcnkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiAtIHV4ICogcjIsIHkyIC0gdXkgKiByMik7XG4gICAgICAgIGNvbnRleHQuYXJjKHgyLCB5MiwgcjIsIHQgLSBNYXRoLlBJLCB0KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEgKyByeCwgeTEgKyByeSk7XG4gICAgICAgIGNvbnRleHQuYXJjKHgxLCB5MSwgcjEsIHQsIHQgKyBNYXRoLlBJKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuYXJjKHgyLCB5MiwgcjIsIDAsIFRhdSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWR5ID0gMTtcbiAgICB9XG5cbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgcjEgPSByMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBkLFxuICAgICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgICBidWZmZXI7XG4gICAgaWYgKGNvbnRleHQgPT0gbnVsbCkgY29udGV4dCA9IGJ1ZmZlciA9IHBhdGgkMygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSByZWFkeSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZpbmVkMCkgcG9pbnQoK3goZCwgaSwgZGF0YSksICt5KGQsIGksIGRhdGEpLCArc2l6ZShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICByZXR1cm4gYnVmZmVyICsgJycgfHwgbnVsbDtcbiAgICB9XG4gIH1cblxuICB0cmFpbC54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeCA9IF87XG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfTtcblxuICB0cmFpbC55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeSA9IF87XG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfTtcblxuICB0cmFpbC5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgc2l6ZSA9IF87XG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgfTtcblxuICB0cmFpbC5kZWZpbmVkID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICB0cmFpbC5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKF8gPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQgPSBfO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdHJhaWw7XG59XG5cbmZ1bmN0aW9uIHZhbHVlJDEoYSwgYikge1xuICByZXR1cm4gYSAhPSBudWxsID8gYSA6IGI7XG59XG5cbmNvbnN0IHggPSBpdGVtID0+IGl0ZW0ueCB8fCAwLFxuICAgICAgeSA9IGl0ZW0gPT4gaXRlbS55IHx8IDAsXG4gICAgICB3ID0gaXRlbSA9PiBpdGVtLndpZHRoIHx8IDAsXG4gICAgICBoID0gaXRlbSA9PiBpdGVtLmhlaWdodCB8fCAwLFxuICAgICAgeHcgPSBpdGVtID0+IChpdGVtLnggfHwgMCkgKyAoaXRlbS53aWR0aCB8fCAwKSxcbiAgICAgIHloID0gaXRlbSA9PiAoaXRlbS55IHx8IDApICsgKGl0ZW0uaGVpZ2h0IHx8IDApLFxuICAgICAgc2EgPSBpdGVtID0+IGl0ZW0uc3RhcnRBbmdsZSB8fCAwLFxuICAgICAgZWEgPSBpdGVtID0+IGl0ZW0uZW5kQW5nbGUgfHwgMCxcbiAgICAgIHBhID0gaXRlbSA9PiBpdGVtLnBhZEFuZ2xlIHx8IDAsXG4gICAgICBpciA9IGl0ZW0gPT4gaXRlbS5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBpdGVtID0+IGl0ZW0ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIGNyID0gaXRlbSA9PiBpdGVtLmNvcm5lclJhZGl1cyB8fCAwLFxuICAgICAgdGwgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNUb3BMZWZ0LCBpdGVtLmNvcm5lclJhZGl1cykgfHwgMCxcbiAgICAgIHRyID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uY29ybmVyUmFkaXVzVG9wUmlnaHQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICAgICAgYnIgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNCb3R0b21SaWdodCwgaXRlbS5jb3JuZXJSYWRpdXMpIHx8IDAsXG4gICAgICBibCA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLmNvcm5lclJhZGl1c0JvdHRvbUxlZnQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICAgICAgc3ogPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5zaXplLCA2NCksXG4gICAgICB0cyA9IGl0ZW0gPT4gaXRlbS5zaXplIHx8IDEsXG4gICAgICBkZWYgPSBpdGVtID0+ICEoaXRlbS5kZWZpbmVkID09PSBmYWxzZSksXG4gICAgICB0eXBlID0gaXRlbSA9PiBzeW1ib2xzKGl0ZW0uc2hhcGUgfHwgJ2NpcmNsZScpO1xuXG5jb25zdCBhcmNTaGFwZSA9IGFyYyQyKCkuc3RhcnRBbmdsZShzYSkuZW5kQW5nbGUoZWEpLnBhZEFuZ2xlKHBhKS5pbm5lclJhZGl1cyhpcikub3V0ZXJSYWRpdXMob3IpLmNvcm5lclJhZGl1cyhjciksXG4gICAgICBhcmVhdlNoYXBlID0gYXJlYSQyKCkueCh4KS55MSh5KS55MCh5aCkuZGVmaW5lZChkZWYpLFxuICAgICAgYXJlYWhTaGFwZSA9IGFyZWEkMigpLnkoeSkueDEoeCkueDAoeHcpLmRlZmluZWQoZGVmKSxcbiAgICAgIGxpbmVTaGFwZSA9IGxpbmUkMigpLngoeCkueSh5KS5kZWZpbmVkKGRlZiksXG4gICAgICByZWN0U2hhcGUgPSB2Z19yZWN0KCkueCh4KS55KHkpLndpZHRoKHcpLmhlaWdodChoKS5jb3JuZXJSYWRpdXModGwsIHRyLCBiciwgYmwpLFxuICAgICAgc3ltYm9sU2hhcGUgPSBzeW1ib2wkMigpLnR5cGUodHlwZSkuc2l6ZShzeiksXG4gICAgICB0cmFpbFNoYXBlID0gdmdfdHJhaWwoKS54KHgpLnkoeSkuZGVmaW5lZChkZWYpLnNpemUodHMpO1xuZnVuY3Rpb24gaGFzQ29ybmVyUmFkaXVzKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uY29ybmVyUmFkaXVzIHx8IGl0ZW0uY29ybmVyUmFkaXVzVG9wTGVmdCB8fCBpdGVtLmNvcm5lclJhZGl1c1RvcFJpZ2h0IHx8IGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tUmlnaHQgfHwgaXRlbS5jb3JuZXJSYWRpdXNCb3R0b21MZWZ0O1xufVxuZnVuY3Rpb24gYXJjJDEoY29udGV4dCwgaXRlbSkge1xuICByZXR1cm4gYXJjU2hhcGUuY29udGV4dChjb250ZXh0KShpdGVtKTtcbn1cbmZ1bmN0aW9uIGFyZWEkMShjb250ZXh0LCBpdGVtcykge1xuICBjb25zdCBpdGVtID0gaXRlbXNbMF0sXG4gICAgICAgIGludGVycCA9IGl0ZW0uaW50ZXJwb2xhdGUgfHwgJ2xpbmVhcic7XG4gIHJldHVybiAoaXRlbS5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/IGFyZWFoU2hhcGUgOiBhcmVhdlNoYXBlKS5jdXJ2ZShjdXJ2ZXMoaW50ZXJwLCBpdGVtLm9yaWVudCwgaXRlbS50ZW5zaW9uKSkuY29udGV4dChjb250ZXh0KShpdGVtcyk7XG59XG5mdW5jdGlvbiBsaW5lJDEoY29udGV4dCwgaXRlbXMpIHtcbiAgY29uc3QgaXRlbSA9IGl0ZW1zWzBdLFxuICAgICAgICBpbnRlcnAgPSBpdGVtLmludGVycG9sYXRlIHx8ICdsaW5lYXInO1xuICByZXR1cm4gbGluZVNoYXBlLmN1cnZlKGN1cnZlcyhpbnRlcnAsIGl0ZW0ub3JpZW50LCBpdGVtLnRlbnNpb24pKS5jb250ZXh0KGNvbnRleHQpKGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZShjb250ZXh0LCBpdGVtLCB4LCB5KSB7XG4gIHJldHVybiByZWN0U2hhcGUuY29udGV4dChjb250ZXh0KShpdGVtLCB4LCB5KTtcbn1cbmZ1bmN0aW9uIHNoYXBlJDEoY29udGV4dCwgaXRlbSkge1xuICByZXR1cm4gKGl0ZW0ubWFyay5zaGFwZSB8fCBpdGVtLnNoYXBlKS5jb250ZXh0KGNvbnRleHQpKGl0ZW0pO1xufVxuZnVuY3Rpb24gc3ltYm9sJDEoY29udGV4dCwgaXRlbSkge1xuICByZXR1cm4gc3ltYm9sU2hhcGUuY29udGV4dChjb250ZXh0KShpdGVtKTtcbn1cbmZ1bmN0aW9uIHRyYWlsJDEoY29udGV4dCwgaXRlbXMpIHtcbiAgcmV0dXJuIHRyYWlsU2hhcGUuY29udGV4dChjb250ZXh0KShpdGVtcyk7XG59XG5cbnZhciBjbGlwX2lkID0gMTtcbmZ1bmN0aW9uIHJlc2V0U1ZHQ2xpcElkKCkge1xuICBjbGlwX2lkID0gMTtcbn1cbmZ1bmN0aW9uIGNsaXAkMSAocmVuZGVyZXIsIGl0ZW0sIHNpemUpIHtcbiAgdmFyIGNsaXAgPSBpdGVtLmNsaXAsXG4gICAgICBkZWZzID0gcmVuZGVyZXIuX2RlZnMsXG4gICAgICBpZCA9IGl0ZW0uY2xpcF9pZCB8fCAoaXRlbS5jbGlwX2lkID0gJ2NsaXAnICsgY2xpcF9pZCsrKSxcbiAgICAgIGMgPSBkZWZzLmNsaXBwaW5nW2lkXSB8fCAoZGVmcy5jbGlwcGluZ1tpZF0gPSB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGNsaXApKSB7XG4gICAgYy5wYXRoID0gY2xpcChudWxsKTtcbiAgfSBlbHNlIGlmIChoYXNDb3JuZXJSYWRpdXMoc2l6ZSkpIHtcbiAgICBjLnBhdGggPSByZWN0YW5nbGUobnVsbCwgc2l6ZSwgMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgYy53aWR0aCA9IHNpemUud2lkdGggfHwgMDtcbiAgICBjLmhlaWdodCA9IHNpemUuaGVpZ2h0IHx8IDA7XG4gIH1cblxuICByZXR1cm4gJ3VybCgjJyArIGlkICsgJyknO1xufVxuXG5mdW5jdGlvbiBCb3VuZHMoYikge1xuICB0aGlzLmNsZWFyKCk7XG4gIGlmIChiKSB0aGlzLnVuaW9uKGIpO1xufVxuQm91bmRzLnByb3RvdHlwZSA9IHtcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZHModGhpcyk7XG4gIH0sXG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy54MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMueTEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLngyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy55MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLngxID09PSArTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLnkxID09PSArTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLngyID09PSAtTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLnkyID09PSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgfSxcblxuICBlcXVhbHMoYikge1xuICAgIHJldHVybiB0aGlzLngxID09PSBiLngxICYmIHRoaXMueTEgPT09IGIueTEgJiYgdGhpcy54MiA9PT0gYi54MiAmJiB0aGlzLnkyID09PSBiLnkyO1xuICB9LFxuXG4gIHNldCh4MSwgeTEsIHgyLCB5Mikge1xuICAgIGlmICh4MiA8IHgxKSB7XG4gICAgICB0aGlzLngyID0geDE7XG4gICAgICB0aGlzLngxID0geDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueDEgPSB4MTtcbiAgICAgIHRoaXMueDIgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAoeTIgPCB5MSkge1xuICAgICAgdGhpcy55MiA9IHkxO1xuICAgICAgdGhpcy55MSA9IHkyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnkxID0geTE7XG4gICAgICB0aGlzLnkyID0geTI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkKHgsIHkpIHtcbiAgICBpZiAoeCA8IHRoaXMueDEpIHRoaXMueDEgPSB4O1xuICAgIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gICAgaWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcbiAgICBpZiAoeSA+IHRoaXMueTIpIHRoaXMueTIgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGV4cGFuZChkKSB7XG4gICAgdGhpcy54MSAtPSBkO1xuICAgIHRoaXMueTEgLT0gZDtcbiAgICB0aGlzLngyICs9IGQ7XG4gICAgdGhpcy55MiArPSBkO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJvdW5kKCkge1xuICAgIHRoaXMueDEgPSBNYXRoLmZsb29yKHRoaXMueDEpO1xuICAgIHRoaXMueTEgPSBNYXRoLmZsb29yKHRoaXMueTEpO1xuICAgIHRoaXMueDIgPSBNYXRoLmNlaWwodGhpcy54Mik7XG4gICAgdGhpcy55MiA9IE1hdGguY2VpbCh0aGlzLnkyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzY2FsZShzKSB7XG4gICAgdGhpcy54MSAqPSBzO1xuICAgIHRoaXMueTEgKj0gcztcbiAgICB0aGlzLngyICo9IHM7XG4gICAgdGhpcy55MiAqPSBzO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRyYW5zbGF0ZShkeCwgZHkpIHtcbiAgICB0aGlzLngxICs9IGR4O1xuICAgIHRoaXMueDIgKz0gZHg7XG4gICAgdGhpcy55MSArPSBkeTtcbiAgICB0aGlzLnkyICs9IGR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJvdGF0ZShhbmdsZSwgeCwgeSkge1xuICAgIGNvbnN0IHAgPSB0aGlzLnJvdGF0ZWRQb2ludHMoYW5nbGUsIHgsIHkpO1xuICAgIHJldHVybiB0aGlzLmNsZWFyKCkuYWRkKHBbMF0sIHBbMV0pLmFkZChwWzJdLCBwWzNdKS5hZGQocFs0XSwgcFs1XSkuYWRkKHBbNl0sIHBbN10pO1xuICB9LFxuXG4gIHJvdGF0ZWRQb2ludHMoYW5nbGUsIHgsIHkpIHtcbiAgICB2YXIge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gdGhpcyxcbiAgICAgICAgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGN4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuICAgICAgICBjeSA9IHkgLSB4ICogc2luIC0geSAqIGNvcztcbiAgICByZXR1cm4gW2NvcyAqIHgxIC0gc2luICogeTEgKyBjeCwgc2luICogeDEgKyBjb3MgKiB5MSArIGN5LCBjb3MgKiB4MSAtIHNpbiAqIHkyICsgY3gsIHNpbiAqIHgxICsgY29zICogeTIgKyBjeSwgY29zICogeDIgLSBzaW4gKiB5MSArIGN4LCBzaW4gKiB4MiArIGNvcyAqIHkxICsgY3ksIGNvcyAqIHgyIC0gc2luICogeTIgKyBjeCwgc2luICogeDIgKyBjb3MgKiB5MiArIGN5XTtcbiAgfSxcblxuICB1bmlvbihiKSB7XG4gICAgaWYgKGIueDEgPCB0aGlzLngxKSB0aGlzLngxID0gYi54MTtcbiAgICBpZiAoYi55MSA8IHRoaXMueTEpIHRoaXMueTEgPSBiLnkxO1xuICAgIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gICAgaWYgKGIueTIgPiB0aGlzLnkyKSB0aGlzLnkyID0gYi55MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbnRlcnNlY3QoYikge1xuICAgIGlmIChiLngxID4gdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gICAgaWYgKGIueTEgPiB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgICBpZiAoYi54MiA8IHRoaXMueDIpIHRoaXMueDIgPSBiLngyO1xuICAgIGlmIChiLnkyIDwgdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW5jbG9zZXMoYikge1xuICAgIHJldHVybiBiICYmIHRoaXMueDEgPD0gYi54MSAmJiB0aGlzLngyID49IGIueDIgJiYgdGhpcy55MSA8PSBiLnkxICYmIHRoaXMueTIgPj0gYi55MjtcbiAgfSxcblxuICBhbGlnbnNXaXRoKGIpIHtcbiAgICByZXR1cm4gYiAmJiAodGhpcy54MSA9PSBiLngxIHx8IHRoaXMueDIgPT0gYi54MiB8fCB0aGlzLnkxID09IGIueTEgfHwgdGhpcy55MiA9PSBiLnkyKTtcbiAgfSxcblxuICBpbnRlcnNlY3RzKGIpIHtcbiAgICByZXR1cm4gYiAmJiAhKHRoaXMueDIgPCBiLngxIHx8IHRoaXMueDEgPiBiLngyIHx8IHRoaXMueTIgPCBiLnkxIHx8IHRoaXMueTEgPiBiLnkyKTtcbiAgfSxcblxuICBjb250YWlucyh4LCB5KSB7XG4gICAgcmV0dXJuICEoeCA8IHRoaXMueDEgfHwgeCA+IHRoaXMueDIgfHwgeSA8IHRoaXMueTEgfHwgeSA+IHRoaXMueTIpO1xuICB9LFxuXG4gIHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbiAgfSxcblxuICBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIEl0ZW0obWFyaykge1xuICB0aGlzLm1hcmsgPSBtYXJrO1xuICB0aGlzLmJvdW5kcyA9IHRoaXMuYm91bmRzIHx8IG5ldyBCb3VuZHMoKTtcbn1cblxuZnVuY3Rpb24gR3JvdXBJdGVtKG1hcmspIHtcbiAgSXRlbS5jYWxsKHRoaXMsIG1hcmspO1xuICB0aGlzLml0ZW1zID0gdGhpcy5pdGVtcyB8fCBbXTtcbn1cbmluaGVyaXRzKEdyb3VwSXRlbSwgSXRlbSk7XG5cbmZ1bmN0aW9uIFJlc291cmNlTG9hZGVyKGN1c3RvbUxvYWRlcikge1xuICB0aGlzLl9wZW5kaW5nID0gMDtcbiAgdGhpcy5fbG9hZGVyID0gY3VzdG9tTG9hZGVyIHx8IGxvYWRlcigpO1xufVxuXG5mdW5jdGlvbiBpbmNyZW1lbnQobG9hZGVyKSB7XG4gIGxvYWRlci5fcGVuZGluZyArPSAxO1xufVxuXG5mdW5jdGlvbiBkZWNyZW1lbnQobG9hZGVyKSB7XG4gIGxvYWRlci5fcGVuZGluZyAtPSAxO1xufVxuXG5SZXNvdXJjZUxvYWRlci5wcm90b3R5cGUgPSB7XG4gIHBlbmRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BlbmRpbmc7XG4gIH0sXG5cbiAgc2FuaXRpemVVUkwodXJpKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcztcbiAgICBpbmNyZW1lbnQobG9hZGVyKTtcbiAgICByZXR1cm4gbG9hZGVyLl9sb2FkZXIuc2FuaXRpemUodXJpLCB7XG4gICAgICBjb250ZXh0OiAnaHJlZidcbiAgICB9KS50aGVuKG9wdCA9PiB7XG4gICAgICBkZWNyZW1lbnQobG9hZGVyKTtcbiAgICAgIHJldHVybiBvcHQ7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgZGVjcmVtZW50KGxvYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSxcblxuICBsb2FkSW1hZ2UodXJpKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcyxcbiAgICAgICAgICBJbWFnZSA9IGltYWdlJDEoKTtcbiAgICBpbmNyZW1lbnQobG9hZGVyKTtcbiAgICByZXR1cm4gbG9hZGVyLl9sb2FkZXIuc2FuaXRpemUodXJpLCB7XG4gICAgICBjb250ZXh0OiAnaW1hZ2UnXG4gICAgfSkudGhlbihvcHQgPT4ge1xuICAgICAgY29uc3QgdXJsID0gb3B0LmhyZWY7XG4gICAgICBpZiAoIXVybCB8fCAhSW1hZ2UpIHRocm93IHtcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH07XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTsgLy8gc2V0IGNyb3NzT3JpZ2luIG9ubHkgaWYgY29ycyBpcyBkZWZpbmVkOyBlbXB0eSBzdHJpbmcgc2V0cyBhbm9ueW1vdXMgbW9kZVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvY3Jvc3NPcmlnaW5cblxuICAgICAgY29uc3QgY29ycyA9IGhhc093blByb3BlcnR5KG9wdCwgJ2Nyb3NzT3JpZ2luJykgPyBvcHQuY3Jvc3NPcmlnaW4gOiAnYW5vbnltb3VzJztcbiAgICAgIGlmIChjb3JzICE9IG51bGwpIGltZy5jcm9zc09yaWdpbiA9IGNvcnM7IC8vIGF0dGVtcHQgdG8gbG9hZCBpbWFnZSByZXNvdXJjZVxuXG4gICAgICBpbWcub25sb2FkID0gKCkgPT4gZGVjcmVtZW50KGxvYWRlcik7XG5cbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gZGVjcmVtZW50KGxvYWRlcik7XG5cbiAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgICByZXR1cm4gaW1nO1xuICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgZGVjcmVtZW50KGxvYWRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHNyYzogZSAmJiBlLnVybCB8fCAnJ1xuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcblxuICByZWFkeSgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhY2NlcHQgPT4ge1xuICAgICAgZnVuY3Rpb24gcG9sbCh2YWx1ZSkge1xuICAgICAgICBpZiAoIWxvYWRlci5wZW5kaW5nKCkpIGFjY2VwdCh2YWx1ZSk7ZWxzZSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwb2xsKHRydWUpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHBvbGwoZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIGJvdW5kU3Ryb2tlIChib3VuZHMsIGl0ZW0sIG1pdGVyKSB7XG4gIGlmIChpdGVtLnN0cm9rZSAmJiBpdGVtLm9wYWNpdHkgIT09IDAgJiYgaXRlbS5zdHJva2VPcGFjaXR5ICE9PSAwKSB7XG4gICAgY29uc3Qgc3cgPSBpdGVtLnN0cm9rZVdpZHRoICE9IG51bGwgPyAraXRlbS5zdHJva2VXaWR0aCA6IDE7XG4gICAgYm91bmRzLmV4cGFuZChzdyArIChtaXRlciA/IG1pdGVyQWRqdXN0bWVudChpdGVtLCBzdykgOiAwKSk7XG4gIH1cblxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBtaXRlckFkanVzdG1lbnQoaXRlbSwgc3Ryb2tlV2lkdGgpIHtcbiAgLy8gVE9ETzogbW9yZSBzb3BoaXN0aWNhdGVkIGFkanVzdG1lbnQ/IE9yIG1pdGVyIHN1cHBvcnQgaW4gYm91bmRDb250ZXh0P1xuICByZXR1cm4gaXRlbS5zdHJva2VKb2luICYmIGl0ZW0uc3Ryb2tlSm9pbiAhPT0gJ21pdGVyJyA/IDAgOiBzdHJva2VXaWR0aDtcbn1cblxuY29uc3QgY2lyY2xlVGhyZXNob2xkID0gVGF1IC0gMWUtODtcbmxldCBib3VuZHMsIGx4LCBseSwgcm90LCBtYSwgbWIsIG1jLCBtZDtcblxuY29uc3QgYWRkID0gKHgsIHkpID0+IGJvdW5kcy5hZGQoeCwgeSk7XG5cbmNvbnN0IGFkZEwgPSAoeCwgeSkgPT4gYWRkKGx4ID0geCwgbHkgPSB5KTtcblxuY29uc3QgYWRkWCA9IHggPT4gYWRkKHgsIGJvdW5kcy55MSk7XG5cbmNvbnN0IGFkZFkgPSB5ID0+IGFkZChib3VuZHMueDEsIHkpO1xuXG5jb25zdCBweCA9ICh4LCB5KSA9PiBtYSAqIHggKyBtYyAqIHk7XG5cbmNvbnN0IHB5ID0gKHgsIHkpID0+IG1iICogeCArIG1kICogeTtcblxuY29uc3QgYWRkcCA9ICh4LCB5KSA9PiBhZGQocHgoeCwgeSksIHB5KHgsIHkpKTtcblxuY29uc3QgYWRkcEwgPSAoeCwgeSkgPT4gYWRkTChweCh4LCB5KSwgcHkoeCwgeSkpO1xuXG5mdW5jdGlvbiBib3VuZENvbnRleHQgKF8sIGRlZykge1xuICBib3VuZHMgPSBfO1xuXG4gIGlmIChkZWcpIHtcbiAgICByb3QgPSBkZWcgKiBEZWdUb1JhZDtcbiAgICBtYSA9IG1kID0gTWF0aC5jb3Mocm90KTtcbiAgICBtYiA9IE1hdGguc2luKHJvdCk7XG4gICAgbWMgPSAtbWI7XG4gIH0gZWxzZSB7XG4gICAgbWEgPSBtZCA9IDE7XG4gICAgcm90ID0gbWIgPSBtYyA9IDA7XG4gIH1cblxuICByZXR1cm4gY29udGV4dCQxO1xufVxuY29uc3QgY29udGV4dCQxID0ge1xuICBiZWdpblBhdGgoKSB7fSxcblxuICBjbG9zZVBhdGgoKSB7fSxcblxuICBtb3ZlVG86IGFkZHBMLFxuICBsaW5lVG86IGFkZHBMLFxuXG4gIHJlY3QoeCwgeSwgdywgaCkge1xuICAgIGlmIChyb3QpIHtcbiAgICAgIGFkZHAoeCArIHcsIHkpO1xuICAgICAgYWRkcCh4ICsgdywgeSArIGgpO1xuICAgICAgYWRkcCh4LCB5ICsgaCk7XG4gICAgICBhZGRwTCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkKHggKyB3LCB5ICsgaCk7XG4gICAgICBhZGRMKHgsIHkpO1xuICAgIH1cbiAgfSxcblxuICBxdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY29uc3QgcHgxID0gcHgoeDEsIHkxKSxcbiAgICAgICAgICBweTEgPSBweSh4MSwgeTEpLFxuICAgICAgICAgIHB4MiA9IHB4KHgyLCB5MiksXG4gICAgICAgICAgcHkyID0gcHkoeDIsIHkyKTtcbiAgICBxdWFkRXh0cmVtYShseCwgcHgxLCBweDIsIGFkZFgpO1xuICAgIHF1YWRFeHRyZW1hKGx5LCBweTEsIHB5MiwgYWRkWSk7XG4gICAgYWRkTChweDIsIHB5Mik7XG4gIH0sXG5cbiAgYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgY29uc3QgcHgxID0gcHgoeDEsIHkxKSxcbiAgICAgICAgICBweTEgPSBweSh4MSwgeTEpLFxuICAgICAgICAgIHB4MiA9IHB4KHgyLCB5MiksXG4gICAgICAgICAgcHkyID0gcHkoeDIsIHkyKSxcbiAgICAgICAgICBweDMgPSBweCh4MywgeTMpLFxuICAgICAgICAgIHB5MyA9IHB5KHgzLCB5Myk7XG4gICAgY3ViaWNFeHRyZW1hKGx4LCBweDEsIHB4MiwgcHgzLCBhZGRYKTtcbiAgICBjdWJpY0V4dHJlbWEobHksIHB5MSwgcHkyLCBweTMsIGFkZFkpO1xuICAgIGFkZEwocHgzLCBweTMpO1xuICB9LFxuXG4gIGFyYyhjeCwgY3ksIHIsIHNhLCBlYSwgY2N3KSB7XG4gICAgc2EgKz0gcm90O1xuICAgIGVhICs9IHJvdDsgLy8gc3RvcmUgbGFzdCBwb2ludCBvbiBwYXRoXG5cbiAgICBseCA9IHIgKiBNYXRoLmNvcyhlYSkgKyBjeDtcbiAgICBseSA9IHIgKiBNYXRoLnNpbihlYSkgKyBjeTtcblxuICAgIGlmIChNYXRoLmFicyhlYSAtIHNhKSA+IGNpcmNsZVRocmVzaG9sZCkge1xuICAgICAgLy8gdHJlYXQgYXMgZnVsbCBjaXJjbGVcbiAgICAgIGFkZChjeCAtIHIsIGN5IC0gcik7XG4gICAgICBhZGQoY3ggKyByLCBjeSArIHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSBhID0+IGFkZChyICogTWF0aC5jb3MoYSkgKyBjeCwgciAqIE1hdGguc2luKGEpICsgY3kpO1xuXG4gICAgICBsZXQgcywgaTsgLy8gc2FtcGxlIGVuZCBwb2ludHNcblxuICAgICAgdXBkYXRlKHNhKTtcbiAgICAgIHVwZGF0ZShlYSk7IC8vIHNhbXBsZSBpbnRlcmlvciBwb2ludHMgYWxpZ25lZCB3aXRoIDkwIGRlZ3JlZXNcblxuICAgICAgaWYgKGVhICE9PSBzYSkge1xuICAgICAgICBzYSA9IHNhICUgVGF1O1xuICAgICAgICBpZiAoc2EgPCAwKSBzYSArPSBUYXU7XG4gICAgICAgIGVhID0gZWEgJSBUYXU7XG4gICAgICAgIGlmIChlYSA8IDApIGVhICs9IFRhdTtcblxuICAgICAgICBpZiAoZWEgPCBzYSkge1xuICAgICAgICAgIGNjdyA9ICFjY3c7IC8vIGZsaXAgZGlyZWN0aW9uXG5cbiAgICAgICAgICBzID0gc2E7XG4gICAgICAgICAgc2EgPSBlYTtcbiAgICAgICAgICBlYSA9IHM7IC8vIHN3YXAgZW5kLXBvaW50c1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNjdykge1xuICAgICAgICAgIGVhIC09IFRhdTtcbiAgICAgICAgICBzID0gc2EgLSBzYSAlIEhhbGZQaTtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0ICYmIHMgPiBlYTsgKytpLCBzIC09IEhhbGZQaSkgdXBkYXRlKHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMgPSBzYSAtIHNhICUgSGFsZlBpICsgSGFsZlBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQgJiYgcyA8IGVhOyArK2ksIHMgPSBzICsgSGFsZlBpKSB1cGRhdGUocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gcXVhZEV4dHJlbWEoeDAsIHgxLCB4MiwgY2IpIHtcbiAgY29uc3QgdCA9ICh4MCAtIHgxKSAvICh4MCArIHgyIC0gMiAqIHgxKTtcbiAgaWYgKDAgPCB0ICYmIHQgPCAxKSBjYih4MCArICh4MSAtIHgwKSAqIHQpO1xufVxuXG5mdW5jdGlvbiBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIGNiKSB7XG4gIGNvbnN0IGEgPSB4MyAtIHgwICsgMyAqIHgxIC0gMyAqIHgyLFxuICAgICAgICBiID0geDAgKyB4MiAtIDIgKiB4MSxcbiAgICAgICAgYyA9IHgwIC0geDE7XG4gIGxldCB0MCA9IDAsXG4gICAgICB0MSA9IDAsXG4gICAgICByOyAvLyBzb2x2ZSBmb3IgcGFyYW1ldGVyIHRcblxuICBpZiAoTWF0aC5hYnMoYSkgPiBFcHNpbG9uKSB7XG4gICAgLy8gcXVhZHJhdGljIGVxdWF0aW9uXG4gICAgciA9IGIgKiBiICsgYyAqIGE7XG5cbiAgICBpZiAociA+PSAwKSB7XG4gICAgICByID0gTWF0aC5zcXJ0KHIpO1xuICAgICAgdDAgPSAoLWIgKyByKSAvIGE7XG4gICAgICB0MSA9ICgtYiAtIHIpIC8gYTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbGluZWFyIGVxdWF0aW9uXG4gICAgdDAgPSAwLjUgKiBjIC8gYjtcbiAgfSAvLyBjYWxjdWxhdGUgcG9zaXRpb25cblxuXG4gIGlmICgwIDwgdDAgJiYgdDAgPCAxKSBjYihjdWJpYyh0MCwgeDAsIHgxLCB4MiwgeDMpKTtcbiAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIGNiKGN1YmljKHQxLCB4MCwgeDEsIHgyLCB4MykpO1xufVxuXG5mdW5jdGlvbiBjdWJpYyh0LCB4MCwgeDEsIHgyLCB4Mykge1xuICBjb25zdCBzID0gMSAtIHQsXG4gICAgICAgIHMyID0gcyAqIHMsXG4gICAgICAgIHQyID0gdCAqIHQ7XG4gIHJldHVybiBzMiAqIHMgKiB4MCArIDMgKiBzMiAqIHQgKiB4MSArIDMgKiBzICogdDIgKiB4MiArIHQyICogdCAqIHgzO1xufVxuXG52YXIgY29udGV4dCA9IChjb250ZXh0ID0gY2FudmFzKDEsIDEpKSA/IGNvbnRleHQuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGw7XG5cbmNvbnN0IGIgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBpbnRlcnNlY3RQYXRoKGRyYXcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBicnVzaCkge1xuICAgIC8vIHJlbHkgb24gKGluYWNjdXJhdGUpIGJvdW5kcyBpbnRlcnNlY3Rpb24gaWYgbm8gY29udGV4dFxuICAgIGlmICghY29udGV4dCkgcmV0dXJuIHRydWU7IC8vIGFkZCBwYXRoIHRvIG9mZnNjcmVlbiBncmFwaGljcyBjb250ZXh0XG5cbiAgICBkcmF3KGNvbnRleHQsIGl0ZW0pOyAvLyBnZXQgYm91bmRzIGludGVyc2VjdGlvbiByZWdpb25cblxuICAgIGIuY2xlYXIoKS51bmlvbihpdGVtLmJvdW5kcykuaW50ZXJzZWN0KGJydXNoKS5yb3VuZCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHgxLFxuICAgICAgeTEsXG4gICAgICB4MixcbiAgICAgIHkyXG4gICAgfSA9IGI7IC8vIGl0ZXJhdGUgb3ZlciBpbnRlcnNlY3Rpb24gcmVnaW9uXG4gICAgLy8gcGVyZm9ybSBmaW5lIGdyYWluZWQgaW5jbHVzaW9uIHRlc3RcblxuICAgIGZvciAobGV0IHkgPSB5MTsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0geDE7IHggPD0geDI7ICsreCkge1xuICAgICAgICBpZiAoY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGZhbHNlIGlmIG5vIGhpdHMgaW4gaW50ZXJzZWN0aW9uIHJlZ2lvblxuXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RQb2ludChpdGVtLCBib3gpIHtcbiAgcmV0dXJuIGJveC5jb250YWlucyhpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdChpdGVtLCBib3gpIHtcbiAgY29uc3QgeCA9IGl0ZW0ueCB8fCAwLFxuICAgICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICAgIHcgPSBpdGVtLndpZHRoIHx8IDAsXG4gICAgICAgIGggPSBpdGVtLmhlaWdodCB8fCAwO1xuICByZXR1cm4gYm94LmludGVyc2VjdHMoYi5zZXQoeCwgeSwgeCArIHcsIHkgKyBoKSk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSdWxlKGl0ZW0sIGJveCkge1xuICBjb25zdCB4ID0gaXRlbS54IHx8IDAsXG4gICAgICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICAgICAgeDIgPSBpdGVtLngyICE9IG51bGwgPyBpdGVtLngyIDogeCxcbiAgICAgICAgeTIgPSBpdGVtLnkyICE9IG51bGwgPyBpdGVtLnkyIDogeTtcbiAgcmV0dXJuIGludGVyc2VjdEJveExpbmUoYm94LCB4LCB5LCB4MiwgeTIpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0Qm94TGluZShib3gsIHgsIHksIHUsIHYpIHtcbiAgY29uc3Qge1xuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyXG4gIH0gPSBib3gsXG4gICAgICAgIGR4ID0gdSAtIHgsXG4gICAgICAgIGR5ID0gdiAtIHk7XG4gIGxldCB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBwLFxuICAgICAgcSxcbiAgICAgIHIsXG4gICAgICBlO1xuXG4gIGZvciAoZSA9IDA7IGUgPCA0OyArK2UpIHtcbiAgICBpZiAoZSA9PT0gMCkge1xuICAgICAgcCA9IC1keDtcbiAgICAgIHEgPSAtKHgxIC0geCk7XG4gICAgfVxuXG4gICAgaWYgKGUgPT09IDEpIHtcbiAgICAgIHAgPSBkeDtcbiAgICAgIHEgPSB4MiAtIHg7XG4gICAgfVxuXG4gICAgaWYgKGUgPT09IDIpIHtcbiAgICAgIHAgPSAtZHk7XG4gICAgICBxID0gLSh5MSAtIHkpO1xuICAgIH1cblxuICAgIGlmIChlID09PSAzKSB7XG4gICAgICBwID0gZHk7XG4gICAgICBxID0geTIgLSB5O1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyhwKSA8IDFlLTEwICYmIHEgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgciA9IHEgLyBwO1xuXG4gICAgaWYgKHAgPCAwKSB7XG4gICAgICBpZiAociA+IHQxKSByZXR1cm4gZmFsc2U7ZWxzZSBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgfSBlbHNlIGlmIChwID4gMCkge1xuICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuIGZhbHNlO2Vsc2UgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBibGVuZCAoY29udGV4dCwgaXRlbSkge1xuICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGl0ZW0uYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbn1cblxuZnVuY3Rpb24gdmFsdWUgKHZhbHVlLCBkZmx0KSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gZGZsdCA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhZGRTdG9wcyhncmFkaWVudCwgc3RvcHMpIHtcbiAgY29uc3QgbiA9IHN0b3BzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wc1tpXS5vZmZzZXQsIHN0b3BzW2ldLmNvbG9yKTtcbiAgfVxuXG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZnVuY3Rpb24gZ3JhZGllbnQgKGNvbnRleHQsIHNwZWMsIGJvdW5kcykge1xuICBjb25zdCB3ID0gYm91bmRzLndpZHRoKCksXG4gICAgICAgIGggPSBib3VuZHMuaGVpZ2h0KCk7XG4gIGxldCBncmFkaWVudDtcblxuICBpZiAoc3BlYy5ncmFkaWVudCA9PT0gJ3JhZGlhbCcpIHtcbiAgICBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoYm91bmRzLngxICsgdmFsdWUoc3BlYy54MSwgMC41KSAqIHcsIGJvdW5kcy55MSArIHZhbHVlKHNwZWMueTEsIDAuNSkgKiBoLCBNYXRoLm1heCh3LCBoKSAqIHZhbHVlKHNwZWMucjEsIDApLCBib3VuZHMueDEgKyB2YWx1ZShzcGVjLngyLCAwLjUpICogdywgYm91bmRzLnkxICsgdmFsdWUoc3BlYy55MiwgMC41KSAqIGgsIE1hdGgubWF4KHcsIGgpICogdmFsdWUoc3BlYy5yMiwgMC41KSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbGluZWFyIGdyYWRpZW50XG4gICAgY29uc3QgeDEgPSB2YWx1ZShzcGVjLngxLCAwKSxcbiAgICAgICAgICB5MSA9IHZhbHVlKHNwZWMueTEsIDApLFxuICAgICAgICAgIHgyID0gdmFsdWUoc3BlYy54MiwgMSksXG4gICAgICAgICAgeTIgPSB2YWx1ZShzcGVjLnkyLCAwKTtcblxuICAgIGlmICh4MSA9PT0geDIgfHwgeTEgPT09IHkyIHx8IHcgPT09IGgpIHtcbiAgICAgIC8vIGF4aXMgYWxpZ25lZDogdXNlIG5vcm1hbCBncmFkaWVudFxuICAgICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KGJvdW5kcy54MSArIHgxICogdywgYm91bmRzLnkxICsgeTEgKiBoLCBib3VuZHMueDEgKyB4MiAqIHcsIGJvdW5kcy55MSArIHkyICogaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBheGlzIGFsaWduZWQ6IHJlbmRlciBncmFkaWVudCBpbnRvIGEgcGF0dGVybiAoIzIzNjUpXG4gICAgICAvLyB0aGlzIGFsbG93cyB1cyB0byB1c2Ugbm9ybWFsaXplZCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IGltYWdlID0gY2FudmFzKE1hdGguY2VpbCh3KSwgTWF0aC5jZWlsKGgpKSxcbiAgICAgICAgICAgIGljdHggPSBpbWFnZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWN0eC5zY2FsZSh3LCBoKTtcbiAgICAgIGljdHguZmlsbFN0eWxlID0gYWRkU3RvcHMoaWN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MiksIHNwZWMuc3RvcHMpO1xuICAgICAgaWN0eC5maWxsUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIHJldHVybiBjb250ZXh0LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsICduby1yZXBlYXQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWRkU3RvcHMoZ3JhZGllbnQsIHNwZWMuc3RvcHMpO1xufVxuXG5mdW5jdGlvbiBjb2xvciAoY29udGV4dCwgaXRlbSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzR3JhZGllbnQodmFsdWUpID8gZ3JhZGllbnQoY29udGV4dCwgdmFsdWUsIGl0ZW0uYm91bmRzKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmaWxsIChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgKj0gaXRlbS5maWxsT3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0uZmlsbE9wYWNpdHk7XG5cbiAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcihjb250ZXh0LCBpdGVtLCBpdGVtLmZpbGwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgRW1wdHkgPSBbXTtcbmZ1bmN0aW9uIHN0cm9rZSAoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkge1xuICB2YXIgbHcgPSAobHcgPSBpdGVtLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiAxO1xuICBpZiAobHcgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICBvcGFjaXR5ICo9IGl0ZW0uc3Ryb2tlT3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0uc3Ryb2tlT3BhY2l0eTtcblxuICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3IoY29udGV4dCwgaXRlbSwgaXRlbS5zdHJva2UpO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gbHc7XG4gICAgY29udGV4dC5saW5lQ2FwID0gaXRlbS5zdHJva2VDYXAgfHwgJ2J1dHQnO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSBpdGVtLnN0cm9rZUpvaW4gfHwgJ21pdGVyJztcbiAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBpdGVtLnN0cm9rZU1pdGVyTGltaXQgfHwgMTA7XG5cbiAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChpdGVtLnN0cm9rZURhc2ggfHwgRW1wdHkpO1xuICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IGl0ZW0uc3Ryb2tlRGFzaE9mZnNldCB8fCAwO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGEuemluZGV4IC0gYi56aW5kZXggfHwgYS5pbmRleCAtIGIuaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHpvcmRlcihzY2VuZSkge1xuICBpZiAoIXNjZW5lLnpkaXJ0eSkgcmV0dXJuIHNjZW5lLnppdGVtcztcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvdXRwdXQgPSBbXSxcbiAgICAgIGl0ZW0sXG4gICAgICBpLFxuICAgICAgbjtcblxuICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIGl0ZW0uaW5kZXggPSBpO1xuICAgIGlmIChpdGVtLnppbmRleCkgb3V0cHV0LnB1c2goaXRlbSk7XG4gIH1cblxuICBzY2VuZS56ZGlydHkgPSBmYWxzZTtcbiAgcmV0dXJuIHNjZW5lLnppdGVtcyA9IG91dHB1dC5zb3J0KGNvbXBhcmUpO1xufVxuZnVuY3Rpb24gdmlzaXQoc2NlbmUsIHZpc2l0b3IpIHtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBpLFxuICAgICAgbjtcbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIGNvbnN0IHppdGVtcyA9IHpvcmRlcihzY2VuZSk7XG5cbiAgaWYgKHppdGVtcyAmJiB6aXRlbXMubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCFpdGVtc1tpXS56aW5kZXgpIHZpc2l0b3IoaXRlbXNbaV0pO1xuICAgIH1cblxuICAgIGl0ZW1zID0geml0ZW1zO1xuICB9XG5cbiAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHZpc2l0b3IoaXRlbXNbaV0pO1xuICB9XG59XG5mdW5jdGlvbiBwaWNrVmlzaXQoc2NlbmUsIHZpc2l0b3IpIHtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBoaXQsXG4gICAgICBpO1xuICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCB6aXRlbXMgPSB6b3JkZXIoc2NlbmUpO1xuICBpZiAoeml0ZW1zICYmIHppdGVtcy5sZW5ndGgpIGl0ZW1zID0geml0ZW1zO1xuXG4gIGZvciAoaSA9IGl0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgaWYgKGhpdCA9IHZpc2l0b3IoaXRlbXNbaV0pKSByZXR1cm4gaGl0O1xuICB9XG5cbiAgaWYgKGl0ZW1zID09PSB6aXRlbXMpIHtcbiAgICBmb3IgKGl0ZW1zID0gc2NlbmUuaXRlbXMsIGkgPSBpdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgICAgaWYgKCFpdGVtc1tpXS56aW5kZXgpIHtcbiAgICAgICAgaWYgKGhpdCA9IHZpc2l0b3IoaXRlbXNbaV0pKSByZXR1cm4gaGl0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkcmF3QWxsKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gICAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgICAgaWYgKCFib3VuZHMgfHwgYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKSB7XG4gICAgICAgIGRyYXdQYXRoKHBhdGgsIGNvbnRleHQsIGl0ZW0sIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gZHJhd09uZShwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICAgIGlmIChzY2VuZS5pdGVtcy5sZW5ndGggJiYgKCFib3VuZHMgfHwgYm91bmRzLmludGVyc2VjdHMoc2NlbmUuYm91bmRzKSkpIHtcbiAgICAgIGRyYXdQYXRoKHBhdGgsIGNvbnRleHQsIHNjZW5lLml0ZW1zWzBdLCBzY2VuZS5pdGVtcyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3UGF0aChwYXRoLCBjb250ZXh0LCBpdGVtLCBpdGVtcykge1xuICB2YXIgb3BhY2l0eSA9IGl0ZW0ub3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0ub3BhY2l0eTtcbiAgaWYgKG9wYWNpdHkgPT09IDApIHJldHVybjtcbiAgaWYgKHBhdGgoY29udGV4dCwgaXRlbXMpKSByZXR1cm47XG4gIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuXG4gIGlmIChpdGVtLmZpbGwgJiYgZmlsbChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG5cbiAgaWYgKGl0ZW0uc3Ryb2tlICYmIHN0cm9rZShjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGljayQxKHRlc3QpIHtcbiAgdGVzdCA9IHRlc3QgfHwgdHJ1dGh5O1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICB4ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICB5ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICByZXR1cm4gcGlja1Zpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICAgIGNvbnN0IGIgPSBpdGVtLmJvdW5kczsgLy8gZmlyc3QgaGl0IHRlc3QgYWdhaW5zdCBib3VuZGluZyBib3hcblxuICAgICAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSB8fCAhYikgcmV0dXJuOyAvLyBpZiBpbiBib3VuZGluZyBib3gsIHBlcmZvcm0gbW9yZSBjYXJlZnVsIHRlc3RcblxuICAgICAgaWYgKHRlc3QoY29udGV4dCwgaXRlbSwgeCwgeSwgZ3gsIGd5KSkgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBoaXRQYXRoKHBhdGgsIGZpbGxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIG8sIHgsIHkpIHtcbiAgICB2YXIgaXRlbSA9IEFycmF5LmlzQXJyYXkobykgPyBvWzBdIDogbyxcbiAgICAgICAgZmlsbCA9IGZpbGxlZCA9PSBudWxsID8gaXRlbS5maWxsIDogZmlsbGVkLFxuICAgICAgICBzdHJva2UgPSBpdGVtLnN0cm9rZSAmJiBjb250ZXh0LmlzUG9pbnRJblN0cm9rZSxcbiAgICAgICAgbHcsXG4gICAgICAgIGxjO1xuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgbHcgPSBpdGVtLnN0cm9rZVdpZHRoO1xuICAgICAgbGMgPSBpdGVtLnN0cm9rZUNhcDtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogMTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aChjb250ZXh0LCBvKSA/IGZhbHNlIDogZmlsbCAmJiBjb250ZXh0LmlzUG9pbnRJblBhdGgoeCwgeSkgfHwgc3Ryb2tlICYmIGNvbnRleHQuaXNQb2ludEluU3Ryb2tlKHgsIHkpO1xuICB9O1xufVxuZnVuY3Rpb24gcGlja1BhdGgocGF0aCkge1xuICByZXR1cm4gcGljayQxKGhpdFBhdGgocGF0aCkpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSc7XG59XG5mdW5jdGlvbiByb3RhdGUoYSkge1xuICByZXR1cm4gJ3JvdGF0ZSgnICsgYSArICcpJztcbn1cbmZ1bmN0aW9uIHNjYWxlKHNjYWxlWCwgc2NhbGVZKSB7XG4gIHJldHVybiAnc2NhbGUoJyArIHNjYWxlWCArICcsJyArIHNjYWxlWSArICcpJztcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUl0ZW0oaXRlbSkge1xuICByZXR1cm4gdHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCk7XG59XG5mdW5jdGlvbiByb3RhdGVJdGVtKGl0ZW0pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApICsgKGl0ZW0uYW5nbGUgPyAnICcgKyByb3RhdGUoaXRlbS5hbmdsZSkgOiAnJyk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1JdGVtKGl0ZW0pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApICsgKGl0ZW0uYW5nbGUgPyAnICcgKyByb3RhdGUoaXRlbS5hbmdsZSkgOiAnJykgKyAoaXRlbS5zY2FsZVggfHwgaXRlbS5zY2FsZVkgPyAnICcgKyBzY2FsZShpdGVtLnNjYWxlWCB8fCAxLCBpdGVtLnNjYWxlWSB8fCAxKSA6ICcnKTtcbn1cblxuZnVuY3Rpb24gbWFya0l0ZW1QYXRoICh0eXBlLCBzaGFwZSwgaXNlY3QpIHtcbiAgZnVuY3Rpb24gYXR0cihlbWl0LCBpdGVtKSB7XG4gICAgZW1pdCgndHJhbnNmb3JtJywgcm90YXRlSXRlbShpdGVtKSk7XG4gICAgZW1pdCgnZCcsIHNoYXBlKG51bGwsIGl0ZW0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJvdW5kKGJvdW5kcywgaXRlbSkge1xuICAgIHNoYXBlKGJvdW5kQ29udGV4dChib3VuZHMsIGl0ZW0uYW5nbGUpLCBpdGVtKTtcbiAgICByZXR1cm4gYm91bmRTdHJva2UoYm91bmRzLCBpdGVtKS50cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbSkge1xuICAgIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICAgICAgYSA9IGl0ZW0uYW5nbGUgfHwgMDtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBpZiAoYSkgY29udGV4dC5yb3RhdGUoYSAqPSBEZWdUb1JhZCk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBzaGFwZShjb250ZXh0LCBpdGVtKTtcbiAgICBpZiAoYSkgY29udGV4dC5yb3RhdGUoLWEpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGFnOiAncGF0aCcsXG4gICAgbmVzdGVkOiBmYWxzZSxcbiAgICBhdHRyOiBhdHRyLFxuICAgIGJvdW5kOiBib3VuZCxcbiAgICBkcmF3OiBkcmF3QWxsKGRyYXcpLFxuICAgIHBpY2s6IHBpY2tQYXRoKGRyYXcpLFxuICAgIGlzZWN0OiBpc2VjdCB8fCBpbnRlcnNlY3RQYXRoKGRyYXcpXG4gIH07XG59XG5cbnZhciBhcmMgPSBtYXJrSXRlbVBhdGgoJ2FyYycsIGFyYyQxKTtcblxuZnVuY3Rpb24gcGlja0FyZWEoYSwgcCkge1xuICB2YXIgdiA9IGFbMF0ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwWzFdIDogcFswXSxcbiAgICAgIHogPSBhWzBdLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gJ3knIDogJ3gnLFxuICAgICAgaSA9IGEubGVuZ3RoLFxuICAgICAgbWluID0gK0luZmluaXR5LFxuICAgICAgaGl0LFxuICAgICAgZDtcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAoYVtpXS5kZWZpbmVkID09PSBmYWxzZSkgY29udGludWU7XG4gICAgZCA9IE1hdGguYWJzKGFbaV1bel0gLSB2KTtcblxuICAgIGlmIChkIDwgbWluKSB7XG4gICAgICBtaW4gPSBkO1xuICAgICAgaGl0ID0gYVtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGl0O1xufVxuZnVuY3Rpb24gcGlja0xpbmUoYSwgcCkge1xuICB2YXIgdCA9IE1hdGgucG93KGFbMF0uc3Ryb2tlV2lkdGggfHwgMSwgMiksXG4gICAgICBpID0gYS5sZW5ndGgsXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgZGQ7XG5cbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgaWYgKGFbaV0uZGVmaW5lZCA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgIGR4ID0gYVtpXS54IC0gcFswXTtcbiAgICBkeSA9IGFbaV0ueSAtIHBbMV07XG4gICAgZGQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICBpZiAoZGQgPCB0KSByZXR1cm4gYVtpXTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGlja1RyYWlsKGEsIHApIHtcbiAgdmFyIGkgPSBhLmxlbmd0aCxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICBkZDtcblxuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAoYVtpXS5kZWZpbmVkID09PSBmYWxzZSkgY29udGludWU7XG4gICAgZHggPSBhW2ldLnggLSBwWzBdO1xuICAgIGR5ID0gYVtpXS55IC0gcFsxXTtcbiAgICBkZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGR4ID0gYVtpXS5zaXplIHx8IDE7XG4gICAgaWYgKGRkIDwgZHggKiBkeCkgcmV0dXJuIGFbaV07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFya011bHRpSXRlbVBhdGggKHR5cGUsIHNoYXBlLCB0aXApIHtcbiAgZnVuY3Rpb24gYXR0cihlbWl0LCBpdGVtKSB7XG4gICAgdmFyIGl0ZW1zID0gaXRlbS5tYXJrLml0ZW1zO1xuICAgIGlmIChpdGVtcy5sZW5ndGgpIGVtaXQoJ2QnLCBzaGFwZShudWxsLCBpdGVtcykpO1xuICB9XG5cbiAgZnVuY3Rpb24gYm91bmQoYm91bmRzLCBtYXJrKSB7XG4gICAgdmFyIGl0ZW1zID0gbWFyay5pdGVtcztcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlKGJvdW5kQ29udGV4dChib3VuZHMpLCBpdGVtcyk7XG4gICAgICByZXR1cm4gYm91bmRTdHJva2UoYm91bmRzLCBpdGVtc1swXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBpdGVtcykge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgc2hhcGUoY29udGV4dCwgaXRlbXMpO1xuICB9XG5cbiAgY29uc3QgaGl0ID0gaGl0UGF0aChkcmF3KTtcblxuICBmdW5jdGlvbiBwaWNrKGNvbnRleHQsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgICAgYiA9IHNjZW5lLmJvdW5kcztcblxuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCB8fCBiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHggKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHkgKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHJldHVybiBoaXQoY29udGV4dCwgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRhZzogJ3BhdGgnLFxuICAgIG5lc3RlZDogdHJ1ZSxcbiAgICBhdHRyOiBhdHRyLFxuICAgIGJvdW5kOiBib3VuZCxcbiAgICBkcmF3OiBkcmF3T25lKGRyYXcpLFxuICAgIHBpY2s6IHBpY2ssXG4gICAgaXNlY3Q6IGludGVyc2VjdFBvaW50LFxuICAgIHRpcDogdGlwXG4gIH07XG59XG5cbnZhciBhcmVhID0gbWFya011bHRpSXRlbVBhdGgoJ2FyZWEnLCBhcmVhJDEsIHBpY2tBcmVhKTtcblxuZnVuY3Rpb24gY2xpcCAoY29udGV4dCwgc2NlbmUpIHtcbiAgdmFyIGNsaXAgPSBzY2VuZS5jbGlwO1xuICBjb250ZXh0LnNhdmUoKTtcblxuICBpZiAoaXNGdW5jdGlvbihjbGlwKSkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY2xpcChjb250ZXh0KTtcbiAgICBjb250ZXh0LmNsaXAoKTtcbiAgfSBlbHNlIHtcbiAgICBjbGlwR3JvdXAoY29udGV4dCwgc2NlbmUuZ3JvdXApO1xuICB9XG59XG5mdW5jdGlvbiBjbGlwR3JvdXAoY29udGV4dCwgZ3JvdXApIHtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgaGFzQ29ybmVyUmFkaXVzKGdyb3VwKSA/IHJlY3RhbmdsZShjb250ZXh0LCBncm91cCwgMCwgMCkgOiBjb250ZXh0LnJlY3QoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICBjb250ZXh0LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0JDEoaXRlbSkge1xuICBjb25zdCBzdyA9IHZhbHVlKGl0ZW0uc3Ryb2tlV2lkdGgsIDEpO1xuICByZXR1cm4gaXRlbS5zdHJva2VPZmZzZXQgIT0gbnVsbCA/IGl0ZW0uc3Ryb2tlT2Zmc2V0IDogaXRlbS5zdHJva2UgJiYgc3cgPiAwLjUgJiYgc3cgPCAxLjUgPyAwLjUgLSBNYXRoLmFicyhzdyAtIDEpIDogMDtcbn1cblxuZnVuY3Rpb24gYXR0ciQ1KGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShpdGVtKSk7XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWN0YW5nbGUoZW1pdCwgaXRlbSkge1xuICBjb25zdCBvZmYgPSBvZmZzZXQkMShpdGVtKTtcbiAgZW1pdCgnZCcsIHJlY3RhbmdsZShudWxsLCBpdGVtLCBvZmYsIG9mZikpO1xufVxuXG5mdW5jdGlvbiBiYWNrZ3JvdW5kKGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgnY2xhc3MnLCAnYmFja2dyb3VuZCcpO1xuICBlbWl0KCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICBlbWl0UmVjdGFuZ2xlKGVtaXQsIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBmb3JlZ3JvdW5kKGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgnY2xhc3MnLCAnZm9yZWdyb3VuZCcpO1xuICBlbWl0KCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gIGlmIChpdGVtLnN0cm9rZUZvcmVncm91bmQpIHtcbiAgICBlbWl0UmVjdGFuZ2xlKGVtaXQsIGl0ZW0pO1xuICB9IGVsc2Uge1xuICAgIGVtaXQoJ2QnLCAnJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udGVudChlbWl0LCBpdGVtLCByZW5kZXJlcikge1xuICBjb25zdCB1cmwgPSBpdGVtLmNsaXAgPyBjbGlwJDEocmVuZGVyZXIsIGl0ZW0sIGl0ZW0pIDogbnVsbDtcbiAgZW1pdCgnY2xpcC1wYXRoJywgdXJsKTtcbn1cblxuZnVuY3Rpb24gYm91bmQkNShib3VuZHMsIGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuY2xpcCAmJiBncm91cC5pdGVtcykge1xuICAgIGNvbnN0IGl0ZW1zID0gZ3JvdXAuaXRlbXMsXG4gICAgICAgICAgbSA9IGl0ZW1zLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbXNbal0uYm91bmRzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoKGdyb3VwLmNsaXAgfHwgZ3JvdXAud2lkdGggfHwgZ3JvdXAuaGVpZ2h0KSAmJiAhZ3JvdXAubm9Cb3VuZCkge1xuICAgIGJvdW5kcy5hZGQoMCwgMCkuYWRkKGdyb3VwLndpZHRoIHx8IDAsIGdyb3VwLmhlaWdodCB8fCAwKTtcbiAgfVxuXG4gIGJvdW5kU3Ryb2tlKGJvdW5kcywgZ3JvdXApO1xuICByZXR1cm4gYm91bmRzLnRyYW5zbGF0ZShncm91cC54IHx8IDAsIGdyb3VwLnkgfHwgMCk7XG59XG5cbmZ1bmN0aW9uIHJlY3RhbmdsZVBhdGgoY29udGV4dCwgZ3JvdXAsIHgsIHkpIHtcbiAgY29uc3Qgb2ZmID0gb2Zmc2V0JDEoZ3JvdXApO1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICByZWN0YW5nbGUoY29udGV4dCwgZ3JvdXAsICh4IHx8IDApICsgb2ZmLCAoeSB8fCAwKSArIG9mZik7XG59XG5cbmNvbnN0IGhpdEJhY2tncm91bmQgPSBoaXRQYXRoKHJlY3RhbmdsZVBhdGgpO1xuY29uc3QgaGl0Rm9yZWdyb3VuZCA9IGhpdFBhdGgocmVjdGFuZ2xlUGF0aCwgZmFsc2UpO1xuY29uc3QgaGl0Q29ybmVyID0gaGl0UGF0aChyZWN0YW5nbGVQYXRoLCB0cnVlKTtcblxuZnVuY3Rpb24gZHJhdyQ0KGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmlzaXQoc2NlbmUsIGdyb3VwID0+IHtcbiAgICBjb25zdCBneCA9IGdyb3VwLnggfHwgMCxcbiAgICAgICAgICBneSA9IGdyb3VwLnkgfHwgMCxcbiAgICAgICAgICBmb3JlID0gZ3JvdXAuc3Ryb2tlRm9yZWdyb3VuZCxcbiAgICAgICAgICBvcGFjaXR5ID0gZ3JvdXAub3BhY2l0eSA9PSBudWxsID8gMSA6IGdyb3VwLm9wYWNpdHk7IC8vIGRyYXcgZ3JvdXAgYmFja2dyb3VuZFxuXG4gICAgaWYgKChncm91cC5zdHJva2UgfHwgZ3JvdXAuZmlsbCkgJiYgb3BhY2l0eSkge1xuICAgICAgcmVjdGFuZ2xlUGF0aChjb250ZXh0LCBncm91cCwgZ3gsIGd5KTtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGdyb3VwKTtcblxuICAgICAgaWYgKGdyb3VwLmZpbGwgJiYgZmlsbChjb250ZXh0LCBncm91cCwgb3BhY2l0eSkpIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5zdHJva2UgJiYgIWZvcmUgJiYgc3Ryb2tlKGNvbnRleHQsIGdyb3VwLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH0gLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dCwgc2V0IGNsaXAgYW5kIGJvdW5kc1xuXG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGlmIChncm91cC5jbGlwKSBjbGlwR3JvdXAoY29udGV4dCwgZ3JvdXApO1xuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoLWd4LCAtZ3kpOyAvLyBkcmF3IGdyb3VwIGNvbnRlbnRzXG5cbiAgICB2aXNpdChncm91cCwgaXRlbSA9PiB7XG4gICAgICB0aGlzLmRyYXcoY29udGV4dCwgaXRlbSwgYm91bmRzKTtcbiAgICB9KTsgLy8gcmVzdG9yZSBncmFwaGljcyBjb250ZXh0XG5cbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7IC8vIGRyYXcgZ3JvdXAgZm9yZWdyb3VuZFxuXG4gICAgaWYgKGZvcmUgJiYgZ3JvdXAuc3Ryb2tlICYmIG9wYWNpdHkpIHtcbiAgICAgIHJlY3RhbmdsZVBhdGgoY29udGV4dCwgZ3JvdXAsIGd4LCBneSk7XG4gICAgICBibGVuZChjb250ZXh0LCBncm91cCk7XG5cbiAgICAgIGlmIChzdHJva2UoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcGljayhjb250ZXh0LCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChzY2VuZS5ib3VuZHMgJiYgIXNjZW5lLmJvdW5kcy5jb250YWlucyhneCwgZ3kpIHx8ICFzY2VuZS5pdGVtcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgY3ggPSB4ICogY29udGV4dC5waXhlbFJhdGlvLFxuICAgICAgICBjeSA9IHkgKiBjb250ZXh0LnBpeGVsUmF0aW87XG4gIHJldHVybiBwaWNrVmlzaXQoc2NlbmUsIGdyb3VwID0+IHtcbiAgICBsZXQgaGl0LCBkeCwgZHk7IC8vIGZpcnN0IGhpdCB0ZXN0IGJvdW5kaW5nIGJveFxuXG4gICAgY29uc3QgYiA9IGdyb3VwLmJvdW5kcztcbiAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm47IC8vIHBhc3NlZCBib3VuZHMgY2hlY2ssIHRlc3QgcmVjdGFuZ3VsYXIgY2xpcFxuXG4gICAgZHggPSBncm91cC54IHx8IDA7XG4gICAgZHkgPSBncm91cC55IHx8IDA7XG4gICAgY29uc3QgZHcgPSBkeCArIChncm91cC53aWR0aCB8fCAwKSxcbiAgICAgICAgICBkaCA9IGR5ICsgKGdyb3VwLmhlaWdodCB8fCAwKSxcbiAgICAgICAgICBjID0gZ3JvdXAuY2xpcDtcbiAgICBpZiAoYyAmJiAoZ3ggPCBkeCB8fCBneCA+IGR3IHx8IGd5IDwgZHkgfHwgZ3kgPiBkaCkpIHJldHVybjsgLy8gYWRqdXN0IGNvb3JkaW5hdGUgc3lzdGVtXG5cbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShkeCwgZHkpO1xuICAgIGR4ID0gZ3ggLSBkeDtcbiAgICBkeSA9IGd5IC0gZHk7IC8vIHRlc3QgYmFja2dyb3VuZCBmb3Igcm91bmRlZCBjb3JuZXIgY2xpcFxuXG4gICAgaWYgKGMgJiYgaGFzQ29ybmVyUmFkaXVzKGdyb3VwKSAmJiAhaGl0Q29ybmVyKGNvbnRleHQsIGdyb3VwLCBjeCwgY3kpKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcmUgPSBncm91cC5zdHJva2VGb3JlZ3JvdW5kLFxuICAgICAgICAgIGl4ID0gc2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlOyAvLyBoaXQgdGVzdCBhZ2FpbnN0IGdyb3VwIGZvcmVncm91bmRcblxuICAgIGlmIChpeCAmJiBmb3JlICYmIGdyb3VwLnN0cm9rZSAmJiBoaXRGb3JlZ3JvdW5kKGNvbnRleHQsIGdyb3VwLCBjeCwgY3kpKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9IC8vIGhpdCB0ZXN0IGFnYWluc3QgY29udGFpbmVkIG1hcmtzXG5cblxuICAgIGhpdCA9IHBpY2tWaXNpdChncm91cCwgbWFyayA9PiBwaWNrTWFyayhtYXJrLCBkeCwgZHkpID8gdGhpcy5waWNrKG1hcmssIHgsIHksIGR4LCBkeSkgOiBudWxsKTsgLy8gaGl0IHRlc3QgYWdhaW5zdCBncm91cCBiYWNrZ3JvdW5kXG5cbiAgICBpZiAoIWhpdCAmJiBpeCAmJiAoZ3JvdXAuZmlsbCB8fCAhZm9yZSAmJiBncm91cC5zdHJva2UpICYmIGhpdEJhY2tncm91bmQoY29udGV4dCwgZ3JvdXAsIGN4LCBjeSkpIHtcbiAgICAgIGhpdCA9IGdyb3VwO1xuICAgIH0gLy8gcmVzdG9yZSBzdGF0ZSBhbmQgcmV0dXJuXG5cblxuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIHJldHVybiBoaXQgfHwgbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBpY2tNYXJrKG1hcmssIHgsIHkpIHtcbiAgcmV0dXJuIChtYXJrLmludGVyYWN0aXZlICE9PSBmYWxzZSB8fCBtYXJrLm1hcmt0eXBlID09PSAnZ3JvdXAnKSAmJiBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jb250YWlucyh4LCB5KTtcbn1cblxudmFyIGdyb3VwID0ge1xuICB0eXBlOiAnZ3JvdXAnLFxuICB0YWc6ICdnJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQ1LFxuICBib3VuZDogYm91bmQkNSxcbiAgZHJhdzogZHJhdyQ0LFxuICBwaWNrOiBwaWNrLFxuICBpc2VjdDogaW50ZXJzZWN0UmVjdCxcbiAgY29udGVudDogY29udGVudCxcbiAgYmFja2dyb3VuZDogYmFja2dyb3VuZCxcbiAgZm9yZWdyb3VuZDogZm9yZWdyb3VuZFxufTtcblxudmFyIG1ldGFkYXRhID0ge1xuICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gICd2ZXJzaW9uJzogJzEuMSdcbn07XG5cbmZ1bmN0aW9uIGdldEltYWdlKGl0ZW0sIHJlbmRlcmVyKSB7XG4gIHZhciBpbWFnZSA9IGl0ZW0uaW1hZ2U7XG5cbiAgaWYgKCFpbWFnZSB8fCBpdGVtLnVybCAmJiBpdGVtLnVybCAhPT0gaW1hZ2UudXJsKSB7XG4gICAgaW1hZ2UgPSB7XG4gICAgICBjb21wbGV0ZTogZmFsc2UsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgcmVuZGVyZXIubG9hZEltYWdlKGl0ZW0udXJsKS50aGVuKGltYWdlID0+IHtcbiAgICAgIGl0ZW0uaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGl0ZW0uaW1hZ2UudXJsID0gaXRlbS51cmw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59XG5cbmZ1bmN0aW9uIGltYWdlV2lkdGgoaXRlbSwgaW1hZ2UpIHtcbiAgcmV0dXJuIGl0ZW0ud2lkdGggIT0gbnVsbCA/IGl0ZW0ud2lkdGggOiAhaW1hZ2UgfHwgIWltYWdlLndpZHRoID8gMCA6IGl0ZW0uYXNwZWN0ICE9PSBmYWxzZSAmJiBpdGVtLmhlaWdodCA/IGl0ZW0uaGVpZ2h0ICogaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQgOiBpbWFnZS53aWR0aDtcbn1cblxuZnVuY3Rpb24gaW1hZ2VIZWlnaHQoaXRlbSwgaW1hZ2UpIHtcbiAgcmV0dXJuIGl0ZW0uaGVpZ2h0ICE9IG51bGwgPyBpdGVtLmhlaWdodCA6ICFpbWFnZSB8fCAhaW1hZ2UuaGVpZ2h0ID8gMCA6IGl0ZW0uYXNwZWN0ICE9PSBmYWxzZSAmJiBpdGVtLndpZHRoID8gaXRlbS53aWR0aCAqIGltYWdlLmhlaWdodCAvIGltYWdlLndpZHRoIDogaW1hZ2UuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBpbWFnZVhPZmZzZXQoYWxpZ24sIHcpIHtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyA/IHcgLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyB3IDogMDtcbn1cblxuZnVuY3Rpb24gaW1hZ2VZT2Zmc2V0KGJhc2VsaW5lLCBoKSB7XG4gIHJldHVybiBiYXNlbGluZSA9PT0gJ21pZGRsZScgPyBoIC8gMiA6IGJhc2VsaW5lID09PSAnYm90dG9tJyA/IGggOiAwO1xufVxuXG5mdW5jdGlvbiBhdHRyJDQoZW1pdCwgaXRlbSwgcmVuZGVyZXIpIHtcbiAgY29uc3QgaW1nID0gZ2V0SW1hZ2UoaXRlbSwgcmVuZGVyZXIpLFxuICAgICAgICB3ID0gaW1hZ2VXaWR0aChpdGVtLCBpbWcpLFxuICAgICAgICBoID0gaW1hZ2VIZWlnaHQoaXRlbSwgaW1nKSxcbiAgICAgICAgeCA9IChpdGVtLnggfHwgMCkgLSBpbWFnZVhPZmZzZXQoaXRlbS5hbGlnbiwgdyksXG4gICAgICAgIHkgPSAoaXRlbS55IHx8IDApIC0gaW1hZ2VZT2Zmc2V0KGl0ZW0uYmFzZWxpbmUsIGgpLFxuICAgICAgICBpID0gIWltZy5zcmMgJiYgaW1nLnRvRGF0YVVSTCA/IGltZy50b0RhdGFVUkwoKSA6IGltZy5zcmMgfHwgJyc7XG4gIGVtaXQoJ2hyZWYnLCBpLCBtZXRhZGF0YVsneG1sbnM6eGxpbmsnXSwgJ3hsaW5rOmhyZWYnKTtcbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlKHgsIHkpKTtcbiAgZW1pdCgnd2lkdGgnLCB3KTtcbiAgZW1pdCgnaGVpZ2h0JywgaCk7XG4gIGVtaXQoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBpdGVtLmFzcGVjdCA9PT0gZmFsc2UgPyAnbm9uZScgOiAneE1pZFlNaWQnKTtcbn1cblxuZnVuY3Rpb24gYm91bmQkNChib3VuZHMsIGl0ZW0pIHtcbiAgY29uc3QgaW1nID0gaXRlbS5pbWFnZSxcbiAgICAgICAgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKSxcbiAgICAgICAgaCA9IGltYWdlSGVpZ2h0KGl0ZW0sIGltZyksXG4gICAgICAgIHggPSAoaXRlbS54IHx8IDApIC0gaW1hZ2VYT2Zmc2V0KGl0ZW0uYWxpZ24sIHcpLFxuICAgICAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCArIHcsIHkgKyBoKTtcbn1cblxuZnVuY3Rpb24gZHJhdyQzKGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkgcmV0dXJuOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIGNvbnN0IGltZyA9IGdldEltYWdlKGl0ZW0sIHRoaXMpO1xuICAgIGxldCB3ID0gaW1hZ2VXaWR0aChpdGVtLCBpbWcpO1xuICAgIGxldCBoID0gaW1hZ2VIZWlnaHQoaXRlbSwgaW1nKTtcbiAgICBpZiAodyA9PT0gMCB8fCBoID09PSAwKSByZXR1cm47IC8vIGVhcmx5IGV4aXRcblxuICAgIGxldCB4ID0gKGl0ZW0ueCB8fCAwKSAtIGltYWdlWE9mZnNldChpdGVtLmFsaWduLCB3KSxcbiAgICAgICAgeSA9IChpdGVtLnkgfHwgMCkgLSBpbWFnZVlPZmZzZXQoaXRlbS5iYXNlbGluZSwgaCksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGFyMCxcbiAgICAgICAgYXIxLFxuICAgICAgICB0O1xuXG4gICAgaWYgKGl0ZW0uYXNwZWN0ICE9PSBmYWxzZSkge1xuICAgICAgYXIwID0gaW1nLndpZHRoIC8gaW1nLmhlaWdodDtcbiAgICAgIGFyMSA9IGl0ZW0ud2lkdGggLyBpdGVtLmhlaWdodDtcblxuICAgICAgaWYgKGFyMCA9PT0gYXIwICYmIGFyMSA9PT0gYXIxICYmIGFyMCAhPT0gYXIxKSB7XG4gICAgICAgIGlmIChhcjEgPCBhcjApIHtcbiAgICAgICAgICB0ID0gdyAvIGFyMDtcbiAgICAgICAgICB5ICs9IChoIC0gdCkgLyAyO1xuICAgICAgICAgIGggPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSBoICogYXIwO1xuICAgICAgICAgIHggKz0gKHcgLSB0KSAvIDI7XG4gICAgICAgICAgdyA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1nLmNvbXBsZXRlIHx8IGltZy50b0RhdGFVUkwpIHtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IChvcGFjaXR5ID0gaXRlbS5vcGFjaXR5KSAhPSBudWxsID8gb3BhY2l0eSA6IDE7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGl0ZW0uc21vb3RoICE9PSBmYWxzZTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGltYWdlID0ge1xuICB0eXBlOiAnaW1hZ2UnLFxuICB0YWc6ICdpbWFnZScsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkNCxcbiAgYm91bmQ6IGJvdW5kJDQsXG4gIGRyYXc6IGRyYXckMyxcbiAgcGljazogcGljayQxKCksXG4gIGlzZWN0OiB0cnV0aHksXG4gIC8vIGJvdW5kcyBjaGVjayBpcyBzdWZmaWNpZW50XG4gIGdldDogZ2V0SW1hZ2UsXG4gIHhPZmZzZXQ6IGltYWdlWE9mZnNldCxcbiAgeU9mZnNldDogaW1hZ2VZT2Zmc2V0XG59O1xuXG52YXIgbGluZSA9IG1hcmtNdWx0aUl0ZW1QYXRoKCdsaW5lJywgbGluZSQxLCBwaWNrTGluZSk7XG5cbmZ1bmN0aW9uIGF0dHIkMyhlbWl0LCBpdGVtKSB7XG4gIHZhciBzeCA9IGl0ZW0uc2NhbGVYIHx8IDEsXG4gICAgICBzeSA9IGl0ZW0uc2NhbGVZIHx8IDE7XG5cbiAgaWYgKHN4ICE9PSAxIHx8IHN5ICE9PSAxKSB7XG4gICAgZW1pdCgndmVjdG9yLWVmZmVjdCcsICdub24tc2NhbGluZy1zdHJva2UnKTtcbiAgfVxuXG4gIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybUl0ZW0oaXRlbSkpO1xuICBlbWl0KCdkJywgaXRlbS5wYXRoKTtcbn1cblxuZnVuY3Rpb24gcGF0aCQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgdmFyIHBhdGggPSBpdGVtLnBhdGg7XG4gIGlmIChwYXRoID09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgeCA9IGl0ZW0ueCB8fCAwLFxuICAgICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgICAgc3ggPSBpdGVtLnNjYWxlWCB8fCAxLFxuICAgICAgc3kgPSBpdGVtLnNjYWxlWSB8fCAxLFxuICAgICAgYSA9IChpdGVtLmFuZ2xlIHx8IDApICogRGVnVG9SYWQsXG4gICAgICBjYWNoZSA9IGl0ZW0ucGF0aENhY2hlO1xuXG4gIGlmICghY2FjaGUgfHwgY2FjaGUucGF0aCAhPT0gcGF0aCkge1xuICAgIChpdGVtLnBhdGhDYWNoZSA9IGNhY2hlID0gcGF0aFBhcnNlKHBhdGgpKS5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIGlmIChhICYmIGNvbnRleHQucm90YXRlICYmIGNvbnRleHQudHJhbnNsYXRlKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgY29udGV4dC5yb3RhdGUoYSk7XG4gICAgcGF0aFJlbmRlcihjb250ZXh0LCBjYWNoZSwgMCwgMCwgc3gsIHN5KTtcbiAgICBjb250ZXh0LnJvdGF0ZSgtYSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoUmVuZGVyKGNvbnRleHQsIGNhY2hlLCB4LCB5LCBzeCwgc3kpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kJDMoYm91bmRzLCBpdGVtKSB7XG4gIHJldHVybiBwYXRoJDEoYm91bmRDb250ZXh0KGJvdW5kcywgaXRlbS5hbmdsZSksIGl0ZW0pID8gYm91bmRzLnNldCgwLCAwLCAwLCAwKSA6IGJvdW5kU3Ryb2tlKGJvdW5kcywgaXRlbSwgdHJ1ZSk7XG59XG5cbnZhciBwYXRoJDIgPSB7XG4gIHR5cGU6ICdwYXRoJyxcbiAgdGFnOiAncGF0aCcsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkMyxcbiAgYm91bmQ6IGJvdW5kJDMsXG4gIGRyYXc6IGRyYXdBbGwocGF0aCQxKSxcbiAgcGljazogcGlja1BhdGgocGF0aCQxKSxcbiAgaXNlY3Q6IGludGVyc2VjdFBhdGgocGF0aCQxKVxufTtcblxuZnVuY3Rpb24gYXR0ciQyKGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgnZCcsIHJlY3RhbmdsZShudWxsLCBpdGVtKSk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kJDIoYm91bmRzLCBpdGVtKSB7XG4gIHZhciB4LCB5O1xuICByZXR1cm4gYm91bmRTdHJva2UoYm91bmRzLnNldCh4ID0gaXRlbS54IHx8IDAsIHkgPSBpdGVtLnkgfHwgMCwgeCArIGl0ZW0ud2lkdGggfHwgMCwgeSArIGl0ZW0uaGVpZ2h0IHx8IDApLCBpdGVtKTtcbn1cblxuZnVuY3Rpb24gZHJhdyQyKGNvbnRleHQsIGl0ZW0pIHtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcmVjdGFuZ2xlKGNvbnRleHQsIGl0ZW0pO1xufVxuXG52YXIgcmVjdCA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICB0YWc6ICdwYXRoJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQyLFxuICBib3VuZDogYm91bmQkMixcbiAgZHJhdzogZHJhd0FsbChkcmF3JDIpLFxuICBwaWNrOiBwaWNrUGF0aChkcmF3JDIpLFxuICBpc2VjdDogaW50ZXJzZWN0UmVjdFxufTtcblxuZnVuY3Rpb24gYXR0ciQxKGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShpdGVtKSk7XG4gIGVtaXQoJ3gyJywgaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiAtIChpdGVtLnggfHwgMCkgOiAwKTtcbiAgZW1pdCgneTInLCBpdGVtLnkyICE9IG51bGwgPyBpdGVtLnkyIC0gKGl0ZW0ueSB8fCAwKSA6IDApO1xufVxuXG5mdW5jdGlvbiBib3VuZCQxKGJvdW5kcywgaXRlbSkge1xuICB2YXIgeDEsIHkxO1xuICByZXR1cm4gYm91bmRTdHJva2UoYm91bmRzLnNldCh4MSA9IGl0ZW0ueCB8fCAwLCB5MSA9IGl0ZW0ueSB8fCAwLCBpdGVtLngyICE9IG51bGwgPyBpdGVtLngyIDogeDEsIGl0ZW0ueTIgIT0gbnVsbCA/IGl0ZW0ueTIgOiB5MSksIGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBwYXRoKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuXG4gIGlmIChpdGVtLnN0cm9rZSAmJiBzdHJva2UoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICB4MSA9IGl0ZW0ueCB8fCAwO1xuICAgIHkxID0gaXRlbS55IHx8IDA7XG4gICAgeDIgPSBpdGVtLngyICE9IG51bGwgPyBpdGVtLngyIDogeDE7XG4gICAgeTIgPSBpdGVtLnkyICE9IG51bGwgPyBpdGVtLnkyIDogeTE7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRyYXckMShjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICB2YXIgb3BhY2l0eSA9IGl0ZW0ub3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0ub3BhY2l0eTtcblxuICAgIGlmIChvcGFjaXR5ICYmIHBhdGgoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaXQkMShjb250ZXh0LCBpdGVtLCB4LCB5KSB7XG4gIGlmICghY29udGV4dC5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHBhdGgoY29udGV4dCwgaXRlbSwgMSkgJiYgY29udGV4dC5pc1BvaW50SW5TdHJva2UoeCwgeSk7XG59XG5cbnZhciBydWxlID0ge1xuICB0eXBlOiAncnVsZScsXG4gIHRhZzogJ2xpbmUnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDEsXG4gIGJvdW5kOiBib3VuZCQxLFxuICBkcmF3OiBkcmF3JDEsXG4gIHBpY2s6IHBpY2skMShoaXQkMSksXG4gIGlzZWN0OiBpbnRlcnNlY3RSdWxlXG59O1xuXG52YXIgc2hhcGUgPSBtYXJrSXRlbVBhdGgoJ3NoYXBlJywgc2hhcGUkMSk7XG5cbnZhciBzeW1ib2wgPSBtYXJrSXRlbVBhdGgoJ3N5bWJvbCcsIHN5bWJvbCQxLCBpbnRlcnNlY3RQb2ludCk7XG5cbmNvbnN0IHdpZHRoQ2FjaGUgPSBscnVDYWNoZSgpO1xudmFyIHRleHRNZXRyaWNzID0ge1xuICBoZWlnaHQ6IGZvbnRTaXplLFxuICBtZWFzdXJlV2lkdGg6IG1lYXN1cmVXaWR0aCxcbiAgZXN0aW1hdGVXaWR0aDogZXN0aW1hdGVXaWR0aCxcbiAgd2lkdGg6IGVzdGltYXRlV2lkdGgsXG4gIGNhbnZhczogdXNlQ2FudmFzXG59O1xudXNlQ2FudmFzKHRydWUpO1xuXG5mdW5jdGlvbiB1c2VDYW52YXModXNlKSB7XG4gIHRleHRNZXRyaWNzLndpZHRoID0gdXNlICYmIGNvbnRleHQgPyBtZWFzdXJlV2lkdGggOiBlc3RpbWF0ZVdpZHRoO1xufSAvLyBtYWtlIHNpbXBsZSBlc3RpbWF0ZSBpZiBubyBjYW52YXMgaXMgYXZhaWxhYmxlXG5cblxuZnVuY3Rpb24gZXN0aW1hdGVXaWR0aChpdGVtLCB0ZXh0KSB7XG4gIHJldHVybiBfZXN0aW1hdGVXaWR0aCh0ZXh0VmFsdWUoaXRlbSwgdGV4dCksIGZvbnRTaXplKGl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gX2VzdGltYXRlV2lkdGgodGV4dCwgY3VycmVudEZvbnRIZWlnaHQpIHtcbiAgcmV0dXJuIH5+KDAuOCAqIHRleHQubGVuZ3RoICogY3VycmVudEZvbnRIZWlnaHQpO1xufSAvLyBtZWFzdXJlIHRleHQgd2lkdGggaWYgY2FudmFzIGlzIGF2YWlsYWJsZVxuXG5cbmZ1bmN0aW9uIG1lYXN1cmVXaWR0aChpdGVtLCB0ZXh0KSB7XG4gIHJldHVybiBmb250U2l6ZShpdGVtKSA8PSAwIHx8ICEodGV4dCA9IHRleHRWYWx1ZShpdGVtLCB0ZXh0KSkgPyAwIDogX21lYXN1cmVXaWR0aCh0ZXh0LCBmb250KGl0ZW0pKTtcbn1cblxuZnVuY3Rpb24gX21lYXN1cmVXaWR0aCh0ZXh0LCBjdXJyZW50Rm9udCkge1xuICBjb25zdCBrZXkgPSBgKCR7Y3VycmVudEZvbnR9KSAke3RleHR9YDtcbiAgbGV0IHdpZHRoID0gd2lkdGhDYWNoZS5nZXQoa2V5KTtcblxuICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnRleHQuZm9udCA9IGN1cnJlbnRGb250O1xuICAgIHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICB3aWR0aENhY2hlLnNldChrZXksIHdpZHRoKTtcbiAgfVxuXG4gIHJldHVybiB3aWR0aDtcbn1cblxuZnVuY3Rpb24gZm9udFNpemUoaXRlbSkge1xuICByZXR1cm4gaXRlbS5mb250U2l6ZSAhPSBudWxsID8gK2l0ZW0uZm9udFNpemUgfHwgMCA6IDExO1xufVxuZnVuY3Rpb24gbGluZUhlaWdodChpdGVtKSB7XG4gIHJldHVybiBpdGVtLmxpbmVIZWlnaHQgIT0gbnVsbCA/IGl0ZW0ubGluZUhlaWdodCA6IGZvbnRTaXplKGl0ZW0pICsgMjtcbn1cblxuZnVuY3Rpb24gbGluZUFycmF5KF8pIHtcbiAgcmV0dXJuIGlzQXJyYXkoXykgPyBfLmxlbmd0aCA+IDEgPyBfIDogX1swXSA6IF87XG59XG5cbmZ1bmN0aW9uIHRleHRMaW5lcyhpdGVtKSB7XG4gIHJldHVybiBsaW5lQXJyYXkoaXRlbS5saW5lQnJlYWsgJiYgaXRlbS50ZXh0ICYmICFpc0FycmF5KGl0ZW0udGV4dCkgPyBpdGVtLnRleHQuc3BsaXQoaXRlbS5saW5lQnJlYWspIDogaXRlbS50ZXh0KTtcbn1cbmZ1bmN0aW9uIG11bHRpTGluZU9mZnNldChpdGVtKSB7XG4gIGNvbnN0IHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuICByZXR1cm4gKGlzQXJyYXkodGwpID8gdGwubGVuZ3RoIC0gMSA6IDApICogbGluZUhlaWdodChpdGVtKTtcbn1cbmZ1bmN0aW9uIHRleHRWYWx1ZShpdGVtLCBsaW5lKSB7XG4gIGNvbnN0IHRleHQgPSBsaW5lID09IG51bGwgPyAnJyA6IChsaW5lICsgJycpLnRyaW0oKTtcbiAgcmV0dXJuIGl0ZW0ubGltaXQgPiAwICYmIHRleHQubGVuZ3RoID8gdHJ1bmNhdGUoaXRlbSwgdGV4dCkgOiB0ZXh0O1xufVxuXG5mdW5jdGlvbiB3aWR0aEdldHRlcihpdGVtKSB7XG4gIGlmICh0ZXh0TWV0cmljcy53aWR0aCA9PT0gbWVhc3VyZVdpZHRoKSB7XG4gICAgLy8gd2UgYXJlIHVzaW5nIGNhbnZhc1xuICAgIGNvbnN0IGN1cnJlbnRGb250ID0gZm9udChpdGVtKTtcbiAgICByZXR1cm4gdGV4dCA9PiBfbWVhc3VyZVdpZHRoKHRleHQsIGN1cnJlbnRGb250KTtcbiAgfSBlbHNlIHtcbiAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiBlc3RpbWF0ZXNcbiAgICBjb25zdCBjdXJyZW50Rm9udEhlaWdodCA9IGZvbnRTaXplKGl0ZW0pO1xuICAgIHJldHVybiB0ZXh0ID0+IF9lc3RpbWF0ZVdpZHRoKHRleHQsIGN1cnJlbnRGb250SGVpZ2h0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShpdGVtLCB0ZXh0KSB7XG4gIHZhciBsaW1pdCA9ICtpdGVtLmxpbWl0LFxuICAgICAgd2lkdGggPSB3aWR0aEdldHRlcihpdGVtKTtcbiAgaWYgKHdpZHRoKHRleHQpIDwgbGltaXQpIHJldHVybiB0ZXh0O1xuICB2YXIgZWxsaXBzaXMgPSBpdGVtLmVsbGlwc2lzIHx8ICdcXHUyMDI2JyxcbiAgICAgIHJ0bCA9IGl0ZW0uZGlyID09PSAncnRsJyxcbiAgICAgIGxvID0gMCxcbiAgICAgIGhpID0gdGV4dC5sZW5ndGgsXG4gICAgICBtaWQ7XG4gIGxpbWl0IC09IHdpZHRoKGVsbGlwc2lzKTtcblxuICBpZiAocnRsKSB7XG4gICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICBpZiAod2lkdGgodGV4dC5zbGljZShtaWQpKSA+IGxpbWl0KSBsbyA9IG1pZCArIDE7ZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxsaXBzaXMgKyB0ZXh0LnNsaWNlKGxvKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gMSArIChsbyArIGhpID4+PiAxKTtcbiAgICAgIGlmICh3aWR0aCh0ZXh0LnNsaWNlKDAsIG1pZCkpIDwgbGltaXQpIGxvID0gbWlkO2Vsc2UgaGkgPSBtaWQgLSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIGxvKSArIGVsbGlwc2lzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvbnRGYW1pbHkoaXRlbSwgcXVvdGUpIHtcbiAgdmFyIGZvbnQgPSBpdGVtLmZvbnQ7XG4gIHJldHVybiAocXVvdGUgJiYgZm9udCA/IFN0cmluZyhmb250KS5yZXBsYWNlKC9cIi9nLCAnXFwnJykgOiBmb250KSB8fCAnc2Fucy1zZXJpZic7XG59XG5mdW5jdGlvbiBmb250KGl0ZW0sIHF1b3RlKSB7XG4gIHJldHVybiAnJyArIChpdGVtLmZvbnRTdHlsZSA/IGl0ZW0uZm9udFN0eWxlICsgJyAnIDogJycpICsgKGl0ZW0uZm9udFZhcmlhbnQgPyBpdGVtLmZvbnRWYXJpYW50ICsgJyAnIDogJycpICsgKGl0ZW0uZm9udFdlaWdodCA/IGl0ZW0uZm9udFdlaWdodCArICcgJyA6ICcnKSArIGZvbnRTaXplKGl0ZW0pICsgJ3B4ICcgKyBmb250RmFtaWx5KGl0ZW0sIHF1b3RlKTtcbn1cbmZ1bmN0aW9uIG9mZnNldChpdGVtKSB7XG4gIC8vIHBlcmZvcm0gb3VyIG93biBmb250IGJhc2VsaW5lIGNhbGN1bGF0aW9uXG4gIC8vIHdoeT8gbm90IGFsbCBicm93c2VycyBzdXBwb3J0IFNWRyAxLjEgJ2FsaWdubWVudC1iYXNlbGluZScgOihcbiAgLy8gdGhpcyBhbHNvIGVuc3VyZXMgY29uc2lzdGVudCBsYXlvdXQgYWNyb3NzIHJlbmRlcmVyc1xuICB2YXIgYmFzZWxpbmUgPSBpdGVtLmJhc2VsaW5lLFxuICAgICAgaCA9IGZvbnRTaXplKGl0ZW0pO1xuICByZXR1cm4gTWF0aC5yb3VuZChiYXNlbGluZSA9PT0gJ3RvcCcgPyAwLjc5ICogaCA6IGJhc2VsaW5lID09PSAnbWlkZGxlJyA/IDAuMzAgKiBoIDogYmFzZWxpbmUgPT09ICdib3R0b20nID8gLTAuMjEgKiBoIDogYmFzZWxpbmUgPT09ICdsaW5lLXRvcCcgPyAwLjI5ICogaCArIDAuNSAqIGxpbmVIZWlnaHQoaXRlbSkgOiBiYXNlbGluZSA9PT0gJ2xpbmUtYm90dG9tJyA/IDAuMjkgKiBoIC0gMC41ICogbGluZUhlaWdodChpdGVtKSA6IDApO1xufVxuXG5jb25zdCB0ZXh0QWxpZ24gPSB7XG4gICdsZWZ0JzogJ3N0YXJ0JyxcbiAgJ2NlbnRlcic6ICdtaWRkbGUnLFxuICAncmlnaHQnOiAnZW5kJ1xufTtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cbmZ1bmN0aW9uIGFuY2hvclBvaW50KGl0ZW0pIHtcbiAgdmFyIHggPSBpdGVtLnggfHwgMCxcbiAgICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICAgIHIgPSBpdGVtLnJhZGl1cyB8fCAwLFxuICAgICAgdDtcblxuICBpZiAocikge1xuICAgIHQgPSAoaXRlbS50aGV0YSB8fCAwKSAtIEhhbGZQaTtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIHRlbXBCb3VuZHMueDEgPSB4O1xuICB0ZW1wQm91bmRzLnkxID0geTtcbiAgcmV0dXJuIHRlbXBCb3VuZHM7XG59XG5cbmZ1bmN0aW9uIGF0dHIoZW1pdCwgaXRlbSkge1xuICB2YXIgZHggPSBpdGVtLmR4IHx8IDAsXG4gICAgICBkeSA9IChpdGVtLmR5IHx8IDApICsgb2Zmc2V0KGl0ZW0pLFxuICAgICAgcCA9IGFuY2hvclBvaW50KGl0ZW0pLFxuICAgICAgeCA9IHAueDEsXG4gICAgICB5ID0gcC55MSxcbiAgICAgIGEgPSBpdGVtLmFuZ2xlIHx8IDAsXG4gICAgICB0O1xuICBlbWl0KCd0ZXh0LWFuY2hvcicsIHRleHRBbGlnbltpdGVtLmFsaWduXSB8fCAnc3RhcnQnKTtcblxuICBpZiAoYSkge1xuICAgIHQgPSB0cmFuc2xhdGUoeCwgeSkgKyAnICcgKyByb3RhdGUoYSk7XG4gICAgaWYgKGR4IHx8IGR5KSB0ICs9ICcgJyArIHRyYW5zbGF0ZShkeCwgZHkpO1xuICB9IGVsc2Uge1xuICAgIHQgPSB0cmFuc2xhdGUoeCArIGR4LCB5ICsgZHkpO1xuICB9XG5cbiAgZW1pdCgndHJhbnNmb3JtJywgdCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kKGJvdW5kcywgaXRlbSwgbW9kZSkge1xuICB2YXIgaCA9IHRleHRNZXRyaWNzLmhlaWdodChpdGVtKSxcbiAgICAgIGEgPSBpdGVtLmFsaWduLFxuICAgICAgcCA9IGFuY2hvclBvaW50KGl0ZW0pLFxuICAgICAgeCA9IHAueDEsXG4gICAgICB5ID0gcC55MSxcbiAgICAgIGR4ID0gaXRlbS5keCB8fCAwLFxuICAgICAgZHkgPSAoaXRlbS5keSB8fCAwKSArIG9mZnNldChpdGVtKSAtIE1hdGgucm91bmQoMC44ICogaCksXG4gICAgICAvLyB1c2UgNC81IG9mZnNldFxuICB0bCA9IHRleHRMaW5lcyhpdGVtKSxcbiAgICAgIHc7IC8vIGdldCBkaW1lbnNpb25zXG5cbiAgaWYgKGlzQXJyYXkodGwpKSB7XG4gICAgLy8gbXVsdGktbGluZSB0ZXh0XG4gICAgaCArPSBsaW5lSGVpZ2h0KGl0ZW0pICogKHRsLmxlbmd0aCAtIDEpO1xuICAgIHcgPSB0bC5yZWR1Y2UoKHcsIHQpID0+IE1hdGgubWF4KHcsIHRleHRNZXRyaWNzLndpZHRoKGl0ZW0sIHQpKSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gc2luZ2xlLWxpbmUgdGV4dFxuICAgIHcgPSB0ZXh0TWV0cmljcy53aWR0aChpdGVtLCB0bCk7XG4gIH0gLy8gaG9yaXpvbnRhbCBhbGlnbm1lbnRcblxuXG4gIGlmIChhID09PSAnY2VudGVyJykge1xuICAgIGR4IC09IHcgLyAyO1xuICB9IGVsc2UgaWYgKGEgPT09ICdyaWdodCcpIHtcbiAgICBkeCAtPSB3O1xuICB9IGVsc2UgO1xuXG4gIGJvdW5kcy5zZXQoZHggKz0geCwgZHkgKz0geSwgZHggKyB3LCBkeSArIGgpO1xuXG4gIGlmIChpdGVtLmFuZ2xlICYmICFtb2RlKSB7XG4gICAgYm91bmRzLnJvdGF0ZShpdGVtLmFuZ2xlICogRGVnVG9SYWQsIHgsIHkpO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IDIpIHtcbiAgICByZXR1cm4gYm91bmRzLnJvdGF0ZWRQb2ludHMoaXRlbS5hbmdsZSAqIERlZ1RvUmFkLCB4LCB5KTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICB2aXNpdChzY2VuZSwgaXRlbSA9PiB7XG4gICAgdmFyIG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLm9wYWNpdHksXG4gICAgICAgIHAsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGksXG4gICAgICAgIGxoLFxuICAgICAgICB0bCxcbiAgICAgICAgc3RyO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSB8fCAvLyBib3VuZHMgY2hlY2tcbiAgICBvcGFjaXR5ID09PSAwIHx8IGl0ZW0uZm9udFNpemUgPD0gMCB8fCBpdGVtLnRleHQgPT0gbnVsbCB8fCBpdGVtLnRleHQubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29udGV4dC5mb250ID0gZm9udChpdGVtKTtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IGl0ZW0uYWxpZ24gfHwgJ2xlZnQnO1xuICAgIHAgPSBhbmNob3JQb2ludChpdGVtKTtcbiAgICB4ID0gcC54MSwgeSA9IHAueTE7XG5cbiAgICBpZiAoaXRlbS5hbmdsZSkge1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGNvbnRleHQucm90YXRlKGl0ZW0uYW5nbGUgKiBEZWdUb1JhZCk7XG4gICAgICB4ID0geSA9IDA7IC8vIHJlc2V0IHgsIHlcbiAgICB9XG5cbiAgICB4ICs9IGl0ZW0uZHggfHwgMDtcbiAgICB5ICs9IChpdGVtLmR5IHx8IDApICsgb2Zmc2V0KGl0ZW0pO1xuICAgIHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuICAgIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuXG4gICAgaWYgKGlzQXJyYXkodGwpKSB7XG4gICAgICBsaCA9IGxpbmVIZWlnaHQoaXRlbSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0bC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzdHIgPSB0ZXh0VmFsdWUoaXRlbSwgdGxbaV0pO1xuXG4gICAgICAgIGlmIChpdGVtLmZpbGwgJiYgZmlsbChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoc3RyLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtLnN0cm9rZSAmJiBzdHJva2UoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoc3RyLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgKz0gbGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IHRleHRWYWx1ZShpdGVtLCB0bCk7XG5cbiAgICAgIGlmIChpdGVtLmZpbGwgJiYgZmlsbChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHN0ciwgeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtLnN0cm9rZSAmJiBzdHJva2UoY29udGV4dCwgaXRlbSwgb3BhY2l0eSkpIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHN0ciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uYW5nbGUpIGNvbnRleHQucmVzdG9yZSgpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGl0KGNvbnRleHQsIGl0ZW0sIHgsIHksIGd4LCBneSkge1xuICBpZiAoaXRlbS5mb250U2l6ZSA8PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXRlbS5hbmdsZSkgcmV0dXJuIHRydWU7IC8vIGJvdW5kcyBzdWZmaWNpZW50IGlmIG5vIHJvdGF0aW9uXG4gIC8vIHByb2plY3QgcG9pbnQgaW50byBzcGFjZSBvZiB1bnJvdGF0ZWQgYm91bmRzXG5cbiAgdmFyIHAgPSBhbmNob3JQb2ludChpdGVtKSxcbiAgICAgIGF4ID0gcC54MSxcbiAgICAgIGF5ID0gcC55MSxcbiAgICAgIGIgPSBib3VuZCh0ZW1wQm91bmRzLCBpdGVtLCAxKSxcbiAgICAgIGEgPSAtaXRlbS5hbmdsZSAqIERlZ1RvUmFkLFxuICAgICAgY29zID0gTWF0aC5jb3MoYSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhKSxcbiAgICAgIHB4ID0gY29zICogZ3ggLSBzaW4gKiBneSArIChheCAtIGNvcyAqIGF4ICsgc2luICogYXkpLFxuICAgICAgcHkgPSBzaW4gKiBneCArIGNvcyAqIGd5ICsgKGF5IC0gc2luICogYXggLSBjb3MgKiBheSk7XG4gIHJldHVybiBiLmNvbnRhaW5zKHB4LCBweSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdFRleHQoaXRlbSwgYm94KSB7XG4gIGNvbnN0IHAgPSBib3VuZCh0ZW1wQm91bmRzLCBpdGVtLCAyKTtcbiAgcmV0dXJuIGludGVyc2VjdEJveExpbmUoYm94LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKSB8fCBpbnRlcnNlY3RCb3hMaW5lKGJveCwgcFswXSwgcFsxXSwgcFs0XSwgcFs1XSkgfHwgaW50ZXJzZWN0Qm94TGluZShib3gsIHBbNF0sIHBbNV0sIHBbNl0sIHBbN10pIHx8IGludGVyc2VjdEJveExpbmUoYm94LCBwWzJdLCBwWzNdLCBwWzZdLCBwWzddKTtcbn1cblxudmFyIHRleHQgPSB7XG4gIHR5cGU6ICd0ZXh0JyxcbiAgdGFnOiAndGV4dCcsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIsXG4gIGJvdW5kOiBib3VuZCxcbiAgZHJhdzogZHJhdyxcbiAgcGljazogcGljayQxKGhpdCksXG4gIGlzZWN0OiBpbnRlcnNlY3RUZXh0XG59O1xuXG52YXIgdHJhaWwgPSBtYXJrTXVsdGlJdGVtUGF0aCgndHJhaWwnLCB0cmFpbCQxLCBwaWNrVHJhaWwpO1xuXG52YXIgTWFya3MgPSB7XG4gIGFyYzogYXJjLFxuICBhcmVhOiBhcmVhLFxuICBncm91cDogZ3JvdXAsXG4gIGltYWdlOiBpbWFnZSxcbiAgbGluZTogbGluZSxcbiAgcGF0aDogcGF0aCQyLFxuICByZWN0OiByZWN0LFxuICBydWxlOiBydWxlLFxuICBzaGFwZTogc2hhcGUsXG4gIHN5bWJvbDogc3ltYm9sLFxuICB0ZXh0OiB0ZXh0LFxuICB0cmFpbDogdHJhaWxcbn07XG5cbmZ1bmN0aW9uIGJvdW5kSXRlbSAoaXRlbSwgZnVuYywgb3B0KSB7XG4gIHZhciB0eXBlID0gTWFya3NbaXRlbS5tYXJrLm1hcmt0eXBlXSxcbiAgICAgIGJvdW5kID0gZnVuYyB8fCB0eXBlLmJvdW5kO1xuICBpZiAodHlwZS5uZXN0ZWQpIGl0ZW0gPSBpdGVtLm1hcms7XG4gIHJldHVybiBib3VuZChpdGVtLmJvdW5kcyB8fCAoaXRlbS5ib3VuZHMgPSBuZXcgQm91bmRzKCkpLCBpdGVtLCBvcHQpO1xufVxuXG52YXIgRFVNTVkgPSB7XG4gIG1hcms6IG51bGxcbn07XG5mdW5jdGlvbiBib3VuZE1hcmsgKG1hcmssIGJvdW5kcywgb3B0KSB7XG4gIHZhciB0eXBlID0gTWFya3NbbWFyay5tYXJrdHlwZV0sXG4gICAgICBib3VuZCA9IHR5cGUuYm91bmQsXG4gICAgICBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICBoYXNJdGVtcyA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgaXRlbSxcbiAgICAgIGI7XG5cbiAgaWYgKHR5cGUubmVzdGVkKSB7XG4gICAgaWYgKGhhc0l0ZW1zKSB7XG4gICAgICBpdGVtID0gaXRlbXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGl0ZW1zLCBmYWtlIGl0XG4gICAgICBEVU1NWS5tYXJrID0gbWFyaztcbiAgICAgIGl0ZW0gPSBEVU1NWTtcbiAgICB9XG5cbiAgICBiID0gYm91bmRJdGVtKGl0ZW0sIGJvdW5kLCBvcHQpO1xuICAgIGJvdW5kcyA9IGJvdW5kcyAmJiBib3VuZHMudW5pb24oYikgfHwgYjtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuXG4gIGlmIChoYXNJdGVtcykge1xuICAgIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGJvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbXNbaV0sIGJvdW5kLCBvcHQpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFyay5ib3VuZHMgPSBib3VuZHM7XG59XG5cbmNvbnN0IGtleXMgPSBbJ21hcmt0eXBlJywgJ25hbWUnLCAncm9sZScsICdpbnRlcmFjdGl2ZScsICdjbGlwJywgJ2l0ZW1zJywgJ3ppbmRleCcsICd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsaWduJywgJ2Jhc2VsaW5lJywgLy8gbGF5b3V0XG4nZmlsbCcsICdmaWxsT3BhY2l0eScsICdvcGFjaXR5JywgJ2JsZW5kJywgLy8gZmlsbFxuJ3N0cm9rZScsICdzdHJva2VPcGFjaXR5JywgJ3N0cm9rZVdpZHRoJywgJ3N0cm9rZUNhcCcsIC8vIHN0cm9rZVxuJ3N0cm9rZURhc2gnLCAnc3Ryb2tlRGFzaE9mZnNldCcsIC8vIHN0cm9rZSBkYXNoXG4nc3Ryb2tlRm9yZWdyb3VuZCcsICdzdHJva2VPZmZzZXQnLCAvLyBncm91cFxuJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAvLyBhcmNcbidjb3JuZXJSYWRpdXMnLCAncGFkQW5nbGUnLCAvLyBhcmMsIHJlY3Rcbidjb3JuZXJSYWRpdXNUb3BMZWZ0JywgJ2Nvcm5lclJhZGl1c1RvcFJpZ2h0JywgLy8gcmVjdCwgZ3JvdXBcbidjb3JuZXJSYWRpdXNCb3R0b21MZWZ0JywgJ2Nvcm5lclJhZGl1c0JvdHRvbVJpZ2h0JywgJ2ludGVycG9sYXRlJywgJ3RlbnNpb24nLCAnb3JpZW50JywgJ2RlZmluZWQnLCAvLyBhcmVhLCBsaW5lXG4ndXJsJywgJ2FzcGVjdCcsICdzbW9vdGgnLCAvLyBpbWFnZVxuJ3BhdGgnLCAnc2NhbGVYJywgJ3NjYWxlWScsIC8vIHBhdGhcbid4MicsICd5MicsIC8vIHJ1bGVcbidzaXplJywgJ3NoYXBlJywgLy8gc3ltYm9sXG4ndGV4dCcsICdhbmdsZScsICd0aGV0YScsICdyYWRpdXMnLCAnZGlyJywgJ2R4JywgJ2R5JywgLy8gdGV4dFxuJ2VsbGlwc2lzJywgJ2xpbWl0JywgJ2xpbmVCcmVhaycsICdsaW5lSGVpZ2h0JywgJ2ZvbnQnLCAnZm9udFNpemUnLCAnZm9udFdlaWdodCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAvLyBmb250XG4nZGVzY3JpcHRpb24nLCAnYXJpYScsICdhcmlhUm9sZScsICdhcmlhUm9sZURlc2NyaXB0aW9uJyAvLyBhcmlhXG5dO1xuZnVuY3Rpb24gc2NlbmVUb0pTT04oc2NlbmUsIGluZGVudCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2NlbmUsIGtleXMsIGluZGVudCk7XG59XG5mdW5jdGlvbiBzY2VuZUZyb21KU09OKGpzb24pIHtcbiAgY29uc3Qgc2NlbmUgPSB0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbiAgcmV0dXJuIGluaXRpYWxpemUoc2NlbmUpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplKHNjZW5lKSB7XG4gIHZhciB0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgcGFyZW50LFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgaWYgKGl0ZW1zKSB7XG4gICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgcGFyZW50ID0gdHlwZSA/ICdtYXJrJyA6ICdncm91cCc7XG4gICAgICBpdGVtc1tpXVtwYXJlbnRdID0gc2NlbmU7XG4gICAgICBpZiAoaXRlbXNbaV0uemluZGV4KSBpdGVtc1tpXVtwYXJlbnRdLnpkaXJ0eSA9IHRydWU7XG4gICAgICBpZiAoJ2dyb3VwJyA9PT0gKHR5cGUgfHwgcGFyZW50KSkgaW5pdGlhbGl6ZShpdGVtc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUpIGJvdW5kTWFyayhzY2VuZSk7XG4gIHJldHVybiBzY2VuZTtcbn1cblxuZnVuY3Rpb24gU2NlbmVncmFwaChzY2VuZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMucm9vdCA9IHNjZW5lRnJvbUpTT04oc2NlbmUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucm9vdCA9IGNyZWF0ZU1hcmsoe1xuICAgICAgbWFya3R5cGU6ICdncm91cCcsXG4gICAgICBuYW1lOiAncm9vdCcsXG4gICAgICByb2xlOiAnZnJhbWUnXG4gICAgfSk7XG4gICAgdGhpcy5yb290Lml0ZW1zID0gW25ldyBHcm91cEl0ZW0odGhpcy5yb290KV07XG4gIH1cbn1cblNjZW5lZ3JhcGgucHJvdG90eXBlID0ge1xuICB0b0pTT04oaW5kZW50KSB7XG4gICAgcmV0dXJuIHNjZW5lVG9KU09OKHRoaXMucm9vdCwgaW5kZW50IHx8IDApO1xuICB9LFxuXG4gIG1hcmsobWFya2RlZiwgZ3JvdXAsIGluZGV4KSB7XG4gICAgZ3JvdXAgPSBncm91cCB8fCB0aGlzLnJvb3QuaXRlbXNbMF07XG4gICAgY29uc3QgbWFyayA9IGNyZWF0ZU1hcmsobWFya2RlZiwgZ3JvdXApO1xuICAgIGdyb3VwLml0ZW1zW2luZGV4XSA9IG1hcms7XG4gICAgaWYgKG1hcmsuemluZGV4KSBtYXJrLmdyb3VwLnpkaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIG1hcms7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gY3JlYXRlTWFyayhkZWYsIGdyb3VwKSB7XG4gIGNvbnN0IG1hcmsgPSB7XG4gICAgYm91bmRzOiBuZXcgQm91bmRzKCksXG4gICAgY2xpcDogISFkZWYuY2xpcCxcbiAgICBncm91cDogZ3JvdXAsXG4gICAgaW50ZXJhY3RpdmU6IGRlZi5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWUsXG4gICAgaXRlbXM6IFtdLFxuICAgIG1hcmt0eXBlOiBkZWYubWFya3R5cGUsXG4gICAgbmFtZTogZGVmLm5hbWUgfHwgdW5kZWZpbmVkLFxuICAgIHJvbGU6IGRlZi5yb2xlIHx8IHVuZGVmaW5lZCxcbiAgICB6aW5kZXg6IGRlZi56aW5kZXggfHwgMFxuICB9OyAvLyBhZGQgYWNjZXNzaWJpbGl0eSBwcm9wZXJ0aWVzIGlmIGRlZmluZWRcblxuICBpZiAoZGVmLmFyaWEgIT0gbnVsbCkge1xuICAgIG1hcmsuYXJpYSA9IGRlZi5hcmlhO1xuICB9XG5cbiAgaWYgKGRlZi5kZXNjcmlwdGlvbikge1xuICAgIG1hcmsuZGVzY3JpcHRpb24gPSBkZWYuZGVzY3JpcHRpb247XG4gIH1cblxuICByZXR1cm4gbWFyaztcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERPTSBlbGVtZW50XG5mdW5jdGlvbiBkb21DcmVhdGUoZG9jLCB0YWcsIG5zKSB7XG4gIGlmICghZG9jICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkge1xuICAgIGRvYyA9IGRvY3VtZW50O1xuICB9XG5cbiAgcmV0dXJuIGRvYyA/IG5zID8gZG9jLmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZykgOiBudWxsO1xufSAvLyBmaW5kIGZpcnN0IGNoaWxkIGVsZW1lbnQgd2l0aCBtYXRjaGluZyB0YWdcblxuZnVuY3Rpb24gZG9tRmluZChlbCwgdGFnKSB7XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbm9kZXMgPSBlbC5jaGlsZE5vZGVzLFxuICAgICAgaSA9IDAsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSBpZiAobm9kZXNbaV0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcpIHtcbiAgICByZXR1cm4gbm9kZXNbaV07XG4gIH1cbn0gLy8gcmV0cmlldmUgY2hpbGQgZWxlbWVudCBhdCBnaXZlbiBpbmRleFxuLy8gY3JlYXRlICYgaW5zZXJ0IGlmIGRvZXNuJ3QgZXhpc3Qgb3IgaWYgdGFncyBkbyBub3QgbWF0Y2hcblxuZnVuY3Rpb24gZG9tQ2hpbGQoZWwsIGluZGV4LCB0YWcsIG5zKSB7XG4gIHZhciBhID0gZWwuY2hpbGROb2Rlc1tpbmRleF0sXG4gICAgICBiO1xuXG4gIGlmICghYSB8fCBhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBiID0gYSB8fCBudWxsO1xuICAgIGEgPSBkb21DcmVhdGUoZWwub3duZXJEb2N1bWVudCwgdGFnLCBucyk7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGEsIGIpO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59IC8vIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgYXQgb3IgYWJvdmUgdGhlIGdpdmVuIGluZGV4XG5cbmZ1bmN0aW9uIGRvbUNsZWFyKGVsLCBpbmRleCkge1xuICB2YXIgbm9kZXMgPSBlbC5jaGlsZE5vZGVzLFxuICAgICAgY3VyciA9IG5vZGVzLmxlbmd0aDtcblxuICB3aGlsZSAoY3VyciA+IGluZGV4KSBlbC5yZW1vdmVDaGlsZChub2Rlc1stLWN1cnJdKTtcblxuICByZXR1cm4gZWw7XG59IC8vIGdlbmVyYXRlIGNzcyBjbGFzcyBuYW1lIGZvciBtYXJrXG5cbmZ1bmN0aW9uIGNzc0NsYXNzKG1hcmspIHtcbiAgcmV0dXJuICdtYXJrLScgKyBtYXJrLm1hcmt0eXBlICsgKG1hcmsucm9sZSA/ICcgcm9sZS0nICsgbWFyay5yb2xlIDogJycpICsgKG1hcmsubmFtZSA/ICcgJyArIG1hcmsubmFtZSA6ICcnKTtcbn1cblxuZnVuY3Rpb24gcG9pbnQgKGV2ZW50LCBlbCkge1xuICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIChlbC5jbGllbnRMZWZ0IHx8IDApLCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSAoZWwuY2xpZW50VG9wIHx8IDApXTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUl0ZW0gKGl0ZW0sIGV2ZW50LCBlbCwgb3JpZ2luKSB7XG4gIHZhciBtYXJrID0gaXRlbSAmJiBpdGVtLm1hcmssXG4gICAgICBtZGVmLFxuICAgICAgcDtcblxuICBpZiAobWFyayAmJiAobWRlZiA9IE1hcmtzW21hcmsubWFya3R5cGVdKS50aXApIHtcbiAgICBwID0gcG9pbnQoZXZlbnQsIGVsKTtcbiAgICBwWzBdIC09IG9yaWdpblswXTtcbiAgICBwWzFdIC09IG9yaWdpblsxXTtcblxuICAgIHdoaWxlIChpdGVtID0gaXRlbS5tYXJrLmdyb3VwKSB7XG4gICAgICBwWzBdIC09IGl0ZW0ueCB8fCAwO1xuICAgICAgcFsxXSAtPSBpdGVtLnkgfHwgMDtcbiAgICB9XG5cbiAgICBpdGVtID0gbWRlZi50aXAobWFyay5pdGVtcywgcCk7XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgSGFuZGxlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbY3VzdG9tTG9hZGVyXSAtIE9wdGlvbmFsIGxvYWRlciBpbnN0YW5jZSBmb3JcbiAqICAgaHJlZiBVUkwgc2FuaXRpemF0aW9uLiBJZiBub3Qgc3BlY2lmaWVkLCBhIHN0YW5kYXJkIGxvYWRlclxuICogICBpbnN0YW5jZSB3aWxsIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjdXN0b21Ub29sdGlwXSAtIE9wdGlvbmFsIHRvb2x0aXAgaGFuZGxlclxuICogICBmdW5jdGlvbiBmb3IgY3VzdG9tIHRvb2x0aXAgZGlzcGxheS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIEhhbmRsZXIoY3VzdG9tTG9hZGVyLCBjdXN0b21Ub29sdGlwKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIHRoaXMuX2xvYWRlciA9IGN1c3RvbUxvYWRlciB8fCBsb2FkZXIoKTtcbiAgdGhpcy5fdG9vbHRpcCA9IGN1c3RvbVRvb2x0aXAgfHwgZGVmYXVsdFRvb2x0aXA7XG59IC8vIFRoZSBkZWZhdWx0IHRvb2x0aXAgZGlzcGxheSBoYW5kbGVyLlxuLy8gU2V0cyB0aGUgSFRNTCB0aXRsZSBhdHRyaWJ1dGUgb24gdGhlIHZpc3VhbGl6YXRpb24gY29udGFpbmVyLlxuXG5mdW5jdGlvbiBkZWZhdWx0VG9vbHRpcChoYW5kbGVyLCBldmVudCwgaXRlbSwgdmFsdWUpIHtcbiAgaGFuZGxlci5lbGVtZW50KCkuc2V0QXR0cmlidXRlKCd0aXRsZScsIHZhbHVlIHx8ICcnKTtcbn1cblxuSGFuZGxlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IEhhbmRsZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudCBmb3IgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdIC0gT3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgc2VydmUgYXNcbiAgICogICB0aGUgXCJ0aGlzXCIgY29udGV4dCBmb3IgZXZlbnQgY2FsbGJhY2tzLlxuICAgKiBAcmV0dXJuIHtIYW5kbGVyfSAtIFRoaXMgaGFuZGxlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIG9yaWdpbiwgb2JqKSB7XG4gICAgdGhpcy5fZWwgPSBlbDtcbiAgICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4ob3JpZ2luKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IGNvbnRhaW5lciBlbGVtZW50IGZvciBhIHZpc3VhbGl6YXRpb24uXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IC0gVGhlIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2NlbmUgZWxlbWVudCAoZS5nLiwgY2FudmFzIG9yIFNWRykgb2YgdGhlIHZpc3VhbGl6YXRpb25cbiAgICogU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGlmIHRoZSBmaXJzdCBjaGlsZCBpcyBub3QgdGhlIHNjZW5lIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IC0gVGhlIHNjZW5lIChlLmcuLCBjYW52YXMgb3IgU1ZHKSBlbGVtZW50LlxuICAgKi9cbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbCAmJiB0aGlzLl9lbC5maXJzdENoaWxkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIG9yaWdpbiBjb29yZGluYXRlcyBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICovXG4gIG9yaWdpbihvcmlnaW4pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luIHx8IFswLCAwXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luLnNsaWNlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIHNjZW5lZ3JhcGggcm9vdC5cbiAgICovXG4gIHNjZW5lKHNjZW5lKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2NlbmU7XG4gICAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGFuIGV2ZW50IGhhbmRsZXIuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgb24oKVxuICAvKnR5cGUsIGhhbmRsZXIqL1xuICB7fSxcblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXIuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgb2ZmKClcbiAgLyp0eXBlLCBoYW5kbGVyKi9cbiAge30sXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBmaW5kaW5nIHRoZSBhcnJheSBpbmRleCBvZiBhbiBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge0FycmF5fSBoIC0gQW4gYXJyYXkgb2YgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIGluc3RhbmNlIHRvIGZpbmQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgaGFuZGxlcidzIGFycmF5IGluZGV4IG9yIC0xIGlmIG5vdCByZWdpc3RlcmVkLlxuICAgKi9cbiAgX2hhbmRsZXJJbmRleChoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IGggPyBoLmxlbmd0aCA6IDA7IC0taSA+PSAwOykge1xuICAgICAgaWYgKGhbaV0udHlwZSA9PT0gdHlwZSAmJiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVGhlIGV2ZW50IHR5cGUgdG8gcXVlcnkuIEFueSBhbm5vdGF0aW9uc1xuICAgKiAgIGFyZSBpZ25vcmVkOyBmb3IgZXhhbXBsZSwgZm9yIHRoZSBhcmd1bWVudCBcImNsaWNrLmZvb1wiLCBcIi5mb29cIiB3aWxsXG4gICAqICAgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCByZXR1cm5zIGFsbCBcImNsaWNrXCIgaGFuZGxlcnMuIElmIHR5cGUgaXNcbiAgICogICBudWxsIG9yIHVuc3BlY2lmaWVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIGhhbmRsZXJzIGZvciBhbGwgdHlwZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBoYW5kbGVycyh0eXBlKSB7XG4gICAgY29uc3QgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgICAgIGEgPSBbXTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBhLnB1c2goLi4uaFt0aGlzLmV2ZW50TmFtZSh0eXBlKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gaCkge1xuICAgICAgICBhLnB1c2goLi4uaFtrXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBldmVudCBuYW1lIHN0cmluZyB0byByZXR1cm4gdGhlIHNwZWNpZmljIGV2ZW50IHR5cGUuXG4gICAqIEZvciBleGFtcGxlLCBnaXZlbiBcImNsaWNrLmZvb1wiIHJldHVybnMgXCJjbGlja1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGlucHV0IGV2ZW50IHR5cGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSBzdHJpbmcgd2l0aCB0aGUgZXZlbnQgdHlwZSBvbmx5LlxuICAgKi9cbiAgZXZlbnROYW1lKG5hbWUpIHtcbiAgICBjb25zdCBpID0gbmFtZS5pbmRleE9mKCcuJyk7XG4gICAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCwgaSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBoeXBlcmxpbmsgbmF2aWdhdGlvbiBpbiByZXNwb25zZSB0byBhbiBpdGVtLmhyZWYgdmFsdWUuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRyaWdnZXJpbmcgaHlwZXJsaW5rIG5hdmlnYXRpb24uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBzY2VuZWdyYXBoIGl0ZW0uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIC0gVGhlIFVSTCB0byBuYXZpZ2F0ZSB0by5cbiAgICovXG4gIGhhbmRsZUhyZWYoZXZlbnQsIGl0ZW0sIGhyZWYpIHtcbiAgICB0aGlzLl9sb2FkZXIuc2FuaXRpemUoaHJlZiwge1xuICAgICAgY29udGV4dDogJ2hyZWYnXG4gICAgfSkudGhlbihvcHQgPT4ge1xuICAgICAgY29uc3QgZSA9IG5ldyBNb3VzZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50KSxcbiAgICAgICAgICAgIGEgPSBkb21DcmVhdGUobnVsbCwgJ2EnKTtcblxuICAgICAgZm9yIChjb25zdCBuYW1lIGluIG9wdCkgYS5zZXRBdHRyaWJ1dGUobmFtZSwgb3B0W25hbWVdKTtcblxuICAgICAgYS5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlIHRvb2x0aXAgZGlzcGxheSBpbiByZXNwb25zZSB0byBhbiBpdGVtLnRvb2x0aXAgdmFsdWUuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRyaWdnZXJpbmcgdG9vbHRpcCBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgc2NlbmVncmFwaCBpdGVtLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3cgLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICogICB0byBzaG93IG9yIGhpZGUgYSB0b29sdGlwIGZvciB0aGUgZ2l2ZW4gaXRlbS5cbiAgICovXG4gIGhhbmRsZVRvb2x0aXAoZXZlbnQsIGl0ZW0sIHNob3cpIHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLnRvb2x0aXAgIT0gbnVsbCkge1xuICAgICAgaXRlbSA9IHJlc29sdmVJdGVtKGl0ZW0sIGV2ZW50LCB0aGlzLmNhbnZhcygpLCB0aGlzLl9vcmlnaW4pO1xuICAgICAgY29uc3QgdmFsdWUgPSBzaG93ICYmIGl0ZW0gJiYgaXRlbS50b29sdGlwIHx8IG51bGw7XG5cbiAgICAgIHRoaXMuX3Rvb2x0aXAuY2FsbCh0aGlzLl9vYmosIHRoaXMsIGV2ZW50LCBpdGVtLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIGEgc2NlbmVncmFwaCBpdGVtIGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmVcbiAgICogdG8gdGhlIHZpZXdwb3J0LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgc2NlbmVncmFwaCBpdGVtLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gQSBib3VuZGluZyBib3ggb2JqZWN0IChjb21wYXRpYmxlIHdpdGggdGhlXG4gICAqICAgRE9NUmVjdCB0eXBlKSBjb25zaXN0aW5nIG9mIHgsIHksIHdpZHRoLCBoZWlnaCwgdG9wLCBsZWZ0LFxuICAgKiAgIHJpZ2h0LCBhbmQgYm90dG9tIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRJdGVtQm91bmRpbmdDbGllbnRSZWN0KGl0ZW0pIHtcbiAgICBjb25zdCBlbCA9IHRoaXMuY2FudmFzKCk7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICBvcmlnaW4gPSB0aGlzLl9vcmlnaW4sXG4gICAgICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHMsXG4gICAgICAgICAgd2lkdGggPSBib3VuZHMud2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0KCk7XG4gICAgbGV0IHggPSBib3VuZHMueDEgKyBvcmlnaW5bMF0gKyByZWN0LmxlZnQsXG4gICAgICAgIHkgPSBib3VuZHMueTEgKyBvcmlnaW5bMV0gKyByZWN0LnRvcDsgLy8gdHJhbnNsYXRlIGNvb3JkaW5hdGUgZm9yIGVhY2ggcGFyZW50IGdyb3VwXG5cbiAgICB3aGlsZSAoaXRlbS5tYXJrICYmIChpdGVtID0gaXRlbS5tYXJrLmdyb3VwKSkge1xuICAgICAgeCArPSBpdGVtLnggfHwgMDtcbiAgICAgIHkgKz0gaXRlbS55IHx8IDA7XG4gICAgfSAvLyByZXR1cm4gRE9NUmVjdC1jb21wYXRpYmxlIGJvdW5kaW5nIGJveFxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogeCArIHdpZHRoLFxuICAgICAgYm90dG9tOiB5ICsgaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBSZW5kZXJlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbbG9hZGVyXSAtIE9wdGlvbmFsIGxvYWRlciBpbnN0YW5jZSBmb3JcbiAqICAgaW1hZ2UgYW5kIGhyZWYgVVJMIHNhbml0aXphdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgYVxuICogICBzdGFuZGFyZCBsb2FkZXIgaW5zdGFuY2Ugd2lsbCBiZSBnZW5lcmF0ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBSZW5kZXJlcihsb2FkZXIpIHtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9iZ2NvbG9yID0gbnVsbDtcbiAgdGhpcy5fbG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyKGxvYWRlcik7XG59XG5SZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IFJlbmRlcmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsIC0gVGhlIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQgZm9yIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGNvb3JkaW5hdGUgaGVpZ2h0IG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZUZhY3Rvcj0xXSAtIE9wdGlvbmFsIHNjYWxlRmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5XG4gICAqICAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIHRoaXMuX2VsID0gZWw7XG4gICAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudC5cbiAgICovXG4gIGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY2VuZSBlbGVtZW50IChlLmcuLCBjYW52YXMgb3IgU1ZHKSBvZiB0aGUgdmlzdWFsaXphdGlvblxuICAgKiBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgaWYgdGhlIGZpcnN0IGNoaWxkIGlzIG5vdCB0aGUgc2NlbmUgZWxlbWVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgc2NlbmUgKGUuZy4sIGNhbnZhcyBvciBTVkcpIGVsZW1lbnQuXG4gICAqL1xuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsICYmIHRoaXMuX2VsLmZpcnN0Q2hpbGQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCAvIHNldCB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIGJhY2tncm91bmQoYmdjb2xvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYmdjb2xvcjtcbiAgICB0aGlzLl9iZ2NvbG9yID0gYmdjb2xvcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVzaXplIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgbmV3IG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZUZhY3Rvcj0xXSAtIE9wdGlvbmFsIHNjYWxlRmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5XG4gICAqICAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlO1xuICAgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW4gfHwgWzAsIDBdO1xuICAgIHRoaXMuX3NjYWxlID0gc2NhbGVGYWN0b3IgfHwgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVwb3J0IGEgZGlydHkgaXRlbSB3aG9zZSBib3VuZHMgc2hvdWxkIGJlIHJlZHJhd24uXG4gICAqIFRoaXMgYmFzZSBjbGFzcyBtZXRob2QgZG9lcyBub3RoaW5nLiBTdWJjbGFzc2VzIHRoYXQgcGVyZm9ybVxuICAgKiBpbmNyZW1lbnRhbCBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgZGlydHkgaXRlbSB3aG9zZSBib3VuZHMgc2hvdWxkIGJlIHJlZHJhd24uXG4gICAqL1xuICBkaXJ0eSgpXG4gIC8qaXRlbSovXG4gIHt9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW4gaW5wdXQgc2NlbmVncmFwaCwgcG90ZW50aWFsbHkgd2l0aCBhIHNldCBvZiBkaXJ0eSBpdGVtcy5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCBwZXJmb3JtIGFuIGltbWVkaWF0ZSByZW5kZXJpbmcgd2l0aCBhdmFpbGFibGUgcmVzb3VyY2VzLlxuICAgKiBUaGUgcmVuZGVyZXIgbWF5IGFsc28gbmVlZCB0byBwZXJmb3JtIGltYWdlIGxvYWRpbmcgdG8gcGVyZm9ybSBhIGNvbXBsZXRlXG4gICAqIHJlbmRlci4gVGhpcyBwcm9jZXNzIGNhbiBsZWFkIHRvIGFzeW5jaHJvbm91cyByZS1yZW5kZXJpbmcgb2YgdGhlIHNjZW5lXG4gICAqIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuIFRvIHJlY2VpdmUgbm90aWZpY2F0aW9uIHdoZW4gcmVuZGVyaW5nIGlzXG4gICAqIGNvbXBsZXRlLCB1c2UgdGhlIHJlbmRlckFzeW5jIG1ldGhvZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICByZW5kZXIoc2NlbmUpIHtcbiAgICBjb25zdCByID0gdGhpczsgLy8gYmluZCBhcmd1bWVudHMgaW50byBhIHJlbmRlciBjYWxsLCBhbmQgY2FjaGUgaXRcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIGZvciBhc3luYyByZWRyYXdcblxuICAgIHIuX2NhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByLl9yZW5kZXIoc2NlbmUpO1xuICAgIH07IC8vIGludm9rZSB0aGUgcmVuZGVyZXJcblxuXG4gICAgci5fY2FsbCgpOyAvLyBjbGVhciB0aGUgY2FjaGVkIGNhbGwgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIC8vIGFzeW5jIHJlZHJhd3Mgd2lsbCBzdGFzaCB0aGVpciBvd24gY29weVxuXG5cbiAgICByLl9jYWxsID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfSxcblxuICAvKipcbiAgICogSW50ZXJuYWwgcmVuZGVyaW5nIG1ldGhvZC4gUmVuZGVyZXIgc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpc1xuICAgKiBtZXRob2QgdG8gYWN0dWFsbHkgcGVyZm9ybSByZW5kZXJpbmcuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICovXG4gIF9yZW5kZXIoKVxuICAvKnNjZW5lKi9cbiAgey8vIHN1YmNsYXNzZXMgdG8gb3ZlcnJpZGVcbiAgfSxcblxuICAvKipcbiAgICogQXN5bmNocm9ub3VzIHJlbmRlcmluZyBtZXRob2QuIFNpbWlsYXIgdG8gcmVuZGVyLCBidXQgcmV0dXJucyBhIFByb21pc2VcbiAgICogdGhhdCByZXNvbHZlcyB3aGVuIGFsbCByZW5kZXJpbmcgaXMgY29tcGxldGVkLiBTb21ldGltZXMgYSByZW5kZXJlciBtdXN0XG4gICAqIHBlcmZvcm0gaW1hZ2UgbG9hZGluZyB0byBnZXQgYSBjb21wbGV0ZSByZW5kZXJpbmcuIFRoZSByZXR1cm5lZFxuICAgKiBQcm9taXNlIHdpbGwgbm90IHJlc29sdmUgdW50aWwgdGhpcyBwcm9jZXNzIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIHJvb3QgbWFyayBvZiBhIHNjZW5lZ3JhcGggdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcmVuZGVyaW5nIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgcmVuZGVyQXN5bmMoc2NlbmUpIHtcbiAgICBjb25zdCByID0gdGhpcy5yZW5kZXIoc2NlbmUpO1xuICAgIHJldHVybiB0aGlzLl9yZWFkeSA/IHRoaXMuX3JlYWR5LnRoZW4oKCkgPT4gcikgOiBQcm9taXNlLnJlc29sdmUocik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgYXN5bmNocm9ub3VzIHJlc291cmNlIGxvYWRpbmcuXG4gICAqIFByb3hpZXMgbWV0aG9kIGNhbGxzIHRvIHRoZSBJbWFnZUxvYWRlciwgYW5kIHRyYWNrcyBsb2FkaW5nXG4gICAqIHByb2dyZXNzIHRvIGludm9rZSBhIHJlLXJlbmRlciBvbmNlIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGludm9rZSBvbiB0aGUgSW1hZ2VMb2FkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgVVJJIGZvciB0aGUgcmVxdWVzdGVkIHJlc291cmNlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuXG4gICAqL1xuICBfbG9hZChtZXRob2QsIHVyaSkge1xuICAgIHZhciByID0gdGhpcyxcbiAgICAgICAgcCA9IHIuX2xvYWRlclttZXRob2RdKHVyaSk7XG5cbiAgICBpZiAoIXIuX3JlYWR5KSB7XG4gICAgICAvLyByZS1yZW5kZXIgdGhlIHNjZW5lIHdoZW4gbG9hZGluZyBjb21wbGV0ZXNcbiAgICAgIGNvbnN0IGNhbGwgPSByLl9jYWxsO1xuICAgICAgci5fcmVhZHkgPSByLl9sb2FkZXIucmVhZHkoKS50aGVuKHJlZHJhdyA9PiB7XG4gICAgICAgIGlmIChyZWRyYXcpIGNhbGwoKTtcbiAgICAgICAgci5fcmVhZHkgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbml0aXplIGEgVVJMIHRvIGluY2x1ZGUgYXMgYSBoeXBlcmxpbmsgaW4gdGhlIHJlbmRlcmVkIHNjZW5lLlxuICAgKiBUaGlzIG1ldGhvZCBwcm94aWVzIGEgY2FsbCB0byBJbWFnZUxvYWRlci5zYW5pdGl6ZVVSTCwgYnV0IGFsc28gdHJhY2tzXG4gICAqIGltYWdlIGxvYWRpbmcgcHJvZ3Jlc3MgYW5kIGludm9rZXMgYSByZS1yZW5kZXIgb25jZSBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSBVUkkgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzYW5pdGl6ZWQgVVJMLlxuICAgKi9cbiAgc2FuaXRpemVVUkwodXJpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWQoJ3Nhbml0aXplVVJMJywgdXJpKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVxdWVzdHMgYW4gaW1hZ2UgdG8gaW5jbHVkZSBpbiB0aGUgcmVuZGVyZWQgc2NlbmUuXG4gICAqIFRoaXMgbWV0aG9kIHByb3hpZXMgYSBjYWxsIHRvIEltYWdlTG9hZGVyLmxvYWRJbWFnZSwgYnV0IGFsc28gdHJhY2tzXG4gICAqIGltYWdlIGxvYWRpbmcgcHJvZ3Jlc3MgYW5kIGludm9rZXMgYSByZS1yZW5kZXIgb25jZSBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIFRoZSBVUkkgc3RyaW5nIG9mIHRoZSBpbWFnZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbG9hZGVkIEltYWdlLlxuICAgKi9cbiAgbG9hZEltYWdlKHVyaSkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkKCdsb2FkSW1hZ2UnLCB1cmkpO1xuICB9XG5cbn07XG5cbmNvbnN0IEtleURvd25FdmVudCA9ICdrZXlkb3duJztcbmNvbnN0IEtleVByZXNzRXZlbnQgPSAna2V5cHJlc3MnO1xuY29uc3QgS2V5VXBFdmVudCA9ICdrZXl1cCc7XG5jb25zdCBEcmFnRW50ZXJFdmVudCA9ICdkcmFnZW50ZXInO1xuY29uc3QgRHJhZ0xlYXZlRXZlbnQgPSAnZHJhZ2xlYXZlJztcbmNvbnN0IERyYWdPdmVyRXZlbnQgPSAnZHJhZ292ZXInO1xuY29uc3QgTW91c2VEb3duRXZlbnQgPSAnbW91c2Vkb3duJztcbmNvbnN0IE1vdXNlVXBFdmVudCA9ICdtb3VzZXVwJztcbmNvbnN0IE1vdXNlTW92ZUV2ZW50ID0gJ21vdXNlbW92ZSc7XG5jb25zdCBNb3VzZU91dEV2ZW50ID0gJ21vdXNlb3V0JztcbmNvbnN0IE1vdXNlT3ZlckV2ZW50ID0gJ21vdXNlb3Zlcic7XG5jb25zdCBDbGlja0V2ZW50ID0gJ2NsaWNrJztcbmNvbnN0IERvdWJsZUNsaWNrRXZlbnQgPSAnZGJsY2xpY2snO1xuY29uc3QgV2hlZWxFdmVudCA9ICd3aGVlbCc7XG5jb25zdCBNb3VzZVdoZWVsRXZlbnQgPSAnbW91c2V3aGVlbCc7XG5jb25zdCBUb3VjaFN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCc7XG5jb25zdCBUb3VjaE1vdmVFdmVudCA9ICd0b3VjaG1vdmUnO1xuY29uc3QgVG91Y2hFbmRFdmVudCA9ICd0b3VjaGVuZCc7XG5jb25zdCBFdmVudHMgPSBbS2V5RG93bkV2ZW50LCBLZXlQcmVzc0V2ZW50LCBLZXlVcEV2ZW50LCBEcmFnRW50ZXJFdmVudCwgRHJhZ0xlYXZlRXZlbnQsIERyYWdPdmVyRXZlbnQsIE1vdXNlRG93bkV2ZW50LCBNb3VzZVVwRXZlbnQsIE1vdXNlTW92ZUV2ZW50LCBNb3VzZU91dEV2ZW50LCBNb3VzZU92ZXJFdmVudCwgQ2xpY2tFdmVudCwgRG91YmxlQ2xpY2tFdmVudCwgV2hlZWxFdmVudCwgTW91c2VXaGVlbEV2ZW50LCBUb3VjaFN0YXJ0RXZlbnQsIFRvdWNoTW92ZUV2ZW50LCBUb3VjaEVuZEV2ZW50XTtcbmNvbnN0IFRvb2x0aXBTaG93RXZlbnQgPSBNb3VzZU1vdmVFdmVudDtcbmNvbnN0IFRvb2x0aXBIaWRlRXZlbnQgPSBNb3VzZU91dEV2ZW50O1xuY29uc3QgSHJlZkV2ZW50ID0gQ2xpY2tFdmVudDtcblxuZnVuY3Rpb24gQ2FudmFzSGFuZGxlcihsb2FkZXIsIHRvb2x0aXApIHtcbiAgSGFuZGxlci5jYWxsKHRoaXMsIGxvYWRlciwgdG9vbHRpcCk7XG4gIHRoaXMuX2Rvd24gPSBudWxsO1xuICB0aGlzLl90b3VjaCA9IG51bGw7XG4gIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcbiAgdGhpcy5fZXZlbnRzID0ge307XG59XG5cbmNvbnN0IGV2ZW50QnVuZGxlID0gdHlwZSA9PiB0eXBlID09PSBUb3VjaFN0YXJ0RXZlbnQgfHwgdHlwZSA9PT0gVG91Y2hNb3ZlRXZlbnQgfHwgdHlwZSA9PT0gVG91Y2hFbmRFdmVudCA/IFtUb3VjaFN0YXJ0RXZlbnQsIFRvdWNoTW92ZUV2ZW50LCBUb3VjaEVuZEV2ZW50XSA6IFt0eXBlXTsgLy8gbGF6aWx5IGFkZCBsaXN0ZW5lcnMgdG8gdGhlIGNhbnZhcyBhcyBuZWVkZWRcblxuXG5mdW5jdGlvbiBldmVudExpc3RlbmVyQ2hlY2soaGFuZGxlciwgdHlwZSkge1xuICBldmVudEJ1bmRsZSh0eXBlKS5mb3JFYWNoKF8gPT4gYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVyLCBfKSk7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlciwgdHlwZSkge1xuICBjb25zdCBjYW52YXMgPSBoYW5kbGVyLmNhbnZhcygpO1xuXG4gIGlmIChjYW52YXMgJiYgIWhhbmRsZXIuX2V2ZW50c1t0eXBlXSkge1xuICAgIGhhbmRsZXIuX2V2ZW50c1t0eXBlXSA9IDE7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlclt0eXBlXSA/IGV2dCA9PiBoYW5kbGVyW3R5cGVdKGV2dCkgOiBldnQgPT4gaGFuZGxlci5maXJlKHR5cGUsIGV2dCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmUobW92ZUV2ZW50LCBvdmVyRXZlbnQsIG91dEV2ZW50KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgY29uc3QgYSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgICAgICBwID0gdGhpcy5waWNrRXZlbnQoZXZ0KTtcblxuICAgIGlmIChwID09PSBhKSB7XG4gICAgICAvLyBhY3RpdmUgaXRlbSBhbmQgcGlja2VkIGl0ZW0gYXJlIHRoZSBzYW1lXG4gICAgICB0aGlzLmZpcmUobW92ZUV2ZW50LCBldnQpOyAvLyBmaXJlIG1vdmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmICghYSB8fCAhYS5leGl0KSB7XG4gICAgICAgIC8vIGZpcmUgb3V0IGZvciBwcmlvciBhY3RpdmUgaXRlbVxuICAgICAgICAvLyBzdXBwcmVzcyBpZiBhY3RpdmUgaXRlbSB3YXMgcmVtb3ZlZCBmcm9tIHNjZW5lXG4gICAgICAgIHRoaXMuZmlyZShvdXRFdmVudCwgZXZ0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlID0gcDsgLy8gc2V0IG5ldyBhY3RpdmUgaXRlbVxuXG4gICAgICB0aGlzLmZpcmUob3ZlckV2ZW50LCBldnQpOyAvLyBmaXJlIG92ZXIgZm9yIG5ldyBhY3RpdmUgaXRlbVxuXG4gICAgICB0aGlzLmZpcmUobW92ZUV2ZW50LCBldnQpOyAvLyBmaXJlIG1vdmUgZm9yIG5ldyBhY3RpdmUgaXRlbVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5hY3RpdmUodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2dCkge1xuICAgIHRoaXMuZmlyZSh0eXBlLCBldnQpO1xuICAgIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIH07XG59XG5cbmluaGVyaXRzKENhbnZhc0hhbmRsZXIsIEhhbmRsZXIsIHtcbiAgaW5pdGlhbGl6ZShlbCwgb3JpZ2luLCBvYmopIHtcbiAgICB0aGlzLl9jYW52YXMgPSBlbCAmJiBkb21GaW5kKGVsLCAnY2FudmFzJyk7IC8vIGFkZCBtaW5pbWFsIGV2ZW50cyByZXF1aXJlZCBmb3IgcHJvcGVyIHN0YXRlIG1hbmFnZW1lbnRcblxuICAgIFtDbGlja0V2ZW50LCBNb3VzZURvd25FdmVudCwgTW91c2VNb3ZlRXZlbnQsIE1vdXNlT3V0RXZlbnQsIERyYWdMZWF2ZUV2ZW50XS5mb3JFYWNoKHR5cGUgPT4gZXZlbnRMaXN0ZW5lckNoZWNrKHRoaXMsIHR5cGUpKTtcbiAgICByZXR1cm4gSGFuZGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCBvcmlnaW4sIG9iaik7XG4gIH0sXG5cbiAgLy8gcmV0dXJuIHRoZSBiYWNraW5nIGNhbnZhcyBpbnN0YW5jZVxuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfSxcblxuICAvLyByZXRyaWV2ZSB0aGUgY3VycmVudCBjYW52YXMgY29udGV4dFxuICBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgfSxcblxuICAvLyBzdXBwb3J0ZWQgZXZlbnRzXG4gIGV2ZW50czogRXZlbnRzLFxuXG4gIC8vIHRvIGtlZXAgb2xkIHZlcnNpb25zIG9mIGZpcmVmb3ggaGFwcHlcbiAgRE9NTW91c2VTY3JvbGwoZXZ0KSB7XG4gICAgdGhpcy5maXJlKE1vdXNlV2hlZWxFdmVudCwgZXZ0KTtcbiAgfSxcblxuICBtb3VzZW1vdmU6IG1vdmUoTW91c2VNb3ZlRXZlbnQsIE1vdXNlT3ZlckV2ZW50LCBNb3VzZU91dEV2ZW50KSxcbiAgZHJhZ292ZXI6IG1vdmUoRHJhZ092ZXJFdmVudCwgRHJhZ0VudGVyRXZlbnQsIERyYWdMZWF2ZUV2ZW50KSxcbiAgbW91c2VvdXQ6IGluYWN0aXZlKE1vdXNlT3V0RXZlbnQpLFxuICBkcmFnbGVhdmU6IGluYWN0aXZlKERyYWdMZWF2ZUV2ZW50KSxcblxuICBtb3VzZWRvd24oZXZ0KSB7XG4gICAgdGhpcy5fZG93biA9IHRoaXMuX2FjdGl2ZTtcbiAgICB0aGlzLmZpcmUoTW91c2VEb3duRXZlbnQsIGV2dCk7XG4gIH0sXG5cbiAgY2xpY2soZXZ0KSB7XG4gICAgaWYgKHRoaXMuX2Rvd24gPT09IHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5maXJlKENsaWNrRXZlbnQsIGV2dCk7XG4gICAgICB0aGlzLl9kb3duID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgdG91Y2hzdGFydChldnQpIHtcbiAgICB0aGlzLl90b3VjaCA9IHRoaXMucGlja0V2ZW50KGV2dC5jaGFuZ2VkVG91Y2hlc1swXSk7XG5cbiAgICBpZiAodGhpcy5fZmlyc3QpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX3RvdWNoO1xuICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoVG91Y2hTdGFydEV2ZW50LCBldnQsIHRydWUpO1xuICB9LFxuXG4gIHRvdWNobW92ZShldnQpIHtcbiAgICB0aGlzLmZpcmUoVG91Y2hNb3ZlRXZlbnQsIGV2dCwgdHJ1ZSk7XG4gIH0sXG5cbiAgdG91Y2hlbmQoZXZ0KSB7XG4gICAgdGhpcy5maXJlKFRvdWNoRW5kRXZlbnQsIGV2dCwgdHJ1ZSk7XG4gICAgdGhpcy5fdG91Y2ggPSBudWxsO1xuICB9LFxuXG4gIC8vIGZpcmUgYW4gZXZlbnRcbiAgZmlyZSh0eXBlLCBldnQsIHRvdWNoKSB7XG4gICAgY29uc3QgYSA9IHRvdWNoID8gdGhpcy5fdG91Y2ggOiB0aGlzLl9hY3RpdmUsXG4gICAgICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdOyAvLyBzZXQgZXZlbnQgdHlwZSByZWxhdGl2ZSB0byBzY2VuZWdyYXBoIGl0ZW1zXG5cbiAgICBldnQudmVnYVR5cGUgPSB0eXBlOyAvLyBoYW5kbGUgaHlwZXJsaW5rcyBhbmQgdG9vbHRpcHMgZmlyc3RcblxuICAgIGlmICh0eXBlID09PSBIcmVmRXZlbnQgJiYgYSAmJiBhLmhyZWYpIHtcbiAgICAgIHRoaXMuaGFuZGxlSHJlZihldnQsIGEsIGEuaHJlZik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBUb29sdGlwU2hvd0V2ZW50IHx8IHR5cGUgPT09IFRvb2x0aXBIaWRlRXZlbnQpIHtcbiAgICAgIHRoaXMuaGFuZGxlVG9vbHRpcChldnQsIGEsIHR5cGUgIT09IFRvb2x0aXBIaWRlRXZlbnQpO1xuICAgIH0gLy8gaW52b2tlIGFsbCByZWdpc3RlcmVkIGhhbmRsZXJzXG5cblxuICAgIGlmIChoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gaC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG4gIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaFtuYW1lXSwgdHlwZSwgaGFuZGxlcik7XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIGV2ZW50TGlzdGVuZXJDaGVjayh0aGlzLCB0eXBlKTtcbiAgICAgIChoW25hbWVdIHx8IChoW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLFxuICAgICAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaCwgdHlwZSwgaGFuZGxlcik7XG5cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBoLnNwbGljZShpLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwaWNrRXZlbnQoZXZ0KSB7XG4gICAgY29uc3QgcCA9IHBvaW50KGV2dCwgdGhpcy5fY2FudmFzKSxcbiAgICAgICAgICBvID0gdGhpcy5fb3JpZ2luO1xuICAgIHJldHVybiB0aGlzLnBpY2sodGhpcy5fc2NlbmUsIHBbMF0sIHBbMV0sIHBbMF0gLSBvWzBdLCBwWzFdIC0gb1sxXSk7XG4gIH0sXG5cbiAgLy8gZmluZCB0aGUgc2NlbmVncmFwaCBpdGVtIGF0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4gIC8vIHgsIHkgLS0gdGhlIGFic29sdXRlIHgsIHkgbW91c2UgY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcyBlbGVtZW50XG4gIC8vIGd4LCBneSAtLSB0aGUgcmVsYXRpdmUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBjdXJyZW50IGdyb3VwXG4gIHBpY2soc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICAgIGNvbnN0IGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgICAgICBtYXJrID0gTWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICAgIHJldHVybiBtYXJrLnBpY2suY2FsbCh0aGlzLCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gZGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSA6IDE7XG59XG5cbnZhciBwaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbygpO1xuZnVuY3Rpb24gcmVzaXplIChjYW52YXMsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IsIG9wdCkge1xuICBjb25zdCBpbkRPTSA9IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgY2FudmFzLnBhcmVudE5vZGUgIT0gbnVsbCxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgICAgICByYXRpbyA9IGluRE9NID8gcGl4ZWxSYXRpbyA6IHNjYWxlRmFjdG9yO1xuICBjYW52YXMud2lkdGggPSB3aWR0aCAqIHJhdGlvO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcmF0aW87XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gb3B0KSB7XG4gICAgY29udGV4dFtrZXldID0gb3B0W2tleV07XG4gIH1cblxuICBpZiAoaW5ET00gJiYgcmF0aW8gIT09IDEpIHtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cblxuICBjb250ZXh0LnBpeGVsUmF0aW8gPSByYXRpbztcbiAgY29udGV4dC5zZXRUcmFuc2Zvcm0ocmF0aW8sIDAsIDAsIHJhdGlvLCByYXRpbyAqIG9yaWdpblswXSwgcmF0aW8gKiBvcmlnaW5bMV0pO1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihsb2FkZXIpIHtcbiAgUmVuZGVyZXIuY2FsbCh0aGlzLCBsb2FkZXIpO1xuICB0aGlzLl9vcHRpb25zID0ge307XG4gIHRoaXMuX3JlZHJhdyA9IGZhbHNlO1xuICB0aGlzLl9kaXJ0eSA9IG5ldyBCb3VuZHMoKTtcbiAgdGhpcy5fdGVtcGIgPSBuZXcgQm91bmRzKCk7XG59XG5jb25zdCBiYXNlJDEgPSBSZW5kZXJlci5wcm90b3R5cGU7XG5cbmNvbnN0IHZpZXdCb3VuZHMgPSAob3JpZ2luLCB3aWR0aCwgaGVpZ2h0KSA9PiBuZXcgQm91bmRzKCkuc2V0KDAsIDAsIHdpZHRoLCBoZWlnaHQpLnRyYW5zbGF0ZSgtb3JpZ2luWzBdLCAtb3JpZ2luWzFdKTtcblxuZnVuY3Rpb24gY2xpcFRvQm91bmRzKGcsIGIsIG9yaWdpbikge1xuICAvLyBleHBhbmQgYm91bmRzIGJ5IDEgcGl4ZWwsIHRoZW4gcm91bmQgdG8gcGl4ZWwgYm91bmRhcmllc1xuICBiLmV4cGFuZCgxKS5yb3VuZCgpOyAvLyBhbGlnbiB0byBiYXNlIHBpeGVsIGdyaWQgaW4gY2FzZSBvZiBub24taW50ZWdlciBzY2FsaW5nICgjMjQyNSlcblxuICBpZiAoZy5waXhlbFJhdGlvICUgMSkge1xuICAgIGIuc2NhbGUoZy5waXhlbFJhdGlvKS5yb3VuZCgpLnNjYWxlKDEgLyBnLnBpeGVsUmF0aW8pO1xuICB9IC8vIHRvIGF2b2lkIGFydGlmYWN0cyB0cmFuc2xhdGUgaWYgb3JpZ2luIGhhcyBmcmFjdGlvbmFsIHBpeGVsc1xuXG5cbiAgYi50cmFuc2xhdGUoLShvcmlnaW5bMF0gJSAxKSwgLShvcmlnaW5bMV0gJSAxKSk7IC8vIHNldCBjbGlwIHBhdGhcblxuICBnLmJlZ2luUGF0aCgpO1xuICBnLnJlY3QoYi54MSwgYi55MSwgYi53aWR0aCgpLCBiLmhlaWdodCgpKTtcbiAgZy5jbGlwKCk7XG4gIHJldHVybiBiO1xufVxuXG5pbmhlcml0cyhDYW52YXNSZW5kZXJlciwgUmVuZGVyZXIsIHtcbiAgaW5pdGlhbGl6ZShlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvciwgb3B0aW9ucykge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX29wdGlvbnMuZXh0ZXJuYWxDb250ZXh0ID8gbnVsbCA6IGNhbnZhcygxLCAxLCB0aGlzLl9vcHRpb25zLnR5cGUpOyAvLyBpbnN0YW50aWF0ZSBhIHNtYWxsIGNhbnZhc1xuXG4gICAgaWYgKGVsICYmIHRoaXMuX2NhbnZhcykge1xuICAgICAgZG9tQ2xlYXIoZWwsIDApLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG5cbiAgICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21hcmtzJyk7XG4gICAgfSAvLyB0aGlzIG1ldGhvZCB3aWxsIGludm9rZSByZXNpemUgdG8gc2l6ZSB0aGUgY2FudmFzIGFwcHJvcHJpYXRlbHlcblxuXG4gICAgcmV0dXJuIGJhc2UkMS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICB9LFxuXG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgYmFzZSQxLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuXG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgLy8gY29uZmlndXJlIGNhbnZhcyBzaXplIGFuZCB0cmFuc2Zvcm1cbiAgICAgIHJlc2l6ZSh0aGlzLl9jYW52YXMsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX29yaWdpbiwgdGhpcy5fc2NhbGUsIHRoaXMuX29wdGlvbnMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4dGVybmFsIGNvbnRleHQgbmVlZHMgdG8gYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIHRvIG9yaWdpblxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fb3B0aW9ucy5leHRlcm5hbENvbnRleHQ7XG4gICAgICBpZiAoIWN0eCkgZXJyb3IoJ0NhbnZhc1JlbmRlcmVyIGlzIG1pc3NpbmcgYSB2YWxpZCBjYW52YXMgb3IgY29udGV4dCcpO1xuICAgICAgY3R4LnNjYWxlKHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHRoaXMuX29yaWdpblswXSwgdGhpcy5fb3JpZ2luWzFdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWRyYXcgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9LFxuXG4gIGNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZXh0ZXJuYWxDb250ZXh0IHx8ICh0aGlzLl9jYW52YXMgPyB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGwpO1xuICB9LFxuXG4gIGRpcnR5KGl0ZW0pIHtcbiAgICBjb25zdCBiID0gdGhpcy5fdGVtcGIuY2xlYXIoKS51bmlvbihpdGVtLmJvdW5kcyk7XG5cbiAgICBsZXQgZyA9IGl0ZW0ubWFyay5ncm91cDtcblxuICAgIHdoaWxlIChnKSB7XG4gICAgICBiLnRyYW5zbGF0ZShnLnggfHwgMCwgZy55IHx8IDApO1xuICAgICAgZyA9IGcubWFyay5ncm91cDtcbiAgICB9XG5cbiAgICB0aGlzLl9kaXJ0eS51bmlvbihiKTtcbiAgfSxcblxuICBfcmVuZGVyKHNjZW5lKSB7XG4gICAgY29uc3QgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgICAgIG8gPSB0aGlzLl9vcmlnaW4sXG4gICAgICAgICAgdyA9IHRoaXMuX3dpZHRoLFxuICAgICAgICAgIGggPSB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgZGIgPSB0aGlzLl9kaXJ0eSxcbiAgICAgICAgICB2YiA9IHZpZXdCb3VuZHMobywgdywgaCk7IC8vIHNldHVwXG5cbiAgICBnLnNhdmUoKTtcbiAgICBjb25zdCBiID0gdGhpcy5fcmVkcmF3IHx8IGRiLmVtcHR5KCkgPyAodGhpcy5fcmVkcmF3ID0gZmFsc2UsIHZiLmV4cGFuZCgxKSkgOiBjbGlwVG9Cb3VuZHMoZywgdmIuaW50ZXJzZWN0KGRiKSwgbyk7XG4gICAgdGhpcy5jbGVhcigtb1swXSwgLW9bMV0sIHcsIGgpOyAvLyByZW5kZXJcblxuICAgIHRoaXMuZHJhdyhnLCBzY2VuZSwgYik7IC8vIHRha2Vkb3duXG5cbiAgICBnLnJlc3RvcmUoKTtcbiAgICBkYi5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGRyYXcoY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gICAgY29uc3QgbWFyayA9IE1hcmtzW3NjZW5lLm1hcmt0eXBlXTtcbiAgICBpZiAoc2NlbmUuY2xpcCkgY2xpcChjdHgsIHNjZW5lKTtcbiAgICBtYXJrLmRyYXcuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xuICAgIGlmIChzY2VuZS5jbGlwKSBjdHgucmVzdG9yZSgpO1xuICB9LFxuXG4gIGNsZWFyKHgsIHksIHcsIGgpIHtcbiAgICBjb25zdCBvcHQgPSB0aGlzLl9vcHRpb25zLFxuICAgICAgICAgIGcgPSB0aGlzLmNvbnRleHQoKTtcblxuICAgIGlmIChvcHQudHlwZSAhPT0gJ3BkZicgJiYgIW9wdC5leHRlcm5hbENvbnRleHQpIHtcbiAgICAgIC8vIGNhbGxpbmcgY2xlYXIgcmVjdCB2b2lkcyB2ZWN0b3Igb3V0cHV0IGluIHBkZiBtb2RlXG4gICAgICAvLyBhbmQgY291bGQgcmVtb3ZlIGV4dGVybmFsIGNvbnRleHQgY29udGVudCAoIzI2MTUpXG4gICAgICBnLmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYmdjb2xvciAhPSBudWxsKSB7XG4gICAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2JnY29sb3I7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gU1ZHSGFuZGxlcihsb2FkZXIsIHRvb2x0aXApIHtcbiAgSGFuZGxlci5jYWxsKHRoaXMsIGxvYWRlciwgdG9vbHRpcCk7XG4gIGNvbnN0IGggPSB0aGlzO1xuICBoLl9ocmVmSGFuZGxlciA9IGxpc3RlbmVyKGgsIChldnQsIGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtLmhyZWYpIGguaGFuZGxlSHJlZihldnQsIGl0ZW0sIGl0ZW0uaHJlZik7XG4gIH0pO1xuICBoLl90b29sdGlwSGFuZGxlciA9IGxpc3RlbmVyKGgsIChldnQsIGl0ZW0pID0+IHtcbiAgICBoLmhhbmRsZVRvb2x0aXAoZXZ0LCBpdGVtLCBldnQudHlwZSAhPT0gVG9vbHRpcEhpZGVFdmVudCk7XG4gIH0pO1xufSAvLyB3cmFwIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgU1ZHIERPTVxuXG5jb25zdCBsaXN0ZW5lciA9IChjb250ZXh0LCBoYW5kbGVyKSA9PiBldnQgPT4ge1xuICBsZXQgaXRlbSA9IGV2dC50YXJnZXQuX19kYXRhX187XG4gIGl0ZW0gPSBBcnJheS5pc0FycmF5KGl0ZW0pID8gaXRlbVswXSA6IGl0ZW07XG4gIGV2dC52ZWdhVHlwZSA9IGV2dC50eXBlO1xuICBoYW5kbGVyLmNhbGwoY29udGV4dC5fb2JqLCBldnQsIGl0ZW0pO1xufTtcblxuaW5oZXJpdHMoU1ZHSGFuZGxlciwgSGFuZGxlciwge1xuICBpbml0aWFsaXplKGVsLCBvcmlnaW4sIG9iaikge1xuICAgIGxldCBzdmcgPSB0aGlzLl9zdmc7XG5cbiAgICBpZiAoc3ZnKSB7XG4gICAgICBzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihIcmVmRXZlbnQsIHRoaXMuX2hyZWZIYW5kbGVyKTtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFRvb2x0aXBTaG93RXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFRvb2x0aXBIaWRlRXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdmcgPSBzdmcgPSBlbCAmJiBkb21GaW5kKGVsLCAnc3ZnJyk7XG5cbiAgICBpZiAoc3ZnKSB7XG4gICAgICBzdmcuYWRkRXZlbnRMaXN0ZW5lcihIcmVmRXZlbnQsIHRoaXMuX2hyZWZIYW5kbGVyKTtcbiAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKFRvb2x0aXBTaG93RXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKFRvb2x0aXBIaWRlRXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSGFuZGxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVsLCBvcmlnaW4sIG9iaik7XG4gIH0sXG5cbiAgY2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdmc7XG4gIH0sXG5cbiAgLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbiAgb24odHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICAgICAgaSA9IHRoaXMuX2hhbmRsZXJJbmRleChoW25hbWVdLCB0eXBlLCBoYW5kbGVyKTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgY29uc3QgeCA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgaGFuZGxlcixcbiAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyKHRoaXMsIGhhbmRsZXIpXG4gICAgICB9O1xuICAgICAgKGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSkpLnB1c2goeCk7XG5cbiAgICAgIGlmICh0aGlzLl9zdmcpIHtcbiAgICAgICAgdGhpcy5fc3ZnLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgeC5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLFxuICAgICAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaCwgdHlwZSwgaGFuZGxlcik7XG5cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgICAgIHRoaXMuX3N2Zy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhbaV0ubGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBoLnNwbGljZShpLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59KTtcblxuY29uc3QgQVJJQV9ISURERU4gPSAnYXJpYS1oaWRkZW4nO1xuY29uc3QgQVJJQV9MQUJFTCA9ICdhcmlhLWxhYmVsJztcbmNvbnN0IEFSSUFfUk9MRSA9ICdyb2xlJztcbmNvbnN0IEFSSUFfUk9MRURFU0NSSVBUSU9OID0gJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJztcbmNvbnN0IEdSQVBISUNTX09CSkVDVCA9ICdncmFwaGljcy1vYmplY3QnO1xuY29uc3QgR1JBUEhJQ1NfU1lNQk9MID0gJ2dyYXBoaWNzLXN5bWJvbCc7XG5cbmNvbnN0IGJ1bmRsZSA9IChyb2xlLCByb2xlZGVzYywgbGFiZWwpID0+ICh7XG4gIFtBUklBX1JPTEVdOiByb2xlLFxuICBbQVJJQV9ST0xFREVTQ1JJUFRJT05dOiByb2xlZGVzYyxcbiAgW0FSSUFfTEFCRUxdOiBsYWJlbCB8fCB1bmRlZmluZWRcbn0pOyAvLyB0aGVzZSByb2xlcyBhcmUgY292ZXJlZCBieSByZWxhdGVkIHJvbGVzXG4vLyB3ZSBjYW4gaWdub3JlIHRoZW0sIG5vIG5lZWQgdG8gZ2VuZXJhdGUgYXR0cmlidXRlc1xuXG5cbmNvbnN0IEFyaWFJZ25vcmUgPSB0b1NldChbJ2F4aXMtZG9tYWluJywgJ2F4aXMtZ3JpZCcsICdheGlzLWxhYmVsJywgJ2F4aXMtdGljaycsICdheGlzLXRpdGxlJywgJ2xlZ2VuZC1iYW5kJywgJ2xlZ2VuZC1lbnRyeScsICdsZWdlbmQtZ3JhZGllbnQnLCAnbGVnZW5kLWxhYmVsJywgJ2xlZ2VuZC10aXRsZScsICdsZWdlbmQtc3ltYm9sJywgJ3RpdGxlJ10pOyAvLyBhcmlhIGF0dHJpYnV0ZSBnZW5lcmF0b3JzIGZvciBndWlkZSByb2xlc1xuXG5jb25zdCBBcmlhR3VpZGVzID0ge1xuICAnYXhpcyc6IHtcbiAgICBkZXNjOiAnYXhpcycsXG4gICAgY2FwdGlvbjogYXhpc0NhcHRpb25cbiAgfSxcbiAgJ2xlZ2VuZCc6IHtcbiAgICBkZXNjOiAnbGVnZW5kJyxcbiAgICBjYXB0aW9uOiBsZWdlbmRDYXB0aW9uXG4gIH0sXG4gICd0aXRsZS10ZXh0Jzoge1xuICAgIGRlc2M6ICd0aXRsZScsXG4gICAgY2FwdGlvbjogaXRlbSA9PiBgVGl0bGUgdGV4dCAnJHt0aXRsZUNhcHRpb24oaXRlbSl9J2BcbiAgfSxcbiAgJ3RpdGxlLXN1YnRpdGxlJzoge1xuICAgIGRlc2M6ICdzdWJ0aXRsZScsXG4gICAgY2FwdGlvbjogaXRlbSA9PiBgU3VidGl0bGUgdGV4dCAnJHt0aXRsZUNhcHRpb24oaXRlbSl9J2BcbiAgfVxufTsgLy8gYXJpYSBwcm9wZXJ0aWVzIGdlbmVyYXRlZCBmb3IgbWFyayBpdGVtIGVuY29kaW5nIGNoYW5uZWxzXG5cbmNvbnN0IEFyaWFFbmNvZGUgPSB7XG4gIGFyaWFSb2xlOiBBUklBX1JPTEUsXG4gIGFyaWFSb2xlRGVzY3JpcHRpb246IEFSSUFfUk9MRURFU0NSSVBUSU9OLFxuICBkZXNjcmlwdGlvbjogQVJJQV9MQUJFTFxufTtcbmZ1bmN0aW9uIGFyaWFJdGVtQXR0cmlidXRlcyhlbWl0LCBpdGVtKSB7XG4gIGNvbnN0IGhpZGUgPSBpdGVtLmFyaWEgPT09IGZhbHNlO1xuICBlbWl0KEFSSUFfSElEREVOLCBoaWRlIHx8IHVuZGVmaW5lZCk7XG5cbiAgaWYgKGhpZGUgfHwgaXRlbS5kZXNjcmlwdGlvbiA9PSBudWxsKSB7XG4gICAgZm9yIChjb25zdCBwcm9wIGluIEFyaWFFbmNvZGUpIHtcbiAgICAgIGVtaXQoQXJpYUVuY29kZVtwcm9wXSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdHlwZSA9IGl0ZW0ubWFyay5tYXJrdHlwZTtcbiAgICBlbWl0KEFSSUFfTEFCRUwsIGl0ZW0uZGVzY3JpcHRpb24pO1xuICAgIGVtaXQoQVJJQV9ST0xFLCBpdGVtLmFyaWFSb2xlIHx8ICh0eXBlID09PSAnZ3JvdXAnID8gR1JBUEhJQ1NfT0JKRUNUIDogR1JBUEhJQ1NfU1lNQk9MKSk7XG4gICAgZW1pdChBUklBX1JPTEVERVNDUklQVElPTiwgaXRlbS5hcmlhUm9sZURlc2NyaXB0aW9uIHx8IGAke3R5cGV9IG1hcmtgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXJpYU1hcmtBdHRyaWJ1dGVzKG1hcmspIHtcbiAgcmV0dXJuIG1hcmsuYXJpYSA9PT0gZmFsc2UgPyB7XG4gICAgW0FSSUFfSElEREVOXTogdHJ1ZVxuICB9IDogQXJpYUlnbm9yZVttYXJrLnJvbGVdID8gbnVsbCA6IEFyaWFHdWlkZXNbbWFyay5yb2xlXSA/IGFyaWFHdWlkZShtYXJrLCBBcmlhR3VpZGVzW21hcmsucm9sZV0pIDogYXJpYU1hcmsobWFyayk7XG59XG5cbmZ1bmN0aW9uIGFyaWFNYXJrKG1hcmspIHtcbiAgY29uc3QgdHlwZSA9IG1hcmsubWFya3R5cGU7XG4gIGNvbnN0IHJlY3Vyc2UgPSB0eXBlID09PSAnZ3JvdXAnIHx8IHR5cGUgPT09ICd0ZXh0JyB8fCBtYXJrLml0ZW1zLnNvbWUoXyA9PiBfLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgXy5hcmlhICE9PSBmYWxzZSk7XG4gIHJldHVybiBidW5kbGUocmVjdXJzZSA/IEdSQVBISUNTX09CSkVDVCA6IEdSQVBISUNTX1NZTUJPTCwgYCR7dHlwZX0gbWFyayBjb250YWluZXJgLCBtYXJrLmRlc2NyaXB0aW9uKTtcbn1cblxuZnVuY3Rpb24gYXJpYUd1aWRlKG1hcmssIG9wdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGl0ZW0gPSBtYXJrLml0ZW1zWzBdLFxuICAgICAgICAgIGNhcHRpb24gPSBvcHQuY2FwdGlvbiB8fCAoKCkgPT4gJycpO1xuXG4gICAgcmV0dXJuIGJ1bmRsZShvcHQucm9sZSB8fCBHUkFQSElDU19TWU1CT0wsIG9wdC5kZXNjLCBpdGVtLmRlc2NyaXB0aW9uIHx8IGNhcHRpb24oaXRlbSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aXRsZUNhcHRpb24oaXRlbSkge1xuICByZXR1cm4gYXJyYXkoaXRlbS50ZXh0KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIGF4aXNDYXB0aW9uKGl0ZW0pIHtcbiAgY29uc3QgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgICAgICBvcmllbnQgPSBpdGVtLm9yaWVudCxcbiAgICAgICAgdGl0bGUgPSBkYXR1bS50aXRsZSA/IGV4dHJhY3RUaXRsZShpdGVtKSA6IG51bGwsXG4gICAgICAgIGN0eCA9IGl0ZW0uY29udGV4dCxcbiAgICAgICAgc2NhbGUgPSBjdHguc2NhbGVzW2RhdHVtLnNjYWxlXS52YWx1ZSxcbiAgICAgICAgbG9jYWxlID0gY3R4LmRhdGFmbG93LmxvY2FsZSgpLFxuICAgICAgICB0eXBlID0gc2NhbGUudHlwZSxcbiAgICAgICAgeHkgPSBvcmllbnQgPT09ICdsZWZ0JyB8fCBvcmllbnQgPT09ICdyaWdodCcgPyAnWScgOiAnWCc7XG4gIHJldHVybiBgJHt4eX0tYXhpc2AgKyAodGl0bGUgPyBgIHRpdGxlZCAnJHt0aXRsZX0nYCA6ICcnKSArIGAgZm9yIGEgJHtpc0Rpc2NyZXRlKHR5cGUpID8gJ2Rpc2NyZXRlJyA6IHR5cGV9IHNjYWxlYCArIGAgd2l0aCAke2RvbWFpbkNhcHRpb24obG9jYWxlLCBzY2FsZSwgaXRlbSl9YDtcbn1cblxuZnVuY3Rpb24gbGVnZW5kQ2FwdGlvbihpdGVtKSB7XG4gIGNvbnN0IGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICAgICAgdGl0bGUgPSBkYXR1bS50aXRsZSA/IGV4dHJhY3RUaXRsZShpdGVtKSA6IG51bGwsXG4gICAgICAgIHR5cGUgPSBgJHtkYXR1bS50eXBlIHx8ICcnfSBsZWdlbmRgLnRyaW0oKSxcbiAgICAgICAgc2NhbGVzID0gZGF0dW0uc2NhbGVzLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5rZXlzKHNjYWxlcyksXG4gICAgICAgIGN0eCA9IGl0ZW0uY29udGV4dCxcbiAgICAgICAgc2NhbGUgPSBjdHguc2NhbGVzW3NjYWxlc1twcm9wc1swXV1dLnZhbHVlLFxuICAgICAgICBsb2NhbGUgPSBjdHguZGF0YWZsb3cubG9jYWxlKCk7XG4gIHJldHVybiBjYXBpdGFsaXplKHR5cGUpICsgKHRpdGxlID8gYCB0aXRsZWQgJyR7dGl0bGV9J2AgOiAnJykgKyBgIGZvciAke2NoYW5uZWxDYXB0aW9uKHByb3BzKX1gICsgYCB3aXRoICR7ZG9tYWluQ2FwdGlvbihsb2NhbGUsIHNjYWxlLCBpdGVtKX1gO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0VGl0bGUoaXRlbSkge1xuICB0cnkge1xuICAgIHJldHVybiBhcnJheShwZWVrKGl0ZW0uaXRlbXMpLml0ZW1zWzBdLnRleHQpLmpvaW4oJyAnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hhbm5lbENhcHRpb24ocHJvcHMpIHtcbiAgcHJvcHMgPSBwcm9wcy5tYXAocCA9PiBwICsgKHAgPT09ICdmaWxsJyB8fCBwID09PSAnc3Ryb2tlJyA/ICcgY29sb3InIDogJycpKTtcbiAgcmV0dXJuIHByb3BzLmxlbmd0aCA8IDIgPyBwcm9wc1swXSA6IHByb3BzLnNsaWNlKDAsIC0xKS5qb2luKCcsICcpICsgJyBhbmQgJyArIHBlZWsocHJvcHMpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHMpIHtcbiAgcmV0dXJuIHMubGVuZ3RoID8gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKSA6IHM7XG59XG5cbmNvbnN0IGlubmVyVGV4dCA9IHZhbCA9PiAodmFsICsgJycpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcblxuY29uc3QgYXR0clRleHQgPSB2YWwgPT4gaW5uZXJUZXh0KHZhbCkucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoL1xcdC9nLCAnJiN4OTsnKS5yZXBsYWNlKC9cXG4vZywgJyYjeEE7JykucmVwbGFjZSgvXFxyL2csICcmI3hEOycpO1xuXG5mdW5jdGlvbiBtYXJrdXAoKSB7XG4gIGxldCBidWYgPSAnJyxcbiAgICAgIG91dGVyID0gJycsXG4gICAgICBpbm5lciA9ICcnO1xuXG4gIGNvbnN0IHN0YWNrID0gW10sXG4gICAgICAgIGNsZWFyID0gKCkgPT4gb3V0ZXIgPSBpbm5lciA9ICcnLFxuICAgICAgICBwdXNoID0gdGFnID0+IHtcbiAgICBpZiAob3V0ZXIpIHtcbiAgICAgIGJ1ZiArPSBgJHtvdXRlcn0+JHtpbm5lcn1gO1xuICAgICAgY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHRhZyk7XG4gIH0sXG4gICAgICAgIGF0dHIgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkgb3V0ZXIgKz0gYCAke25hbWV9PVwiJHthdHRyVGV4dCh2YWx1ZSl9XCJgO1xuICAgIHJldHVybiBtO1xuICB9LFxuICAgICAgICBtID0ge1xuICAgIG9wZW4odGFnLCAuLi5hdHRycykge1xuICAgICAgcHVzaCh0YWcpO1xuICAgICAgb3V0ZXIgPSAnPCcgKyB0YWc7XG5cbiAgICAgIGZvciAoY29uc3Qgc2V0IG9mIGF0dHJzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNldCkgYXR0cihrZXksIHNldFtrZXldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIGNsb3NlKCkge1xuICAgICAgY29uc3QgdGFnID0gc3RhY2sucG9wKCk7XG5cbiAgICAgIGlmIChvdXRlcikge1xuICAgICAgICBidWYgKz0gb3V0ZXIgKyAoaW5uZXIgPyBgPiR7aW5uZXJ9PC8ke3RhZ30+YCA6ICcvPicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmICs9IGA8LyR7dGFnfT5gO1xuICAgICAgfVxuXG4gICAgICBjbGVhcigpO1xuICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIGF0dHIsXG4gICAgdGV4dDogdCA9PiAoaW5uZXIgKz0gaW5uZXJUZXh0KHQpLCBtKSxcbiAgICB0b1N0cmluZzogKCkgPT4gYnVmXG4gIH07XG5cbiAgcmV0dXJuIG07XG59XG5jb25zdCBzZXJpYWxpemVYTUwgPSBub2RlID0+IF9zZXJpYWxpemUobWFya3VwKCksIG5vZGUpICsgJyc7XG5cbmZ1bmN0aW9uIF9zZXJpYWxpemUobSwgbm9kZSkge1xuICBtLm9wZW4obm9kZS50YWdOYW1lKTtcblxuICBpZiAobm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICBjb25zdCBhdHRycyA9IG5vZGUuYXR0cmlidXRlcyxcbiAgICAgICAgICBuID0gYXR0cnMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG0uYXR0cihhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXS52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGQubm9kZVR5cGUgPT09IDMgLy8gdGV4dCBub2RlXG4gICAgICA/IG0udGV4dChjaGlsZC5ub2RlVmFsdWUpIDogX3NlcmlhbGl6ZShtLCBjaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG0uY2xvc2UoKTtcbn1cblxuY29uc3Qgc3R5bGVzID0ge1xuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgc3Ryb2tlV2lkdGg6ICdzdHJva2Utd2lkdGgnLFxuICBzdHJva2VDYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gIHN0cm9rZUpvaW46ICdzdHJva2UtbGluZWpvaW4nLFxuICBzdHJva2VEYXNoOiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gIHN0cm9rZURhc2hPZmZzZXQ6ICdzdHJva2UtZGFzaG9mZnNldCcsXG4gIHN0cm9rZU1pdGVyTGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgYmxlbmQ6ICdtaXgtYmxlbmQtbW9kZSdcbn07IC8vIGVuc3VyZSBtaXRlciBsaW1pdCBkZWZhdWx0IGlzIGNvbnNpc3RlbnQgd2l0aCBjYW52YXMgKCMyNDk4KVxuXG5jb25zdCByb290QXR0cmlidXRlcyA9IHtcbiAgJ2ZpbGwnOiAnbm9uZScsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6IDEwXG59O1xuXG5jb25zdCBSb290SW5kZXggPSAwLFxuICAgICAgeG1sbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nLFxuICAgICAgc3ZnbnMgPSBtZXRhZGF0YS54bWxucztcbmZ1bmN0aW9uIFNWR1JlbmRlcmVyKGxvYWRlcikge1xuICBSZW5kZXJlci5jYWxsKHRoaXMsIGxvYWRlcik7XG4gIHRoaXMuX2RpcnR5SUQgPSAwO1xuICB0aGlzLl9kaXJ0eSA9IFtdO1xuICB0aGlzLl9zdmcgPSBudWxsO1xuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5fZGVmcyA9IG51bGw7XG59XG5jb25zdCBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xuaW5oZXJpdHMoU1ZHUmVuZGVyZXIsIFJlbmRlcmVyLCB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IFNWR1JlbmRlcmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsIC0gVGhlIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQgZm9yIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGNvb3JkaW5hdGUgaGVpZ2h0IG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZUZhY3Rvcj0xXSAtIE9wdGlvbmFsIHNjYWxlRmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5XG4gICAqICAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtTVkdSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZShlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIC8vIGNyZWF0ZSB0aGUgc3ZnIGRlZmluaXRpb25zIGNhY2hlXG4gICAgdGhpcy5fZGVmcyA9IHt9O1xuXG4gICAgdGhpcy5fY2xlYXJEZWZzKCk7XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMuX3N2ZyA9IGRvbUNoaWxkKGVsLCAwLCAnc3ZnJywgc3ZnbnMpO1xuXG4gICAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlTlMoeG1sbnMsICd4bWxucycsIHN2Z25zKTtcblxuICAgICAgdGhpcy5fc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnM6eGxpbmsnLCBtZXRhZGF0YVsneG1sbnM6eGxpbmsnXSk7XG5cbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCBtZXRhZGF0YVsndmVyc2lvbiddKTtcblxuICAgICAgdGhpcy5fc3ZnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFya3MnKTtcblxuICAgICAgZG9tQ2xlYXIoZWwsIDEpOyAvLyBzZXQgdGhlIHN2ZyByb290IGdyb3VwXG5cbiAgICAgIHRoaXMuX3Jvb3QgPSBkb21DaGlsZCh0aGlzLl9zdmcsIFJvb3RJbmRleCwgJ2cnLCBzdmducyk7XG4gICAgICBzZXRBdHRyaWJ1dGVzKHRoaXMuX3Jvb3QsIHJvb3RBdHRyaWJ1dGVzKTsgLy8gZW5zdXJlIG5vIGFkZGl0aW9uYWwgY2hpbGQgZWxlbWVudHNcblxuICAgICAgZG9tQ2xlYXIodGhpcy5fc3ZnLCBSb290SW5kZXggKyAxKTtcbiAgICB9IC8vIHNldCBiYWNrZ3JvdW5kIGNvbG9yIGlmIGRlZmluZWRcblxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kKHRoaXMuX2JnY29sb3IpO1xuICAgIHJldHVybiBiYXNlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCAvIHNldCB0aGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICovXG4gIGJhY2tncm91bmQoYmdjb2xvcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHRoaXMuX3N2Zykge1xuICAgICAgdGhpcy5fc3ZnLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYmdjb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2UuYmFja2dyb3VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBuZXcgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1NWR1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2U7XG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIGJhc2UucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG5cbiAgICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgICBzZXRBdHRyaWJ1dGVzKHRoaXMuX3N2Zywge1xuICAgICAgICB3aWR0aDogdGhpcy5fd2lkdGggKiB0aGlzLl9zY2FsZSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQgKiB0aGlzLl9zY2FsZSxcbiAgICAgICAgdmlld0JveDogYDAgMCAke3RoaXMuX3dpZHRofSAke3RoaXMuX2hlaWdodH1gXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcm9vdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHt0aGlzLl9vcmlnaW59KWApO1xuICAgIH1cblxuICAgIHRoaXMuX2RpcnR5ID0gW107XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFNWRyBlbGVtZW50IG9mIHRoZSB2aXN1YWxpemF0aW9uLlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBTVkcgZWxlbWVudC5cbiAgICovXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ZnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFNWRyB0ZXh0IHN0cmluZyBmb3IgdGhlIHJlbmRlcmVkIGNvbnRlbnQsXG4gICAqIG9yIG51bGwgaWYgdGhpcyByZW5kZXJlciBpcyBjdXJyZW50bHkgaGVhZGxlc3MuXG4gICAqL1xuICBzdmcoKSB7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgICAgIGJnID0gdGhpcy5fYmdjb2xvcjtcbiAgICBpZiAoIXN2ZykgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoYmcpIHtcbiAgICAgIHN2Zy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBub2RlID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXgsICdyZWN0Jywgc3ZnbnMpO1xuICAgICAgc2V0QXR0cmlidXRlcyhub2RlLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgIGZpbGw6IGJnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gc2VyaWFsaXplWE1MKHN2Zyk7XG5cbiAgICBpZiAoYmcpIHtcbiAgICAgIHN2Zy5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgICAgdGhpcy5fc3ZnLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYmcpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZW5kZXJpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqL1xuICBfcmVuZGVyKHNjZW5lKSB7XG4gICAgLy8gcGVyZm9ybSBzcG90IHVwZGF0ZXMgYW5kIHJlLXJlbmRlciBtYXJrdXBcbiAgICBpZiAodGhpcy5fZGlydHlDaGVjaygpKSB7XG4gICAgICBpZiAodGhpcy5fZGlydHlBbGwpIHRoaXMuX2NsZWFyRGVmcygpO1xuICAgICAgdGhpcy5tYXJrKHRoaXMuX3Jvb3QsIHNjZW5lKTtcbiAgICAgIGRvbUNsZWFyKHRoaXMuX3Jvb3QsIDEpO1xuICAgIH1cblxuICAgIHRoaXMuZGVmcygpO1xuICAgIHRoaXMuX2RpcnR5ID0gW107XG4gICAgKyt0aGlzLl9kaXJ0eUlEO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIC0tIE1hbmFnZSByZW5kZXJpbmcgb2YgaXRlbXMgbWFya2VkIGFzIGRpcnR5IC0tXG5cbiAgLyoqXG4gICAqIEZsYWcgYSBtYXJrIGl0ZW0gYXMgZGlydHkuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBkaXJ0eShpdGVtKSB7XG4gICAgaWYgKGl0ZW0uZGlydHkgIT09IHRoaXMuX2RpcnR5SUQpIHtcbiAgICAgIGl0ZW0uZGlydHkgPSB0aGlzLl9kaXJ0eUlEO1xuXG4gICAgICB0aGlzLl9kaXJ0eS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBtYXJrIGl0ZW0gaXMgY29uc2lkZXJlZCBkaXJ0eS5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIGlzRGlydHkoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eUFsbCB8fCAhaXRlbS5fc3ZnIHx8IGl0ZW0uZGlydHkgPT09IHRoaXMuX2RpcnR5SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCB0byBjaGVjayBkaXJ0eSBzdGF0dXMgYW5kLCBpZiBwb3NzaWJsZSxcbiAgICogbWFrZSB0YXJnZXR0ZWQgdXBkYXRlcyB3aXRob3V0IGEgZnVsbCByZW5kZXJpbmcgcGFzcy5cbiAgICovXG4gIF9kaXJ0eUNoZWNrKCkge1xuICAgIHRoaXMuX2RpcnR5QWxsID0gdHJ1ZTtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2RpcnR5O1xuICAgIGlmICghaXRlbXMubGVuZ3RoIHx8ICF0aGlzLl9kaXJ0eUlEKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBpZCA9ICsrdGhpcy5fZGlydHlJRDtcbiAgICBsZXQgaXRlbSwgbWFyaywgdHlwZSwgbWRlZiwgaSwgbiwgbztcblxuICAgIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIG1hcmsgPSBpdGVtLm1hcms7XG5cbiAgICAgIGlmIChtYXJrLm1hcmt0eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIC8vIG1lbW9pemUgbWFyayBpbnN0YW5jZSBsb29rdXBcbiAgICAgICAgdHlwZSA9IG1hcmsubWFya3R5cGU7XG4gICAgICAgIG1kZWYgPSBNYXJrc1t0eXBlXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmsuemRpcnR5ICYmIG1hcmsuZGlydHkgIT09IGlkKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5QWxsID0gZmFsc2U7XG4gICAgICAgIGRpcnR5UGFyZW50cyhpdGVtLCBpZCk7XG4gICAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBpLmRpcnR5ID0gaWQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFyay56ZGlydHkpIGNvbnRpbnVlOyAvLyBoYW5kbGUgaW4gc3RhbmRhcmQgZHJhd2luZyBwYXNzXG5cbiAgICAgIGlmIChpdGVtLmV4aXQpIHtcbiAgICAgICAgLy8gRVhJVFxuICAgICAgICBpZiAobWRlZi5uZXN0ZWQgJiYgbWFyay5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpZiBuZXN0ZWQgbWFyayB3aXRoIHJlbWFpbmluZyBwb2ludHMsIHVwZGF0ZSBpbnN0ZWFkXG4gICAgICAgICAgbyA9IG1hcmsuaXRlbXNbMF07XG4gICAgICAgICAgaWYgKG8uX3N2ZykgdGhpcy5fdXBkYXRlKG1kZWYsIG8uX3N2Zywgbyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5fc3ZnKSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHJlbW92ZSBmcm9tIERPTVxuICAgICAgICAgIG8gPSBpdGVtLl9zdmcucGFyZW50Tm9kZTtcbiAgICAgICAgICBpZiAobykgby5yZW1vdmVDaGlsZChpdGVtLl9zdmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5fc3ZnID0gbnVsbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0gPSBtZGVmLm5lc3RlZCA/IG1hcmsuaXRlbXNbMF0gOiBpdGVtO1xuICAgICAgaWYgKGl0ZW0uX3VwZGF0ZSA9PT0gaWQpIGNvbnRpbnVlOyAvLyBhbHJlYWR5IHZpc2l0ZWRcblxuICAgICAgaWYgKCFpdGVtLl9zdmcgfHwgIWl0ZW0uX3N2Zy5vd25lclNWR0VsZW1lbnQpIHtcbiAgICAgICAgLy8gRU5URVJcbiAgICAgICAgdGhpcy5fZGlydHlBbGwgPSBmYWxzZTtcbiAgICAgICAgZGlydHlQYXJlbnRzKGl0ZW0sIGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElOLVBMQUNFIFVQREFURVxuICAgICAgICB0aGlzLl91cGRhdGUobWRlZiwgaXRlbS5fc3ZnLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5fdXBkYXRlID0gaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzLl9kaXJ0eUFsbDtcbiAgfSxcblxuICAvLyAtLSBDb25zdHJ1Y3QgJiBtYWludGFpbiBzY2VuZWdyYXBoIHRvIFNWRyBtYXBwaW5nIC0tLVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBzZXQgb2YgbWFyayBpdGVtcy5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbCAtIFRoZSBwYXJlbnQgZWxlbWVudCBpbiB0aGUgU1ZHIHRyZWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSBtYXJrIHBhcmVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gcHJldiAtIFRoZSBwcmV2aW91cyBzaWJsaW5nIGluIHRoZSBTVkcgdHJlZS5cbiAgICovXG4gIG1hcmsoZWwsIHNjZW5lLCBwcmV2KSB7XG4gICAgaWYgKCF0aGlzLmlzRGlydHkoc2NlbmUpKSByZXR1cm4gc2NlbmUuX3N2ZztcbiAgICBjb25zdCBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICAgICAgbWRlZiA9IE1hcmtzW3NjZW5lLm1hcmt0eXBlXSxcbiAgICAgICAgICBldmVudHMgPSBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsLFxuICAgICAgICAgIGlzR3JvdXAgPSBtZGVmLnRhZyA9PT0gJ2cnO1xuICAgIGxldCBzaWJsaW5nID0gbnVsbCxcbiAgICAgICAgaSA9IDA7XG4gICAgY29uc3QgcGFyZW50ID0gYmluZChzY2VuZSwgZWwsIHByZXYsICdnJywgc3ZnKTtcbiAgICBwYXJlbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNzc0NsYXNzKHNjZW5lKSk7IC8vIGFwcGx5IGFyaWEgYXR0cmlidXRlcyB0byBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnRcblxuICAgIGNvbnN0IGFyaWEgPSBhcmlhTWFya0F0dHJpYnV0ZXMoc2NlbmUpO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXJpYSkgc2V0QXR0cmlidXRlKHBhcmVudCwga2V5LCBhcmlhW2tleV0pO1xuXG4gICAgaWYgKCFpc0dyb3VwKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUocGFyZW50LCAncG9pbnRlci1ldmVudHMnLCBldmVudHMpO1xuICAgIH1cblxuICAgIHNldEF0dHJpYnV0ZShwYXJlbnQsICdjbGlwLXBhdGgnLCBzY2VuZS5jbGlwID8gY2xpcCQxKHRoaXMsIHNjZW5lLCBzY2VuZS5ncm91cCkgOiBudWxsKTtcblxuICAgIGNvbnN0IHByb2Nlc3MgPSBpdGVtID0+IHtcbiAgICAgIGNvbnN0IGRpcnR5ID0gdGhpcy5pc0RpcnR5KGl0ZW0pLFxuICAgICAgICAgICAgbm9kZSA9IGJpbmQoaXRlbSwgcGFyZW50LCBzaWJsaW5nLCBtZGVmLnRhZywgc3ZnKTtcblxuICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBub2RlLCBpdGVtKTtcblxuICAgICAgICBpZiAoaXNHcm91cCkgcmVjdXJzZSh0aGlzLCBub2RlLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2libGluZyA9IG5vZGU7XG4gICAgICArK2k7XG4gICAgfTtcblxuICAgIGlmIChtZGVmLm5lc3RlZCkge1xuICAgICAgaWYgKHNjZW5lLml0ZW1zLmxlbmd0aCkgcHJvY2VzcyhzY2VuZS5pdGVtc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2l0KHNjZW5lLCBwcm9jZXNzKTtcbiAgICB9XG5cbiAgICBkb21DbGVhcihwYXJlbnQsIGkpO1xuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhbiBTVkcgZWxlbWVudCBmb3IgYSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtZGVmIC0gVGhlIG1hcmsgZGVmaW5pdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbCAtIFRoZSBTVkcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIF91cGRhdGUobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICAvLyBzZXQgZG9tIGVsZW1lbnQgYW5kIHZhbHVlcyBjYWNoZVxuICAgIC8vIHByb3ZpZGVzIGFjY2VzcyB0byBlbWl0IG1ldGhvZFxuICAgIGVsZW1lbnQgPSBlbDtcbiAgICB2YWx1ZXMgPSBlbC5fX3ZhbHVlc19fOyAvLyBhcHBseSBhcmlhLXNwZWNpZmljIHByb3BlcnRpZXNcblxuICAgIGFyaWFJdGVtQXR0cmlidXRlcyhlbWl0LCBpdGVtKTsgLy8gYXBwbHkgc3ZnIGF0dHJpYnV0ZXNcblxuICAgIG1kZWYuYXR0cihlbWl0LCBpdGVtLCB0aGlzKTsgLy8gc29tZSBtYXJrcyBuZWVkIHNwZWNpYWwgdHJlYXRtZW50XG5cbiAgICBjb25zdCBleHRyYSA9IG1hcmtfZXh0cmFzW21kZWYudHlwZV07XG4gICAgaWYgKGV4dHJhKSBleHRyYS5jYWxsKHRoaXMsIG1kZWYsIGVsLCBpdGVtKTsgLy8gYXBwbHkgc3ZnIHN0eWxlIGF0dHJpYnV0ZXNcbiAgICAvLyBub3RlOiBlbGVtZW50IHN0YXRlIG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgYnkgJ2V4dHJhJyBtZXRob2RcblxuICAgIGlmIChlbGVtZW50KSB0aGlzLnN0eWxlKGVsZW1lbnQsIGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHByZXNlbnRhdGlvbiBhdHRyaWJ1dGVzIG9mIGFuIFNWRyBlbGVtZW50IGZvciBhIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbCAtIFRoZSBTVkcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIHN0eWxlKGVsLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0gPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHN0eWxlcykge1xuICAgICAgbGV0IHZhbHVlID0gcHJvcCA9PT0gJ2ZvbnQnID8gZm9udEZhbWlseShpdGVtKSA6IGl0ZW1bcHJvcF07XG4gICAgICBpZiAodmFsdWUgPT09IHZhbHVlc1twcm9wXSkgY29udGludWU7XG4gICAgICBjb25zdCBuYW1lID0gc3R5bGVzW3Byb3BdO1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdyYWRpZW50UmVmKHZhbHVlLCB0aGlzLl9kZWZzLmdyYWRpZW50LCBocmVmKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgJycpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXNbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBTVkcgZGVmcywgYXMgbmVlZGVkLlxuICAgKiBNdXN0IGJlIGNhbGxlZCAqYWZ0ZXIqIG1hcmtzIGhhdmUgYmVlbiBwcm9jZXNzZWQgdG8gZW5zdXJlIHRoZVxuICAgKiBjb2xsZWN0ZWQgc3RhdGUgaXMgY3VycmVudCBhbmQgYWNjdXJhdGUuXG4gICAqL1xuICBkZWZzKCkge1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgICAgICBkZWZzID0gdGhpcy5fZGVmcztcbiAgICBsZXQgZWwgPSBkZWZzLmVsLFxuICAgICAgICBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGNvbnN0IGlkIGluIGRlZnMuZ3JhZGllbnQpIHtcbiAgICAgIGlmICghZWwpIGRlZnMuZWwgPSBlbCA9IGRvbUNoaWxkKHN2ZywgUm9vdEluZGV4ICsgMSwgJ2RlZnMnLCBzdmducyk7XG4gICAgICBpbmRleCA9IHVwZGF0ZUdyYWRpZW50KGVsLCBkZWZzLmdyYWRpZW50W2lkXSwgaW5kZXgpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaWQgaW4gZGVmcy5jbGlwcGluZykge1xuICAgICAgaWYgKCFlbCkgZGVmcy5lbCA9IGVsID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXggKyAxLCAnZGVmcycsIHN2Z25zKTtcbiAgICAgIGluZGV4ID0gdXBkYXRlQ2xpcHBpbmcoZWwsIGRlZnMuY2xpcHBpbmdbaWRdLCBpbmRleCk7XG4gICAgfSAvLyBjbGVhbi11cFxuXG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIGluZGV4ID09PSAwID8gKHN2Zy5yZW1vdmVDaGlsZChlbCksIGRlZnMuZWwgPSBudWxsKSA6IGRvbUNsZWFyKGVsLCBpbmRleCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDbGVhciBkZWZzIGNhY2hlcy5cbiAgICovXG4gIF9jbGVhckRlZnMoKSB7XG4gICAgY29uc3QgZGVmID0gdGhpcy5fZGVmcztcbiAgICBkZWYuZ3JhZGllbnQgPSB7fTtcbiAgICBkZWYuY2xpcHBpbmcgPSB7fTtcbiAgfVxuXG59KTsgLy8gbWFyayBhbmNlc3RvciBjaGFpbiB3aXRoIGEgZGlydHkgaWRcblxuZnVuY3Rpb24gZGlydHlQYXJlbnRzKGl0ZW0sIGlkKSB7XG4gIGZvciAoOyBpdGVtICYmIGl0ZW0uZGlydHkgIT09IGlkOyBpdGVtID0gaXRlbS5tYXJrLmdyb3VwKSB7XG4gICAgaXRlbS5kaXJ0eSA9IGlkO1xuXG4gICAgaWYgKGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZGlydHkgIT09IGlkKSB7XG4gICAgICBpdGVtLm1hcmsuZGlydHkgPSBpZDtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG59IC8vIHVwZGF0ZSBncmFkaWVudCBkZWZpbml0aW9uc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUdyYWRpZW50KGVsLCBncmFkLCBpbmRleCkge1xuICBsZXQgaSwgbiwgc3RvcDtcblxuICBpZiAoZ3JhZC5ncmFkaWVudCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAvLyBTVkcgcmFkaWFsIGdyYWRpZW50cyBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybSB0byBub3JtYWxpemVkIGJib3hcbiAgICAvLyBjb29yZGluYXRlcywgaW4gYSB3YXkgdGhhdCBpcyBjdW1iZXJzb21lIHRvIHJlcGxpY2F0ZSBpbiBjYW52YXMuXG4gICAgLy8gV2Ugd3JhcCB0aGUgcmFkaWFsIGdyYWRpZW50IGluIGEgcGF0dGVybiBlbGVtZW50LCBhbGxvd2luZyB1cyB0b1xuICAgIC8vIG1haW50YWluIGEgY2lyY3VsYXIgZ3JhZGllbnQgdGhhdCBtYXRjaGVzIHdoYXQgY2FudmFzIHByb3ZpZGVzLlxuICAgIGxldCBwdCA9IGRvbUNoaWxkKGVsLCBpbmRleCsrLCAncGF0dGVybicsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKHB0LCB7XG4gICAgICBpZDogcGF0dGVyblByZWZpeCArIGdyYWQuaWQsXG4gICAgICB2aWV3Qm94OiAnMCwwLDEsMScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgc2xpY2UnXG4gICAgfSk7XG4gICAgcHQgPSBkb21DaGlsZChwdCwgMCwgJ3JlY3QnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhwdCwge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICBmaWxsOiBgdXJsKCR7aHJlZigpfSMke2dyYWQuaWR9KWBcbiAgICB9KTtcbiAgICBlbCA9IGRvbUNoaWxkKGVsLCBpbmRleCsrLCAncmFkaWFsR3JhZGllbnQnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhlbCwge1xuICAgICAgaWQ6IGdyYWQuaWQsXG4gICAgICBmeDogZ3JhZC54MSxcbiAgICAgIGZ5OiBncmFkLnkxLFxuICAgICAgZnI6IGdyYWQucjEsXG4gICAgICBjeDogZ3JhZC54MixcbiAgICAgIGN5OiBncmFkLnkyLFxuICAgICAgcjogZ3JhZC5yMlxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGVsID0gZG9tQ2hpbGQoZWwsIGluZGV4KyssICdsaW5lYXJHcmFkaWVudCcsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKGVsLCB7XG4gICAgICBpZDogZ3JhZC5pZCxcbiAgICAgIHgxOiBncmFkLngxLFxuICAgICAgeDI6IGdyYWQueDIsXG4gICAgICB5MTogZ3JhZC55MSxcbiAgICAgIHkyOiBncmFkLnkyXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBuID0gZ3JhZC5zdG9wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBzdG9wID0gZG9tQ2hpbGQoZWwsIGksICdzdG9wJywgc3ZnbnMpO1xuICAgIHN0b3Auc2V0QXR0cmlidXRlKCdvZmZzZXQnLCBncmFkLnN0b3BzW2ldLm9mZnNldCk7XG4gICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InLCBncmFkLnN0b3BzW2ldLmNvbG9yKTtcbiAgfVxuXG4gIGRvbUNsZWFyKGVsLCBpKTtcbiAgcmV0dXJuIGluZGV4O1xufSAvLyB1cGRhdGUgY2xpcHBpbmcgcGF0aCBkZWZpbml0aW9uc1xuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsaXBwaW5nKGVsLCBjbGlwLCBpbmRleCkge1xuICBsZXQgbWFzaztcbiAgZWwgPSBkb21DaGlsZChlbCwgaW5kZXgsICdjbGlwUGF0aCcsIHN2Z25zKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdpZCcsIGNsaXAuaWQpO1xuXG4gIGlmIChjbGlwLnBhdGgpIHtcbiAgICBtYXNrID0gZG9tQ2hpbGQoZWwsIDAsICdwYXRoJywgc3ZnbnMpO1xuICAgIG1hc2suc2V0QXR0cmlidXRlKCdkJywgY2xpcC5wYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBtYXNrID0gZG9tQ2hpbGQoZWwsIDAsICdyZWN0Jywgc3ZnbnMpO1xuICAgIHNldEF0dHJpYnV0ZXMobWFzaywge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogY2xpcC53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcC5oZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIGRvbUNsZWFyKGVsLCAxKTtcbiAgcmV0dXJuIGluZGV4ICsgMTtcbn0gLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBncm91cCBjb250ZW50cy5cblxuXG5mdW5jdGlvbiByZWN1cnNlKHJlbmRlcmVyLCBlbCwgZ3JvdXApIHtcbiAgZWwgPSBlbC5sYXN0Q2hpbGQucHJldmlvdXNTaWJsaW5nO1xuICBsZXQgcHJldixcbiAgICAgIGlkeCA9IDA7XG4gIHZpc2l0KGdyb3VwLCBpdGVtID0+IHtcbiAgICBwcmV2ID0gcmVuZGVyZXIubWFyayhlbCwgaXRlbSwgcHJldik7XG4gICAgKytpZHg7XG4gIH0pOyAvLyByZW1vdmUgYW55IGV4dHJhbmVvdXMgRE9NIGVsZW1lbnRzXG5cbiAgZG9tQ2xlYXIoZWwsIDEgKyBpZHgpO1xufSAvLyBCaW5kIGEgc2NlbmVncmFwaCBpdGVtIHRvIGFuIFNWRyBET00gZWxlbWVudC5cbi8vIENyZWF0ZSBuZXcgU1ZHIGVsZW1lbnRzIGFzIG5lZWRlZC5cblxuXG5mdW5jdGlvbiBiaW5kKGl0ZW0sIGVsLCBzaWJsaW5nLCB0YWcsIHN2Zykge1xuICBsZXQgbm9kZSA9IGl0ZW0uX3N2ZyxcbiAgICAgIGRvYzsgLy8gY3JlYXRlIGEgbmV3IGRvbSBub2RlIGlmIG5lZWRlZFxuXG4gIGlmICghbm9kZSkge1xuICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gICAgbm9kZSA9IGRvbUNyZWF0ZShkb2MsIHRhZywgc3ZnbnMpO1xuICAgIGl0ZW0uX3N2ZyA9IG5vZGU7XG5cbiAgICBpZiAoaXRlbS5tYXJrKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gaXRlbTtcbiAgICAgIG5vZGUuX192YWx1ZXNfXyA9IHtcbiAgICAgICAgZmlsbDogJ2RlZmF1bHQnXG4gICAgICB9OyAvLyBpZiBncm91cCwgY3JlYXRlIGJhY2tncm91bmQsIGNvbnRlbnQsIGFuZCBmb3JlZ3JvdW5kIGVsZW1lbnRzXG5cbiAgICAgIGlmICh0YWcgPT09ICdnJykge1xuICAgICAgICBjb25zdCBiZyA9IGRvbUNyZWF0ZShkb2MsICdwYXRoJywgc3ZnbnMpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGJnKTtcbiAgICAgICAgYmcuX19kYXRhX18gPSBpdGVtO1xuICAgICAgICBjb25zdCBjZyA9IGRvbUNyZWF0ZShkb2MsICdnJywgc3ZnbnMpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNnKTtcbiAgICAgICAgY2cuX19kYXRhX18gPSBpdGVtO1xuICAgICAgICBjb25zdCBmZyA9IGRvbUNyZWF0ZShkb2MsICdwYXRoJywgc3ZnbnMpO1xuICAgICAgICBub2RlLmFwcGVuZENoaWxkKGZnKTtcbiAgICAgICAgZmcuX19kYXRhX18gPSBpdGVtO1xuICAgICAgICBmZy5fX3ZhbHVlc19fID0ge1xuICAgICAgICAgIGZpbGw6ICdkZWZhdWx0J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyAocmUtKWluc2VydCBpZiAoYSkgbm90IGNvbnRhaW5lZCBpbiBTVkcgb3IgKGIpIHNpYmxpbmcgb3JkZXIgaGFzIGNoYW5nZWRcblxuXG4gIGlmIChub2RlLm93bmVyU1ZHRWxlbWVudCAhPT0gc3ZnIHx8IHNpYmxpbmdDaGVjayhub2RlLCBzaWJsaW5nKSkge1xuICAgIGVsLmluc2VydEJlZm9yZShub2RlLCBzaWJsaW5nID8gc2libGluZy5uZXh0U2libGluZyA6IGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IC8vIGNoZWNrIGlmIHR3byBub2RlcyBhcmUgb3JkZXJlZCBzaWJsaW5nc1xuXG5cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayhub2RlLCBzaWJsaW5nKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMSAmJiBub2RlLnByZXZpb3VzU2libGluZyAhPSBzaWJsaW5nOyAvLyB0cmVhdCBudWxsL3VuZGVmaW5lZCB0aGUgc2FtZVxufSAvLyAtLSBTZXQgYXR0cmlidXRlcyAmIHN0eWxlcyBvbiBTVkcgZWxlbWVudHMgLS0tXG5cblxubGV0IGVsZW1lbnQgPSBudWxsLFxuICAgIC8vIHRlbXAgdmFyIGZvciBjdXJyZW50IFNWRyBlbGVtZW50XG52YWx1ZXMgPSBudWxsOyAvLyB0ZW1wIHZhciBmb3IgY3VycmVudCB2YWx1ZXMgaGFzaFxuLy8gRXh0cmEgY29uZmlndXJhdGlvbiBmb3IgY2VydGFpbiBtYXJrIHR5cGVzXG5cbmNvbnN0IG1hcmtfZXh0cmFzID0ge1xuICBncm91cChtZGVmLCBlbCwgaXRlbSkge1xuICAgIGNvbnN0IGZnID0gZWxlbWVudCA9IGVsLmNoaWxkTm9kZXNbMl07XG4gICAgdmFsdWVzID0gZmcuX192YWx1ZXNfXztcbiAgICBtZGVmLmZvcmVncm91bmQoZW1pdCwgaXRlbSwgdGhpcyk7XG4gICAgdmFsdWVzID0gZWwuX192YWx1ZXNfXzsgLy8gdXNlIHBhcmVudCdzIHZhbHVlcyBoYXNoXG5cbiAgICBlbGVtZW50ID0gZWwuY2hpbGROb2Rlc1sxXTtcbiAgICBtZGVmLmNvbnRlbnQoZW1pdCwgaXRlbSwgdGhpcyk7XG4gICAgY29uc3QgYmcgPSBlbGVtZW50ID0gZWwuY2hpbGROb2Rlc1swXTtcbiAgICBtZGVmLmJhY2tncm91bmQoZW1pdCwgaXRlbSwgdGhpcyk7XG4gICAgY29uc3QgdmFsdWUgPSBpdGVtLm1hcmsuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbDtcblxuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWVzLmV2ZW50cykge1xuICAgICAgc2V0QXR0cmlidXRlKGZnLCAncG9pbnRlci1ldmVudHMnLCB2YWx1ZSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYmcsICdwb2ludGVyLWV2ZW50cycsIHZhbHVlKTtcbiAgICAgIHZhbHVlcy5ldmVudHMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5zdHJva2VGb3JlZ3JvdW5kICYmIGl0ZW0uc3Ryb2tlKSB7XG4gICAgICBjb25zdCBmaWxsID0gaXRlbS5maWxsO1xuICAgICAgc2V0QXR0cmlidXRlKGZnLCAnZGlzcGxheScsIG51bGwpOyAvLyBzZXQgc3R5bGUgb2YgYmFja2dyb3VuZFxuXG4gICAgICB0aGlzLnN0eWxlKGJnLCBpdGVtKTtcbiAgICAgIHNldEF0dHJpYnV0ZShiZywgJ3N0cm9rZScsIG51bGwpOyAvLyBzZXQgc3R5bGUgb2YgZm9yZWdyb3VuZFxuXG4gICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gbnVsbDtcbiAgICAgIHZhbHVlcyA9IGZnLl9fdmFsdWVzX187XG4gICAgICB0aGlzLnN0eWxlKGZnLCBpdGVtKTtcbiAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBmaWxsOyAvLyBsZWF2ZSBlbGVtZW50IG51bGwgdG8gcHJldmVudCBkb3duc3RyZWFtIHN0eWxpbmdcblxuICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVuc3VyZSBmb3JlZ3JvdW5kIGlzIGlnbm9yZWRcbiAgICAgIHNldEF0dHJpYnV0ZShmZywgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcblxuICBpbWFnZShtZGVmLCBlbCwgaXRlbSkge1xuICAgIGlmIChpdGVtLnNtb290aCA9PT0gZmFsc2UpIHtcbiAgICAgIHNldFN0eWxlKGVsLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ29wdGltaXplU3BlZWQnKTtcbiAgICAgIHNldFN0eWxlKGVsLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ3BpeGVsYXRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTdHlsZShlbCwgJ2ltYWdlLXJlbmRlcmluZycsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICB0ZXh0KG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgY29uc3QgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG4gICAgbGV0IGtleSwgdmFsdWUsIGRvYywgbGg7XG5cbiAgICBpZiAoaXNBcnJheSh0bCkpIHtcbiAgICAgIC8vIG11bHRpLWxpbmUgdGV4dFxuICAgICAgdmFsdWUgPSB0bC5tYXAoXyA9PiB0ZXh0VmFsdWUoaXRlbSwgXykpO1xuICAgICAga2V5ID0gdmFsdWUuam9pbignXFxuJyk7IC8vIGNvbnRlbnQgY2FjaGUga2V5XG5cbiAgICAgIGlmIChrZXkgIT09IHZhbHVlcy50ZXh0KSB7XG4gICAgICAgIGRvbUNsZWFyKGVsLCAwKTtcbiAgICAgICAgZG9jID0gZWwub3duZXJEb2N1bWVudDtcbiAgICAgICAgbGggPSBsaW5lSGVpZ2h0KGl0ZW0pO1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh0LCBpKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHMgPSBkb21DcmVhdGUoZG9jLCAndHNwYW4nLCBzdmducyk7XG4gICAgICAgICAgdHMuX19kYXRhX18gPSBpdGVtOyAvLyBkYXRhIGJpbmRpbmdcblxuICAgICAgICAgIHRzLnRleHRDb250ZW50ID0gdDtcblxuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICB0cy5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgICAgIHRzLnNldEF0dHJpYnV0ZSgnZHknLCBsaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQodHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVzLnRleHQgPSBrZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNpbmdsZS1saW5lIHRleHRcbiAgICAgIHZhbHVlID0gdGV4dFZhbHVlKGl0ZW0sIHRsKTtcblxuICAgICAgaWYgKHZhbHVlICE9PSB2YWx1ZXMudGV4dCkge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICB2YWx1ZXMudGV4dCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtZmFtaWx5JywgZm9udEZhbWlseShpdGVtKSk7XG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC1zaXplJywgZm9udFNpemUoaXRlbSkgKyAncHgnKTtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LXN0eWxlJywgaXRlbS5mb250U3R5bGUpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtdmFyaWFudCcsIGl0ZW0uZm9udFZhcmlhbnQpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtd2VpZ2h0JywgaXRlbS5mb250V2VpZ2h0KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBlbWl0KG5hbWUsIHZhbHVlLCBucykge1xuICAvLyBlYXJseSBleGl0IGlmIHZhbHVlIGlzIHVuY2hhbmdlZFxuICBpZiAodmFsdWUgPT09IHZhbHVlc1tuYW1lXSkgcmV0dXJuOyAvLyB1c2UgYXBwcm9wcmlhdGUgbWV0aG9kIGdpdmVuIG5hbWVzcGFjZSAobnMpXG5cbiAgaWYgKG5zKSB7XG4gICAgc2V0QXR0cmlidXRlTlMoZWxlbWVudCwgbmFtZSwgdmFsdWUsIG5zKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICB9IC8vIG5vdGUgY3VycmVudCB2YWx1ZSBmb3IgZnV0dXJlIGNvbXBhcmlzb25cblxuXG4gIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9PSB2YWx1ZXNbbmFtZV0pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlICsgJycpO1xuICAgIH1cblxuICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWwsIGF0dHJzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgc2V0QXR0cmlidXRlKGVsLCBrZXksIGF0dHJzW2tleV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBpZiB2YWx1ZSBpcyBwcm92aWRlZCwgdXBkYXRlIERPTSBhdHRyaWJ1dGVcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgcmVtb3ZlIERPTSBhdHRyaWJ1dGVcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMoZWwsIG5hbWUsIHZhbHVlLCBucykge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIGlmIHZhbHVlIGlzIHByb3ZpZGVkLCB1cGRhdGUgRE9NIGF0dHJpYnV0ZVxuICAgIGVsLnNldEF0dHJpYnV0ZU5TKG5zLCBuYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSByZW1vdmUgRE9NIGF0dHJpYnV0ZVxuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKG5zLCBuYW1lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBocmVmKCkge1xuICBsZXQgbG9jO1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IChsb2MgPSB3aW5kb3cubG9jYXRpb24pLmhhc2ggPyBsb2MuaHJlZi5zbGljZSgwLCAtbG9jLmhhc2gubGVuZ3RoKSA6IGxvYy5ocmVmO1xufVxuXG5mdW5jdGlvbiBTVkdTdHJpbmdSZW5kZXJlcihsb2FkZXIpIHtcbiAgUmVuZGVyZXIuY2FsbCh0aGlzLCBsb2FkZXIpO1xuICB0aGlzLl90ZXh0ID0gbnVsbDtcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59XG5pbmhlcml0cyhTVkdTdHJpbmdSZW5kZXJlciwgUmVuZGVyZXIsIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbmRlcmVkIFNWRyB0ZXh0IHN0cmluZyxcbiAgICogb3IgbnVsbCBpZiByZW5kZXJpbmcgaGFzIG5vdCB5ZXQgb2NjdXJyZWQuXG4gICAqL1xuICBzdmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICovXG4gIF9yZW5kZXIoc2NlbmUpIHtcbiAgICBjb25zdCBtID0gbWFya3VwKCk7IC8vIHN2ZyB0YWdcblxuICAgIG0ub3Blbignc3ZnJywgZXh0ZW5kKHt9LCBtZXRhZGF0YSwge1xuICAgICAgY2xhc3M6ICdtYXJrcycsXG4gICAgICB3aWR0aDogdGhpcy5fd2lkdGggKiB0aGlzLl9zY2FsZSxcbiAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0ICogdGhpcy5fc2NhbGUsXG4gICAgICB2aWV3Qm94OiBgMCAwICR7dGhpcy5fd2lkdGh9ICR7dGhpcy5faGVpZ2h0fWBcbiAgICB9KSk7IC8vIGJhY2tncm91bmQsIGlmIGRlZmluZWRcblxuICAgIGNvbnN0IGJnID0gdGhpcy5fYmdjb2xvcjtcblxuICAgIGlmIChiZyAmJiBiZyAhPT0gJ3RyYW5zcGFyZW50JyAmJiBiZyAhPT0gJ25vbmUnKSB7XG4gICAgICBtLm9wZW4oJ3JlY3QnLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgIGZpbGw6IGJnXG4gICAgICB9KS5jbG9zZSgpO1xuICAgIH0gLy8gcm9vdCBjb250ZW50IGdyb3VwXG5cblxuICAgIG0ub3BlbignZycsIHJvb3RBdHRyaWJ1dGVzLCB7XG4gICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHRoaXMuX29yaWdpbiArICcpJ1xuICAgIH0pO1xuICAgIHRoaXMubWFyayhtLCBzY2VuZSk7XG4gICAgbS5jbG9zZSgpOyAvLyA8L2c+XG4gICAgLy8gZGVmc1xuXG4gICAgdGhpcy5kZWZzKG0pOyAvLyBnZXQgU1ZHIHRleHQgc3RyaW5nXG5cbiAgICB0aGlzLl90ZXh0ID0gbS5jbG9zZSgpICsgJyc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNldCBvZiBtYXJrIGl0ZW1zLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbSAtIFRoZSBtYXJrdXAgY29udGV4dC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50IHRvIHJlbmRlci5cbiAgICovXG4gIG1hcmsobSwgc2NlbmUpIHtcbiAgICBjb25zdCBtZGVmID0gTWFya3Nbc2NlbmUubWFya3R5cGVdLFxuICAgICAgICAgIHRhZyA9IG1kZWYudGFnLFxuICAgICAgICAgIGF0dHJMaXN0ID0gW2FyaWFJdGVtQXR0cmlidXRlcywgbWRlZi5hdHRyXTsgLy8gcmVuZGVyIG9wZW5pbmcgZ3JvdXAgdGFnXG5cbiAgICBtLm9wZW4oJ2cnLCB7XG4gICAgICAnY2xhc3MnOiBjc3NDbGFzcyhzY2VuZSksXG4gICAgICAnY2xpcC1wYXRoJzogc2NlbmUuY2xpcCA/IGNsaXAkMSh0aGlzLCBzY2VuZSwgc2NlbmUuZ3JvdXApIDogbnVsbFxuICAgIH0sIGFyaWFNYXJrQXR0cmlidXRlcyhzY2VuZSksIHtcbiAgICAgICdwb2ludGVyLWV2ZW50cyc6IHRhZyAhPT0gJ2cnICYmIHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGxcbiAgICB9KTsgLy8gcmVuZGVyIGNvbnRhaW5lZCBlbGVtZW50c1xuXG4gICAgY29uc3QgcHJvY2VzcyA9IGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaHJlZiA9IHRoaXMuaHJlZihpdGVtKTtcbiAgICAgIGlmIChocmVmKSBtLm9wZW4oJ2EnLCBocmVmKTtcbiAgICAgIG0ub3Blbih0YWcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgYXR0ckxpc3QsIHRhZyAhPT0gJ2cnID8gdGFnIDogbnVsbCkpO1xuXG4gICAgICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICAgICAgY29uc3QgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodGwpKSB7XG4gICAgICAgICAgLy8gbXVsdGktbGluZSB0ZXh0XG4gICAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgZHk6IGxpbmVIZWlnaHQoaXRlbSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0bC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbS5vcGVuKCd0c3BhbicsIGkgPyBhdHRycyA6IG51bGwpLnRleHQodGV4dFZhbHVlKGl0ZW0sIHRsW2ldKSkuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2luZ2xlLWxpbmUgdGV4dFxuICAgICAgICAgIG0udGV4dCh0ZXh0VmFsdWUoaXRlbSwgdGwpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdnJykge1xuICAgICAgICBjb25zdCBmb3JlID0gaXRlbS5zdHJva2VGb3JlZ3JvdW5kLFxuICAgICAgICAgICAgICBmaWxsID0gaXRlbS5maWxsLFxuICAgICAgICAgICAgICBzdHJva2UgPSBpdGVtLnN0cm9rZTtcblxuICAgICAgICBpZiAoZm9yZSAmJiBzdHJva2UpIHtcbiAgICAgICAgICBpdGVtLnN0cm9rZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtLm9wZW4oJ3BhdGgnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuYmFja2dyb3VuZCwgJ2JncmVjdCcpKS5jbG9zZSgpOyAvLyByZWN1cnNlIGZvciBncm91cCBjb250ZW50XG5cbiAgICAgICAgbS5vcGVuKCdnJywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBtZGVmLmNvbnRlbnQpKTtcbiAgICAgICAgdmlzaXQoaXRlbSwgc2NlbmUgPT4gdGhpcy5tYXJrKG0sIHNjZW5lKSk7XG4gICAgICAgIG0uY2xvc2UoKTtcblxuICAgICAgICBpZiAoZm9yZSAmJiBzdHJva2UpIHtcbiAgICAgICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gbnVsbDtcbiAgICAgICAgICBpdGVtLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgICBtLm9wZW4oJ3BhdGgnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuZm9yZWdyb3VuZCwgJ2JncmVjdCcpKS5jbG9zZSgpO1xuICAgICAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBmaWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0ub3BlbigncGF0aCcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5mb3JlZ3JvdW5kLCAnYmdmb3JlJykpLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbS5jbG9zZSgpOyAvLyA8L3RhZz5cblxuICAgICAgaWYgKGhyZWYpIG0uY2xvc2UoKTsgLy8gPC9hPlxuICAgIH07XG5cbiAgICBpZiAobWRlZi5uZXN0ZWQpIHtcbiAgICAgIGlmIChzY2VuZS5pdGVtcyAmJiBzY2VuZS5pdGVtcy5sZW5ndGgpIHByb2Nlc3Moc2NlbmUuaXRlbXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpdChzY2VuZSwgcHJvY2Vzcyk7XG4gICAgfSAvLyByZW5kZXIgY2xvc2luZyBncm91cCB0YWdcblxuXG4gICAgcmV0dXJuIG0uY2xvc2UoKTsgLy8gPC9nPlxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgaHJlZiBhdHRyaWJ1dGVzIGZvciBhIGh5cGVybGlua2VkIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIGhyZWYoaXRlbSkge1xuICAgIGNvbnN0IGhyZWYgPSBpdGVtLmhyZWY7XG4gICAgbGV0IGF0dHI7XG5cbiAgICBpZiAoaHJlZikge1xuICAgICAgaWYgKGF0dHIgPSB0aGlzLl9ocmVmcyAmJiB0aGlzLl9ocmVmc1tocmVmXSkge1xuICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2FuaXRpemVVUkwoaHJlZikudGhlbihhdHRyID0+IHtcbiAgICAgICAgICAvLyByZXdyaXRlIHRvIHVzZSB4bGluayBuYW1lc3BhY2VcbiAgICAgICAgICBhdHRyWyd4bGluazpocmVmJ10gPSBhdHRyLmhyZWY7XG4gICAgICAgICAgYXR0ci5ocmVmID0gbnVsbDtcbiAgICAgICAgICAodGhpcy5faHJlZnMgfHwgKHRoaXMuX2hyZWZzID0ge30pKVtocmVmXSA9IGF0dHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IG9mIFNWRyBhdHRyaWJ1dGVzIGZvciBhIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge2FycmF5fGZ1bmN0aW9ufSBhdHRycyAtIE9uZSBvciBtb3JlIGF0dHJpYnV0ZSBlbWl0dGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyAtIFRoZSB0YWcgYmVpbmcgcmVuZGVyZWQuXG4gICAqL1xuICBhdHRyKHNjZW5lLCBpdGVtLCBhdHRycywgdGFnKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0ge30sXG4gICAgICAgICAgZW1pdCA9IChuYW1lLCB2YWx1ZSwgbnMsIHByZWZpeGVkKSA9PiB7XG4gICAgICBvYmplY3RbcHJlZml4ZWQgfHwgbmFtZV0gPSB2YWx1ZTtcbiAgICB9OyAvLyBhcHBseSBtYXJrIHNwZWNpZmljIGF0dHJpYnV0ZXNcblxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICBhdHRycy5mb3JFYWNoKGZuID0+IGZuKGVtaXQsIGl0ZW0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cnMoZW1pdCwgaXRlbSwgdGhpcyk7XG4gICAgfSAvLyBhcHBseSBzdHlsZSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmICh0YWcpIHtcbiAgICAgIHN0eWxlKG9iamVjdCwgaXRlbSwgc2NlbmUsIHRhZywgdGhpcy5fZGVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVyIFNWRyBkZWZzLCBhcyBuZWVkZWQuXG4gICAqIE11c3QgYmUgY2FsbGVkICphZnRlciogbWFya3MgaGF2ZSBiZWVuIHByb2Nlc3NlZCB0byBlbnN1cmUgdGhlXG4gICAqIGNvbGxlY3RlZCBzdGF0ZSBpcyBjdXJyZW50IGFuZCBhY2N1cmF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG0gLSBUaGUgbWFya3VwIGNvbnRleHQuXG4gICAqL1xuICBkZWZzKG0pIHtcbiAgICBjb25zdCBncmFkaWVudCA9IHRoaXMuX2RlZnMuZ3JhZGllbnQsXG4gICAgICAgICAgY2xpcHBpbmcgPSB0aGlzLl9kZWZzLmNsaXBwaW5nLFxuICAgICAgICAgIGNvdW50ID0gT2JqZWN0LmtleXMoZ3JhZGllbnQpLmxlbmd0aCArIE9iamVjdC5rZXlzKGNsaXBwaW5nKS5sZW5ndGg7XG4gICAgaWYgKGNvdW50ID09PSAwKSByZXR1cm47IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIG0ub3BlbignZGVmcycpO1xuXG4gICAgZm9yIChjb25zdCBpZCBpbiBncmFkaWVudCkge1xuICAgICAgY29uc3QgZGVmID0gZ3JhZGllbnRbaWRdLFxuICAgICAgICAgICAgc3RvcHMgPSBkZWYuc3RvcHM7XG5cbiAgICAgIGlmIChkZWYuZ3JhZGllbnQgPT09ICdyYWRpYWwnKSB7XG4gICAgICAgIC8vIFNWRyByYWRpYWwgZ3JhZGllbnRzIGF1dG9tYXRpY2FsbHkgdHJhbnNmb3JtIHRvIG5vcm1hbGl6ZWQgYmJveFxuICAgICAgICAvLyBjb29yZGluYXRlcywgaW4gYSB3YXkgdGhhdCBpcyBjdW1iZXJzb21lIHRvIHJlcGxpY2F0ZSBpbiBjYW52YXMuXG4gICAgICAgIC8vIFdlIHdyYXAgdGhlIHJhZGlhbCBncmFkaWVudCBpbiBhIHBhdHRlcm4gZWxlbWVudCwgYWxsb3dpbmcgdXMgdG9cbiAgICAgICAgLy8gbWFpbnRhaW4gYSBjaXJjdWxhciBncmFkaWVudCB0aGF0IG1hdGNoZXMgd2hhdCBjYW52YXMgcHJvdmlkZXMuXG4gICAgICAgIG0ub3BlbigncGF0dGVybicsIHtcbiAgICAgICAgICBpZDogcGF0dGVyblByZWZpeCArIGlkLFxuICAgICAgICAgIHZpZXdCb3g6ICcwLDAsMSwxJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86ICd4TWlkWU1pZCBzbGljZSdcbiAgICAgICAgfSk7XG4gICAgICAgIG0ub3BlbigncmVjdCcsIHtcbiAgICAgICAgICB3aWR0aDogJzEnLFxuICAgICAgICAgIGhlaWdodDogJzEnLFxuICAgICAgICAgIGZpbGw6ICd1cmwoIycgKyBpZCArICcpJ1xuICAgICAgICB9KS5jbG9zZSgpO1xuICAgICAgICBtLmNsb3NlKCk7IC8vIDwvcGF0dGVybj5cblxuICAgICAgICBtLm9wZW4oJ3JhZGlhbEdyYWRpZW50Jywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBmeDogZGVmLngxLFxuICAgICAgICAgIGZ5OiBkZWYueTEsXG4gICAgICAgICAgZnI6IGRlZi5yMSxcbiAgICAgICAgICBjeDogZGVmLngyLFxuICAgICAgICAgIGN5OiBkZWYueTIsXG4gICAgICAgICAgcjogZGVmLnIyXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbS5vcGVuKCdsaW5lYXJHcmFkaWVudCcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgeDE6IGRlZi54MSxcbiAgICAgICAgICB4MjogZGVmLngyLFxuICAgICAgICAgIHkxOiBkZWYueTEsXG4gICAgICAgICAgeTI6IGRlZi55MlxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtLm9wZW4oJ3N0b3AnLCB7XG4gICAgICAgICAgb2Zmc2V0OiBzdG9wc1tpXS5vZmZzZXQsXG4gICAgICAgICAgJ3N0b3AtY29sb3InOiBzdG9wc1tpXS5jb2xvclxuICAgICAgICB9KS5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBtLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpZCBpbiBjbGlwcGluZykge1xuICAgICAgY29uc3QgZGVmID0gY2xpcHBpbmdbaWRdO1xuICAgICAgbS5vcGVuKCdjbGlwUGF0aCcsIHtcbiAgICAgICAgaWQ6IGlkXG4gICAgICB9KTtcblxuICAgICAgaWYgKGRlZi5wYXRoKSB7XG4gICAgICAgIG0ub3BlbigncGF0aCcsIHtcbiAgICAgICAgICBkOiBkZWYucGF0aFxuICAgICAgICB9KS5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbS5vcGVuKCdyZWN0Jywge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3aWR0aDogZGVmLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogZGVmLmhlaWdodFxuICAgICAgICB9KS5jbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBtLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgbS5jbG9zZSgpO1xuICB9XG5cbn0pOyAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGF0dHIgZm9yIHN0eWxlIHByZXNlbnRhdGlvbiBhdHRyaWJ1dGVzXG5cbmZ1bmN0aW9uIHN0eWxlKHMsIGl0ZW0sIHNjZW5lLCB0YWcsIGRlZnMpIHtcbiAgaWYgKGl0ZW0gPT0gbnVsbCkgcmV0dXJuIHM7XG5cbiAgaWYgKHRhZyA9PT0gJ2JncmVjdCcgJiYgc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgc1sncG9pbnRlci1ldmVudHMnXSA9ICdub25lJztcbiAgfVxuXG4gIGlmICh0YWcgPT09ICdiZ2ZvcmUnKSB7XG4gICAgaWYgKHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgc1sncG9pbnRlci1ldmVudHMnXSA9ICdub25lJztcbiAgICB9XG5cbiAgICBzLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWYgKGl0ZW0uZmlsbCAhPT0gbnVsbCkgcmV0dXJuIHM7XG4gIH1cblxuICBpZiAodGFnID09PSAnaW1hZ2UnICYmIGl0ZW0uc21vb3RoID09PSBmYWxzZSkge1xuICAgIHMuc3R5bGUgPSAnaW1hZ2UtcmVuZGVyaW5nOiBvcHRpbWl6ZVNwZWVkOyBpbWFnZS1yZW5kZXJpbmc6IHBpeGVsYXRlZDsnO1xuICB9XG5cbiAgaWYgKHRhZyA9PT0gJ3RleHQnKSB7XG4gICAgc1snZm9udC1mYW1pbHknXSA9IGZvbnRGYW1pbHkoaXRlbSk7XG4gICAgc1snZm9udC1zaXplJ10gPSBmb250U2l6ZShpdGVtKSArICdweCc7XG4gICAgc1snZm9udC1zdHlsZSddID0gaXRlbS5mb250U3R5bGU7XG4gICAgc1snZm9udC12YXJpYW50J10gPSBpdGVtLmZvbnRWYXJpYW50O1xuICAgIHNbJ2ZvbnQtd2VpZ2h0J10gPSBpdGVtLmZvbnRXZWlnaHQ7XG4gIH1cblxuICBmb3IgKGNvbnN0IHByb3AgaW4gc3R5bGVzKSB7XG4gICAgbGV0IHZhbHVlID0gaXRlbVtwcm9wXTtcbiAgICBjb25zdCBuYW1lID0gc3R5bGVzW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09PSAndHJhbnNwYXJlbnQnICYmIChuYW1lID09PSAnZmlsbCcgfHwgbmFtZSA9PT0gJ3N0cm9rZScpKSA7IGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGlmIChpc0dyYWRpZW50KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IGdyYWRpZW50UmVmKHZhbHVlLCBkZWZzLmdyYWRpZW50LCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcztcbn1cblxuY29uc3QgQ2FudmFzID0gJ2NhbnZhcyc7XG5jb25zdCBQTkcgPSAncG5nJztcbmNvbnN0IFNWRyA9ICdzdmcnO1xuY29uc3QgTm9uZSA9ICdub25lJztcbmNvbnN0IFJlbmRlclR5cGUgPSB7XG4gIENhbnZhczogQ2FudmFzLFxuICBQTkc6IFBORyxcbiAgU1ZHOiBTVkcsXG4gIE5vbmU6IE5vbmVcbn07XG5jb25zdCBtb2R1bGVzID0ge307XG5tb2R1bGVzW0NhbnZhc10gPSBtb2R1bGVzW1BOR10gPSB7XG4gIHJlbmRlcmVyOiBDYW52YXNSZW5kZXJlcixcbiAgaGVhZGxlc3M6IENhbnZhc1JlbmRlcmVyLFxuICBoYW5kbGVyOiBDYW52YXNIYW5kbGVyXG59O1xubW9kdWxlc1tTVkddID0ge1xuICByZW5kZXJlcjogU1ZHUmVuZGVyZXIsXG4gIGhlYWRsZXNzOiBTVkdTdHJpbmdSZW5kZXJlcixcbiAgaGFuZGxlcjogU1ZHSGFuZGxlclxufTtcbm1vZHVsZXNbTm9uZV0gPSB7fTtcbmZ1bmN0aW9uIHJlbmRlck1vZHVsZShuYW1lLCBfKSB7XG4gIG5hbWUgPSBTdHJpbmcobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBtb2R1bGVzW25hbWVdID0gXztcbiAgICByZXR1cm4gdGhpcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbW9kdWxlc1tuYW1lXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Qoc2NlbmUsIGJvdW5kcywgZmlsdGVyKSB7XG4gIGNvbnN0IGhpdHMgPSBbXSxcbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIHJlc3VsdHNcbiAgYm94ID0gbmV3IEJvdW5kcygpLnVuaW9uKGJvdW5kcyksXG4gICAgICAgIC8vIGRlZmVuc2l2ZSBjb3B5XG4gIHR5cGUgPSBzY2VuZS5tYXJrdHlwZTtcbiAgcmV0dXJuIHR5cGUgPyBpbnRlcnNlY3RNYXJrKHNjZW5lLCBib3gsIGZpbHRlciwgaGl0cykgOiB0eXBlID09PSAnZ3JvdXAnID8gaW50ZXJzZWN0R3JvdXAoc2NlbmUsIGJveCwgZmlsdGVyLCBoaXRzKSA6IGVycm9yKCdJbnRlcnNlY3Qgc2NlbmUgbXVzdCBiZSBtYXJrIG5vZGUgb3IgZ3JvdXAgaXRlbS4nKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0TWFyayhtYXJrLCBib3gsIGZpbHRlciwgaGl0cykge1xuICBpZiAodmlzaXRNYXJrKG1hcmssIGJveCwgZmlsdGVyKSkge1xuICAgIGNvbnN0IGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgICAgICB0eXBlID0gbWFyay5tYXJrdHlwZSxcbiAgICAgICAgICBuID0gaXRlbXMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpbnRlcnNlY3RHcm91cChpdGVtc1tpXSwgYm94LCBmaWx0ZXIsIGhpdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHRlc3QgPSBNYXJrc1t0eXBlXS5pc2VjdDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpbnRlcnNlY3RJdGVtKGl0ZW0sIGJveCwgdGVzdCkpIGhpdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGl0cztcbn1cblxuZnVuY3Rpb24gdmlzaXRNYXJrKG1hcmssIGJveCwgZmlsdGVyKSB7XG4gIC8vIHByb2Nlc3MgaWYgYm91bmRzIGludGVyc2VjdCBhbmQgaWZcbiAgLy8gKDEpIG1hcmsgaXMgYSBncm91cCBtYXJrIChzbyB3ZSBtdXN0IHJlY3Vyc2UpLCBvclxuICAvLyAoMikgbWFyayBpcyBpbnRlcmFjdGl2ZSBhbmQgcGFzc2VzIGZpbHRlclxuICByZXR1cm4gbWFyay5ib3VuZHMgJiYgYm94LmludGVyc2VjdHMobWFyay5ib3VuZHMpICYmIChtYXJrLm1hcmt0eXBlID09PSAnZ3JvdXAnIHx8IG1hcmsuaW50ZXJhY3RpdmUgIT09IGZhbHNlICYmICghZmlsdGVyIHx8IGZpbHRlcihtYXJrKSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RHcm91cChncm91cCwgYm94LCBmaWx0ZXIsIGhpdHMpIHtcbiAgLy8gdGVzdCBpbnRlcnNlY3QgYWdhaW5zdCBncm91cFxuICAvLyBza2lwIGdyb3VwcyBieSBkZWZhdWx0IHVubGVzcyBmaWx0ZXIgc2F5cyBvdGhlcndpc2VcbiAgaWYgKGZpbHRlciAmJiBmaWx0ZXIoZ3JvdXAubWFyaykgJiYgaW50ZXJzZWN0SXRlbShncm91cCwgYm94LCBNYXJrcy5ncm91cC5pc2VjdCkpIHtcbiAgICBoaXRzLnB1c2goZ3JvdXApO1xuICB9IC8vIHJlY3Vyc2l2ZWx5IHRlc3QgY2hpbGRyZW4gbWFya3NcbiAgLy8gdHJhbnNsYXRlIGJveCB0byBncm91cCBjb29yZGluYXRlIHNwYWNlXG5cblxuICBjb25zdCBtYXJrcyA9IGdyb3VwLml0ZW1zLFxuICAgICAgICBuID0gbWFya3MgJiYgbWFya3MubGVuZ3RoO1xuXG4gIGlmIChuKSB7XG4gICAgY29uc3QgeCA9IGdyb3VwLnggfHwgMCxcbiAgICAgICAgICB5ID0gZ3JvdXAueSB8fCAwO1xuICAgIGJveC50cmFuc2xhdGUoLXgsIC15KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpbnRlcnNlY3RNYXJrKG1hcmtzW2ldLCBib3gsIGZpbHRlciwgaGl0cyk7XG4gICAgfVxuXG4gICAgYm94LnRyYW5zbGF0ZSh4LCB5KTtcbiAgfVxuXG4gIHJldHVybiBoaXRzO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RJdGVtKGl0ZW0sIGJveCwgdGVzdCkge1xuICAvLyB0ZXN0IGJvdW5kcyBlbmNsb3N1cmUsIGJvdW5kcyBpbnRlcnNlY3Rpb24sIHRoZW4gZGV0YWlsZWQgdGVzdFxuICBjb25zdCBib3VuZHMgPSBpdGVtLmJvdW5kcztcbiAgcmV0dXJuIGJveC5lbmNsb3Nlcyhib3VuZHMpIHx8IGJveC5pbnRlcnNlY3RzKGJvdW5kcykgJiYgdGVzdChpdGVtLCBib3gpO1xufVxuXG5jb25zdCBjbGlwQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gYm91bmRDbGlwIChtYXJrKSB7XG4gIGNvbnN0IGNsaXAgPSBtYXJrLmNsaXA7XG5cbiAgaWYgKGlzRnVuY3Rpb24oY2xpcCkpIHtcbiAgICBjbGlwKGJvdW5kQ29udGV4dChjbGlwQm91bmRzLmNsZWFyKCkpKTtcbiAgfSBlbHNlIGlmIChjbGlwKSB7XG4gICAgY2xpcEJvdW5kcy5zZXQoMCwgMCwgbWFyay5ncm91cC53aWR0aCwgbWFyay5ncm91cC5oZWlnaHQpO1xuICB9IGVsc2UgcmV0dXJuO1xuXG4gIG1hcmsuYm91bmRzLmludGVyc2VjdChjbGlwQm91bmRzKTtcbn1cblxuY29uc3QgVE9MRVJBTkNFID0gMWUtOTtcbmZ1bmN0aW9uIHNjZW5lRXF1YWwoYSwgYiwga2V5KSB7XG4gIHJldHVybiBhID09PSBiID8gdHJ1ZSA6IGtleSA9PT0gJ3BhdGgnID8gcGF0aEVxdWFsKGEsIGIpIDogYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgPyArYSA9PT0gK2IgOiBpc051bWJlcihhKSAmJiBpc051bWJlcihiKSA/IE1hdGguYWJzKGEgLSBiKSA8PSBUT0xFUkFOQ0UgOiAhYSB8fCAhYiB8fCAhaXNPYmplY3QoYSkgJiYgIWlzT2JqZWN0KGIpID8gYSA9PSBiIDogb2JqZWN0RXF1YWwoYSwgYik7XG59XG5mdW5jdGlvbiBwYXRoRXF1YWwoYSwgYikge1xuICByZXR1cm4gc2NlbmVFcXVhbChwYXRoUGFyc2UoYSksIHBhdGhQYXJzZShiKSk7XG59XG5cbmZ1bmN0aW9uIG9iamVjdEVxdWFsKGEsIGIpIHtcbiAgdmFyIGthID0gT2JqZWN0LmtleXMoYSksXG4gICAgICBrYiA9IE9iamVjdC5rZXlzKGIpLFxuICAgICAga2V5LFxuICAgICAgaTtcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuXG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghc2NlbmVFcXVhbChhW2tleV0sIGJba2V5XSwga2V5KSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cblxuZnVuY3Rpb24gcmVzZXRTVkdEZWZJZHMoKSB7XG4gIHJlc2V0U1ZHQ2xpcElkKCk7XG4gIHJlc2V0U1ZHR3JhZGllbnRJZCgpO1xufVxuXG5leHBvcnQgeyBCb3VuZHMsIENhbnZhc0hhbmRsZXIsIENhbnZhc1JlbmRlcmVyLCBHcmFkaWVudCwgR3JvdXBJdGVtLCBIYW5kbGVyLCBJdGVtLCBNYXJrcywgUmVuZGVyVHlwZSwgUmVuZGVyZXIsIFJlc291cmNlTG9hZGVyLCBTVkdIYW5kbGVyLCBTVkdSZW5kZXJlciwgU1ZHU3RyaW5nUmVuZGVyZXIsIFNjZW5lZ3JhcGgsIGJvdW5kQ2xpcCwgYm91bmRDb250ZXh0LCBib3VuZEl0ZW0sIGJvdW5kTWFyaywgYm91bmRTdHJva2UsIGRvbUNoaWxkLCBkb21DbGVhciwgZG9tQ3JlYXRlLCBkb21GaW5kLCBmb250LCBmb250RmFtaWx5LCBmb250U2l6ZSwgaW50ZXJzZWN0LCBpbnRlcnNlY3RCb3hMaW5lLCBpbnRlcnNlY3RQYXRoLCBpbnRlcnNlY3RQb2ludCwgaW50ZXJzZWN0UnVsZSwgbGluZUhlaWdodCwgbWFya3VwLCBtdWx0aUxpbmVPZmZzZXQsIGN1cnZlcyBhcyBwYXRoQ3VydmVzLCBwYXRoRXF1YWwsIHBhdGhQYXJzZSwgdmdfcmVjdCBhcyBwYXRoUmVjdGFuZ2xlLCBwYXRoUmVuZGVyLCBzeW1ib2xzIGFzIHBhdGhTeW1ib2xzLCB2Z190cmFpbCBhcyBwYXRoVHJhaWwsIHBvaW50LCByZW5kZXJNb2R1bGUsIHJlc2V0U1ZHQ2xpcElkLCByZXNldFNWR0RlZklkcywgc2NlbmVFcXVhbCwgc2NlbmVGcm9tSlNPTiwgcGlja1Zpc2l0IGFzIHNjZW5lUGlja1Zpc2l0LCBzY2VuZVRvSlNPTiwgdmlzaXQgYXMgc2NlbmVWaXNpdCwgem9yZGVyIGFzIHNjZW5lWk9yZGVyLCBzZXJpYWxpemVYTUwsIHRleHRNZXRyaWNzIH07XG4iLCJpbXBvcnQgeyBmaWVsZCwgaXNEYXRlLCB0b051bWJlciwgaXNBcnJheSwgaW5yYW5nZSwgZXh0ZW5kLCBhcnJheSwgZXJyb3IsIHBlZWssIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IExpdGVyYWwgfSBmcm9tICd2ZWdhLWV4cHJlc3Npb24nO1xuXG5mdW5jdGlvbiBhc2NlbmRpbmcgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBiaXNlY3RvciAoZikge1xuICBsZXQgZGVsdGEgPSBmO1xuICBsZXQgY29tcGFyZSA9IGY7XG5cbiAgaWYgKGYubGVuZ3RoID09PSAxKSB7XG4gICAgZGVsdGEgPSAoZCwgeCkgPT4gZihkKSAtIHg7XG5cbiAgICBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlZnQoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcblxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBjb25zdCBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA8IDApIGxvID0gbWlkICsgMTtlbHNlIGhpID0gbWlkO1xuICAgIH1cblxuICAgIHJldHVybiBsbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJpZ2h0KGEsIHgsIGxvLCBoaSkge1xuICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgY29uc3QgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtlbHNlIGxvID0gbWlkICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG87XG4gIH1cblxuICBmdW5jdGlvbiBjZW50ZXIoYSwgeCwgbG8sIGhpKSB7XG4gICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICBjb25zdCBpID0gbGVmdChhLCB4LCBsbywgaGkgLSAxKTtcbiAgICByZXR1cm4gaSA+IGxvICYmIGRlbHRhKGFbaSAtIDFdLCB4KSA+IC1kZWx0YShhW2ldLCB4KSA/IGkgLSAxIDogaTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbGVmdCxcbiAgICBjZW50ZXIsXG4gICAgcmlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiAoZCwgeCkgPT4gYXNjZW5kaW5nKGYoZCksIHgpO1xufVxuXG5jb25zdCBJbnRlcnNlY3QgPSAnaW50ZXJzZWN0JztcbmNvbnN0IFVuaW9uID0gJ3VuaW9uJztcbmNvbnN0IFZsTXVsdGkgPSAndmxNdWx0aSc7XG5jb25zdCBWbFBvaW50ID0gJ3ZsUG9pbnQnO1xuY29uc3QgT3IgPSAnb3InO1xuY29uc3QgQW5kID0gJ2FuZCc7XG5cbmNvbnN0IFNFTEVDVElPTl9JRCA9ICdfdmdzaWRfJyxcbiAgICAgIFRZUEVfRU5VTSA9ICdFJyxcbiAgICAgIFRZUEVfUkFOR0VfSU5DID0gJ1InLFxuICAgICAgVFlQRV9SQU5HRV9FWEMgPSAnUi1FJyxcbiAgICAgIFRZUEVfUkFOR0VfTEUgPSAnUi1MRScsXG4gICAgICBUWVBFX1JBTkdFX1JFID0gJ1ItUkUnLFxuICAgICAgVU5JVF9JTkRFWCA9ICdpbmRleDp1bml0JzsgLy8gVE9ETzogcmV2aXNpdCBkYXRlIGNvZXJjaW9uP1xuXG5mdW5jdGlvbiB0ZXN0UG9pbnQoZGF0dW0sIGVudHJ5KSB7XG4gIHZhciBmaWVsZHMgPSBlbnRyeS5maWVsZHMsXG4gICAgICB2YWx1ZXMgPSBlbnRyeS52YWx1ZXMsXG4gICAgICBuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgZHZhbCxcbiAgICAgIGY7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBmID0gZmllbGRzW2ldO1xuICAgIGYuZ2V0dGVyID0gZmllbGQuZ2V0dGVyIHx8IGZpZWxkKGYuZmllbGQpO1xuICAgIGR2YWwgPSBmLmdldHRlcihkYXR1bSk7XG4gICAgaWYgKGlzRGF0ZShkdmFsKSkgZHZhbCA9IHRvTnVtYmVyKGR2YWwpO1xuICAgIGlmIChpc0RhdGUodmFsdWVzW2ldKSkgdmFsdWVzW2ldID0gdG9OdW1iZXIodmFsdWVzW2ldKTtcbiAgICBpZiAoaXNEYXRlKHZhbHVlc1tpXVswXSkpIHZhbHVlc1tpXSA9IHZhbHVlc1tpXS5tYXAodG9OdW1iZXIpO1xuXG4gICAgaWYgKGYudHlwZSA9PT0gVFlQRV9FTlVNKSB7XG4gICAgICAvLyBFbnVtZXJhdGVkIGZpZWxkcyBjYW4gZWl0aGVyIHNwZWNpZnkgaW5kaXZpZHVhbCB2YWx1ZXMgKHNpbmdsZS9tdWx0aSBzZWxlY3Rpb25zKVxuICAgICAgLy8gb3IgYW4gYXJyYXkgb2YgdmFsdWVzIChpbnRlcnZhbCBzZWxlY3Rpb25zKS5cbiAgICAgIGlmIChpc0FycmF5KHZhbHVlc1tpXSkgPyB2YWx1ZXNbaV0uaW5kZXhPZihkdmFsKSA8IDAgOiBkdmFsICE9PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0lOQykge1xuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfUkUpIHtcbiAgICAgICAgLy8gRGlzY3JldGUgc2VsZWN0aW9uIG9mIGJpbnMgdGVzdCB3aXRoaW4gdGhlIHJhbmdlIFtiaW5fc3RhcnQsIGJpbl9lbmQpLlxuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldLCB0cnVlLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0VYQykge1xuICAgICAgICAvLyAnUi1FJy8nUi1MRScgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcy5cbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIGZhbHNlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfTEUpIHtcbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIHRydWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgdHVwbGUgaXMgY29udGFpbmVkIHdpdGhpbiBhbiBpbnRlcmFjdGl2ZSBzZWxlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhIHNldCByZXByZXNlbnRpbmcgdGhlIHNlbGVjdGlvbi5cbiAqICBUdXBsZXMgaW4gdGhlIGRhdGFzZXQgYXJlIG9mIHRoZSBmb3JtXG4gKiAge3VuaXQ6IHN0cmluZywgZmllbGRzOiBhcnJheTxmaWVsZGRlZj4sIHZhbHVlczogYXJyYXk8Kj59LlxuICogIEZpZWxkZGVmIGlzIG9mIHRoZSBmb3JtXG4gKiAge2ZpZWxkOiBzdHJpbmcsIGNoYW5uZWw6IHN0cmluZywgdHlwZTogJ0UnIHwgJ1InfSB3aGVyZVxuICogICd0eXBlJyBpZGVudGlmaWVzIHdoZXRoZXIgdHVwbGVzIGluIHRoZSBkYXRhc2V0IGVudW1lcmF0ZVxuICogIHZhbHVlcyBmb3IgdGhlIGZpZWxkLCBvciBzcGVjaWZ5IGEgY29udGludW91cyByYW5nZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXR1bSAtIFRoZSB0dXBsZSB0byB0ZXN0IGZvciBpbmNsdXNpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3AgLSBUaGUgc2V0IG9wZXJhdGlvbiBmb3IgY29tYmluaW5nIHNlbGVjdGlvbnMuXG4gKiAgIE9uZSBvZiAnaW50ZXJzZWN0JyBvciAndW5pb24nIChkZWZhdWx0KS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZGF0dW0gaXMgaW4gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5cblxuZnVuY3Rpb24gc2VsZWN0aW9uVGVzdChuYW1lLCBkYXR1bSwgb3ApIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICAgIGVudHJpZXMgPSBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXSxcbiAgICAgIHVuaXRJZHggPSBkYXRhID8gZGF0YVtVTklUX0lOREVYXSAmJiBkYXRhW1VOSVRfSU5ERVhdLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJzZWN0ID0gb3AgPT09IEludGVyc2VjdCxcbiAgICAgIG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICAgIGkgPSAwLFxuICAgICAgZW50cnksXG4gICAgICBtaXNzLFxuICAgICAgY291bnQsXG4gICAgICB1bml0LFxuICAgICAgYjtcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGVudHJ5ID0gZW50cmllc1tpXTtcblxuICAgIGlmICh1bml0SWR4ICYmIGludGVyc2VjdCkge1xuICAgICAgLy8gbXVsdGkgc2VsZWN0aW9ucyB1bmlvbiB3aXRoaW4gdGhlIHNhbWUgdW5pdCBhbmQgaW50ZXJzZWN0IGFjcm9zcyB1bml0cy5cbiAgICAgIG1pc3MgPSBtaXNzIHx8IHt9O1xuICAgICAgY291bnQgPSBtaXNzW3VuaXQgPSBlbnRyeS51bml0XSB8fCAwOyAvLyBpZiB3ZSd2ZSBhbHJlYWR5IG1hdGNoZWQgdGhpcyB1bml0LCBza2lwLlxuXG4gICAgICBpZiAoY291bnQgPT09IC0xKSBjb250aW51ZTtcbiAgICAgIGIgPSB0ZXN0UG9pbnQoZGF0dW0sIGVudHJ5KTtcbiAgICAgIG1pc3NbdW5pdF0gPSBiID8gLTEgOiArK2NvdW50OyAvLyBpZiB3ZSBtYXRjaCBhbmQgdGhlcmUgYXJlIG5vIG90aGVyIHVuaXRzIHJldHVybiB0cnVlXG4gICAgICAvLyBpZiB3ZSd2ZSBtaXNzZWQgYWdhaW5zdCBhbGwgdHVwbGVzIGluIHRoaXMgdW5pdCByZXR1cm4gZmFsc2VcblxuICAgICAgaWYgKGIgJiYgdW5pdElkeC5zaXplID09PSAxKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICghYiAmJiBjb3VudCA9PT0gdW5pdElkeC5nZXQodW5pdCkuY291bnQpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IHRlc3RQb2ludChkYXR1bSwgZW50cnkpOyAvLyBpZiB3ZSBmaW5kIGEgbWlzcyBhbmQgd2UgZG8gcmVxdWlyZSBpbnRlcnNlY3Rpb24gcmV0dXJuIGZhbHNlXG4gICAgICAvLyBpZiB3ZSBmaW5kIGEgbWF0Y2ggYW5kIHdlIGRvbid0IHJlcXVpcmUgaW50ZXJzZWN0aW9uIHJldHVybiB0cnVlXG5cbiAgICAgIGlmIChpbnRlcnNlY3QgXiBiKSByZXR1cm4gYjtcbiAgICB9XG4gIH0gLy8gaWYgaW50ZXJzZWN0aW5nIGFuZCB3ZSBtYWRlIGl0IGhlcmUsIHRoZW4gd2Ugc2F3IG5vIG1pc3Nlc1xuICAvLyBpZiBub3QgaW50ZXJzZWN0aW5nLCB0aGVuIHdlIHNhdyBubyBtYXRjaGVzXG4gIC8vIGlmIG5vIGFjdGl2ZSBzZWxlY3Rpb25zLCByZXR1cm4gZmFsc2VcblxuXG4gIHJldHVybiBuICYmIGludGVyc2VjdDtcbn1cbmNvbnN0IHNlbGVjdGlvbklkID0gZmllbGQoU0VMRUNUSU9OX0lEKSxcbiAgICAgIGJpc2VjdCA9IGJpc2VjdG9yKHNlbGVjdGlvbklkKSxcbiAgICAgIGJpc2VjdExlZnQgPSBiaXNlY3QubGVmdCxcbiAgICAgIGJpc2VjdFJpZ2h0ID0gYmlzZWN0LnJpZ2h0O1xuZnVuY3Rpb24gc2VsZWN0aW9uSWRUZXN0KG5hbWUsIGRhdHVtLCBvcCkge1xuICBjb25zdCBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgICAgIGVudHJpZXMgPSBkYXRhID8gZGF0YS52YWx1ZXMudmFsdWUgOiBbXSxcbiAgICAgICAgdW5pdElkeCA9IGRhdGEgPyBkYXRhW1VOSVRfSU5ERVhdICYmIGRhdGFbVU5JVF9JTkRFWF0udmFsdWUgOiB1bmRlZmluZWQsXG4gICAgICAgIGludGVyc2VjdCA9IG9wID09PSBJbnRlcnNlY3QsXG4gICAgICAgIHZhbHVlID0gc2VsZWN0aW9uSWQoZGF0dW0pLFxuICAgICAgICBpbmRleCA9IGJpc2VjdExlZnQoZW50cmllcywgdmFsdWUpO1xuICBpZiAoaW5kZXggPT09IGVudHJpZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGlmIChzZWxlY3Rpb25JZChlbnRyaWVzW2luZGV4XSkgIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHVuaXRJZHggJiYgaW50ZXJzZWN0KSB7XG4gICAgaWYgKHVuaXRJZHguc2l6ZSA9PT0gMSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGJpc2VjdFJpZ2h0KGVudHJpZXMsIHZhbHVlKSAtIGluZGV4IDwgdW5pdElkeC5zaXplKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNYXBzIGFuIGFycmF5IG9mIHNjZW5lIGdyYXBoIGl0ZW1zIHRvIGFuIGFycmF5IG9mIHNlbGVjdGlvbiB0dXBsZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCByZXByZXNlbnRpbmcgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0ICAtIFRoZSBuYW1lIG9mIHRoZSB1bml0IHZpZXcuXG4gKlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzZWxlY3Rpb24gZW50cmllcyBmb3IgdGhlIGdpdmVuIHVuaXQuXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uVHVwbGVzKGFycmF5LCBiYXNlKSB7XG4gIHJldHVybiBhcnJheS5tYXAoeCA9PiBleHRlbmQoe1xuICAgIHZhbHVlczogYmFzZS5maWVsZHMubWFwKGYgPT4gKGYuZ2V0dGVyIHx8IChmLmdldHRlciA9IGZpZWxkKGYuZmllbGQpKSkoeC5kYXR1bSkpXG4gIH0sIGJhc2UpKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBzZWxlY3Rpb24gZm9yIHVzZSBhcyBhIHNjYWxlIGRvbWFpbiBvciByZWFkcyB2aWEgdGhlIEFQSS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3A9J3VuaW9uJ10gLSBUaGUgc2V0IG9wZXJhdGlvbiBmb3IgY29tYmluaW5nIHNlbGVjdGlvbnMuXG4gKiAgICAgICAgICAgICAgICAgT25lIG9mICdpbnRlcnNlY3QnIG9yICd1bmlvbicgKGRlZmF1bHQpLlxuICogQHBhcmFtIHtib29sZWFufSBpc011bHRpIC0gSWRlbnRpZmllcyBhIFwibXVsdGlcIiBzZWxlY3Rpb24gdG8gcGVyZm9ybSBtb3JlXG4gKiAgICAgICAgICAgICAgICAgZXhwZW5zaXZlIHJlc29sdXRpb24gY29tcHV0YXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZsNSAtIFdpdGggVmVnYS1MaXRlIHY1LCBcIm11bHRpXCIgc2VsZWN0aW9ucyBhcmUgbm93IGNhbGxlZCBcInBvaW50XCJcbiAqICAgICAgICAgICAgICAgICBzZWxlY3Rpb25zLCBhbmQgdGh1cyB0aGUgcmVzb2x2ZWQgdHVwbGUgc2hvdWxkIHJlZmxlY3QgdGhpcyBuYW1lLlxuICogICAgICAgICAgICAgICAgIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB1cyB0byByZWZsZWN0IHRoaXMgY2hhbmdlIHdpdGhvdXQgdHJpZ2dlcmluZ1xuICogICAgICAgICAgICAgICAgIGEgbWFqb3IgdmVyc2lvbiBidW1wIGZvciBWZWdhLlxuICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IG9mIHNlbGVjdGVkIGZpZWxkcyBhbmQgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdGlvblJlc29sdmUobmFtZSwgb3AsIGlzTXVsdGksIHZsNSkge1xuICB2YXIgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgICAgZW50cmllcyA9IGRhdGEgPyBkYXRhLnZhbHVlcy52YWx1ZSA6IFtdLFxuICAgICAgcmVzb2x2ZWQgPSB7fSxcbiAgICAgIG11bHRpUmVzID0ge30sXG4gICAgICB0eXBlcyA9IHt9LFxuICAgICAgZW50cnksXG4gICAgICBmaWVsZHMsXG4gICAgICB2YWx1ZXMsXG4gICAgICB1bml0LFxuICAgICAgZmllbGQsXG4gICAgICByZXMsXG4gICAgICByZXNVbml0LFxuICAgICAgdHlwZSxcbiAgICAgIHVuaW9uLFxuICAgICAgbiA9IGVudHJpZXMubGVuZ3RoLFxuICAgICAgaSA9IDAsXG4gICAgICBqLFxuICAgICAgbTsgLy8gRmlyc3QgdW5pb24gYWxsIGVudHJpZXMgd2l0aGluIHRoZSBzYW1lIHVuaXQuXG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBlbnRyeSA9IGVudHJpZXNbaV07XG4gICAgdW5pdCA9IGVudHJ5LnVuaXQ7XG4gICAgZmllbGRzID0gZW50cnkuZmllbGRzO1xuICAgIHZhbHVlcyA9IGVudHJ5LnZhbHVlcztcblxuICAgIGZvciAoaiA9IDAsIG0gPSBmaWVsZHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgIHJlcyA9IHJlc29sdmVkW2ZpZWxkLmZpZWxkXSB8fCAocmVzb2x2ZWRbZmllbGQuZmllbGRdID0ge30pO1xuICAgICAgcmVzVW5pdCA9IHJlc1t1bml0XSB8fCAocmVzW3VuaXRdID0gW10pO1xuICAgICAgdHlwZXNbZmllbGQuZmllbGRdID0gdHlwZSA9IGZpZWxkLnR5cGUuY2hhckF0KDApO1xuICAgICAgdW5pb24gPSBvcHNbdHlwZSArICdfdW5pb24nXTtcbiAgICAgIHJlc1t1bml0XSA9IHVuaW9uKHJlc1VuaXQsIGFycmF5KHZhbHVlc1tqXSkpO1xuICAgIH0gLy8gSWYgdGhlIHNhbWUgbXVsdGktc2VsZWN0aW9uIGlzIHJlcGVhdGVkIG92ZXIgdmlld3MgYW5kIHByb2plY3RlZCBvdmVyXG4gICAgLy8gYW4gZW5jb2RpbmcsIGl0IG1heSBvcGVyYXRlIG92ZXIgZGlmZmVyZW50IGZpZWxkcyBtYWtpbmcgaXQgZXNwZWNpYWxseVxuICAgIC8vIHRyaWNreSB0byByZWxpYWJseSByZXNvbHZlIGl0LiBBdCBiZXN0LCB3ZSBjYW4gZGUtZHVwZSBpZGVudGljYWwgZW50cmllc1xuICAgIC8vIGJ1dCBkb2luZyBzbyBtYXkgYmUgbW9yZSBjb21wdXRhdGlvbmFsbHkgZXhwZW5zaXZlIHRoYW4gaXQgaXMgd29ydGguXG4gICAgLy8gSW5zdGVhZCwgZm9yIG5vdywgd2Ugc2ltcGx5IHRyYW5zZm9ybSBvdXIgc3RvcmUgcmVwcmVzZW50YXRpb24gaW50b1xuICAgIC8vIGEgbW9yZSBodW1hbi1mcmllbmRseSBvbmUuXG5cblxuICAgIGlmIChpc011bHRpKSB7XG4gICAgICByZXNVbml0ID0gbXVsdGlSZXNbdW5pdF0gfHwgKG11bHRpUmVzW3VuaXRdID0gW10pO1xuICAgICAgcmVzVW5pdC5wdXNoKGFycmF5KHZhbHVlcykucmVkdWNlKChvYmosIGN1cnIsIGopID0+IChvYmpbZmllbGRzW2pdLmZpZWxkXSA9IGN1cnIsIG9iaiksIHt9KSk7XG4gICAgfVxuICB9IC8vIFRoZW4gcmVzb2x2ZSBmaWVsZHMgYWNyb3NzIHVuaXRzIGFzIHBlciB0aGUgb3AuXG5cblxuICBvcCA9IG9wIHx8IFVuaW9uO1xuICBPYmplY3Qua2V5cyhyZXNvbHZlZCkuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgcmVzb2x2ZWRbZmllbGRdID0gT2JqZWN0LmtleXMocmVzb2x2ZWRbZmllbGRdKS5tYXAodW5pdCA9PiByZXNvbHZlZFtmaWVsZF1bdW5pdF0pLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgPT09IHVuZGVmaW5lZCA/IGN1cnIgOiBvcHNbdHlwZXNbZmllbGRdICsgJ18nICsgb3BdKGFjYywgY3VycikpO1xuICB9KTtcbiAgZW50cmllcyA9IE9iamVjdC5rZXlzKG11bHRpUmVzKTtcblxuICBpZiAoaXNNdWx0aSAmJiBlbnRyaWVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGtleSA9IHZsNSA/IFZsUG9pbnQgOiBWbE11bHRpO1xuICAgIHJlc29sdmVkW2tleV0gPSBvcCA9PT0gVW5pb24gPyB7XG4gICAgICBbT3JdOiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrKSA9PiAoYWNjLnB1c2goLi4ubXVsdGlSZXNba10pLCBhY2MpLCBbXSlcbiAgICB9IDoge1xuICAgICAgW0FuZF06IGVudHJpZXMubWFwKGsgPT4gKHtcbiAgICAgICAgW09yXTogbXVsdGlSZXNba11cbiAgICAgIH0pKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG52YXIgb3BzID0ge1xuICBFX3VuaW9uOiBmdW5jdGlvbiAoYmFzZSwgdmFsdWUpIHtcbiAgICBpZiAoIWJhc2UubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIGlmIChiYXNlLmluZGV4T2YodmFsdWVbaV0pIDwgMCkgYmFzZS5wdXNoKHZhbHVlW2ldKTtcblxuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICBFX2ludGVyc2VjdDogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuICFiYXNlLmxlbmd0aCA/IHZhbHVlIDogYmFzZS5maWx0ZXIodiA9PiB2YWx1ZS5pbmRleE9mKHYpID49IDApO1xuICB9LFxuICBSX3VuaW9uOiBmdW5jdGlvbiAoYmFzZSwgdmFsdWUpIHtcbiAgICB2YXIgbG8gPSB0b051bWJlcih2YWx1ZVswXSksXG4gICAgICAgIGhpID0gdG9OdW1iZXIodmFsdWVbMV0pO1xuXG4gICAgaWYgKGxvID4gaGkpIHtcbiAgICAgIGxvID0gdmFsdWVbMV07XG4gICAgICBoaSA9IHZhbHVlWzBdO1xuICAgIH1cblxuICAgIGlmICghYmFzZS5sZW5ndGgpIHJldHVybiBbbG8sIGhpXTtcbiAgICBpZiAoYmFzZVswXSA+IGxvKSBiYXNlWzBdID0gbG87XG4gICAgaWYgKGJhc2VbMV0gPCBoaSkgYmFzZVsxXSA9IGhpO1xuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICBSX2ludGVyc2VjdDogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgdmFyIGxvID0gdG9OdW1iZXIodmFsdWVbMF0pLFxuICAgICAgICBoaSA9IHRvTnVtYmVyKHZhbHVlWzFdKTtcblxuICAgIGlmIChsbyA+IGhpKSB7XG4gICAgICBsbyA9IHZhbHVlWzFdO1xuICAgICAgaGkgPSB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAoIWJhc2UubGVuZ3RoKSByZXR1cm4gW2xvLCBoaV07XG5cbiAgICBpZiAoaGkgPCBiYXNlWzBdIHx8IGJhc2VbMV0gPCBsbykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYmFzZVswXSA8IGxvKSBiYXNlWzBdID0gbG87XG4gICAgICBpZiAoYmFzZVsxXSA+IGhpKSBiYXNlWzFdID0gaGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn07XG5cbmNvbnN0IERhdGFQcmVmaXggPSAnOicsXG4gICAgICBJbmRleFByZWZpeCA9ICdAJztcbmZ1bmN0aW9uIHNlbGVjdGlvblZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc2VsZWN0aW9uIGZ1bmN0aW9ucyBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgICAgICBvcCA9IGFyZ3MubGVuZ3RoID49IDIgJiYgcGVlayhhcmdzKS52YWx1ZSxcbiAgICAgICAgZmllbGQgPSAndW5pdCcsXG4gICAgICAgIGluZGV4TmFtZSA9IEluZGV4UHJlZml4ICsgZmllbGQsXG4gICAgICAgIGRhdGFOYW1lID0gRGF0YVByZWZpeCArIGRhdGE7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuICBpZiAob3AgPT09IEludGVyc2VjdCAmJiAhaGFzT3duUHJvcGVydHkocGFyYW1zLCBpbmRleE5hbWUpKSB7XG4gICAgcGFyYW1zW2luZGV4TmFtZV0gPSBzY29wZS5nZXREYXRhKGRhdGEpLmluZGF0YVJlZihzY29wZSwgZmllbGQpO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcblxuXG4gIGlmICghaGFzT3duUHJvcGVydHkocGFyYW1zLCBkYXRhTmFtZSkpIHtcbiAgICBwYXJhbXNbZGF0YU5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS50dXBsZXNSZWYoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBzZWxlY3Rpb25JZFRlc3QsIHNlbGVjdGlvblJlc29sdmUsIHNlbGVjdGlvblRlc3QsIHNlbGVjdGlvblR1cGxlcywgc2VsZWN0aW9uVmlzaXRvciB9O1xuIiwiaW1wb3J0IHsgYXNjZW5kaW5nLCBxdWFudGlsZVNvcnRlZCwgZGV2aWF0aW9uLCBxdWFudGlsZSwgbWVkaWFuIH0gZnJvbSAnZDMtYXJyYXknO1xuXG5mdW5jdGlvbiogbnVtYmVycyAodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcblxuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgdmFsdWUgPSB2YWx1ZW9mKHZhbHVlLCArK2luZGV4LCB2YWx1ZXMpO1xuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gJycgJiYgKHZhbHVlID0gK3ZhbHVlKSA+PSB2YWx1ZSkge1xuICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVhbnRpbGVzIChhcnJheSwgcCwgZikge1xuICBjb25zdCB2YWx1ZXMgPSBGbG9hdDY0QXJyYXkuZnJvbShudW1iZXJzKGFycmF5LCBmKSk7IC8vIGRvbid0IGRlcGVuZCBvbiByZXR1cm4gdmFsdWUgZnJvbSB0eXBlZCBhcnJheSBzb3J0IGNhbGxcbiAgLy8gcHJvdGVjdHMgYWdhaW5zdCB1bmRlZmluZWQgc29ydCByZXN1bHRzIGluIFNhZmFyaSAodmVnYS92ZWdhLWxpdGUjNDk2NClcblxuICB2YWx1ZXMuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gcC5tYXAoXyA9PiBxdWFudGlsZVNvcnRlZCh2YWx1ZXMsIF8pKTtcbn1cblxuZnVuY3Rpb24gcXVhcnRpbGVzIChhcnJheSwgZikge1xuICByZXR1cm4gcXVhbnRpbGVzKGFycmF5LCBbMC4yNSwgMC41MCwgMC43NV0sIGYpO1xufVxuXG4vLyBUaGVvcnksIFByYWN0aWNlLCBhbmQgVmlzdWFsaXphdGlvbi4gV2lsZXkuXG5cbmZ1bmN0aW9uIGVzdGltYXRlQmFuZHdpZHRoIChhcnJheSwgZikge1xuICBjb25zdCBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBkID0gZGV2aWF0aW9uKGFycmF5LCBmKSxcbiAgICAgICAgcSA9IHF1YXJ0aWxlcyhhcnJheSwgZiksXG4gICAgICAgIGggPSAocVsyXSAtIHFbMF0pIC8gMS4zNCxcbiAgICAgICAgdiA9IE1hdGgubWluKGQsIGgpIHx8IGQgfHwgTWF0aC5hYnMocVswXSkgfHwgMTtcbiAgcmV0dXJuIDEuMDYgKiB2ICogTWF0aC5wb3cobiwgLTAuMik7XG59XG5cbmZ1bmN0aW9uIGJpbiAoXykge1xuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgY29uc3QgbWF4YiA9IF8ubWF4YmlucyB8fCAyMCxcbiAgICAgICAgYmFzZSA9IF8uYmFzZSB8fCAxMCxcbiAgICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgICBkaXYgPSBfLmRpdmlkZSB8fCBbNSwgMl07XG4gIGxldCBtaW4gPSBfLmV4dGVudFswXSxcbiAgICAgIG1heCA9IF8uZXh0ZW50WzFdLFxuICAgICAgc3RlcCxcbiAgICAgIGxldmVsLFxuICAgICAgbWluc3RlcCxcbiAgICAgIHYsXG4gICAgICBpLFxuICAgICAgbjtcbiAgY29uc3Qgc3BhbiA9IF8uc3BhbiB8fCBtYXggLSBtaW4gfHwgTWF0aC5hYnMobWluKSB8fCAxO1xuXG4gIGlmIChfLnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gXy5zdGVwO1xuICB9IGVsc2UgaWYgKF8uc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHYgPSBzcGFuIC8gbWF4YjtcblxuICAgIGZvciAoaSA9IDAsIG4gPSBfLnN0ZXBzLmxlbmd0aDsgaSA8IG4gJiYgXy5zdGVwc1tpXSA8IHY7ICsraSk7XG5cbiAgICBzdGVwID0gXy5zdGVwc1tNYXRoLm1heCgwLCBpIC0gMSldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IF8ubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChtaW5zdGVwLCBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbCkpOyAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuXG4gICAgd2hpbGUgKE1hdGguY2VpbChzcGFuIC8gc3RlcCkgPiBtYXhiKSB7XG4gICAgICBzdGVwICo9IGJhc2U7XG4gICAgfSAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuXG5cbiAgICBmb3IgKGkgPSAwLCBuID0gZGl2Lmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfSAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuXG5cbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBjb25zdCBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDEsXG4gICAgICAgIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcblxuICBpZiAoXy5uaWNlIHx8IF8ubmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwO1xuICAgIG1pbiA9IG1pbiA8IHYgPyB2IC0gc3RlcCA6IHY7XG4gICAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiBtYXggPT09IG1pbiA/IG1pbiArIHN0ZXAgOiBtYXgsXG4gICAgc3RlcDogc3RlcFxuICB9O1xufVxuXG52YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5mdW5jdGlvbiBzZXRSYW5kb20ocikge1xuICByYW5kb20gPSByO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBDSSAoYXJyYXksIHNhbXBsZXMsIGFscGhhLCBmKSB7XG4gIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbiAgY29uc3QgdmFsdWVzID0gRmxvYXQ2NEFycmF5LmZyb20obnVtYmVycyhhcnJheSwgZikpLFxuICAgICAgICBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgbSA9IHNhbXBsZXM7XG4gIGxldCBhLCBpLCBqLCBtdTtcblxuICBmb3IgKGogPSAwLCBtdSA9IEFycmF5KG0pOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yIChhID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGEgKz0gdmFsdWVzW35+KHJhbmRvbSgpICogbildO1xuICAgIH1cblxuICAgIG11W2pdID0gYSAvIG47XG4gIH1cblxuICBtdS5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBbcXVhbnRpbGUobXUsIGFscGhhIC8gMiksIHF1YW50aWxlKG11LCAxIC0gYWxwaGEgLyAyKV07XG59XG5cbi8vIERvdCBkZW5zaXR5IGJpbm5pbmcgZm9yIGRvdCBwbG90IGNvbnN0cnVjdGlvbi5cbi8vIEJhc2VkIG9uIExlbGFuZCBXaWxraW5zb24sIERvdCBQbG90cywgVGhlIEFtZXJpY2FuIFN0YXRpc3RpY2lhbiwgMTk5OS5cbi8vIGh0dHBzOi8vd3d3LmNzLnVpYy5lZHUvfndpbGtpbnNvbi9QdWJsaWNhdGlvbnMvZG90cGxvdHMucGRmXG5mdW5jdGlvbiBkb3RiaW4gKGFycmF5LCBzdGVwLCBzbW9vdGgsIGYpIHtcbiAgZiA9IGYgfHwgKF8gPT4gXyk7XG5cbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgdiA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gIGxldCBpID0gMCxcbiAgICAgIGogPSAxLFxuICAgICAgYSA9IGYoYXJyYXlbMF0pLFxuICAgICAgYiA9IGEsXG4gICAgICB3ID0gYSArIHN0ZXAsXG4gICAgICB4O1xuXG4gIGZvciAoOyBqIDwgbjsgKytqKSB7XG4gICAgeCA9IGYoYXJyYXlbal0pO1xuXG4gICAgaWYgKHggPj0gdykge1xuICAgICAgYiA9IChhICsgYikgLyAyO1xuXG4gICAgICBmb3IgKDsgaSA8IGo7ICsraSkgdltpXSA9IGI7XG5cbiAgICAgIHcgPSB4ICsgc3RlcDtcbiAgICAgIGEgPSB4O1xuICAgIH1cblxuICAgIGIgPSB4O1xuICB9XG5cbiAgYiA9IChhICsgYikgLyAyO1xuXG4gIGZvciAoOyBpIDwgajsgKytpKSB2W2ldID0gYjtcblxuICByZXR1cm4gc21vb3RoID8gc21vb3RoaW5nKHYsIHN0ZXAgKyBzdGVwIC8gNCkgOiB2O1xufSAvLyBwZXJmb3JtIHNtb290aGluZyB0byByZWR1Y2UgdmFyaWFuY2Vcbi8vIHN3YXAgcG9pbnRzIGJldHdlZW4gXCJhZGphY2VudFwiIHN0YWNrc1xuLy8gV2lsa2luc29uIGRlZmluZXMgYWRqYWNlbnQgYXMgd2l0aGluIHN0ZXAvNCB1bml0c1xuXG5mdW5jdGlvbiBzbW9vdGhpbmcodiwgdGhyZXNoKSB7XG4gIGNvbnN0IG4gPSB2Lmxlbmd0aDtcbiAgbGV0IGEgPSAwLFxuICAgICAgYiA9IDEsXG4gICAgICBjLFxuICAgICAgZDsgLy8gZ2V0IGxlZnQgc3RhY2tcblxuICB3aGlsZSAodlthXSA9PT0gdltiXSkgKytiO1xuXG4gIHdoaWxlIChiIDwgbikge1xuICAgIC8vIGdldCByaWdodCBzdGFja1xuICAgIGMgPSBiICsgMTtcblxuICAgIHdoaWxlICh2W2JdID09PSB2W2NdKSArK2M7IC8vIGFyZSBzdGFja3MgYWRqYWNlbnQ/XG4gICAgLy8gaWYgc28sIGNvbXBhcmUgc2l6ZXMgYW5kIHN3YXAgYXMgbmVlZGVkXG5cblxuICAgIGlmICh2W2JdIC0gdltiIC0gMV0gPCB0aHJlc2gpIHtcbiAgICAgIGQgPSBiICsgKGEgKyBjIC0gYiAtIGIgPj4gMSk7XG5cbiAgICAgIHdoaWxlIChkIDwgYikgdltkKytdID0gdltiXTtcblxuICAgICAgd2hpbGUgKGQgPiBiKSB2W2QtLV0gPSB2W2FdO1xuICAgIH0gLy8gdXBkYXRlIGxlZnQgc3RhY2sgaW5kaWNlc1xuXG5cbiAgICBhID0gYjtcbiAgICBiID0gYztcbiAgfVxuXG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBsY2cgKHNlZWQpIHtcbiAgLy8gUmFuZG9tIG51bWJlcnMgdXNpbmcgYSBMaW5lYXIgQ29uZ3J1ZW50aWFsIEdlbmVyYXRvciB3aXRoIHNlZWQgdmFsdWVcbiAgLy8gVXNlcyBnbGliYyB2YWx1ZXMgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNlZWQgPSAoMTEwMzUxNTI0NSAqIHNlZWQgKyAxMjM0NSkgJSAyMTQ3NDgzNjQ3O1xuICAgIHJldHVybiBzZWVkIC8gMjE0NzQ4MzY0NztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZWdlciAobWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cblxuICBsZXQgYSwgYiwgZDtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBtaW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYSA9IF8gfHwgMDtcbiAgICAgICAgZCA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBtYXgoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYiA9IF8gfHwgMDtcbiAgICAgICAgZCA9IGIgLSBhO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzYW1wbGUoKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIHJhbmRvbSgpKTtcbiAgICB9LFxuXG4gICAgcGRmKHgpIHtcbiAgICAgIHJldHVybiB4ID09PSBNYXRoLmZsb29yKHgpICYmIHggPj0gYSAmJiB4IDwgYiA/IDEgLyBkIDogMDtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGNvbnN0IHYgPSBNYXRoLmZsb29yKHgpO1xuICAgICAgcmV0dXJuIHYgPCBhID8gMCA6IHYgPj0gYiA/IDEgOiAodiAtIGEgKyAxKSAvIGQ7XG4gICAgfSxcblxuICAgIGljZGYocCkge1xuICAgICAgcmV0dXJuIHAgPj0gMCAmJiBwIDw9IDEgPyBhIC0gMSArIE1hdGguZmxvb3IocCAqIGQpIDogTmFOO1xuICAgIH1cblxuICB9O1xuICByZXR1cm4gZGlzdC5taW4obWluKS5tYXgobWF4KTtcbn1cblxuY29uc3QgU1FSVDJQSSA9IE1hdGguc3FydCgyICogTWF0aC5QSSk7XG5jb25zdCBTUVJUMiA9IE1hdGguU1FSVDI7XG5cbmxldCBuZXh0U2FtcGxlID0gTmFOO1xuZnVuY3Rpb24gc2FtcGxlTm9ybWFsKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgbGV0IHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICByZHMsXG4gICAgICBjO1xuXG4gIGlmIChuZXh0U2FtcGxlID09PSBuZXh0U2FtcGxlKSB7XG4gICAgeCA9IG5leHRTYW1wbGU7XG4gICAgbmV4dFNhbXBsZSA9IE5hTjtcbiAgfSBlbHNlIHtcbiAgICBkbyB7XG4gICAgICB4ID0gcmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgIHkgPSByYW5kb20oKSAqIDIgLSAxO1xuICAgICAgcmRzID0geCAqIHggKyB5ICogeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG5cbiAgICBjID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocmRzKSAvIHJkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG5cbiAgICB4ICo9IGM7XG4gICAgbmV4dFNhbXBsZSA9IHkgKiBjO1xuICB9XG5cbiAgcmV0dXJuIG1lYW4gKyB4ICogc3RkZXY7XG59XG5mdW5jdGlvbiBkZW5zaXR5Tm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIGNvbnN0IHogPSAodmFsdWUgLSAobWVhbiB8fCAwKSkgLyBzdGRldjtcbiAgcmV0dXJuIE1hdGguZXhwKC0wLjUgKiB6ICogeikgLyAoc3RkZXYgKiBTUVJUMlBJKTtcbn0gLy8gQXBwcm94aW1hdGlvbiBmcm9tIFdlc3QgKDIwMDkpXG4vLyBCZXR0ZXIgQXBwcm94aW1hdGlvbnMgdG8gQ3VtdWxhdGl2ZSBOb3JtYWwgRnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGN1bXVsYXRpdmVOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9ICh2YWx1ZSAtIG1lYW4pIC8gc3RkZXYsXG4gICAgICAgIFogPSBNYXRoLmFicyh6KTtcbiAgbGV0IGNkO1xuXG4gIGlmIChaID4gMzcpIHtcbiAgICBjZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwID0gTWF0aC5leHAoLVogKiBaIC8gMik7XG4gICAgbGV0IHN1bTtcblxuICAgIGlmIChaIDwgNy4wNzEwNjc4MTE4NjU0Nykge1xuICAgICAgc3VtID0gMy41MjYyNDk2NTk5ODkxMWUtMDIgKiBaICsgMC43MDAzODMwNjQ0NDM2ODg7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNi4zNzM5NjIyMDM1MzE2NTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAzMy45MTI4NjYwNzgzODM7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMTEyLjA3OTI5MTQ5Nzg3MTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAyMjEuMjEzNTk2MTY5OTMxO1xuICAgICAgc3VtID0gc3VtICogWiArIDIyMC4yMDY4Njc5MTIzNzY7XG4gICAgICBjZCA9IGV4cCAqIHN1bTtcbiAgICAgIHN1bSA9IDguODM4ODM0NzY0ODMxODRlLTAyICogWiArIDEuNzU1NjY3MTYzMTgyNjQ7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMTYuMDY0MTc3NTc5MjA3O1xuICAgICAgc3VtID0gc3VtICogWiArIDg2Ljc4MDczMjIwMjk0NjE7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMjk2LjU2NDI0ODc3OTY3NDtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA2MzcuMzMzNjMzMzc4ODMxO1xuICAgICAgc3VtID0gc3VtICogWiArIDc5My44MjY1MTI1MTk5NDg7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNDQwLjQxMzczNTgyNDc1MjtcbiAgICAgIGNkID0gY2QgLyBzdW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bSA9IFogKyAwLjY1O1xuICAgICAgc3VtID0gWiArIDQgLyBzdW07XG4gICAgICBzdW0gPSBaICsgMyAvIHN1bTtcbiAgICAgIHN1bSA9IFogKyAyIC8gc3VtO1xuICAgICAgc3VtID0gWiArIDEgLyBzdW07XG4gICAgICBjZCA9IGV4cCAvIHN1bSAvIDIuNTA2NjI4Mjc0NjMxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB6ID4gMCA/IDEgLSBjZCA6IGNkO1xufSAvLyBBcHByb3hpbWF0aW9uIG9mIFByb2JpdCBmdW5jdGlvbiB1c2luZyBpbnZlcnNlIGVycm9yIGZ1bmN0aW9uLlxuXG5mdW5jdGlvbiBxdWFudGlsZU5vcm1hbChwLCBtZWFuLCBzdGRldikge1xuICBpZiAocCA8IDAgfHwgcCA+IDEpIHJldHVybiBOYU47XG4gIHJldHVybiAobWVhbiB8fCAwKSArIChzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2KSAqIFNRUlQyICogZXJmaW52KDIgKiBwIC0gMSk7XG59IC8vIEFwcHJveGltYXRlIGludmVyc2UgZXJyb3IgZnVuY3Rpb24uIEltcGxlbWVudGF0aW9uIGZyb20gXCJBcHByb3hpbWF0aW5nXG4vLyB0aGUgZXJmaW52IGZ1bmN0aW9uXCIgYnkgTWlrZSBHaWxlcywgR1BVIENvbXB1dGluZyBHZW1zLCB2b2x1bWUgMiwgMjAxMC5cbi8vIFBvcnRlZCBmcm9tIEFwYWNoZSBDb21tb25zIE1hdGgsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5mdW5jdGlvbiBlcmZpbnYoeCkge1xuICAvLyBiZXdhcmUgdGhhdCB0aGUgbG9nYXJpdGhtIGFyZ3VtZW50IG11c3QgYmVcbiAgLy8gY29tbXB1dGVkIGFzICgxLjAgLSB4KSAqICgxLjAgKyB4KSxcbiAgLy8gaXQgbXVzdCBOT1QgYmUgc2ltcGxpZmllZCBhcyAxLjAgLSB4ICogeCBhcyB0aGlzXG4gIC8vIHdvdWxkIGluZHVjZSByb3VuZGluZyBlcnJvcnMgbmVhciB0aGUgYm91bmRhcmllcyArLy0xXG4gIGxldCB3ID0gLU1hdGgubG9nKCgxIC0geCkgKiAoMSArIHgpKSxcbiAgICAgIHA7XG5cbiAgaWYgKHcgPCA2LjI1KSB7XG4gICAgdyAtPSAzLjEyNTtcbiAgICBwID0gLTMuNjQ0NDEyMDY0MDE3ODE5Njk5NmUtMjE7XG4gICAgcCA9IC0xLjY4NTA1OTEzODE4MjAxNjU4OWUtMTkgKyBwICogdztcbiAgICBwID0gMS4yODU4NDgwNzE1MjU2NDAwMTY3ZS0xOCArIHAgKiB3O1xuICAgIHAgPSAxLjExNTc4Nzc2NzgwMjUxODA5NmUtMTcgKyBwICogdztcbiAgICBwID0gLTEuMzMzMTcxNjYyODU0NjIwOTA2ZS0xNiArIHAgKiB3O1xuICAgIHAgPSAyLjA5NzI3Njc4NzU5Njg1NjE2MzdlLTE3ICsgcCAqIHc7XG4gICAgcCA9IDYuNjM3NjM4MTM0MzU4MzIzODMyNWUtMTUgKyBwICogdztcbiAgICBwID0gLTQuMDU0NTY2MjcyOTc1MjA2ODYzOWUtMTQgKyBwICogdztcbiAgICBwID0gLTguMTUxOTM0MTk3NjA1NDcyMTUyMmUtMTQgKyBwICogdztcbiAgICBwID0gMi42MzM1MDkzMTUzMDgyMzIyOTc3ZS0xMiArIHAgKiB3O1xuICAgIHAgPSAtMS4yOTc1MTMzMjUzNDUzNTMyNDk4ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAtNS40MTU0MTIwNTQyOTQ2Mjc5MzE3ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAxLjA1MTIxMjI3MzMyMTUzMjI4NWUtMDkgKyBwICogdztcbiAgICBwID0gLTQuMTEyNjMzOTgwMzQ2OTgzNjk3NmUtMDkgKyBwICogdztcbiAgICBwID0gLTIuOTA3MDM2OTk1Nzg4MjAwNTA4NmUtMDggKyBwICogdztcbiAgICBwID0gNC4yMzQ3ODc3ODI3OTMyNDAzNTE4ZS0wNyArIHAgKiB3O1xuICAgIHAgPSAtMS4zNjU0NjkyMDAwODM0Njc4NjQ1ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS4zODgyNTIzMzYyNzg2NDY4NzE5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAwLjAwMDE4NjczNDIwODAzNDA1NzEzNTIgKyBwICogdztcbiAgICBwID0gLTAuMDAwNzQwNzAyNTM0MTY2MjY2OTc1MTIgKyBwICogdztcbiAgICBwID0gLTAuMDA2MDMzNjcwODcxNDMwMTQ5MDUzMyArIHAgKiB3O1xuICAgIHAgPSAwLjI0MDE1ODE4MjQyNTU4OTYxNjkzICsgcCAqIHc7XG4gICAgcCA9IDEuNjUzNjU0NTYyNjgzMTAyNzM1NiArIHAgKiB3O1xuICB9IGVsc2UgaWYgKHcgPCAxNi4wKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDMuMjU7XG4gICAgcCA9IDIuMjEzNzM3NjkyMTc3NTc4NzA0OWUtMDk7XG4gICAgcCA9IDkuMDc1NjU2MTkzODg4NTM5MDk3OWUtMDggKyBwICogdztcbiAgICBwID0gLTIuNzUxNzQwNjI5NzA2NDU0NTQyOGUtMDcgKyBwICogdztcbiAgICBwID0gMS44MjM5NjI5MjE0Mzg5MjI3NzU1ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAxLjUwMjc0MDM5Njg5MDk4Mjc2MjdlLTA2ICsgcCAqIHc7XG4gICAgcCA9IC00LjAxMzg2NzUyNjk4MTU0NTk2OWUtMDYgKyBwICogdztcbiAgICBwID0gMi45MjM0NDQ5MDg5OTU1NDQ2MDQ0ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAxLjI0NzUzMDQ0ODE2NzE3Nzg3MjNlLTA1ICsgcCAqIHc7XG4gICAgcCA9IC00LjczMTgyMjkwMDkwNTU3MzM5ODFlLTA1ICsgcCAqIHc7XG4gICAgcCA9IDYuODI4NDg1MTQ1OTU3MzE3NTQ0OGUtMDUgKyBwICogdztcbiAgICBwID0gMi40MDMxMTEwMzg3MDk3ODkzOTk5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAtMC4wMDAzNTUwMzc1MjAzNjI4NDc0Nzk2ICsgcCAqIHc7XG4gICAgcCA9IDAuMDAwOTUzMjg5Mzc5NzM3MzgwNDk3MDMgKyBwICogdztcbiAgICBwID0gLTAuMDAxNjg4Mjc1NTU2MDIzNTA0NzMxMyArIHAgKiB3O1xuICAgIHAgPSAwLjAwMjQ5MTQ0MjA5NjEwNzg1MDgwNjYgKyBwICogdztcbiAgICBwID0gLTAuMDAzNzUxMjA4NTA3NTY5MjQxMjEwNyArIHAgKiB3O1xuICAgIHAgPSAwLjAwNTM3MDkxNDU1MzU5MDA2MzYxNyArIHAgKiB3O1xuICAgIHAgPSAxLjAwNTI1ODk2NzY5NDE1OTIzMzQgKyBwICogdztcbiAgICBwID0gMy4wODM4ODU2MTA0OTIyMjA3NjM1ICsgcCAqIHc7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKHcpKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDUuMDtcbiAgICBwID0gLTIuNzEwOTkyMDYxNjQzODU3MzI0M2UtMTE7XG4gICAgcCA9IC0yLjU1NTY0MTgxNjk5NjUyNTIwNTVlLTEwICsgcCAqIHc7XG4gICAgcCA9IDEuNTA3NjU3MjY5MzUwMDU0ODA4M2UtMDkgKyBwICogdztcbiAgICBwID0gLTMuNzg5NDY1NDQwMTI2NzM2OTkzN2UtMDkgKyBwICogdztcbiAgICBwID0gNy42MTU3MDEyMDgwNzgzMzkzODA0ZS0wOSArIHAgKiB3O1xuICAgIHAgPSAtMS40OTYwMDI2NjI3MTQ5MjQwNDc4ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAyLjkxNDc5NTM0NTA5MDEwODA4MjZlLTA4ICsgcCAqIHc7XG4gICAgcCA9IC02Ljc3MTE5OTc3NTg0NTIzMzk0OThlLTA4ICsgcCAqIHc7XG4gICAgcCA9IDIuMjkwMDQ4MjIyODAyNjY1NDcxN2UtMDcgKyBwICogdztcbiAgICBwID0gLTkuOTI5ODI3Mjk0MjMxNzAwMjUzOWUtMDcgKyBwICogdztcbiAgICBwID0gNC41MjYwNjI1OTcyMjMxNTM3MDM5ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS45NjgxNzc4MTA1NTMxNjcwNTY3ZS0wNSArIHAgKiB3O1xuICAgIHAgPSA3LjU5OTUyNzcwMzAwMTc3NjExMzllLTA1ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDIxNTAzMDExOTMwMDQ0NDc3MzQ3ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDEzODcxOTMxODMzNjIzMTIyMDI2ICsgcCAqIHc7XG4gICAgcCA9IDEuMDEwMzAwNDY0ODY0NTM0Mzk3NyArIHAgKiB3O1xuICAgIHAgPSA0Ljg0OTkwNjQwMTQwODU4NDQyMjEgKyBwICogdztcbiAgfSBlbHNlIHtcbiAgICBwID0gSW5maW5pdHk7XG4gIH1cblxuICByZXR1cm4gcCAqIHg7XG59XG5cbmZ1bmN0aW9uIGdhdXNzaWFuIChtZWFuLCBzdGRldikge1xuICBsZXQgbXUsIHNpZ21hO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIG1lYW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbXUgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG11O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGRldihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBzaWdtYSA9IF8gPT0gbnVsbCA/IDEgOiBfO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWdtYTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2FtcGxlOiAoKSA9PiBzYW1wbGVOb3JtYWwobXUsIHNpZ21hKSxcbiAgICBwZGY6IHZhbHVlID0+IGRlbnNpdHlOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgY2RmOiB2YWx1ZSA9PiBjdW11bGF0aXZlTm9ybWFsKHZhbHVlLCBtdSwgc2lnbWEpLFxuICAgIGljZGY6IHAgPT4gcXVhbnRpbGVOb3JtYWwocCwgbXUsIHNpZ21hKVxuICB9O1xuICByZXR1cm4gZGlzdC5tZWFuKG1lYW4pLnN0ZGV2KHN0ZGV2KTtcbn1cblxuZnVuY3Rpb24ga2RlIChzdXBwb3J0LCBiYW5kd2lkdGgpIHtcbiAgY29uc3Qga2VybmVsID0gZ2F1c3NpYW4oKTtcbiAgbGV0IG4gPSAwO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIGRhdGEoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc3VwcG9ydCA9IF87XG4gICAgICAgIG4gPSBfID8gXy5sZW5ndGggOiAwO1xuICAgICAgICByZXR1cm4gZGlzdC5iYW5kd2lkdGgoYmFuZHdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBiYW5kd2lkdGgoXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFuZHdpZHRoO1xuICAgICAgYmFuZHdpZHRoID0gXztcbiAgICAgIGlmICghYmFuZHdpZHRoICYmIHN1cHBvcnQpIGJhbmR3aWR0aCA9IGVzdGltYXRlQmFuZHdpZHRoKHN1cHBvcnQpO1xuICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgfSxcblxuICAgIHNhbXBsZSgpIHtcbiAgICAgIHJldHVybiBzdXBwb3J0W35+KHJhbmRvbSgpICogbildICsgYmFuZHdpZHRoICoga2VybmVsLnNhbXBsZSgpO1xuICAgIH0sXG5cbiAgICBwZGYoeCkge1xuICAgICAgbGV0IHkgPSAwLFxuICAgICAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ICs9IGtlcm5lbC5wZGYoKHggLSBzdXBwb3J0W2ldKSAvIGJhbmR3aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5IC8gYmFuZHdpZHRoIC8gbjtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGxldCB5ID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgeSArPSBrZXJuZWwuY2RmKCh4IC0gc3VwcG9ydFtpXSkgLyBiYW5kd2lkdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geSAvIG47XG4gICAgfSxcblxuICAgIGljZGYoKSB7XG4gICAgICB0aHJvdyBFcnJvcignS0RFIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIGRpc3QuZGF0YShzdXBwb3J0KTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlTG9nTm9ybWFsKG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgcmV0dXJuIE1hdGguZXhwKG1lYW4gKyBzYW1wbGVOb3JtYWwoKSAqIHN0ZGV2KTtcbn1cbmZ1bmN0aW9uIGRlbnNpdHlMb2dOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIGlmICh2YWx1ZSA8PSAwKSByZXR1cm4gMDtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2O1xuICBjb25zdCB6ID0gKE1hdGgubG9nKHZhbHVlKSAtIG1lYW4pIC8gc3RkZXY7XG4gIHJldHVybiBNYXRoLmV4cCgtMC41ICogeiAqIHopIC8gKHN0ZGV2ICogU1FSVDJQSSAqIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGN1bXVsYXRpdmVMb2dOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIHJldHVybiBjdW11bGF0aXZlTm9ybWFsKE1hdGgubG9nKHZhbHVlKSwgbWVhbiwgc3RkZXYpO1xufVxuZnVuY3Rpb24gcXVhbnRpbGVMb2dOb3JtYWwocCwgbWVhbiwgc3RkZXYpIHtcbiAgcmV0dXJuIE1hdGguZXhwKHF1YW50aWxlTm9ybWFsKHAsIG1lYW4sIHN0ZGV2KSk7XG59XG5mdW5jdGlvbiBsb2dub3JtYWwgKG1lYW4sIHN0ZGV2KSB7XG4gIGxldCBtdSwgc2lnbWE7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWVhbihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBtdSA9IF8gfHwgMDtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbXU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0ZGV2KF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHNpZ21hID0gXyA9PSBudWxsID8gMSA6IF87XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ21hO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzYW1wbGU6ICgpID0+IHNhbXBsZUxvZ05vcm1hbChtdSwgc2lnbWEpLFxuICAgIHBkZjogdmFsdWUgPT4gZGVuc2l0eUxvZ05vcm1hbCh2YWx1ZSwgbXUsIHNpZ21hKSxcbiAgICBjZGY6IHZhbHVlID0+IGN1bXVsYXRpdmVMb2dOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgaWNkZjogcCA9PiBxdWFudGlsZUxvZ05vcm1hbChwLCBtdSwgc2lnbWEpXG4gIH07XG4gIHJldHVybiBkaXN0Lm1lYW4obWVhbikuc3RkZXYoc3RkZXYpO1xufVxuXG5mdW5jdGlvbiBtaXh0dXJlIChkaXN0cywgd2VpZ2h0cykge1xuICBsZXQgbSA9IDAsXG4gICAgICB3O1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZSh4KSB7XG4gICAgY29uc3QgdyA9IFtdO1xuICAgIGxldCBzdW0gPSAwLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgc3VtICs9IHdbaV0gPSB4W2ldID09IG51bGwgPyAxIDogK3hbaV07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgd1tpXSAvPSBzdW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICBjb25zdCBkaXN0ID0ge1xuICAgIHdlaWdodHMoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdyA9IG5vcm1hbGl6ZSh3ZWlnaHRzID0gXyB8fCBbXSk7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2VpZ2h0cztcbiAgICB9LFxuXG4gICAgZGlzdHJpYnV0aW9ucyhfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoXykge1xuICAgICAgICAgIG0gPSBfLmxlbmd0aDtcbiAgICAgICAgICBkaXN0cyA9IF87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgZGlzdHMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkaXN0LndlaWdodHMod2VpZ2h0cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaXN0cztcbiAgICB9LFxuXG4gICAgc2FtcGxlKCkge1xuICAgICAgY29uc3QgciA9IHJhbmRvbSgpO1xuICAgICAgbGV0IGQgPSBkaXN0c1ttIC0gMV0sXG4gICAgICAgICAgdiA9IHdbMF0sXG4gICAgICAgICAgaSA9IDA7IC8vIGZpcnN0IHNlbGVjdCBkaXN0cmlidXRpb25cblxuICAgICAgZm9yICg7IGkgPCBtIC0gMTsgdiArPSB3WysraV0pIHtcbiAgICAgICAgaWYgKHIgPCB2KSB7XG4gICAgICAgICAgZCA9IGRpc3RzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIHRoZW4gc2FtcGxlIGZyb20gaXRcblxuXG4gICAgICByZXR1cm4gZC5zYW1wbGUoKTtcbiAgICB9LFxuXG4gICAgcGRmKHgpIHtcbiAgICAgIGxldCBwID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgcCArPSB3W2ldICogZGlzdHNbaV0ucGRmKHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgY2RmKHgpIHtcbiAgICAgIGxldCBwID0gMCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgcCArPSB3W2ldICogZGlzdHNbaV0uY2RmKHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaWNkZigpIHtcbiAgICAgIHRocm93IEVycm9yKCdNaXh0dXJlIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgfTtcbiAgcmV0dXJuIGRpc3QuZGlzdHJpYnV0aW9ucyhkaXN0cykud2VpZ2h0cyh3ZWlnaHRzKTtcbn1cblxuZnVuY3Rpb24gc2FtcGxlVW5pZm9ybShtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiBtaW4gKyAobWF4IC0gbWluKSAqIHJhbmRvbSgpO1xufVxuZnVuY3Rpb24gZGVuc2l0eVVuaWZvcm0odmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXggPyAxIC8gKG1heCAtIG1pbikgOiAwO1xufVxuZnVuY3Rpb24gY3VtdWxhdGl2ZVVuaWZvcm0odmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gMCA6IHZhbHVlID4gbWF4ID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbn1cbmZ1bmN0aW9uIHF1YW50aWxlVW5pZm9ybShwLCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09IG51bGwpIHtcbiAgICBtYXggPSBtaW4gPT0gbnVsbCA/IDEgOiBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIHJldHVybiBwID49IDAgJiYgcCA8PSAxID8gbWluICsgcCAqIChtYXggLSBtaW4pIDogTmFOO1xufVxuZnVuY3Rpb24gdW5pZm9ybSAobWluLCBtYXgpIHtcbiAgbGV0IGEsIGI7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWluKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGEgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9XG4gICAgfSxcblxuICAgIG1heChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBiID0gXyA9PSBudWxsID8gMSA6IF87XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNhbXBsZTogKCkgPT4gc2FtcGxlVW5pZm9ybShhLCBiKSxcbiAgICBwZGY6IHZhbHVlID0+IGRlbnNpdHlVbmlmb3JtKHZhbHVlLCBhLCBiKSxcbiAgICBjZGY6IHZhbHVlID0+IGN1bXVsYXRpdmVVbmlmb3JtKHZhbHVlLCBhLCBiKSxcbiAgICBpY2RmOiBwID0+IHF1YW50aWxlVW5pZm9ybShwLCBhLCBiKVxuICB9O1xuXG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGRpc3QubWluKG1pbikubWF4KG1heCk7XG59XG5cbi8vIE9yZGluYXJ5IExlYXN0IFNxdWFyZXNcbmZ1bmN0aW9uIG9scyAodVgsIHVZLCB1WFksIHVYMikge1xuICBjb25zdCBkZWx0YSA9IHVYMiAtIHVYICogdVgsXG4gICAgICAgIHNsb3BlID0gTWF0aC5hYnMoZGVsdGEpIDwgMWUtMjQgPyAwIDogKHVYWSAtIHVYICogdVkpIC8gZGVsdGEsXG4gICAgICAgIGludGVyY2VwdCA9IHVZIC0gc2xvcGUgKiB1WDtcbiAgcmV0dXJuIFtpbnRlcmNlcHQsIHNsb3BlXTtcbn1cblxuZnVuY3Rpb24gcG9pbnRzKGRhdGEsIHgsIHksIHNvcnQpIHtcbiAgZGF0YSA9IGRhdGEuZmlsdGVyKGQgPT4ge1xuICAgIGxldCB1ID0geChkKSxcbiAgICAgICAgdiA9IHkoZCk7XG4gICAgcmV0dXJuIHUgIT0gbnVsbCAmJiAodSA9ICt1KSA+PSB1ICYmIHYgIT0gbnVsbCAmJiAodiA9ICt2KSA+PSB2O1xuICB9KTtcblxuICBpZiAoc29ydCkge1xuICAgIGRhdGEuc29ydCgoYSwgYikgPT4geChhKSAtIHgoYikpO1xuICB9XG5cbiAgY29uc3QgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBYID0gbmV3IEZsb2F0NjRBcnJheShuKSxcbiAgICAgICAgWSA9IG5ldyBGbG9hdDY0QXJyYXkobik7IC8vIGV4dHJhY3QgdmFsdWVzLCBjYWxjdWxhdGUgbWVhbnNcblxuICBsZXQgaSA9IDAsXG4gICAgICB1eCA9IDAsXG4gICAgICB1eSA9IDAsXG4gICAgICB4dixcbiAgICAgIHl2LFxuICAgICAgZDtcblxuICBmb3IgKGQgb2YgZGF0YSkge1xuICAgIFhbaV0gPSB4diA9ICt4KGQpO1xuICAgIFlbaV0gPSB5diA9ICt5KGQpO1xuICAgICsraTtcbiAgICB1eCArPSAoeHYgLSB1eCkgLyBpO1xuICAgIHV5ICs9ICh5diAtIHV5KSAvIGk7XG4gIH0gLy8gbWVhbiBjZW50ZXIgdGhlIGRhdGFcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBYW2ldIC09IHV4O1xuICAgIFlbaV0gLT0gdXk7XG4gIH1cblxuICByZXR1cm4gW1gsIFksIHV4LCB1eV07XG59XG5mdW5jdGlvbiB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCBjYWxsYmFjaykge1xuICBsZXQgaSA9IC0xLFxuICAgICAgdSxcbiAgICAgIHY7XG5cbiAgZm9yIChjb25zdCBkIG9mIGRhdGEpIHtcbiAgICB1ID0geChkKTtcbiAgICB2ID0geShkKTtcblxuICAgIGlmICh1ICE9IG51bGwgJiYgKHUgPSArdSkgPj0gdSAmJiB2ICE9IG51bGwgJiYgKHYgPSArdikgPj0gdikge1xuICAgICAgY2FsbGJhY2sodSwgdiwgKytpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuZnVuY3Rpb24gclNxdWFyZWQgKGRhdGEsIHgsIHksIHVZLCBwcmVkaWN0KSB7XG4gIGxldCBTU0UgPSAwLFxuICAgICAgU1NUID0gMDtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKGR4LCBkeSkgPT4ge1xuICAgIGNvbnN0IHNzZSA9IGR5IC0gcHJlZGljdChkeCksXG4gICAgICAgICAgc3N0ID0gZHkgLSB1WTtcbiAgICBTU0UgKz0gc3NlICogc3NlO1xuICAgIFNTVCArPSBzc3QgKiBzc3Q7XG4gIH0pO1xuICByZXR1cm4gMSAtIFNTRSAvIFNTVDtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuZnVuY3Rpb24gbGluZWFyIChkYXRhLCB4LCB5KSB7XG4gIGxldCBYID0gMCxcbiAgICAgIFkgPSAwLFxuICAgICAgWFkgPSAwLFxuICAgICAgWDIgPSAwLFxuICAgICAgbiA9IDA7XG4gIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIChkeCwgZHkpID0+IHtcbiAgICArK247XG4gICAgWCArPSAoZHggLSBYKSAvIG47XG4gICAgWSArPSAoZHkgLSBZKSAvIG47XG4gICAgWFkgKz0gKGR4ICogZHkgLSBYWSkgLyBuO1xuICAgIFgyICs9IChkeCAqIGR4IC0gWDIpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgY29lZiA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiBjb2VmWzBdICsgY29lZlsxXSAqIHg7XG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBjb2VmLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIFksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIGxvZyAoZGF0YSwgeCwgeSkge1xuICBsZXQgWCA9IDAsXG4gICAgICBZID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyID0gMCxcbiAgICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgKytuO1xuICAgIGR4ID0gTWF0aC5sb2coZHgpO1xuICAgIFggKz0gKGR4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAoZHggKiBkeCAtIFgyKSAvIG47XG4gIH0pO1xuXG4gIGNvbnN0IGNvZWYgPSBvbHMoWCwgWSwgWFksIFgyKSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gY29lZlswXSArIGNvZWZbMV0gKiBNYXRoLmxvZyh4KTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IGNvZWYsXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgWSwgcHJlZGljdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXhwIChkYXRhLCB4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCBbeHYsIHl2LCB1eCwgdXldID0gcG9pbnRzKGRhdGEsIHgsIHkpO1xuICBsZXQgWUwgPSAwLFxuICAgICAgWFkgPSAwLFxuICAgICAgWFlMID0gMCxcbiAgICAgIFgyWSA9IDAsXG4gICAgICBuID0gMCxcbiAgICAgIGR4LFxuICAgICAgbHksXG4gICAgICB4eTtcbiAgdmlzaXRQb2ludHMoZGF0YSwgeCwgeSwgKF8sIGR5KSA9PiB7XG4gICAgZHggPSB4dltuKytdO1xuICAgIGx5ID0gTWF0aC5sb2coZHkpO1xuICAgIHh5ID0gZHggKiBkeTtcbiAgICBZTCArPSAoZHkgKiBseSAtIFlMKSAvIG47XG4gICAgWFkgKz0gKHh5IC0gWFkpIC8gbjtcbiAgICBYWUwgKz0gKHh5ICogbHkgLSBYWUwpIC8gbjtcbiAgICBYMlkgKz0gKGR4ICogeHkgLSBYMlkpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgW2MwLCBjMV0gPSBvbHMoWFkgLyB1eSwgWUwgLyB1eSwgWFlMIC8gdXksIFgyWSAvIHV5KSxcbiAgICAgICAgcHJlZGljdCA9IHggPT4gTWF0aC5leHAoYzAgKyBjMSAqICh4IC0gdXgpKTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IFtNYXRoLmV4cChjMCAtIGMxICogdXgpLCBjMV0sXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgdXksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIHBvdyAoZGF0YSwgeCwgeSkge1xuICBsZXQgWCA9IDAsXG4gICAgICBZID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyID0gMCxcbiAgICAgIFlTID0gMCxcbiAgICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgY29uc3QgbHggPSBNYXRoLmxvZyhkeCksXG4gICAgICAgICAgbHkgPSBNYXRoLmxvZyhkeSk7XG4gICAgKytuO1xuICAgIFggKz0gKGx4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGx5IC0gWSkgLyBuO1xuICAgIFhZICs9IChseCAqIGx5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAobHggKiBseCAtIFgyKSAvIG47XG4gICAgWVMgKz0gKGR5IC0gWVMpIC8gbjtcbiAgfSk7XG5cbiAgY29uc3QgY29lZiA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiBjb2VmWzBdICogTWF0aC5wb3coeCwgY29lZlsxXSk7XG5cbiAgY29lZlswXSA9IE1hdGguZXhwKGNvZWZbMF0pO1xuICByZXR1cm4ge1xuICAgIGNvZWY6IGNvZWYsXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgWVMsIHByZWRpY3QpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1YWQgKGRhdGEsIHgsIHkpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aDtcbiAgbGV0IFgyID0gMCxcbiAgICAgIFgzID0gMCxcbiAgICAgIFg0ID0gMCxcbiAgICAgIFhZID0gMCxcbiAgICAgIFgyWSA9IDAsXG4gICAgICBpLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHgyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOykge1xuICAgIGR4ID0geHZbaV07XG4gICAgZHkgPSB5dltpKytdO1xuICAgIHgyID0gZHggKiBkeDtcbiAgICBYMiArPSAoeDIgLSBYMikgLyBpO1xuICAgIFgzICs9ICh4MiAqIGR4IC0gWDMpIC8gaTtcbiAgICBYNCArPSAoeDIgKiB4MiAtIFg0KSAvIGk7XG4gICAgWFkgKz0gKGR4ICogZHkgLSBYWSkgLyBpO1xuICAgIFgyWSArPSAoeDIgKiBkeSAtIFgyWSkgLyBpO1xuICB9XG5cbiAgY29uc3QgWDJYMiA9IFg0IC0gWDIgKiBYMixcbiAgICAgICAgZCA9IFgyICogWDJYMiAtIFgzICogWDMsXG4gICAgICAgIGEgPSAoWDJZICogWDIgLSBYWSAqIFgzKSAvIGQsXG4gICAgICAgIGIgPSAoWFkgKiBYMlgyIC0gWDJZICogWDMpIC8gZCxcbiAgICAgICAgYyA9IC1hICogWDIsXG4gICAgICAgIHByZWRpY3QgPSB4ID0+IHtcbiAgICB4ID0geCAtIHV4O1xuICAgIHJldHVybiBhICogeCAqIHggKyBiICogeCArIGMgKyB1eTtcbiAgfTsgLy8gdHJhbnNmb3JtIGNvZWZmaWNpZW50cyBiYWNrIGZyb20gbWVhbi1jZW50ZXJlZCBzcGFjZVxuXG5cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBbYyAtIGIgKiB1eCArIGEgKiB1eCAqIHV4ICsgdXksIGIgLSAyICogYSAqIHV4LCBhXSxcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCB1eSwgcHJlZGljdClcbiAgfTtcbn1cblxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbi8vIC4uLiB3aGljaCB3YXMgYWRhcHRlZCBmcm9tIHJlZ3Jlc3Npb24tanMgYnkgVG9tIEFsZXhhbmRlclxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vVG9tLUFsZXhhbmRlci9yZWdyZXNzaW9uLWpzL2Jsb2IvbWFzdGVyL3NyYy9yZWdyZXNzaW9uLmpzI0wyNDZcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub20tQWxleGFuZGVyL3JlZ3Jlc3Npb24tanMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG5mdW5jdGlvbiBwb2x5IChkYXRhLCB4LCB5LCBvcmRlcikge1xuICAvLyB1c2UgbW9yZSBlZmZpY2llbnQgbWV0aG9kcyBmb3IgbG93ZXIgb3JkZXJzXG4gIGlmIChvcmRlciA9PT0gMSkgcmV0dXJuIGxpbmVhcihkYXRhLCB4LCB5KTtcbiAgaWYgKG9yZGVyID09PSAyKSByZXR1cm4gcXVhZChkYXRhLCB4LCB5KTtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgbGhzID0gW10sXG4gICAgICAgIHJocyA9IFtdLFxuICAgICAgICBrID0gb3JkZXIgKyAxO1xuICBsZXQgaSwgaiwgbCwgdiwgYztcblxuICBmb3IgKGkgPSAwOyBpIDwgazsgKytpKSB7XG4gICAgZm9yIChsID0gMCwgdiA9IDA7IGwgPCBuOyArK2wpIHtcbiAgICAgIHYgKz0gTWF0aC5wb3coeHZbbF0sIGkpICogeXZbbF07XG4gICAgfVxuXG4gICAgbGhzLnB1c2godik7XG4gICAgYyA9IG5ldyBGbG9hdDY0QXJyYXkoayk7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICBmb3IgKGwgPSAwLCB2ID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpICsgaik7XG4gICAgICB9XG5cbiAgICAgIGNbal0gPSB2O1xuICAgIH1cblxuICAgIHJocy5wdXNoKGMpO1xuICB9XG5cbiAgcmhzLnB1c2gobGhzKTtcblxuICBjb25zdCBjb2VmID0gZ2F1c3NpYW5FbGltaW5hdGlvbihyaHMpLFxuICAgICAgICBwcmVkaWN0ID0geCA9PiB7XG4gICAgeCAtPSB1eDtcbiAgICBsZXQgeSA9IHV5ICsgY29lZlswXSArIGNvZWZbMV0gKiB4ICsgY29lZlsyXSAqIHggKiB4O1xuXG4gICAgZm9yIChpID0gMzsgaSA8IGs7ICsraSkgeSArPSBjb2VmW2ldICogTWF0aC5wb3coeCwgaSk7XG5cbiAgICByZXR1cm4geTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvZWY6IHVuY2VudGVyKGssIGNvZWYsIC11eCwgdXkpLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIHV5LCBwcmVkaWN0KVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bmNlbnRlcihrLCBhLCB4LCB5KSB7XG4gIGNvbnN0IHogPSBBcnJheShrKTtcbiAgbGV0IGksIGosIHYsIGM7IC8vIGluaXRpYWxpemUgdG8gemVyb1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrOyArK2kpIHpbaV0gPSAwOyAvLyBwb2x5bm9taWFsIGV4cGFuc2lvblxuXG5cbiAgZm9yIChpID0gayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdiA9IGFbaV07XG4gICAgYyA9IDE7XG4gICAgeltpXSArPSB2O1xuXG4gICAgZm9yIChqID0gMTsgaiA8PSBpOyArK2opIHtcbiAgICAgIGMgKj0gKGkgKyAxIC0gaikgLyBqOyAvLyBiaW5vbWlhbCBjb2VmZmljZW50XG5cbiAgICAgIHpbaSAtIGpdICs9IHYgKiBNYXRoLnBvdyh4LCBqKSAqIGM7XG4gICAgfVxuICB9IC8vIGJpYXMgdGVybVxuXG5cbiAgelswXSArPSB5O1xuICByZXR1cm4gejtcbn0gLy8gR2l2ZW4gYW4gYXJyYXkgZm9yIGEgdHdvLWRpbWVuc2lvbmFsIG1hdHJpeCBhbmQgdGhlIHBvbHlub21pYWwgb3JkZXIsXG4vLyBzb2x2ZSBBICogeCA9IGIgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24uXG5cblxuZnVuY3Rpb24gZ2F1c3NpYW5FbGltaW5hdGlvbihtYXRyaXgpIHtcbiAgY29uc3QgbiA9IG1hdHJpeC5sZW5ndGggLSAxLFxuICAgICAgICBjb2VmID0gW107XG4gIGxldCBpLCBqLCBrLCByLCB0O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByID0gaTsgLy8gbWF4IHJvd1xuXG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGlmIChNYXRoLmFicyhtYXRyaXhbaV1bal0pID4gTWF0aC5hYnMobWF0cml4W2ldW3JdKSkge1xuICAgICAgICByID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGsgPSBpOyBrIDwgbiArIDE7ICsraykge1xuICAgICAgdCA9IG1hdHJpeFtrXVtpXTtcbiAgICAgIG1hdHJpeFtrXVtpXSA9IG1hdHJpeFtrXVtyXTtcbiAgICAgIG1hdHJpeFtrXVtyXSA9IHQ7XG4gICAgfVxuXG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGZvciAoayA9IG47IGsgPj0gaTsgay0tKSB7XG4gICAgICAgIG1hdHJpeFtrXVtqXSAtPSBtYXRyaXhba11baV0gKiBtYXRyaXhbaV1bal0gLyBtYXRyaXhbaV1baV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yIChqID0gbiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgdCA9IDA7XG5cbiAgICBmb3IgKGsgPSBqICsgMTsgayA8IG47ICsraykge1xuICAgICAgdCArPSBtYXRyaXhba11bal0gKiBjb2VmW2tdO1xuICAgIH1cblxuICAgIGNvZWZbal0gPSAobWF0cml4W25dW2pdIC0gdCkgLyBtYXRyaXhbal1bal07XG4gIH1cblxuICByZXR1cm4gY29lZjtcbn1cblxuY29uc3QgbWF4aXRlcnMgPSAyLFxuICAgICAgZXBzaWxvbiA9IDFlLTEyOyAvLyBBZGFwdGVkIGZyb20gc2NpZW5jZS5qcyBieSBKYXNvbiBEYXZpZXNcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2phc29uZGF2aWVzL3NjaWVuY2UuanMvYmxvYi9tYXN0ZXIvc3JjL3N0YXRzL2xvZXNzLmpzXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vamFzb25kYXZpZXMvc2NpZW5jZS5qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmZ1bmN0aW9uIGxvZXNzIChkYXRhLCB4LCB5LCBiYW5kd2lkdGgpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5LCB0cnVlKSxcbiAgICAgICAgbiA9IHh2Lmxlbmd0aCxcbiAgICAgICAgYncgPSBNYXRoLm1heCgyLCB+fihiYW5kd2lkdGggKiBuKSksXG4gICAgICAgIC8vICMgbmVhcmVzdCBuZWlnaGJvcnNcbiAgeWhhdCA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgICAgIHJlc2lkdWFscyA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgICAgIHJvYnVzdFdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLmZpbGwoMSk7XG5cbiAgZm9yIChsZXQgaXRlciA9IC0xOyArK2l0ZXIgPD0gbWF4aXRlcnM7KSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBbMCwgYncgLSAxXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBkeCA9IHh2W2ldLFxuICAgICAgICAgICAgaTAgPSBpbnRlcnZhbFswXSxcbiAgICAgICAgICAgIGkxID0gaW50ZXJ2YWxbMV0sXG4gICAgICAgICAgICBlZGdlID0gZHggLSB4dltpMF0gPiB4dltpMV0gLSBkeCA/IGkwIDogaTE7XG4gICAgICBsZXQgVyA9IDAsXG4gICAgICAgICAgWCA9IDAsXG4gICAgICAgICAgWSA9IDAsXG4gICAgICAgICAgWFkgPSAwLFxuICAgICAgICAgIFgyID0gMDtcbiAgICAgIGNvbnN0IGRlbm9tID0gMSAvIE1hdGguYWJzKHh2W2VkZ2VdIC0gZHggfHwgMSk7IC8vIGF2b2lkIHNpbmd1bGFyaXR5IVxuXG4gICAgICBmb3IgKGxldCBrID0gaTA7IGsgPD0gaTE7ICsraykge1xuICAgICAgICBjb25zdCB4ayA9IHh2W2tdLFxuICAgICAgICAgICAgICB5ayA9IHl2W2tdLFxuICAgICAgICAgICAgICB3ID0gdHJpY3ViZShNYXRoLmFicyhkeCAtIHhrKSAqIGRlbm9tKSAqIHJvYnVzdFdlaWdodHNba10sXG4gICAgICAgICAgICAgIHhrdyA9IHhrICogdztcbiAgICAgICAgVyArPSB3O1xuICAgICAgICBYICs9IHhrdztcbiAgICAgICAgWSArPSB5ayAqIHc7XG4gICAgICAgIFhZICs9IHlrICogeGt3O1xuICAgICAgICBYMiArPSB4ayAqIHhrdztcbiAgICAgIH0gLy8gbGluZWFyIHJlZ3Jlc3Npb24gZml0XG5cblxuICAgICAgY29uc3QgW2EsIGJdID0gb2xzKFggLyBXLCBZIC8gVywgWFkgLyBXLCBYMiAvIFcpO1xuICAgICAgeWhhdFtpXSA9IGEgKyBiICogZHg7XG4gICAgICByZXNpZHVhbHNbaV0gPSBNYXRoLmFicyh5dltpXSAtIHloYXRbaV0pO1xuICAgICAgdXBkYXRlSW50ZXJ2YWwoeHYsIGkgKyAxLCBpbnRlcnZhbCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZXIgPT09IG1heGl0ZXJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb25zdCBtZWRpYW5SZXNpZHVhbCA9IG1lZGlhbihyZXNpZHVhbHMpO1xuICAgIGlmIChNYXRoLmFicyhtZWRpYW5SZXNpZHVhbCkgPCBlcHNpbG9uKSBicmVhaztcblxuICAgIGZvciAobGV0IGkgPSAwLCBhcmcsIHc7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFyZyA9IHJlc2lkdWFsc1tpXSAvICg2ICogbWVkaWFuUmVzaWR1YWwpOyAvLyBkZWZhdWx0IHRvIGVwc2lsb24gKHJhdGhlciB0aGFuIHplcm8pIGZvciBsYXJnZSBkZXZpYXRpb25zXG4gICAgICAvLyBrZWVwaW5nIHdlaWdodHMgdGlueSBidXQgbm9uLXplcm8gcHJldmVudHMgc2luZ3VsYXJpdGVzXG5cbiAgICAgIHJvYnVzdFdlaWdodHNbaV0gPSBhcmcgPj0gMSA/IGVwc2lsb24gOiAodyA9IDEgLSBhcmcgKiBhcmcpICogdztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0KHh2LCB5aGF0LCB1eCwgdXkpO1xufSAvLyB3ZWlnaHRpbmcga2VybmVsIGZvciBsb2NhbCByZWdyZXNzaW9uXG5cbmZ1bmN0aW9uIHRyaWN1YmUoeCkge1xuICByZXR1cm4gKHggPSAxIC0geCAqIHggKiB4KSAqIHggKiB4O1xufSAvLyBhZHZhbmNlIHNsaWRpbmcgd2luZG93IGludGVydmFsIG9mIG5lYXJlc3QgbmVpZ2hib3JzXG5cblxuZnVuY3Rpb24gdXBkYXRlSW50ZXJ2YWwoeHYsIGksIGludGVydmFsKSB7XG4gIGNvbnN0IHZhbCA9IHh2W2ldO1xuICBsZXQgbGVmdCA9IGludGVydmFsWzBdLFxuICAgICAgcmlnaHQgPSBpbnRlcnZhbFsxXSArIDE7XG4gIGlmIChyaWdodCA+PSB4di5sZW5ndGgpIHJldHVybjsgLy8gc3RlcCByaWdodCBpZiBkaXN0YW5jZSB0byBuZXcgcmlnaHQgZWRnZSBpcyA8PSBkaXN0YW5jZSB0byBvbGQgbGVmdCBlZGdlXG4gIC8vIHN0ZXAgd2hlbiBkaXN0YW5jZSBpcyBlcXVhbCB0byBlbnN1cmUgbW92ZW1lbnQgb3ZlciBkdXBsaWNhdGUgeCB2YWx1ZXNcblxuICB3aGlsZSAoaSA+IGxlZnQgJiYgeHZbcmlnaHRdIC0gdmFsIDw9IHZhbCAtIHh2W2xlZnRdKSB7XG4gICAgaW50ZXJ2YWxbMF0gPSArK2xlZnQ7XG4gICAgaW50ZXJ2YWxbMV0gPSByaWdodDtcbiAgICArK3JpZ2h0O1xuICB9XG59IC8vIGdlbmVyYXRlIHNtb290aGVkIG91dHB1dCBwb2ludHNcbi8vIGF2ZXJhZ2UgcG9pbnRzIHdpdGggcmVwZWF0ZWQgeCB2YWx1ZXNcblxuXG5mdW5jdGlvbiBvdXRwdXQoeHYsIHloYXQsIHV4LCB1eSkge1xuICBjb25zdCBuID0geHYubGVuZ3RoLFxuICAgICAgICBvdXQgPSBbXTtcbiAgbGV0IGkgPSAwLFxuICAgICAgY250ID0gMCxcbiAgICAgIHByZXYgPSBbXSxcbiAgICAgIHY7XG5cbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICB2ID0geHZbaV0gKyB1eDtcblxuICAgIGlmIChwcmV2WzBdID09PSB2KSB7XG4gICAgICAvLyBhdmVyYWdlIG91dHB1dCB2YWx1ZXMgdmlhIG9ubGluZSB1cGRhdGVcbiAgICAgIHByZXZbMV0gKz0gKHloYXRbaV0gLSBwcmV2WzFdKSAvICsrY250O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgbmV3IG91dHB1dCBwb2ludFxuICAgICAgY250ID0gMDtcbiAgICAgIHByZXZbMV0gKz0gdXk7XG4gICAgICBwcmV2ID0gW3YsIHloYXRbaV1dO1xuICAgICAgb3V0LnB1c2gocHJldik7XG4gICAgfVxuICB9XG5cbiAgcHJldlsxXSArPSB1eTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gc3ViZGl2aWRlIHVwIHRvIGFjY3VyYWN5IG9mIDAuNSBkZWdyZWVzXG5jb25zdCBNSU5fUkFESUFOUyA9IDAuNSAqIE1hdGguUEkgLyAxODA7IC8vIEFkYXB0aXZlbHkgc2FtcGxlIGFuIGludGVycG9sYXRlZCBmdW5jdGlvbiBvdmVyIGEgZG9tYWluIGV4dGVudFxuXG5mdW5jdGlvbiBzYW1wbGVDdXJ2ZSAoZiwgZXh0ZW50LCBtaW5TdGVwcywgbWF4U3RlcHMpIHtcbiAgbWluU3RlcHMgPSBtaW5TdGVwcyB8fCAyNTtcbiAgbWF4U3RlcHMgPSBNYXRoLm1heChtaW5TdGVwcywgbWF4U3RlcHMgfHwgMjAwKTtcblxuICBjb25zdCBwb2ludCA9IHggPT4gW3gsIGYoeCldLFxuICAgICAgICBtaW5YID0gZXh0ZW50WzBdLFxuICAgICAgICBtYXhYID0gZXh0ZW50WzFdLFxuICAgICAgICBzcGFuID0gbWF4WCAtIG1pblgsXG4gICAgICAgIHN0b3AgPSBzcGFuIC8gbWF4U3RlcHMsXG4gICAgICAgIHByZXYgPSBbcG9pbnQobWluWCldLFxuICAgICAgICBuZXh0ID0gW107XG5cbiAgaWYgKG1pblN0ZXBzID09PSBtYXhTdGVwcykge1xuICAgIC8vIG5vIGFkYXB0YXRpb24sIHNhbXBsZSB1bmlmb3JtIGdyaWQgZGlyZWN0bHkgYW5kIHJldHVyblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF4U3RlcHM7ICsraSkge1xuICAgICAgcHJldi5wdXNoKHBvaW50KG1pblggKyBpIC8gbWluU3RlcHMgKiBzcGFuKSk7XG4gICAgfVxuXG4gICAgcHJldi5wdXNoKHBvaW50KG1heFgpKTtcbiAgICByZXR1cm4gcHJldjtcbiAgfSBlbHNlIHtcbiAgICAvLyBzYW1wbGUgbWluaW11bSBwb2ludHMgb24gdW5pZm9ybSBncmlkXG4gICAgLy8gdGhlbiBtb3ZlIG9uIHRvIHBlcmZvcm0gYWRhcHRpdmUgcmVmaW5lbWVudFxuICAgIG5leHQucHVzaChwb2ludChtYXhYKSk7XG5cbiAgICBmb3IgKGxldCBpID0gbWluU3RlcHM7IC0taSA+IDA7KSB7XG4gICAgICBuZXh0LnB1c2gocG9pbnQobWluWCArIGkgLyBtaW5TdGVwcyAqIHNwYW4pKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcDAgPSBwcmV2WzBdO1xuICBsZXQgcDEgPSBuZXh0W25leHQubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHN4ID0gMSAvIHNwYW47XG4gIGNvbnN0IHN5ID0gc2NhbGVZKHAwWzFdLCBuZXh0KTtcblxuICB3aGlsZSAocDEpIHtcbiAgICAvLyBtaWRwb2ludCBmb3IgcG90ZW50aWFsIGN1cnZlIHN1YmRpdmlzaW9uXG4gICAgY29uc3QgcG0gPSBwb2ludCgocDBbMF0gKyBwMVswXSkgLyAyKTtcbiAgICBjb25zdCBkeCA9IHBtWzBdIC0gcDBbMF0gPj0gc3RvcDtcblxuICAgIGlmIChkeCAmJiBhbmdsZURlbHRhKHAwLCBwbSwgcDEsIHN4LCBzeSkgPiBNSU5fUkFESUFOUykge1xuICAgICAgLy8gbWF4aW11bSByZXNvbHV0aW9uIGhhcyBub3QgeWV0IGJlZW4gbWV0LCBhbmRcbiAgICAgIC8vIHN1YmRpdmlzaW9uIG1pZHBvaW50IGlzIHN1ZmZpY2llbnRseSBkaWZmZXJlbnQgZnJvbSBlbmRwb2ludFxuICAgICAgLy8gc2F2ZSBzdWJkaXZpc2lvbiwgcHVzaCBtaWRwb2ludCBvbnRvIHRoZSB2aXNpdGF0aW9uIHN0YWNrXG4gICAgICBuZXh0LnB1c2gocG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWJkaXZpc2lvbiBtaWRwb2ludCBzdWZmaWNpZW50bHkgc2ltaWxhciB0byBlbmRwb2ludFxuICAgICAgLy8gc2tpcCBzdWJkaXZpc2lvbiwgc3RvcmUgZW5kcG9pbnQsIG1vdmUgdG8gbmV4dCBwb2ludCBvbiB0aGUgc3RhY2tcbiAgICAgIHAwID0gcDE7XG4gICAgICBwcmV2LnB1c2gocDEpO1xuICAgICAgbmV4dC5wb3AoKTtcbiAgICB9XG5cbiAgICBwMSA9IG5leHRbbmV4dC5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHJldHVybiBwcmV2O1xufVxuXG5mdW5jdGlvbiBzY2FsZVkoaW5pdCwgcG9pbnRzKSB7XG4gIGxldCB5bWluID0gaW5pdDtcbiAgbGV0IHltYXggPSBpbml0O1xuICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IHkgPSBwb2ludHNbaV1bMV07XG4gICAgaWYgKHkgPCB5bWluKSB5bWluID0geTtcbiAgICBpZiAoeSA+IHltYXgpIHltYXggPSB5O1xuICB9XG5cbiAgcmV0dXJuIDEgLyAoeW1heCAtIHltaW4pO1xufVxuXG5mdW5jdGlvbiBhbmdsZURlbHRhKHAsIHEsIHIsIHN4LCBzeSkge1xuICBjb25zdCBhMCA9IE1hdGguYXRhbjIoc3kgKiAoclsxXSAtIHBbMV0pLCBzeCAqIChyWzBdIC0gcFswXSkpLFxuICAgICAgICBhMSA9IE1hdGguYXRhbjIoc3kgKiAocVsxXSAtIHBbMV0pLCBzeCAqIChxWzBdIC0gcFswXSkpO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBhMSk7XG59XG5cbmV4cG9ydCB7IGVzdGltYXRlQmFuZHdpZHRoIGFzIGJhbmR3aWR0aE5SRCwgYmluLCBib290c3RyYXBDSSwgY3VtdWxhdGl2ZUxvZ05vcm1hbCwgY3VtdWxhdGl2ZU5vcm1hbCwgY3VtdWxhdGl2ZVVuaWZvcm0sIGRlbnNpdHlMb2dOb3JtYWwsIGRlbnNpdHlOb3JtYWwsIGRlbnNpdHlVbmlmb3JtLCBkb3RiaW4sIHF1YW50aWxlTG9nTm9ybWFsLCBxdWFudGlsZU5vcm1hbCwgcXVhbnRpbGVVbmlmb3JtLCBxdWFudGlsZXMsIHF1YXJ0aWxlcywgcmFuZG9tLCBpbnRlZ2VyIGFzIHJhbmRvbUludGVnZXIsIGtkZSBhcyByYW5kb21LREUsIGxjZyBhcyByYW5kb21MQ0csIGxvZ25vcm1hbCBhcyByYW5kb21Mb2dOb3JtYWwsIG1peHR1cmUgYXMgcmFuZG9tTWl4dHVyZSwgZ2F1c3NpYW4gYXMgcmFuZG9tTm9ybWFsLCB1bmlmb3JtIGFzIHJhbmRvbVVuaWZvcm0sIGV4cCBhcyByZWdyZXNzaW9uRXhwLCBsaW5lYXIgYXMgcmVncmVzc2lvbkxpbmVhciwgbG9lc3MgYXMgcmVncmVzc2lvbkxvZXNzLCBsb2cgYXMgcmVncmVzc2lvbkxvZywgcG9seSBhcyByZWdyZXNzaW9uUG9seSwgcG93IGFzIHJlZ3Jlc3Npb25Qb3csIHF1YWQgYXMgcmVncmVzc2lvblF1YWQsIHNhbXBsZUN1cnZlLCBzYW1wbGVMb2dOb3JtYWwsIHNhbXBsZU5vcm1hbCwgc2FtcGxlVW5pZm9ybSwgc2V0UmFuZG9tIH07XG4iLCJpbXBvcnQgeyBhcnJheSwgZXJyb3IsIGhhc093blByb3BlcnR5LCBleHRlbmQsIHBlZWssIHRvU2V0LCBjb25zdGFudCwgemVybywgb25lLCBzcGFuIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHRpbWVEYXksIHRpbWVXZWVrLCB1dGNEYXksIHV0Y1dlZWssIHRpbWVZZWFyLCB0aW1lTW9udGgsIHRpbWVIb3VyLCB0aW1lTWludXRlLCB0aW1lU2Vjb25kLCB0aW1lTWlsbGlzZWNvbmQsIHV0Y1llYXIsIHV0Y01vbnRoLCB1dGNIb3VyLCB1dGNNaW51dGUsIHV0Y1NlY29uZCwgdXRjTWlsbGlzZWNvbmQgfSBmcm9tICdkMy10aW1lJztcbmltcG9ydCB7IGJpc2VjdG9yLCB0aWNrU3RlcCB9IGZyb20gJ2QzLWFycmF5JztcblxuY29uc3QgWUVBUiA9ICd5ZWFyJztcbmNvbnN0IFFVQVJURVIgPSAncXVhcnRlcic7XG5jb25zdCBNT05USCA9ICdtb250aCc7XG5jb25zdCBXRUVLID0gJ3dlZWsnO1xuY29uc3QgREFURSA9ICdkYXRlJztcbmNvbnN0IERBWSA9ICdkYXknO1xuY29uc3QgREFZT0ZZRUFSID0gJ2RheW9meWVhcic7XG5jb25zdCBIT1VSUyA9ICdob3Vycyc7XG5jb25zdCBNSU5VVEVTID0gJ21pbnV0ZXMnO1xuY29uc3QgU0VDT05EUyA9ICdzZWNvbmRzJztcbmNvbnN0IE1JTExJU0VDT05EUyA9ICdtaWxsaXNlY29uZHMnO1xuY29uc3QgVElNRV9VTklUUyA9IFtZRUFSLCBRVUFSVEVSLCBNT05USCwgV0VFSywgREFURSwgREFZLCBEQVlPRllFQVIsIEhPVVJTLCBNSU5VVEVTLCBTRUNPTkRTLCBNSUxMSVNFQ09ORFNdO1xuY29uc3QgVU5JVFMgPSBUSU1FX1VOSVRTLnJlZHVjZSgobywgdSwgaSkgPT4gKG9bdV0gPSAxICsgaSwgbyksIHt9KTtcbmZ1bmN0aW9uIHRpbWVVbml0cyh1bml0cykge1xuICBjb25zdCB1ID0gYXJyYXkodW5pdHMpLnNsaWNlKCksXG4gICAgICAgIG0gPSB7fTsgLy8gY2hlY2sgdmFsaWRpdHlcblxuICBpZiAoIXUubGVuZ3RoKSBlcnJvcignTWlzc2luZyB0aW1lIHVuaXQuJyk7XG4gIHUuZm9yRWFjaCh1bml0ID0+IHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoVU5JVFMsIHVuaXQpKSB7XG4gICAgICBtW3VuaXRdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoXCJJbnZhbGlkIHRpbWUgdW5pdDogXCIuY29uY2F0KHVuaXQsIFwiLlwiKSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbnVtVHlwZXMgPSAobVtXRUVLXSB8fCBtW0RBWV0gPyAxIDogMCkgKyAobVtRVUFSVEVSXSB8fCBtW01PTlRIXSB8fCBtW0RBVEVdID8gMSA6IDApICsgKG1bREFZT0ZZRUFSXSA/IDEgOiAwKTtcblxuICBpZiAobnVtVHlwZXMgPiAxKSB7XG4gICAgZXJyb3IoXCJJbmNvbXBhdGlibGUgdGltZSB1bml0czogXCIuY29uY2F0KHVuaXRzKSk7XG4gIH0gLy8gZW5zdXJlIHByb3BlciBzb3J0IG9yZGVyXG5cblxuICB1LnNvcnQoKGEsIGIpID0+IFVOSVRTW2FdIC0gVU5JVFNbYl0pO1xuICByZXR1cm4gdTtcbn1cbmNvbnN0IGRlZmF1bHRTcGVjaWZpZXJzID0ge1xuICBbWUVBUl06ICclWSAnLFxuICBbUVVBUlRFUl06ICdRJXEgJyxcbiAgW01PTlRIXTogJyViICcsXG4gIFtEQVRFXTogJyVkICcsXG4gIFtXRUVLXTogJ1clVSAnLFxuICBbREFZXTogJyVhICcsXG4gIFtEQVlPRllFQVJdOiAnJWogJyxcbiAgW0hPVVJTXTogJyVIOjAwJyxcbiAgW01JTlVURVNdOiAnMDA6JU0nLFxuICBbU0VDT05EU106ICc6JVMnLFxuICBbTUlMTElTRUNPTkRTXTogJy4lTCcsXG4gIFtcIlwiLmNvbmNhdChZRUFSLCBcIi1cIikuY29uY2F0KE1PTlRIKV06ICclWS0lbSAnLFxuICBbXCJcIi5jb25jYXQoWUVBUiwgXCItXCIpLmNvbmNhdChNT05USCwgXCItXCIpLmNvbmNhdChEQVRFKV06ICclWS0lbS0lZCAnLFxuICBbXCJcIi5jb25jYXQoSE9VUlMsIFwiLVwiKS5jb25jYXQoTUlOVVRFUyldOiAnJUg6JU0nXG59O1xuZnVuY3Rpb24gdGltZVVuaXRTcGVjaWZpZXIodW5pdHMsIHNwZWNpZmllcnMpIHtcbiAgY29uc3QgcyA9IGV4dGVuZCh7fSwgZGVmYXVsdFNwZWNpZmllcnMsIHNwZWNpZmllcnMpLFxuICAgICAgICB1ID0gdGltZVVuaXRzKHVuaXRzKSxcbiAgICAgICAgbiA9IHUubGVuZ3RoO1xuICBsZXQgZm10ID0gJycsXG4gICAgICBzdGFydCA9IDAsXG4gICAgICBlbmQsXG4gICAgICBrZXk7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbjspIHtcbiAgICBmb3IgKGVuZCA9IHUubGVuZ3RoOyBlbmQgPiBzdGFydDsgLS1lbmQpIHtcbiAgICAgIGtleSA9IHUuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignLScpO1xuXG4gICAgICBpZiAoc1trZXldICE9IG51bGwpIHtcbiAgICAgICAgZm10ICs9IHNba2V5XTtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbXQudHJpbSgpO1xufVxuXG5jb25zdCB0MCA9IG5ldyBEYXRlKCk7XG5cbmZ1bmN0aW9uIGxvY2FsWWVhcih5KSB7XG4gIHQwLnNldEZ1bGxZZWFyKHkpO1xuICB0MC5zZXRNb250aCgwKTtcbiAgdDAuc2V0RGF0ZSgxKTtcbiAgdDAuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiB0MDtcbn1cblxuZnVuY3Rpb24gZGF5b2Z5ZWFyKGQpIHtcbiAgcmV0dXJuIGxvY2FsRGF5T2ZZZWFyKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIHdlZWsoZCkge1xuICByZXR1cm4gbG9jYWxXZWVrTnVtKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIGxvY2FsRGF5T2ZZZWFyKGQpIHtcbiAgcmV0dXJuIHRpbWVEYXkuY291bnQobG9jYWxZZWFyKGQuZ2V0RnVsbFllYXIoKSkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIGxvY2FsV2Vla051bShkKSB7XG4gIHJldHVybiB0aW1lV2Vlay5jb3VudChsb2NhbFllYXIoZC5nZXRGdWxsWWVhcigpKSAtIDEsIGQpO1xufVxuZnVuY3Rpb24gbG9jYWxGaXJzdCh5KSB7XG4gIHJldHVybiBsb2NhbFllYXIoeSkuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBsb2NhbERhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCkge1xuICBpZiAoMCA8PSB5ICYmIHkgPCAxMDApIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoLTEsIG0sIGQsIEgsIE0sIFMsIEwpO1xuICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCk7XG59XG5mdW5jdGlvbiB1dGNkYXlvZnllYXIoZCkge1xuICByZXR1cm4gdXRjRGF5T2ZZZWFyKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIHV0Y3dlZWsoZCkge1xuICByZXR1cm4gdXRjV2Vla051bShuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiB1dGNEYXlPZlllYXIoZCkge1xuICBjb25zdCB5ID0gRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKTtcbiAgcmV0dXJuIHV0Y0RheS5jb3VudCh5IC0gMSwgZCk7XG59XG5mdW5jdGlvbiB1dGNXZWVrTnVtKGQpIHtcbiAgY29uc3QgeSA9IERhdGUuVVRDKGQuZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSk7XG4gIHJldHVybiB1dGNXZWVrLmNvdW50KHkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIHV0Y0ZpcnN0KHkpIHtcbiAgdDAuc2V0VGltZShEYXRlLlVUQyh5LCAwLCAxKSk7XG4gIHJldHVybiB0MC5nZXRVVENEYXkoKTtcbn1cbmZ1bmN0aW9uIHV0Y0RhdGUoeSwgbSwgZCwgSCwgTSwgUywgTCkge1xuICBpZiAoMCA8PSB5ICYmIHkgPCAxMDApIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoLTEsIG0sIGQsIEgsIE0sIFMsIEwpKTtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgZCwgSCwgTSwgUywgTCkpO1xufVxuXG5mdW5jdGlvbiBmbG9vcih1bml0cywgc3RlcCwgZ2V0LCBpbnYsIG5ld0RhdGUpIHtcbiAgY29uc3QgcyA9IHN0ZXAgfHwgMSxcbiAgICAgICAgYiA9IHBlZWsodW5pdHMpLFxuICAgICAgICBfID0gKHVuaXQsIHAsIGtleSkgPT4ge1xuICAgIGtleSA9IGtleSB8fCB1bml0O1xuICAgIHJldHVybiBnZXRVbml0KGdldFtrZXldLCBpbnZba2V5XSwgdW5pdCA9PT0gYiAmJiBzLCBwKTtcbiAgfTtcblxuICBjb25zdCB0ID0gbmV3IERhdGUoKSxcbiAgICAgICAgdSA9IHRvU2V0KHVuaXRzKSxcbiAgICAgICAgeSA9IHVbWUVBUl0gPyBfKFlFQVIpIDogY29uc3RhbnQoMjAxMiksXG4gICAgICAgIG0gPSB1W01PTlRIXSA/IF8oTU9OVEgpIDogdVtRVUFSVEVSXSA/IF8oUVVBUlRFUikgOiB6ZXJvLFxuICAgICAgICBkID0gdVtXRUVLXSAmJiB1W0RBWV0gPyBfKERBWSwgMSwgV0VFSyArIERBWSkgOiB1W1dFRUtdID8gXyhXRUVLLCAxKSA6IHVbREFZXSA/IF8oREFZLCAxKSA6IHVbREFURV0gPyBfKERBVEUsIDEpIDogdVtEQVlPRllFQVJdID8gXyhEQVlPRllFQVIsIDEpIDogb25lLFxuICAgICAgICBIID0gdVtIT1VSU10gPyBfKEhPVVJTKSA6IHplcm8sXG4gICAgICAgIE0gPSB1W01JTlVURVNdID8gXyhNSU5VVEVTKSA6IHplcm8sXG4gICAgICAgIFMgPSB1W1NFQ09ORFNdID8gXyhTRUNPTkRTKSA6IHplcm8sXG4gICAgICAgIEwgPSB1W01JTExJU0VDT05EU10gPyBfKE1JTExJU0VDT05EUykgOiB6ZXJvO1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB0LnNldFRpbWUoK3YpO1xuICAgIGNvbnN0IHllYXIgPSB5KHQpO1xuICAgIHJldHVybiBuZXdEYXRlKHllYXIsIG0odCksIGQodCwgeWVhciksIEgodCksIE0odCksIFModCksIEwodCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRVbml0KGYsIGludiwgc3RlcCwgcGhhc2UpIHtcbiAgY29uc3QgdSA9IHN0ZXAgPD0gMSA/IGYgOiBwaGFzZSA/IChkLCB5KSA9PiBwaGFzZSArIHN0ZXAgKiBNYXRoLmZsb29yKChmKGQsIHkpIC0gcGhhc2UpIC8gc3RlcCkgOiAoZCwgeSkgPT4gc3RlcCAqIE1hdGguZmxvb3IoZihkLCB5KSAvIHN0ZXApO1xuICByZXR1cm4gaW52ID8gKGQsIHkpID0+IGludih1KGQsIHkpLCB5KSA6IHU7XG59IC8vIHJldHVybnMgdGhlIGRheSBvZiB0aGUgeWVhciBiYXNlZCBvbiB3ZWVrIG51bWJlciwgZGF5IG9mIHdlZWssXG4vLyBhbmQgdGhlIGRheSBvZiB0aGUgd2VlayBmb3IgdGhlIGZpcnN0IGRheSBvZiB0aGUgeWVhclxuXG5cbmZ1bmN0aW9uIHdlZWtkYXkod2VlaywgZGF5LCBmaXJzdERheSkge1xuICByZXR1cm4gZGF5ICsgd2VlayAqIDcgLSAoZmlyc3REYXkgKyA2KSAlIDc7XG59IC8vIC0tIExPQ0FMIFRJTUUgLS1cblxuXG5jb25zdCBsb2NhbEdldCA9IHtcbiAgW1lFQVJdOiBkID0+IGQuZ2V0RnVsbFllYXIoKSxcbiAgW1FVQVJURVJdOiBkID0+IE1hdGguZmxvb3IoZC5nZXRNb250aCgpIC8gMyksXG4gIFtNT05USF06IGQgPT4gZC5nZXRNb250aCgpLFxuICBbREFURV06IGQgPT4gZC5nZXREYXRlKCksXG4gIFtIT1VSU106IGQgPT4gZC5nZXRIb3VycygpLFxuICBbTUlOVVRFU106IGQgPT4gZC5nZXRNaW51dGVzKCksXG4gIFtTRUNPTkRTXTogZCA9PiBkLmdldFNlY29uZHMoKSxcbiAgW01JTExJU0VDT05EU106IGQgPT4gZC5nZXRNaWxsaXNlY29uZHMoKSxcbiAgW0RBWU9GWUVBUl06IGQgPT4gbG9jYWxEYXlPZlllYXIoZCksXG4gIFtXRUVLXTogZCA9PiBsb2NhbFdlZWtOdW0oZCksXG4gIFtXRUVLICsgREFZXTogKGQsIHkpID0+IHdlZWtkYXkobG9jYWxXZWVrTnVtKGQpLCBkLmdldERheSgpLCBsb2NhbEZpcnN0KHkpKSxcbiAgW0RBWV06IChkLCB5KSA9PiB3ZWVrZGF5KDEsIGQuZ2V0RGF5KCksIGxvY2FsRmlyc3QoeSkpXG59O1xuY29uc3QgbG9jYWxJbnYgPSB7XG4gIFtRVUFSVEVSXTogcSA9PiAzICogcSxcbiAgW1dFRUtdOiAodywgeSkgPT4gd2Vla2RheSh3LCAwLCBsb2NhbEZpcnN0KHkpKVxufTtcbmZ1bmN0aW9uIHRpbWVGbG9vcih1bml0cywgc3RlcCkge1xuICByZXR1cm4gZmxvb3IodW5pdHMsIHN0ZXAgfHwgMSwgbG9jYWxHZXQsIGxvY2FsSW52LCBsb2NhbERhdGUpO1xufSAvLyAtLSBVVEMgVElNRSAtLVxuXG5jb25zdCB1dGNHZXQgPSB7XG4gIFtZRUFSXTogZCA9PiBkLmdldFVUQ0Z1bGxZZWFyKCksXG4gIFtRVUFSVEVSXTogZCA9PiBNYXRoLmZsb29yKGQuZ2V0VVRDTW9udGgoKSAvIDMpLFxuICBbTU9OVEhdOiBkID0+IGQuZ2V0VVRDTW9udGgoKSxcbiAgW0RBVEVdOiBkID0+IGQuZ2V0VVRDRGF0ZSgpLFxuICBbSE9VUlNdOiBkID0+IGQuZ2V0VVRDSG91cnMoKSxcbiAgW01JTlVURVNdOiBkID0+IGQuZ2V0VVRDTWludXRlcygpLFxuICBbU0VDT05EU106IGQgPT4gZC5nZXRVVENTZWNvbmRzKCksXG4gIFtNSUxMSVNFQ09ORFNdOiBkID0+IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIFtEQVlPRllFQVJdOiBkID0+IHV0Y0RheU9mWWVhcihkKSxcbiAgW1dFRUtdOiBkID0+IHV0Y1dlZWtOdW0oZCksXG4gIFtEQVldOiAoZCwgeSkgPT4gd2Vla2RheSgxLCBkLmdldFVUQ0RheSgpLCB1dGNGaXJzdCh5KSksXG4gIFtXRUVLICsgREFZXTogKGQsIHkpID0+IHdlZWtkYXkodXRjV2Vla051bShkKSwgZC5nZXRVVENEYXkoKSwgdXRjRmlyc3QoeSkpXG59O1xuY29uc3QgdXRjSW52ID0ge1xuICBbUVVBUlRFUl06IHEgPT4gMyAqIHEsXG4gIFtXRUVLXTogKHcsIHkpID0+IHdlZWtkYXkodywgMCwgdXRjRmlyc3QoeSkpXG59O1xuZnVuY3Rpb24gdXRjRmxvb3IodW5pdHMsIHN0ZXApIHtcbiAgcmV0dXJuIGZsb29yKHVuaXRzLCBzdGVwIHx8IDEsIHV0Y0dldCwgdXRjSW52LCB1dGNEYXRlKTtcbn1cblxuY29uc3QgdGltZUludGVydmFscyA9IHtcbiAgW1lFQVJdOiB0aW1lWWVhcixcbiAgW1FVQVJURVJdOiB0aW1lTW9udGguZXZlcnkoMyksXG4gIFtNT05USF06IHRpbWVNb250aCxcbiAgW1dFRUtdOiB0aW1lV2VlayxcbiAgW0RBVEVdOiB0aW1lRGF5LFxuICBbREFZXTogdGltZURheSxcbiAgW0RBWU9GWUVBUl06IHRpbWVEYXksXG4gIFtIT1VSU106IHRpbWVIb3VyLFxuICBbTUlOVVRFU106IHRpbWVNaW51dGUsXG4gIFtTRUNPTkRTXTogdGltZVNlY29uZCxcbiAgW01JTExJU0VDT05EU106IHRpbWVNaWxsaXNlY29uZFxufTtcbmNvbnN0IHV0Y0ludGVydmFscyA9IHtcbiAgW1lFQVJdOiB1dGNZZWFyLFxuICBbUVVBUlRFUl06IHV0Y01vbnRoLmV2ZXJ5KDMpLFxuICBbTU9OVEhdOiB1dGNNb250aCxcbiAgW1dFRUtdOiB1dGNXZWVrLFxuICBbREFURV06IHV0Y0RheSxcbiAgW0RBWV06IHV0Y0RheSxcbiAgW0RBWU9GWUVBUl06IHV0Y0RheSxcbiAgW0hPVVJTXTogdXRjSG91cixcbiAgW01JTlVURVNdOiB1dGNNaW51dGUsXG4gIFtTRUNPTkRTXTogdXRjU2Vjb25kLFxuICBbTUlMTElTRUNPTkRTXTogdXRjTWlsbGlzZWNvbmRcbn07XG5mdW5jdGlvbiB0aW1lSW50ZXJ2YWwodW5pdCkge1xuICByZXR1cm4gdGltZUludGVydmFsc1t1bml0XTtcbn1cbmZ1bmN0aW9uIHV0Y0ludGVydmFsKHVuaXQpIHtcbiAgcmV0dXJuIHV0Y0ludGVydmFsc1t1bml0XTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KGl2YWwsIGRhdGUsIHN0ZXApIHtcbiAgcmV0dXJuIGl2YWwgPyBpdmFsLm9mZnNldChkYXRlLCBzdGVwKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdGltZU9mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodGltZUludGVydmFsKHVuaXQpLCBkYXRlLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIHV0Y09mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodXRjSW50ZXJ2YWwodW5pdCksIGRhdGUsIHN0ZXApO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW5jZShpdmFsLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICByZXR1cm4gaXZhbCA/IGl2YWwucmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB0aW1lU2VxdWVuY2UodW5pdCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHRpbWVJbnRlcnZhbCh1bml0KSwgc3RhcnQsIHN0b3AsIHN0ZXApO1xufVxuZnVuY3Rpb24gdXRjU2VxdWVuY2UodW5pdCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIHNlcXVlbmNlKHV0Y0ludGVydmFsKHVuaXQpLCBzdGFydCwgc3RvcCwgc3RlcCk7XG59XG5cbmNvbnN0IGR1cmF0aW9uU2Vjb25kID0gMTAwMCxcbiAgICAgIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MCxcbiAgICAgIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gICAgICBkdXJhdGlvbkRheSA9IGR1cmF0aW9uSG91ciAqIDI0LFxuICAgICAgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3LFxuICAgICAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gICAgICBkdXJhdGlvblllYXIgPSBkdXJhdGlvbkRheSAqIDM2NTtcbmNvbnN0IE1pbGxpID0gW1lFQVIsIE1PTlRILCBEQVRFLCBIT1VSUywgTUlOVVRFUywgU0VDT05EUywgTUlMTElTRUNPTkRTXSxcbiAgICAgIFNlY29uZHMgPSBNaWxsaS5zbGljZSgwLCAtMSksXG4gICAgICBNaW51dGVzID0gU2Vjb25kcy5zbGljZSgwLCAtMSksXG4gICAgICBIb3VycyA9IE1pbnV0ZXMuc2xpY2UoMCwgLTEpLFxuICAgICAgRGF5ID0gSG91cnMuc2xpY2UoMCwgLTEpLFxuICAgICAgV2VlayA9IFtZRUFSLCBXRUVLXSxcbiAgICAgIE1vbnRoID0gW1lFQVIsIE1PTlRIXSxcbiAgICAgIFllYXIgPSBbWUVBUl07XG5jb25zdCBpbnRlcnZhbHMgPSBbW1NlY29uZHMsIDEsIGR1cmF0aW9uU2Vjb25kXSwgW1NlY29uZHMsIDUsIDUgKiBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCAxNSwgMTUgKiBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sIFtNaW51dGVzLCAxLCBkdXJhdGlvbk1pbnV0ZV0sIFtNaW51dGVzLCA1LCA1ICogZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgMTUsIDE1ICogZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLCBbSG91cnMsIDEsIGR1cmF0aW9uSG91cl0sIFtIb3VycywgMywgMyAqIGR1cmF0aW9uSG91cl0sIFtIb3VycywgNiwgNiAqIGR1cmF0aW9uSG91cl0sIFtIb3VycywgMTIsIDEyICogZHVyYXRpb25Ib3VyXSwgW0RheSwgMSwgZHVyYXRpb25EYXldLCBbV2VlaywgMSwgZHVyYXRpb25XZWVrXSwgW01vbnRoLCAxLCBkdXJhdGlvbk1vbnRoXSwgW01vbnRoLCAzLCAzICogZHVyYXRpb25Nb250aF0sIFtZZWFyLCAxLCBkdXJhdGlvblllYXJdXTtcbmZ1bmN0aW9uIGJpbiAob3B0KSB7XG4gIGNvbnN0IGV4dCA9IG9wdC5leHRlbnQsXG4gICAgICAgIG1heCA9IG9wdC5tYXhiaW5zIHx8IDQwLFxuICAgICAgICB0YXJnZXQgPSBNYXRoLmFicyhzcGFuKGV4dCkpIC8gbWF4O1xuICBsZXQgaSA9IGJpc2VjdG9yKGkgPT4gaVsyXSkucmlnaHQoaW50ZXJ2YWxzLCB0YXJnZXQpLFxuICAgICAgdW5pdHMsXG4gICAgICBzdGVwO1xuXG4gIGlmIChpID09PSBpbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgdW5pdHMgPSBZZWFyLCBzdGVwID0gdGlja1N0ZXAoZXh0WzBdIC8gZHVyYXRpb25ZZWFyLCBleHRbMV0gLyBkdXJhdGlvblllYXIsIG1heCk7XG4gIH0gZWxzZSBpZiAoaSkge1xuICAgIGkgPSBpbnRlcnZhbHNbdGFyZ2V0IC8gaW50ZXJ2YWxzW2kgLSAxXVsyXSA8IGludGVydmFsc1tpXVsyXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgdW5pdHMgPSBpWzBdO1xuICAgIHN0ZXAgPSBpWzFdO1xuICB9IGVsc2Uge1xuICAgIHVuaXRzID0gTWlsbGk7XG4gICAgc3RlcCA9IE1hdGgubWF4KHRpY2tTdGVwKGV4dFswXSwgZXh0WzFdLCBtYXgpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdW5pdHMsXG4gICAgc3RlcFxuICB9O1xufVxuXG5leHBvcnQgeyBEQVRFLCBEQVksIERBWU9GWUVBUiwgSE9VUlMsIE1JTExJU0VDT05EUywgTUlOVVRFUywgTU9OVEgsIFFVQVJURVIsIFNFQ09ORFMsIFRJTUVfVU5JVFMsIFdFRUssIFlFQVIsIGRheW9meWVhciwgYmluIGFzIHRpbWVCaW4sIHRpbWVGbG9vciwgdGltZUludGVydmFsLCB0aW1lT2Zmc2V0LCB0aW1lU2VxdWVuY2UsIHRpbWVVbml0U3BlY2lmaWVyLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB1dGNJbnRlcnZhbCwgdXRjT2Zmc2V0LCB1dGNTZXF1ZW5jZSwgdXRjZGF5b2Z5ZWFyLCB1dGN3ZWVrLCB3ZWVrIH07XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlkZW50aXR5LCBmaWVsZCwgaGFzT3duUHJvcGVydHksIGV4dGVudEluZGV4LCBpbmhlcml0cywgYXJyYXksIGFjY2Vzc29yTmFtZSwgZXJyb3IsIGFjY2Vzc29yRmllbGRzLCBhY2Nlc3NvciwgdG9OdW1iZXIsIG1lcmdlLCBjb21wYXJlLCB0cnV0aHksIGV4dGVudCwgc3BhbiwgZmFzdG1hcCwgaXNBcnJheSwga2V5LCBhc2NlbmRpbmcsIHBlZWssIHplcm8sIGNvbnN0YW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHR1cGxlaWQsIFRyYW5zZm9ybSwgcmVwbGFjZSwgaW5nZXN0LCBzdGFibGVDb21wYXJlLCBPcGVyYXRvciwgZGVyaXZlLCByZWRlcml2ZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgcXVhcnRpbGVzLCBib290c3RyYXBDSSwgYmluLCByYW5kb21LREUsIHJhbmRvbU1peHR1cmUsIHJhbmRvbU5vcm1hbCwgcmFuZG9tTG9nTm9ybWFsLCByYW5kb21Vbmlmb3JtLCBzYW1wbGVDdXJ2ZSwgZG90YmluLCBxdWFudGlsZXMsIHJhbmRvbSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBtZWRpYW4sIG1lYW4sIG1pbiwgbWF4LCByYW5nZSwgYmlzZWN0b3IgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBUSU1FX1VOSVRTLCB1dGNJbnRlcnZhbCwgdGltZUludGVydmFsLCB0aW1lQmluLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB0aW1lRmxvb3IgfSBmcm9tICd2ZWdhLXRpbWUnO1xuXG5mdW5jdGlvbiBtdWx0aWtleShmKSB7XG4gIHJldHVybiB4ID0+IHtcbiAgICBjb25zdCBuID0gZi5sZW5ndGg7XG4gICAgbGV0IGkgPSAxLFxuICAgICAgICBrID0gU3RyaW5nKGZbMF0oeCkpO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGsgKz0gJ3wnICsgZltpXSh4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaztcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3Vwa2V5KGZpZWxkcykge1xuICByZXR1cm4gIWZpZWxkcyB8fCAhZmllbGRzLmxlbmd0aCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gOiBmaWVsZHMubGVuZ3RoID09PSAxID8gZmllbGRzWzBdIDogbXVsdGlrZXkoZmllbGRzKTtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZU5hbWUob3AsIGZpZWxkLCBhcykge1xuICByZXR1cm4gYXMgfHwgb3AgKyAoIWZpZWxkID8gJycgOiAnXycgKyBmaWVsZCk7XG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcblxuY29uc3QgYmFzZV9vcCA9IHtcbiAgaW5pdDogbm9vcCxcbiAgYWRkOiBub29wLFxuICByZW06IG5vb3AsXG4gIGlkeDogMFxufTtcbmNvbnN0IEFnZ3JlZ2F0ZU9wcyA9IHtcbiAgdmFsdWVzOiB7XG4gICAgaW5pdDogbSA9PiBtLmNlbGwuc3RvcmUgPSB0cnVlLFxuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnZhbHVlcygpLFxuICAgIGlkeDogLTFcbiAgfSxcbiAgY291bnQ6IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwubnVtXG4gIH0sXG4gIF9fY291bnRfXzoge1xuICAgIHZhbHVlOiBtID0+IG0ubWlzc2luZyArIG0udmFsaWRcbiAgfSxcbiAgbWlzc2luZzoge1xuICAgIHZhbHVlOiBtID0+IG0ubWlzc2luZ1xuICB9LFxuICB2YWxpZDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWRcbiAgfSxcbiAgc3VtOiB7XG4gICAgaW5pdDogbSA9PiBtLnN1bSA9IDAsXG4gICAgdmFsdWU6IG0gPT4gbS5zdW0sXG4gICAgYWRkOiAobSwgdikgPT4gbS5zdW0gKz0gK3YsXG4gICAgcmVtOiAobSwgdikgPT4gbS5zdW0gLT0gdlxuICB9LFxuICBwcm9kdWN0OiB7XG4gICAgaW5pdDogbSA9PiBtLnByb2R1Y3QgPSAxLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPyBtLnByb2R1Y3QgOiB1bmRlZmluZWQsXG4gICAgYWRkOiAobSwgdikgPT4gbS5wcm9kdWN0ICo9IHYsXG4gICAgcmVtOiAobSwgdikgPT4gbS5wcm9kdWN0IC89IHZcbiAgfSxcbiAgbWVhbjoge1xuICAgIGluaXQ6IG0gPT4gbS5tZWFuID0gMCxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID8gbS5tZWFuIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiArPSBtLm1lYW5fZCAvIG0udmFsaWQpLFxuICAgIHJlbTogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiAtPSBtLnZhbGlkID8gbS5tZWFuX2QgLyBtLnZhbGlkIDogbS5tZWFuKVxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0ubWVhbiA6IHVuZGVmaW5lZCxcbiAgICByZXE6IFsnbWVhbiddLFxuICAgIGlkeDogMVxuICB9LFxuICB2YXJpYW5jZToge1xuICAgIGluaXQ6IG0gPT4gbS5kZXYgPSAwLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyAobS52YWxpZCAtIDEpIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IG0uZGV2ICs9IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlbTogKG0sIHYpID0+IG0uZGV2IC09IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlcTogWydtZWFuJ10sXG4gICAgaWR4OiAxXG4gIH0sXG4gIHZhcmlhbmNlcDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyBtLnZhbGlkIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBzdGRldjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgLSAxKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGV2cDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gbS52YWxpZCkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGVycjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgKiAobS52YWxpZCAtIDEpKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIGRpc3RpbmN0OiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuZGlzdGluY3QobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgY2kwOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuY2kwKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGNpMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLmNpMShtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBtZWRpYW46IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS5xMihtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBxMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnExKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIHEzOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEucTMobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgbWluOiB7XG4gICAgaW5pdDogbSA9PiBtLm1pbiA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLm1pbiA9IE51bWJlci5pc05hTihtLm1pbikgPyBtLmNlbGwuZGF0YS5taW4obS5nZXQpIDogbS5taW4sXG4gICAgYWRkOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbiB8fCBtLm1pbiA9PT0gdW5kZWZpbmVkKSBtLm1pbiA9IHY7XG4gICAgfSxcbiAgICByZW06IChtLCB2KSA9PiB7XG4gICAgICBpZiAodiA8PSBtLm1pbikgbS5taW4gPSBOYU47XG4gICAgfSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiA0XG4gIH0sXG4gIG1heDoge1xuICAgIGluaXQ6IG0gPT4gbS5tYXggPSB1bmRlZmluZWQsXG4gICAgdmFsdWU6IG0gPT4gbS5tYXggPSBOdW1iZXIuaXNOYU4obS5tYXgpID8gbS5jZWxsLmRhdGEubWF4KG0uZ2V0KSA6IG0ubWF4LFxuICAgIGFkZDogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXggfHwgbS5tYXggPT09IHVuZGVmaW5lZCkgbS5tYXggPSB2O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPj0gbS5tYXgpIG0ubWF4ID0gTmFOO1xuICAgIH0sXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogNFxuICB9LFxuICBhcmdtaW46IHtcbiAgICBpbml0OiBtID0+IG0uYXJnbWluID0gdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBtID0+IG0uYXJnbWluIHx8IG0uY2VsbC5kYXRhLmFyZ21pbihtLmdldCksXG4gICAgYWRkOiAobSwgdiwgdCkgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbikgbS5hcmdtaW4gPSB0O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPD0gbS5taW4pIG0uYXJnbWluID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcmVxOiBbJ21pbicsICd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgYXJnbWF4OiB7XG4gICAgaW5pdDogbSA9PiBtLmFyZ21heCA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLmFyZ21heCB8fCBtLmNlbGwuZGF0YS5hcmdtYXgobS5nZXQpLFxuICAgIGFkZDogKG0sIHYsIHQpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXgpIG0uYXJnbWF4ID0gdDtcbiAgICB9LFxuICAgIHJlbTogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID49IG0ubWF4KSBtLmFyZ21heCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHJlcTogWydtYXgnLCAndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH1cbn07XG5jb25zdCBWYWxpZEFnZ3JlZ2F0ZU9wcyA9IE9iamVjdC5rZXlzKEFnZ3JlZ2F0ZU9wcyk7XG5cbmZ1bmN0aW9uIG1lYXN1cmUoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gb3V0ID0+IGV4dGVuZCh7XG4gICAgbmFtZToga2V5LFxuICAgIG91dDogb3V0IHx8IGtleVxuICB9LCBiYXNlX29wLCB2YWx1ZSk7XG59XG5cblZhbGlkQWdncmVnYXRlT3BzLmZvckVhY2goa2V5ID0+IHtcbiAgQWdncmVnYXRlT3BzW2tleV0gPSBtZWFzdXJlKGtleSwgQWdncmVnYXRlT3BzW2tleV0pO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVNZWFzdXJlKG9wLCBuYW1lKSB7XG4gIHJldHVybiBBZ2dyZWdhdGVPcHNbb3BdKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSW5kZXgoYSwgYikge1xuICByZXR1cm4gYS5pZHggLSBiLmlkeDtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShhZ2cpIHtcbiAgY29uc3QgbWFwID0ge307XG4gIGFnZy5mb3JFYWNoKGEgPT4gbWFwW2EubmFtZV0gPSBhKTtcblxuICBjb25zdCBnZXRyZXFzID0gYSA9PiB7XG4gICAgaWYgKCFhLnJlcSkgcmV0dXJuO1xuICAgIGEucmVxLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghbWFwW2tleV0pIGdldHJlcXMobWFwW2tleV0gPSBBZ2dyZWdhdGVPcHNba2V5XSgpKTtcbiAgICB9KTtcbiAgfTtcblxuICBhZ2cuZm9yRWFjaChnZXRyZXFzKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwKS5zb3J0KGNvbXBhcmVJbmRleCk7XG59XG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIHRoaXMudmFsaWQgPSAwO1xuICB0aGlzLm1pc3NpbmcgPSAwO1xuXG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLmluaXQodGhpcykpO1xufVxuXG5mdW5jdGlvbiBhZGQodiwgdCkge1xuICBpZiAodiA9PSBudWxsIHx8IHYgPT09ICcnKSB7XG4gICAgKyt0aGlzLm1pc3Npbmc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHYgIT09IHYpIHJldHVybjtcbiAgKyt0aGlzLnZhbGlkO1xuXG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLmFkZCh0aGlzLCB2LCB0KSk7XG59XG5cbmZ1bmN0aW9uIHJlbSh2LCB0KSB7XG4gIGlmICh2ID09IG51bGwgfHwgdiA9PT0gJycpIHtcbiAgICAtLXRoaXMubWlzc2luZztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodiAhPT0gdikgcmV0dXJuO1xuICAtLXRoaXMudmFsaWQ7XG5cbiAgdGhpcy5fb3BzLmZvckVhY2gob3AgPT4gb3AucmVtKHRoaXMsIHYsIHQpKTtcbn1cblxuZnVuY3Rpb24gc2V0KHQpIHtcbiAgdGhpcy5fb3V0LmZvckVhY2gob3AgPT4gdFtvcC5vdXRdID0gb3AudmFsdWUodGhpcykpO1xuXG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBjb21waWxlTWVhc3VyZXMoYWdnLCBmaWVsZCkge1xuICBjb25zdCBnZXQgPSBmaWVsZCB8fCBpZGVudGl0eSxcbiAgICAgICAgb3BzID0gcmVzb2x2ZShhZ2cpLFxuICAgICAgICBvdXQgPSBhZ2cuc2xpY2UoKS5zb3J0KGNvbXBhcmVJbmRleCk7XG5cbiAgZnVuY3Rpb24gY3RyKGNlbGwpIHtcbiAgICB0aGlzLl9vcHMgPSBvcHM7XG4gICAgdGhpcy5fb3V0ID0gb3V0O1xuICAgIHRoaXMuY2VsbCA9IGNlbGw7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBjdHIucHJvdG90eXBlLmluaXQgPSBpbml0O1xuICBjdHIucHJvdG90eXBlLmFkZCA9IGFkZDtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSByZW07XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gc2V0O1xuICBjdHIucHJvdG90eXBlLmdldCA9IGdldDtcbiAgY3RyLmZpZWxkcyA9IGFnZy5tYXAob3AgPT4gb3Aub3V0KTtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gVHVwbGVTdG9yZShrZXkpIHtcbiAgdGhpcy5fa2V5ID0ga2V5ID8gZmllbGQoa2V5KSA6IHR1cGxlaWQ7XG4gIHRoaXMucmVzZXQoKTtcbn1cbmNvbnN0IHByb3RvdHlwZSQxID0gVHVwbGVTdG9yZS5wcm90b3R5cGU7XG5cbnByb3RvdHlwZSQxLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hZGQgPSBbXTtcbiAgdGhpcy5fcmVtID0gW107XG4gIHRoaXMuX2V4dCA9IG51bGw7XG4gIHRoaXMuX2dldCA9IG51bGw7XG4gIHRoaXMuX3EgPSBudWxsO1xufTtcblxucHJvdG90eXBlJDEuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5fYWRkLnB1c2godik7XG59O1xuXG5wcm90b3R5cGUkMS5yZW0gPSBmdW5jdGlvbiAodikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvdHlwZSQxLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fZ2V0ID0gbnVsbDtcbiAgaWYgKHRoaXMuX3JlbS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9hZGQ7XG4gIGNvbnN0IGEgPSB0aGlzLl9hZGQsXG4gICAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICAgIGsgPSB0aGlzLl9rZXksXG4gICAgICAgIG4gPSBhLmxlbmd0aCxcbiAgICAgICAgbSA9IHIubGVuZ3RoLFxuICAgICAgICB4ID0gQXJyYXkobiAtIG0pLFxuICAgICAgICBtYXAgPSB7fTtcbiAgbGV0IGksIGosIHY7IC8vIHVzZSB1bmlxdWUga2V5IGZpZWxkIHRvIGNsZWFyIHJlbW92ZWQgdmFsdWVzXG5cbiAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgIG1hcFtrKHJbaV0pXSA9IDE7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXBbayh2ID0gYVtpXSldKSB7XG4gICAgICBtYXBbayh2KV0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4W2orK10gPSB2O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICByZXR1cm4gdGhpcy5fYWRkID0geDtcbn07IC8vIG1lbW9pemluZyBzdGF0aXN0aWNzIG1ldGhvZHNcblxuXG5wcm90b3R5cGUkMS5kaXN0aW5jdCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIG1hcCA9IHt9O1xuICBsZXQgbiA9IHYubGVuZ3RoLFxuICAgICAgY291bnQgPSAwLFxuICAgICAgcztcblxuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICBzID0gZ2V0KHZbbl0pICsgJyc7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG1hcCwgcykpIHtcbiAgICAgIG1hcFtzXSA9IDE7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbnByb3RvdHlwZSQxLmV4dGVudCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICBjb25zdCB2ID0gdGhpcy52YWx1ZXMoKSxcbiAgICAgICAgICBpID0gZXh0ZW50SW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2V4dDtcbn07XG5cbnByb3RvdHlwZSQxLmFyZ21pbiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50KGdldClbMF0gfHwge307XG59O1xuXG5wcm90b3R5cGUkMS5hcmdtYXggPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdIHx8IHt9O1xufTtcblxucHJvdG90eXBlJDEubWluID0gZnVuY3Rpb24gKGdldCkge1xuICBjb25zdCBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gIT0gbnVsbCA/IGdldChtKSA6IHVuZGVmaW5lZDtcbn07XG5cbnByb3RvdHlwZSQxLm1heCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgbSA9IHRoaXMuZXh0ZW50KGdldClbMV07XG4gIHJldHVybiBtICE9IG51bGwgPyBnZXQobSkgOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90b3R5cGUkMS5xdWFydGlsZSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9xKSB7XG4gICAgdGhpcy5fcSA9IHF1YXJ0aWxlcyh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9xO1xufTtcblxucHJvdG90eXBlJDEucTEgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMF07XG59O1xuXG5wcm90b3R5cGUkMS5xMiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsxXTtcbn07XG5cbnByb3RvdHlwZSQxLnEzID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzJdO1xufTtcblxucHJvdG90eXBlJDEuY2kgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fY2kpIHtcbiAgICB0aGlzLl9jaSA9IGJvb3RzdHJhcENJKHRoaXMudmFsdWVzKCksIDEwMDAsIDAuMDUsIGdldCk7XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2NpO1xufTtcblxucHJvdG90eXBlJDEuY2kwID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5jaShnZXQpWzBdO1xufTtcblxucHJvdG90eXBlJDEuY2kxID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5jaShnZXQpWzFdO1xufTtcblxuLyoqXG4gKiBHcm91cC1ieSBhZ2dyZWdhdGlvbiBvcGVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyB0byBncm91cGJ5LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5maWVsZHNdIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGFnZ3JlZ2F0ZS5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5vcHNdIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpbmRpY2F0aW5nIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciBhZ2dyZWdhdGVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jcm9zcz1mYWxzZV0gLSBBIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBmdWxsXG4gKiAgIGNyb3NzLXByb2R1Y3Qgb2YgZ3JvdXBieSB2YWx1ZXMgc2hvdWxkIGJlIGdlbmVyYXRlZCwgaW5jbHVkaW5nIGVtcHR5IGNlbGxzLlxuICogICBJZiB0cnVlLCB0aGUgZHJvcCBwYXJhbWV0ZXIgaXMgaWdub3JlZCBhbmQgZW1wdHkgY2VsbHMgYXJlIHJldGFpbmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmRyb3A9dHJ1ZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiBlbXB0eSBjZWxscyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqL1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMuX2FkZHMgPSBbXTsgLy8gYXJyYXkgb2YgYWRkZWQgb3V0cHV0IHR1cGxlc1xuXG4gIHRoaXMuX21vZHMgPSBbXTsgLy8gYXJyYXkgb2YgbW9kaWZpZWQgb3V0cHV0IHR1cGxlc1xuXG4gIHRoaXMuX2FsZW4gPSAwOyAvLyBudW1iZXIgb2YgYWN0aXZlIGFkZGVkIHR1cGxlc1xuXG4gIHRoaXMuX21sZW4gPSAwOyAvLyBudW1iZXIgb2YgYWN0aXZlIG1vZGlmaWVkIHR1cGxlc1xuXG4gIHRoaXMuX2Ryb3AgPSB0cnVlOyAvLyBzaG91bGQgZW1wdHkgYWdncmVnYXRpb24gY2VsbHMgYmUgcmVtb3ZlZFxuXG4gIHRoaXMuX2Nyb3NzID0gZmFsc2U7IC8vIHByb2R1Y2UgZnVsbCBjcm9zcy1wcm9kdWN0IG9mIGdyb3VwLWJ5IHZhbHVlc1xuXG4gIHRoaXMuX2RpbXMgPSBbXTsgLy8gZ3JvdXAtYnkgZGltZW5zaW9uIGFjY2Vzc29yc1xuXG4gIHRoaXMuX2RuYW1lcyA9IFtdOyAvLyBncm91cC1ieSBkaW1lbnNpb24gbmFtZXNcblxuICB0aGlzLl9tZWFzdXJlcyA9IFtdOyAvLyBjb2xsZWN0aW9uIG9mIGFnZ3JlZ2F0aW9uIG1vbm9pZHNcblxuICB0aGlzLl9jb3VudE9ubHkgPSBmYWxzZTsgLy8gZmxhZyBpbmRpY2F0aW5nIG9ubHkgY291bnQgYWdncmVnYXRpb25cblxuICB0aGlzLl9jb3VudHMgPSBudWxsOyAvLyBjb2xsZWN0aW9uIG9mIGNvdW50IGZpZWxkc1xuXG4gIHRoaXMuX3ByZXYgPSBudWxsOyAvLyBwcmV2aW91cyBhZ2dyZWdhdGlvbiBjZWxsc1xuXG4gIHRoaXMuX2lucHV0cyA9IG51bGw7IC8vIGFycmF5IG9mIGRlcGVuZGVudCBpbnB1dCB0dXBsZSBmaWVsZCBuYW1lc1xuXG4gIHRoaXMuX291dHB1dHMgPSBudWxsOyAvLyBhcnJheSBvZiBvdXRwdXQgdHVwbGUgZmllbGQgbmFtZXNcbn1cbkFnZ3JlZ2F0ZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdBZ2dyZWdhdGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcHMnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkQWdncmVnYXRlT3BzXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Ryb3AnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnY3Jvc3MnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoQWdncmVnYXRlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgYWdnciA9IHRoaXMsXG4gICAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKTtcblxuICAgIGFnZ3Iuc3RhbXAgPSBvdXQuc3RhbXA7XG5cbiAgICBpZiAoYWdnci52YWx1ZSAmJiAobW9kIHx8IHB1bHNlLm1vZGlmaWVkKGFnZ3IuX2lucHV0cywgdHJ1ZSkpKSB7XG4gICAgICBhZ2dyLl9wcmV2ID0gYWdnci52YWx1ZTtcbiAgICAgIGFnZ3IudmFsdWUgPSBtb2QgPyBhZ2dyLmluaXQoXykgOiB7fTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFnZ3IudmFsdWUgPSBhZ2dyLnZhbHVlIHx8IGFnZ3IuaW5pdChfKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBhZ2dyLnJlbSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gLy8gSW5kaWNhdGUgb3V0cHV0IGZpZWxkcyBhbmQgcmV0dXJuIGFnZ3JlZ2F0ZSB0dXBsZXMuXG5cblxuICAgIG91dC5tb2RpZmllcyhhZ2dyLl9vdXRwdXRzKTsgLy8gU2hvdWxkIGVtcHR5IGNlbGxzIGJlIGRyb3BwZWQ/XG5cbiAgICBhZ2dyLl9kcm9wID0gXy5kcm9wICE9PSBmYWxzZTsgLy8gSWYgZG9tYWluIGNyb3NzLXByb2R1Y3QgcmVxdWVzdGVkLCBnZW5lcmF0ZSBlbXB0eSBjZWxscyBhcyBuZWVkZWRcbiAgICAvLyBhbmQgZW5zdXJlIHRoYXQgZW1wdHkgY2VsbHMgYXJlIG5vdCBkcm9wcGVkXG5cbiAgICBpZiAoXy5jcm9zcyAmJiBhZ2dyLl9kaW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgIGFnZ3IuX2Ryb3AgPSBmYWxzZTtcbiAgICAgIGFnZ3IuY3Jvc3MoKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSAmJiBhZ2dyLl9kcm9wKSB7XG4gICAgICBvdXQuY2xlYW4odHJ1ZSkucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdnci5jaGFuZ2VzKG91dCk7XG4gIH0sXG5cbiAgY3Jvc3MoKSB7XG4gICAgY29uc3QgYWdnciA9IHRoaXMsXG4gICAgICAgICAgY3VyciA9IGFnZ3IudmFsdWUsXG4gICAgICAgICAgZGltcyA9IGFnZ3IuX2RuYW1lcyxcbiAgICAgICAgICB2YWxzID0gZGltcy5tYXAoKCkgPT4gKHt9KSksXG4gICAgICAgICAgbiA9IGRpbXMubGVuZ3RoOyAvLyBjb2xsZWN0IGFsbCBncm91cC1ieSBkb21haW4gdmFsdWVzXG5cbiAgICBmdW5jdGlvbiBjb2xsZWN0KGNlbGxzKSB7XG4gICAgICBsZXQga2V5LCBpLCB0LCB2O1xuXG4gICAgICBmb3IgKGtleSBpbiBjZWxscykge1xuICAgICAgICB0ID0gY2VsbHNba2V5XS50dXBsZTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgdmFsc1tpXVt2ID0gdFtkaW1zW2ldXV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29sbGVjdChhZ2dyLl9wcmV2KTtcbiAgICBjb2xsZWN0KGN1cnIpOyAvLyBpdGVyYXRlIG92ZXIga2V5IGNyb3NzLXByb2R1Y3QsIGNyZWF0ZSBjZWxscyBhcyBuZWVkZWRcblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlKGJhc2UsIHR1cGxlLCBpbmRleCkge1xuICAgICAgY29uc3QgbmFtZSA9IGRpbXNbaW5kZXhdLFxuICAgICAgICAgICAgdiA9IHZhbHNbaW5kZXgrK107XG5cbiAgICAgIGZvciAoY29uc3QgayBpbiB2KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGJhc2UgPyBiYXNlICsgJ3wnICsgayA6IGs7XG4gICAgICAgIHR1cGxlW25hbWVdID0gdltrXTtcbiAgICAgICAgaWYgKGluZGV4IDwgbikgZ2VuZXJhdGUoa2V5LCB0dXBsZSwgaW5kZXgpO2Vsc2UgaWYgKCFjdXJyW2tleV0pIGFnZ3IuY2VsbChrZXksIHR1cGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnZW5lcmF0ZSgnJywge30sIDApO1xuICB9LFxuXG4gIGluaXQoXykge1xuICAgIC8vIGluaXRpYWxpemUgaW5wdXQgYW5kIG91dHB1dCBmaWVsZHNcbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLl9pbnB1dHMgPSBbXSxcbiAgICAgICAgICBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cyA9IFtdLFxuICAgICAgICAgIGlucHV0TWFwID0ge307XG5cbiAgICBmdW5jdGlvbiBpbnB1dFZpc2l0KGdldCkge1xuICAgICAgY29uc3QgZmllbGRzID0gYXJyYXkoYWNjZXNzb3JGaWVsZHMoZ2V0KSksXG4gICAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aDtcbiAgICAgIGxldCBpID0gMCxcbiAgICAgICAgICBmO1xuXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAoIWlucHV0TWFwW2YgPSBmaWVsZHNbaV1dKSB7XG4gICAgICAgICAgaW5wdXRNYXBbZl0gPSAxO1xuICAgICAgICAgIGlucHV0cy5wdXNoKGYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBpbml0aWFsaXplIGdyb3VwLWJ5IGRpbWVuc2lvbnNcblxuXG4gICAgdGhpcy5fZGltcyA9IGFycmF5KF8uZ3JvdXBieSk7XG4gICAgdGhpcy5fZG5hbWVzID0gdGhpcy5fZGltcy5tYXAoZCA9PiB7XG4gICAgICBjb25zdCBkbmFtZSA9IGFjY2Vzc29yTmFtZShkKTtcbiAgICAgIGlucHV0VmlzaXQoZCk7XG4gICAgICBvdXRwdXRzLnB1c2goZG5hbWUpO1xuICAgICAgcmV0dXJuIGRuYW1lO1xuICAgIH0pO1xuICAgIHRoaXMuY2VsbGtleSA9IF8ua2V5ID8gXy5rZXkgOiBncm91cGtleSh0aGlzLl9kaW1zKTsgLy8gaW5pdGlhbGl6ZSBhZ2dyZWdhdGUgbWVhc3VyZXNcblxuICAgIHRoaXMuX2NvdW50T25seSA9IHRydWU7XG4gICAgdGhpcy5fY291bnRzID0gW107XG4gICAgdGhpcy5fbWVhc3VyZXMgPSBbXTtcbiAgICBjb25zdCBmaWVsZHMgPSBfLmZpZWxkcyB8fCBbbnVsbF0sXG4gICAgICAgICAgb3BzID0gXy5vcHMgfHwgWydjb3VudCddLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBbXSxcbiAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBtYXAgPSB7fTtcbiAgICBsZXQgZmllbGQsIG9wLCBtLCBtbmFtZSwgb3V0bmFtZSwgaTtcblxuICAgIGlmIChuICE9PSBvcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVW5tYXRjaGVkIG51bWJlciBvZiBmaWVsZHMgYW5kIGFnZ3JlZ2F0ZSBvcHMuJyk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICBvcCA9IG9wc1tpXTtcblxuICAgICAgaWYgKGZpZWxkID09IG51bGwgJiYgb3AgIT09ICdjb3VudCcpIHtcbiAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgbW5hbWUgPSBhY2Nlc3Nvck5hbWUoZmllbGQpO1xuICAgICAgb3V0bmFtZSA9IG1lYXN1cmVOYW1lKG9wLCBtbmFtZSwgYXNbaV0pO1xuICAgICAgb3V0cHV0cy5wdXNoKG91dG5hbWUpO1xuXG4gICAgICBpZiAob3AgPT09ICdjb3VudCcpIHtcbiAgICAgICAgdGhpcy5fY291bnRzLnB1c2gob3V0bmFtZSk7XG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG0gPSBtYXBbbW5hbWVdO1xuXG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgaW5wdXRWaXNpdChmaWVsZCk7XG4gICAgICAgIG0gPSBtYXBbbW5hbWVdID0gW107XG4gICAgICAgIG0uZmllbGQgPSBmaWVsZDtcblxuICAgICAgICB0aGlzLl9tZWFzdXJlcy5wdXNoKG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AgIT09ICdjb3VudCcpIHRoaXMuX2NvdW50T25seSA9IGZhbHNlO1xuICAgICAgbS5wdXNoKGNyZWF0ZU1lYXN1cmUob3AsIG91dG5hbWUpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tZWFzdXJlcyA9IHRoaXMuX21lYXN1cmVzLm1hcChtID0+IGNvbXBpbGVNZWFzdXJlcyhtLCBtLmZpZWxkKSk7XG4gICAgcmV0dXJuIHt9OyAvLyBhZ2dyZWdhdGlvbiBjZWxscyAodGhpcy52YWx1ZSlcbiAgfSxcblxuICAvLyAtLSBDZWxsIE1hbmFnZW1lbnQgLS0tLS1cbiAgY2VsbGtleTogZ3JvdXBrZXkoKSxcblxuICBjZWxsKGtleSwgdCkge1xuICAgIGxldCBjZWxsID0gdGhpcy52YWx1ZVtrZXldO1xuXG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICBjZWxsID0gdGhpcy52YWx1ZVtrZXldID0gdGhpcy5uZXdjZWxsKGtleSwgdCk7XG4gICAgICB0aGlzLl9hZGRzW3RoaXMuX2FsZW4rK10gPSBjZWxsO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5udW0gPT09IDAgJiYgdGhpcy5fZHJvcCAmJiBjZWxsLnN0YW1wIDwgdGhpcy5zdGFtcCkge1xuICAgICAgY2VsbC5zdGFtcCA9IHRoaXMuc3RhbXA7XG4gICAgICB0aGlzLl9hZGRzW3RoaXMuX2FsZW4rK10gPSBjZWxsO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGNlbGwuc3RhbXAgPSB0aGlzLnN0YW1wO1xuICAgICAgdGhpcy5fbW9kc1t0aGlzLl9tbGVuKytdID0gY2VsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VsbDtcbiAgfSxcblxuICBuZXdjZWxsKGtleSwgdCkge1xuICAgIGNvbnN0IGNlbGwgPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIG51bTogMCxcbiAgICAgIGFnZzogbnVsbCxcbiAgICAgIHR1cGxlOiB0aGlzLm5ld3R1cGxlKHQsIHRoaXMuX3ByZXYgJiYgdGhpcy5fcHJldltrZXldKSxcbiAgICAgIHN0YW1wOiB0aGlzLnN0YW1wLFxuICAgICAgc3RvcmU6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICghdGhpcy5fY291bnRPbmx5KSB7XG4gICAgICBjb25zdCBtZWFzdXJlcyA9IHRoaXMuX21lYXN1cmVzLFxuICAgICAgICAgICAgbiA9IG1lYXN1cmVzLmxlbmd0aDtcbiAgICAgIGNlbGwuYWdnID0gQXJyYXkobik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnW2ldID0gbmV3IG1lYXN1cmVzW2ldKGNlbGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgICBjZWxsLmRhdGEgPSBuZXcgVHVwbGVTdG9yZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsO1xuICB9LFxuXG4gIG5ld3R1cGxlKHQsIHApIHtcbiAgICBjb25zdCBuYW1lcyA9IHRoaXMuX2RuYW1lcyxcbiAgICAgICAgICBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgICAgICBuID0gZGltcy5sZW5ndGgsXG4gICAgICAgICAgeCA9IHt9O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHhbbmFtZXNbaV1dID0gZGltc1tpXSh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcCA/IHJlcGxhY2UocC50dXBsZSwgeCkgOiBpbmdlc3QoeCk7XG4gIH0sXG5cbiAgY2xlYW4oKSB7XG4gICAgY29uc3QgY2VsbHMgPSB0aGlzLnZhbHVlO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2VsbHMpIHtcbiAgICAgIGlmIChjZWxsc1trZXldLm51bSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgY2VsbHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLy8gLS0gUHJvY2VzcyBUdXBsZXMgLS0tLS1cbiAgYWRkKHQpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNlbGxrZXkodCksXG4gICAgICAgICAgY2VsbCA9IHRoaXMuY2VsbChrZXksIHQpO1xuICAgIGNlbGwubnVtICs9IDE7XG4gICAgaWYgKHRoaXMuX2NvdW50T25seSkgcmV0dXJuO1xuICAgIGlmIChjZWxsLnN0b3JlKSBjZWxsLmRhdGEuYWRkKHQpO1xuICAgIGNvbnN0IGFnZyA9IGNlbGwuYWdnO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZ2dbaV0uYWRkKGFnZ1tpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfSxcblxuICByZW0odCkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuY2VsbGtleSh0KSxcbiAgICAgICAgICBjZWxsID0gdGhpcy5jZWxsKGtleSwgdCk7XG4gICAgY2VsbC5udW0gLT0gMTtcbiAgICBpZiAodGhpcy5fY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKGNlbGwuc3RvcmUpIGNlbGwuZGF0YS5yZW0odCk7XG4gICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFnZy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFnZ1tpXS5yZW0oYWdnW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9LFxuXG4gIGNlbGx0dXBsZShjZWxsKSB7XG4gICAgY29uc3QgdHVwbGUgPSBjZWxsLnR1cGxlLFxuICAgICAgICAgIGNvdW50cyA9IHRoaXMuX2NvdW50czsgLy8gY29uc29saWRhdGUgc3RvcmVkIHZhbHVlc1xuXG4gICAgaWYgKGNlbGwuc3RvcmUpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9IC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG5cblxuICAgIGZvciAobGV0IGkgPSAwLCBuID0gY291bnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdHVwbGVbY291bnRzW2ldXSA9IGNlbGwubnVtO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fY291bnRPbmx5KSB7XG4gICAgICBjb25zdCBhZ2cgPSBjZWxsLmFnZztcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGFnZ1tpXS5zZXQodHVwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0dXBsZTtcbiAgfSxcblxuICBjaGFuZ2VzKG91dCkge1xuICAgIGNvbnN0IGFkZHMgPSB0aGlzLl9hZGRzLFxuICAgICAgICAgIG1vZHMgPSB0aGlzLl9tb2RzLFxuICAgICAgICAgIHByZXYgPSB0aGlzLl9wcmV2LFxuICAgICAgICAgIGRyb3AgPSB0aGlzLl9kcm9wLFxuICAgICAgICAgIGFkZCA9IG91dC5hZGQsXG4gICAgICAgICAgcmVtID0gb3V0LnJlbSxcbiAgICAgICAgICBtb2QgPSBvdXQubW9kO1xuICAgIGxldCBjZWxsLCBrZXksIGksIG47XG4gICAgaWYgKHByZXYpIGZvciAoa2V5IGluIHByZXYpIHtcbiAgICAgIGNlbGwgPSBwcmV2W2tleV07XG4gICAgICBpZiAoIWRyb3AgfHwgY2VsbC5udW0pIHJlbS5wdXNoKGNlbGwudHVwbGUpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9hbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZGQucHVzaCh0aGlzLmNlbGx0dXBsZShhZGRzW2ldKSk7XG4gICAgICBhZGRzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBjZWxsID0gbW9kc1tpXTtcbiAgICAgIChjZWxsLm51bSA9PT0gMCAmJiBkcm9wID8gcmVtIDogbW9kKS5wdXNoKHRoaXMuY2VsbHR1cGxlKGNlbGwpKTtcbiAgICAgIG1vZHNbaV0gPSBudWxsOyAvLyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxuXG4gICAgdGhpcy5fYWxlbiA9IHRoaXMuX21sZW4gPSAwOyAvLyByZXNldCBsaXN0IG9mIGFjdGl2ZSBjZWxsc1xuXG4gICAgdGhpcy5fcHJldiA9IG51bGw7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuY29uc3QgRVBTSUxPTiQxID0gMWUtMTQ7XG4vKipcbiAqIEdlbmVyYXRlcyBhIGJpbm5pbmcgZnVuY3Rpb24gZm9yIGRpc2NyZXRpemluZyBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuIFRoZVxuICogICBwcm92aWRlZCB2YWx1ZXMgc2hvdWxkIGJlIHZhbGlkIG9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgYmlufSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGRhdGEgZmllbGQgdG8gYmluLlxuICovXG5cbmZ1bmN0aW9uIEJpbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkJpbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdCaW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ludGVydmFsJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FuY2hvcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWF4YmlucycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDIwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYXNlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMTBcbiAgfSwge1xuICAgICduYW1lJzogJ2RpdmlkZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWzUsIDJdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzcGFuJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtaW5zdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbmljZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduYW1lJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydiaW4wJywgJ2JpbjEnXVxuICB9XVxufTtcbmluaGVyaXRzKEJpbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGJhbmQgPSBfLmludGVydmFsICE9PSBmYWxzZSxcbiAgICAgICAgICBiaW5zID0gdGhpcy5fYmlucyhfKSxcbiAgICAgICAgICBzdGFydCA9IGJpbnMuc3RhcnQsXG4gICAgICAgICAgc3RlcCA9IGJpbnMuc3RlcCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWydiaW4wJywgJ2JpbjEnXSxcbiAgICAgICAgICBiMCA9IGFzWzBdLFxuICAgICAgICAgIGIxID0gYXNbMV07XG5cbiAgICBsZXQgZmxhZztcblxuICAgIGlmIChfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHB1bHNlID0gcHVsc2UucmVmbG93KHRydWUpO1xuICAgICAgZmxhZyA9IHB1bHNlLlNPVVJDRTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmxhZyA9IHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKF8uZmllbGQpKSA/IHB1bHNlLkFERF9NT0QgOiBwdWxzZS5BREQ7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgYmFuZCA/IHQgPT4ge1xuICAgICAgY29uc3QgdiA9IGJpbnModCk7IC8vIG1pbmltdW0gYmluIHZhbHVlIChpbmNsdXNpdmUpXG5cbiAgICAgIHRbYjBdID0gdjsgLy8gbWF4aW11bSBiaW4gdmFsdWUgKGV4Y2x1c2l2ZSlcbiAgICAgIC8vIHVzZSBjb252b2x1dGVkIG1hdGggZm9yIGJldHRlciBmbG9hdGluZyBwb2ludCBhZ3JlZW1lbnRcbiAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdmVnYS92ZWdhL2lzc3Vlcy84MzBcbiAgICAgIC8vIGluZmluaXRlIHZhbHVlcyBwcm9wYWdhdGUgdGhyb3VnaCB0aGlzIGZvcm11bGEhICMyMjI3XG5cbiAgICAgIHRbYjFdID0gdiA9PSBudWxsID8gbnVsbCA6IHN0YXJ0ICsgc3RlcCAqICgxICsgKHYgLSBzdGFydCkgLyBzdGVwKTtcbiAgICB9IDogdCA9PiB0W2IwXSA9IGJpbnModCkpO1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhiYW5kID8gYXMgOiBiMCk7XG4gIH0sXG5cbiAgX2JpbnMoXykge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBiaW5zID0gYmluKF8pLFxuICAgICAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCxcbiAgICAgICAgc3RvcCA9IHN0YXJ0ICsgTWF0aC5jZWlsKChiaW5zLnN0b3AgLSBzdGFydCkgLyBzdGVwKSAqIHN0ZXAsXG4gICAgICAgIGEsXG4gICAgICAgIGQ7XG5cbiAgICBpZiAoKGEgPSBfLmFuY2hvcikgIT0gbnVsbCkge1xuICAgICAgZCA9IGEgLSAoc3RhcnQgKyBzdGVwICogTWF0aC5mbG9vcigoYSAtIHN0YXJ0KSAvIHN0ZXApKTtcbiAgICAgIHN0YXJ0ICs9IGQ7XG4gICAgICBzdG9wICs9IGQ7XG4gICAgfVxuXG4gICAgY29uc3QgZiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICBsZXQgdiA9IHRvTnVtYmVyKGZpZWxkKHQpKTtcbiAgICAgIHJldHVybiB2ID09IG51bGwgPyBudWxsIDogdiA8IHN0YXJ0ID8gLUluZmluaXR5IDogdiA+IHN0b3AgPyArSW5maW5pdHkgOiAodiA9IE1hdGgubWF4KHN0YXJ0LCBNYXRoLm1pbih2LCBzdG9wIC0gc3RlcCkpLCBzdGFydCArIHN0ZXAgKiBNYXRoLmZsb29yKEVQU0lMT04kMSArICh2IC0gc3RhcnQpIC8gc3RlcCkpO1xuICAgIH07XG5cbiAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgZi5zdG9wID0gYmlucy5zdG9wO1xuICAgIGYuc3RlcCA9IHN0ZXA7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBhY2Nlc3NvcihmLCBhY2Nlc3NvckZpZWxkcyhmaWVsZCksIF8ubmFtZSB8fCAnYmluXycgKyBhY2Nlc3Nvck5hbWUoZmllbGQpKTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gU29ydGVkTGlzdCAoaWRGdW5jLCBzb3VyY2UsIGlucHV0KSB7XG4gIGNvbnN0ICQgPSBpZEZ1bmM7XG4gIGxldCBkYXRhID0gc291cmNlIHx8IFtdLFxuICAgICAgYWRkID0gaW5wdXQgfHwgW10sXG4gICAgICByZW0gPSB7fSxcbiAgICAgIGNudCA9IDA7XG4gIHJldHVybiB7XG4gICAgYWRkOiB0ID0+IGFkZC5wdXNoKHQpLFxuICAgIHJlbW92ZTogdCA9PiByZW1bJCh0KV0gPSArK2NudCxcbiAgICBzaXplOiAoKSA9PiBkYXRhLmxlbmd0aCxcbiAgICBkYXRhOiAoY29tcGFyZSwgcmVzb3J0KSA9PiB7XG4gICAgICBpZiAoY250KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcih0ID0+ICFyZW1bJCh0KV0pO1xuICAgICAgICByZW0gPSB7fTtcbiAgICAgICAgY250ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29ydCAmJiBjb21wYXJlKSB7XG4gICAgICAgIGRhdGEuc29ydChjb21wYXJlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IGNvbXBhcmUgPyBtZXJnZShjb21wYXJlLCBkYXRhLCBhZGQuc29ydChjb21wYXJlKSkgOiBkYXRhLmNvbmNhdChhZGQpO1xuICAgICAgICBhZGQgPSBbXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIENvbGxlY3RzIGFsbCBkYXRhIHR1cGxlcyB0aGF0IHBhc3MgdGhyb3VnaCB0aGlzIG9wZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIGFkZGl0aW9uYWxseSBzb3J0aW5nIHRoZSBjb2xsZWN0ZWQgdHVwbGVzLlxuICovXG5cbmZ1bmN0aW9uIENvbGxlY3QocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuQ29sbGVjdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDb2xsZWN0JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdzb3VyY2UnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3NvcnQnLFxuICAgICd0eXBlJzogJ2NvbXBhcmUnXG4gIH1dXG59O1xuaW5oZXJpdHMoQ29sbGVjdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgICAgICBsaXN0ID0gU29ydGVkTGlzdCh0dXBsZWlkLCB0aGlzLnZhbHVlLCBvdXQubWF0ZXJpYWxpemUob3V0LkFERCkuYWRkKSxcbiAgICAgICAgICBzb3J0ID0gXy5zb3J0LFxuICAgICAgICAgIG1vZCA9IHB1bHNlLmNoYW5nZWQoKSB8fCBzb3J0ICYmIChfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UubW9kaWZpZWQoc29ydC5maWVsZHMpKTtcbiAgICBvdXQudmlzaXQob3V0LlJFTSwgbGlzdC5yZW1vdmUpO1xuICAgIHRoaXMubW9kaWZpZWQobW9kKTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IGxpc3QuZGF0YShzdGFibGVDb21wYXJlKHNvcnQpLCBtb2QpOyAvLyBwcm9wYWdhdGUgdHJlZSByb290IGlmIGRlZmluZWRcblxuICAgIGlmIChwdWxzZS5zb3VyY2UgJiYgcHVsc2Uuc291cmNlLnJvb3QpIHtcbiAgICAgIHRoaXMudmFsdWUucm9vdCA9IHB1bHNlLnNvdXJjZS5yb290O1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8ZnVuY3Rpb24+fSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkcyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLm9yZGVyc10gLSBUaGUgc29ydCBvcmRlcnMuXG4gKiAgIEVhY2ggZW50cnkgc2hvdWxkIGJlIG9uZSBvZiBcImFzY2VuZGluZ1wiIChkZWZhdWx0KSBvciBcImRlc2NlbmRpbmdcIi5cbiAqL1xuXG5mdW5jdGlvbiBDb21wYXJlKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQ1LCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQ29tcGFyZSwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkNShfKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkgPyB0aGlzLnZhbHVlIDogY29tcGFyZShfLmZpZWxkcywgXy5vcmRlcnMpO1xufVxuXG4vKipcbiAqIENvdW50IHJlZ2V4cC1kZWZpbmVkIHBhdHRlcm4gb2NjdXJyZW5jZXMgaW4gYSB0ZXh0IGZpZWxkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgdGV4dCBmaWVsZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnBhdHRlcm5dIC0gUmVnRXhwIHN0cmluZyBkZWZpbmluZyB0aGUgdGV4dCBwYXR0ZXJuLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY2FzZV0gLSBPbmUgb2YgJ2xvd2VyJywgJ3VwcGVyJyBvciBudWxsIChtaXhlZCkgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnN0b3B3b3Jkc10gLSBSZWdFeHAgc3RyaW5nIG9mIHdvcmRzIHRvIGlnbm9yZS5cbiAqL1xuXG5mdW5jdGlvbiBDb3VudFBhdHRlcm4ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Db3VudFBhdHRlcm4uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ291bnRQYXR0ZXJuJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Nhc2UnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3VwcGVyJywgJ2xvd2VyJywgJ21peGVkJ10sXG4gICAgJ2RlZmF1bHQnOiAnbWl4ZWQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXR0ZXJuJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ1tcXFxcd1wiXSsnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdG9wd29yZHMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsndGV4dCcsICdjb3VudCddXG4gIH1dXG59O1xuXG5mdW5jdGlvbiB0b2tlbml6ZSh0ZXh0LCB0Y2FzZSwgbWF0Y2gpIHtcbiAgc3dpdGNoICh0Y2FzZSkge1xuICAgIGNhc2UgJ3VwcGVyJzpcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xvd2VyJzpcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB0ZXh0Lm1hdGNoKG1hdGNoKTtcbn1cblxuaW5oZXJpdHMoQ291bnRQYXR0ZXJuLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgcHJvY2VzcyA9IHVwZGF0ZSA9PiB0dXBsZSA9PiB7XG4gICAgICB2YXIgdG9rZW5zID0gdG9rZW5pemUoZ2V0KHR1cGxlKSwgXy5jYXNlLCBtYXRjaCkgfHwgW10sXG4gICAgICAgICAgdDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICghc3RvcC50ZXN0KHQgPSB0b2tlbnNbaV0pKSB1cGRhdGUodCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGluaXQgPSB0aGlzLl9wYXJhbWV0ZXJDaGVjayhfLCBwdWxzZSksXG4gICAgICAgICAgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgICAgIG1hdGNoID0gdGhpcy5fbWF0Y2gsXG4gICAgICAgICAgc3RvcCA9IHRoaXMuX3N0b3AsXG4gICAgICAgICAgZ2V0ID0gXy5maWVsZCxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWyd0ZXh0JywgJ2NvdW50J10sXG4gICAgICAgICAgYWRkID0gcHJvY2Vzcyh0ID0+IGNvdW50c1t0XSA9IDEgKyAoY291bnRzW3RdIHx8IDApKSxcbiAgICAgICAgICByZW0gPSBwcm9jZXNzKHQgPT4gY291bnRzW3RdIC09IDEpO1xuXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgYWRkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBhZGQpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCByZW0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9maW5pc2gocHVsc2UsIGFzKTsgLy8gZ2VuZXJhdGUgb3V0cHV0IHR1cGxlc1xuICB9LFxuXG4gIF9wYXJhbWV0ZXJDaGVjayhfLCBwdWxzZSkge1xuICAgIGxldCBpbml0ID0gZmFsc2U7XG5cbiAgICBpZiAoXy5tb2RpZmllZCgnc3RvcHdvcmRzJykgfHwgIXRoaXMuX3N0b3ApIHtcbiAgICAgIHRoaXMuX3N0b3AgPSBuZXcgUmVnRXhwKCdeJyArIChfLnN0b3B3b3JkcyB8fCAnJykgKyAnJCcsICdpJyk7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXy5tb2RpZmllZCgncGF0dGVybicpIHx8ICF0aGlzLl9tYXRjaCkge1xuICAgICAgdGhpcy5fbWF0Y2ggPSBuZXcgUmVnRXhwKF8ucGF0dGVybiB8fCAnW1xcXFx3XFwnXSsnLCAnZycpO1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgcHVsc2UubW9kaWZpZWQoXy5maWVsZC5maWVsZHMpKSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdCkgdGhpcy5fY291bnRzID0ge307XG4gICAgcmV0dXJuIGluaXQ7XG4gIH0sXG5cbiAgX2ZpbmlzaChwdWxzZSwgYXMpIHtcbiAgICBjb25zdCBjb3VudHMgPSB0aGlzLl9jb3VudHMsXG4gICAgICAgICAgdHVwbGVzID0gdGhpcy5fdHVwbGVzIHx8ICh0aGlzLl90dXBsZXMgPSB7fSksXG4gICAgICAgICAgdGV4dCA9IGFzWzBdLFxuICAgICAgICAgIGNvdW50ID0gYXNbMV0sXG4gICAgICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpO1xuICAgIGxldCB3LCB0LCBjO1xuXG4gICAgZm9yICh3IGluIGNvdW50cykge1xuICAgICAgdCA9IHR1cGxlc1t3XTtcbiAgICAgIGMgPSBjb3VudHNbd10gfHwgMDtcblxuICAgICAgaWYgKCF0ICYmIGMpIHtcbiAgICAgICAgdHVwbGVzW3ddID0gdCA9IGluZ2VzdCh7fSk7XG4gICAgICAgIHRbdGV4dF0gPSB3O1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5hZGQucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMCkge1xuICAgICAgICBpZiAodCkgb3V0LnJlbS5wdXNoKHQpO1xuICAgICAgICBjb3VudHNbd10gPSBudWxsO1xuICAgICAgICB0dXBsZXNbd10gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0W2NvdW50XSAhPT0gYykge1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5tb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgY3Jvc3MtcHJvZHVjdCBvZiBhIHR1cGxlIHN0cmVhbSB3aXRoIGl0c2VsZi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOmJvb2xlYW59IFtwYXJhbXMuZmlsdGVyXSAtIEFuIG9wdGlvbmFsIGZpbHRlclxuICogICBmdW5jdGlvbiBmb3Igc2VsZWN0aXZlbHkgaW5jbHVkaW5nIHR1cGxlcyBpbiB0aGUgY3Jvc3MgcHJvZHVjdC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBUaGUgbmFtZXMgb2YgdGhlIG91dHB1dCBmaWVsZHMuXG4gKi9cblxuZnVuY3Rpb24gQ3Jvc3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Dcm9zcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDcm9zcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ2V4cHInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydhJywgJ2InXVxuICB9XVxufTtcbmluaGVyaXRzKENyb3NzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBbJ2EnLCAnYiddLFxuICAgICAgICAgIGEgPSBhc1swXSxcbiAgICAgICAgICBiID0gYXNbMV0sXG4gICAgICAgICAgcmVzZXQgPSAhdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pIHx8IF8ubW9kaWZpZWQoJ2FzJykgfHwgXy5tb2RpZmllZCgnZmlsdGVyJyk7XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMudmFsdWU7XG5cbiAgICBpZiAocmVzZXQpIHtcbiAgICAgIGlmIChkYXRhKSBvdXQucmVtID0gZGF0YTtcbiAgICAgIGRhdGEgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZTtcbiAgICAgIG91dC5hZGQgPSB0aGlzLnZhbHVlID0gY3Jvc3MoZGF0YSwgYSwgYiwgXy5maWx0ZXIgfHwgdHJ1dGh5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lm1vZCA9IGRhdGE7XG4gICAgfVxuXG4gICAgb3V0LnNvdXJjZSA9IHRoaXMudmFsdWU7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGNyb3NzKGlucHV0LCBhLCBiLCBmaWx0ZXIpIHtcbiAgdmFyIGRhdGEgPSBbXSxcbiAgICAgIHQgPSB7fSxcbiAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBsZWZ0O1xuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgdFthXSA9IGxlZnQgPSBpbnB1dFtpXTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgIHRbYl0gPSBpbnB1dFtqXTtcblxuICAgICAgaWYgKGZpbHRlcih0KSkge1xuICAgICAgICBkYXRhLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgdCA9IHt9O1xuICAgICAgICB0W2FdID0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuY29uc3QgRGlzdHJpYnV0aW9ucyA9IHtcbiAga2RlOiByYW5kb21LREUsXG4gIG1peHR1cmU6IHJhbmRvbU1peHR1cmUsXG4gIG5vcm1hbDogcmFuZG9tTm9ybWFsLFxuICBsb2dub3JtYWw6IHJhbmRvbUxvZ05vcm1hbCxcbiAgdW5pZm9ybTogcmFuZG9tVW5pZm9ybVxufTtcbmNvbnN0IERJU1RSSUJVVElPTlMgPSAnZGlzdHJpYnV0aW9ucycsXG4gICAgICBGVU5DVElPTiA9ICdmdW5jdGlvbicsXG4gICAgICBGSUVMRCA9ICdmaWVsZCc7XG4vKipcbiAqIFBhcnNlIGEgcGFyYW1ldGVyIG9iamVjdCBmb3IgYSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gZGVmIC0gVGhlIGRpc3RyaWJ1dGlvbiBwYXJhbWV0ZXIgb2JqZWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbigpOkFycmF5PG9iamVjdD59IC0gQSBtZXRob2QgZm9yIHJlcXVlc3RpbmdcbiAqICAgc291cmNlIGRhdGEuIFVzZWQgZm9yIGRpc3RyaWJ1dGlvbnMgKHN1Y2ggYXMgS0RFKSB0aGF0XG4gKiAgIHJlcXVpcmUgc2FtcGxlIGRhdGEgcG9pbnRzLiBUaGlzIG1ldGhvZCB3aWxsIG9ubHkgYmVcbiAqICAgaW52b2tlZCBpZiB0aGUgJ2Zyb20nIHBhcmFtZXRlciBmb3IgYSB0YXJnZXQgZGF0YSBzb3VyY2VcbiAqICAgaXMgbm90IHByb3ZpZGVkLiBUeXBpY2FsbHkgdGhpcyBtZXRob2QgcmV0dXJucyBiYWNraW5nXG4gKiAgIHNvdXJjZSBkYXRhIGZvciBhIFB1bHNlIG9iamVjdC5cbiAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgb3V0cHV0IGRpc3RyaWJ1dGlvbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoZGVmLCBkYXRhKSB7XG4gIGNvbnN0IGZ1bmMgPSBkZWZbRlVOQ1RJT05dO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoRGlzdHJpYnV0aW9ucywgZnVuYykpIHtcbiAgICBlcnJvcignVW5rbm93biBkaXN0cmlidXRpb24gZnVuY3Rpb246ICcgKyBmdW5jKTtcbiAgfVxuXG4gIGNvbnN0IGQgPSBEaXN0cmlidXRpb25zW2Z1bmNdKCk7XG5cbiAgZm9yIChjb25zdCBuYW1lIGluIGRlZikge1xuICAgIC8vIGlmIGRhdGEgZmllbGQsIGV4dHJhY3QgdmFsdWVzXG4gICAgaWYgKG5hbWUgPT09IEZJRUxEKSB7XG4gICAgICBkLmRhdGEoKGRlZi5mcm9tIHx8IGRhdGEoKSkubWFwKGRlZltuYW1lXSkpO1xuICAgIH0gLy8gaWYgZGlzdHJpYnV0aW9uIG1peHR1cmUsIHJlY3Vyc2UgdG8gcGFyc2UgZWFjaCBkZWZpbml0aW9uXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gRElTVFJJQlVUSU9OUykge1xuICAgICAgICBkW25hbWVdKGRlZltuYW1lXS5tYXAoXyA9PiBwYXJzZShfLCBkYXRhKSkpO1xuICAgICAgfSAvLyBvdGhlcndpc2UsIHNpbXBseSBzZXQgdGhlIHBhcmFtZXRlclxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRbbmFtZV0gPT09IEZVTkNUSU9OKSB7XG4gICAgICAgICAgZFtuYW1lXShkZWZbbmFtZV0pO1xuICAgICAgICB9XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBHcmlkIHNhbXBsZSBwb2ludHMgZm9yIGEgcHJvYmFiaWxpdHkgZGVuc2l0eS4gR2l2ZW4gYSBkaXN0cmlidXRpb24gYW5kXG4gKiBhIHNhbXBsaW5nIGV4dGVudCwgd2lsbCBnZW5lcmF0ZSBwb2ludHMgc3VpdGFibGUgZm9yIHBsb3R0aW5nIGVpdGhlclxuICogUERGIChwcm9iYWJpbGl0eSBkZW5zaXR5IGZ1bmN0aW9uKSBvciBDREYgKGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uXG4gKiBmdW5jdGlvbikgY3VydmVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmRpc3RyaWJ1dGlvbiAtIFRoZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24uIFRoaXNcbiAqICAgaXMgYW4gb2JqZWN0IHBhcmFtZXRlciBkZXBlbmRlbnQgb24gdGhlIGRpc3RyaWJ1dGlvbiB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWV0aG9kPSdwZGYnXSAtIFRoZSBkaXN0cmlidXRpb24gbWV0aG9kIHRvIHNhbXBsZS5cbiAqICAgT25lIG9mICdwZGYnIG9yICdjZGYnLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmV4dGVudF0gLSBUaGUgW21pbiwgbWF4XSBleHRlbnQgb3ZlciB3aGljaFxuICogICB0byBzYW1wbGUgdGhlIGRpc3RyaWJ1dGlvbi4gVGhpcyBhcmd1bWVudCBpcyByZXF1aXJlZCBpbiBtb3N0IGNhc2VzLCBidXRcbiAqICAgY2FuIGJlIG9taXR0ZWQgaWYgdGhlIGRpc3RyaWJ1dGlvbiAoZS5nLiwgJ2tkZScpIHN1cHBvcnRzIGEgJ2RhdGEnIG1ldGhvZFxuICogICB0aGF0IHJldHVybnMgbnVtZXJpY2FsIHNhbXBsZSBwb2ludHMgZnJvbSB3aGljaCB0aGUgZXh0ZW50IGNhbiBiZSBkZWR1Y2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWluc3RlcHM9MjVdIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWF4c3RlcHM9MjAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBzXSAtIFRoZSBleGFjdCBudW1iZXIgb2YgY3VydmUgc2FtcGxlcyBmb3JcbiAqICAgcGxvdHRpbmcgdGhlIGRlbnNpdHkuIElmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGJvdGggbWluc3RlcHMgYW5kIG1heHN0ZXBzXG4gKiAgIHRvIHNldCBhbiBleGFjdCBudW1iZXIgb2YgdW5pZm9ybSBzYW1wbGVzLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICBhIGZpeGVkIGV4dGVudCB0byBlbnN1cmUgY29uc2lzdGVudCBzYW1wbGUgcG9pbnRzIGZvciBzdGFja2VkIGRlbnNpdGllcy5cbiAqL1xuXG5mdW5jdGlvbiBEZW5zaXR5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuY29uc3QgZGlzdHJpYnV0aW9ucyA9IFt7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ25vcm1hbCdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnbWVhbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZGV2JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9XVxufSwge1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdsb2dub3JtYWwnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21lYW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGRldicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAndW5pZm9ybSdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnbWluJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWF4JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9XVxufSwge1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdrZGUnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZnJvbScsXG4gICAgJ3R5cGUnOiAnZGF0YSdcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfV1cbn1dO1xuY29uc3QgbWl4dHVyZSA9IHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAnbWl4dHVyZSdcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZGlzdHJpYnV0aW9ucycsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3BhcmFtcyc6IGRpc3RyaWJ1dGlvbnNcbiAgfSwge1xuICAgICduYW1lJzogJ3dlaWdodHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbkRlbnNpdHkuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRGVuc2l0eScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjVcbiAgfSwge1xuICAgICduYW1lJzogJ21heHN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtZXRob2QnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAncGRmJyxcbiAgICAndmFsdWVzJzogWydwZGYnLCAnY2RmJ11cbiAgfSwge1xuICAgICduYW1lJzogJ2Rpc3RyaWJ1dGlvbicsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdwYXJhbXMnOiBkaXN0cmlidXRpb25zLmNvbmNhdChtaXh0dXJlKVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6IFsndmFsdWUnLCAnZGVuc2l0eSddXG4gIH1dXG59O1xuaW5oZXJpdHMoRGVuc2l0eSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcblxuICAgIGlmICghdGhpcy52YWx1ZSB8fCBwdWxzZS5jaGFuZ2VkKCkgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBjb25zdCBkaXN0ID0gcGFyc2UoXy5kaXN0cmlidXRpb24sIHNvdXJjZShwdWxzZSkpLFxuICAgICAgICAgICAgbWluc3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWluc3RlcHMgfHwgMjUsXG4gICAgICAgICAgICBtYXhzdGVwcyA9IF8uc3RlcHMgfHwgXy5tYXhzdGVwcyB8fCAyMDA7XG4gICAgICBsZXQgbWV0aG9kID0gXy5tZXRob2QgfHwgJ3BkZic7XG5cbiAgICAgIGlmIChtZXRob2QgIT09ICdwZGYnICYmIG1ldGhvZCAhPT0gJ2NkZicpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZGVuc2l0eSBtZXRob2Q6ICcgKyBtZXRob2QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uZXh0ZW50ICYmICFkaXN0LmRhdGEpIHtcbiAgICAgICAgZXJyb3IoJ01pc3NpbmcgZGVuc2l0eSBleHRlbnQgcGFyYW1ldGVyLicpO1xuICAgICAgfVxuXG4gICAgICBtZXRob2QgPSBkaXN0W21ldGhvZF07XG4gICAgICBjb25zdCBhcyA9IF8uYXMgfHwgWyd2YWx1ZScsICdkZW5zaXR5J10sXG4gICAgICAgICAgICBkb21haW4gPSBfLmV4dGVudCB8fCBleHRlbnQoZGlzdC5kYXRhKCkpLFxuICAgICAgICAgICAgdmFsdWVzID0gc2FtcGxlQ3VydmUobWV0aG9kLCBkb21haW4sIG1pbnN0ZXBzLCBtYXhzdGVwcykubWFwKHYgPT4ge1xuICAgICAgICBjb25zdCB0dXBsZSA9IHt9O1xuICAgICAgICB0dXBsZVthc1swXV0gPSB2WzBdO1xuICAgICAgICB0dXBsZVthc1sxXV0gPSB2WzFdO1xuICAgICAgICByZXR1cm4gaW5nZXN0KHR1cGxlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHNvdXJjZShwdWxzZSkge1xuICByZXR1cm4gKCkgPT4gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGZpZWxkTmFtZXMoZmllbGRzLCBhcykge1xuICBpZiAoIWZpZWxkcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBmaWVsZHMubWFwKChmLCBpKSA9PiBhc1tpXSB8fCBhY2Nlc3Nvck5hbWUoZikpO1xufVxuZnVuY3Rpb24gcGFydGl0aW9uJDEoZGF0YSwgZ3JvdXBieSwgZmllbGQpIHtcbiAgY29uc3QgZ3JvdXBzID0gW10sXG4gICAgICAgIGdldCA9IGYgPT4gZih0KTtcblxuICBsZXQgbWFwLCBpLCBuLCB0LCBrLCBnOyAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBncm91cHNcblxuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5tYXAoZmllbGQpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcblxuICAgICAgaWYgKCFnKSB7XG4gICAgICAgIG1hcFtrXSA9IGcgPSBbXTtcbiAgICAgICAgZy5kaW1zID0gaztcbiAgICAgICAgZ3JvdXBzLnB1c2goZyk7XG4gICAgICB9XG5cbiAgICAgIGcucHVzaChmaWVsZCh0KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuY29uc3QgT3V0cHV0ID0gJ2Jpbic7XG4vKipcbiAqIERvdCBkZW5zaXR5IGJpbm5pbmcgZm9yIGRvdCBwbG90IGNvbnN0cnVjdGlvbi5cbiAqIEJhc2VkIG9uIExlbGFuZCBXaWxraW5zb24sIERvdCBQbG90cywgVGhlIEFtZXJpY2FuIFN0YXRpc3RpY2lhbiwgMTk5OS5cbiAqIGh0dHBzOi8vd3d3LmNzLnVpYy5lZHUvfndpbGtpbnNvbi9QdWJsaWNhdGlvbnMvZG90cGxvdHMucGRmXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIGJpbi5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBdIC0gVGhlIHN0ZXAgc2l6ZSAoYmluIHdpZHRoKSB3aXRoaW4gd2hpY2ggZG90cyBzaG91bGQgYmVcbiAqICAgc3RhY2tlZC4gRGVmYXVsdHMgdG8gMS8zMCBvZiB0aGUgZXh0ZW50IG9mIHRoZSBkYXRhICpmaWVsZCouXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgZG90IGRlbnNpdHlcbiAqICAgc3RhY2tzIHNob3VsZCBiZSBzbW9vdGhlZCB0byByZWR1Y2UgdmFyaWFuY2UuXG4gKi9cblxuZnVuY3Rpb24gRG90QmluKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRG90QmluLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0RvdEJpbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ3Ntb290aCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiBPdXRwdXRcbiAgfV1cbn07XG5cbmNvbnN0IGF1dG9zdGVwID0gKGRhdGEsIGZpZWxkKSA9PiBzcGFuKGV4dGVudChkYXRhLCBmaWVsZCkpIC8gMzA7XG5cbmluaGVyaXRzKERvdEJpbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICEoXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQoKSkpIHtcbiAgICAgIHJldHVybiBwdWxzZTsgLy8gZWFybHkgZXhpdFxuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbiQxKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBpZGVudGl0eSksXG4gICAgICAgICAgc21vb3RoID0gXy5zbW9vdGggfHwgZmFsc2UsXG4gICAgICAgICAgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIHN0ZXAgPSBfLnN0ZXAgfHwgYXV0b3N0ZXAoc291cmNlLCBmaWVsZCksXG4gICAgICAgICAgc29ydCA9IHN0YWJsZUNvbXBhcmUoKGEsIGIpID0+IGZpZWxkKGEpIC0gZmllbGQoYikpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBPdXRwdXQsXG4gICAgICAgICAgbiA9IGdyb3Vwcy5sZW5ndGg7IC8vIGNvbXB1dGUgZG90cGxvdCBiaW5zIHBlciBncm91cFxuXG4gICAgbGV0IG1pbiA9IEluZmluaXR5LFxuICAgICAgICBtYXggPSAtSW5maW5pdHksXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBqO1xuXG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbaV0uc29ydChzb3J0KTtcbiAgICAgIGogPSAtMTtcblxuICAgICAgZm9yIChjb25zdCB2IG9mIGRvdGJpbihnLCBzdGVwLCBzbW9vdGgsIGZpZWxkKSkge1xuICAgICAgICBpZiAodiA8IG1pbikgbWluID0gdjtcbiAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHY7XG4gICAgICAgIGdbKytqXVthc10gPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICBzdGFydDogbWluLFxuICAgICAgc3RvcDogbWF4LFxuICAgICAgc3RlcDogc3RlcFxuICAgIH07XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyh0cnVlKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogV3JhcHMgYW4gZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byBleHRlcm5hbCBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuZXhwciAtIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uLiBUaGVcbiAqICBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IGJvdGggYSBkYXR1bSBhbmQgYSBwYXJhbWV0ZXIgb2JqZWN0LlxuICogIFRoaXMgb3BlcmF0b3IncyB2YWx1ZSB3aWxsIGJlIGEgbmV3IGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlXG4gKiAgZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byB0aGlzIG9wZXJhdG9yJ3MgcGFyYW1ldGVycy5cbiAqL1xuXG5mdW5jdGlvbiBFeHByZXNzaW9uKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQ0LCBwYXJhbXMpO1xuICB0aGlzLm1vZGlmaWVkKHRydWUpO1xufVxuaW5oZXJpdHMoRXhwcmVzc2lvbiwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkNChfKSB7XG4gIGNvbnN0IGV4cHIgPSBfLmV4cHI7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCdleHByJykgPyB0aGlzLnZhbHVlIDogYWNjZXNzb3IoZGF0dW0gPT4gZXhwcihkYXR1bSwgXyksIGFjY2Vzc29yRmllbGRzKGV4cHIpLCBhY2Nlc3Nvck5hbWUoZXhwcikpO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGV4dGVudHMgKG1pbi9tYXgpIGZvciBhIGRhdGEgZmllbGQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGZpZWxkIG92ZXIgd2hpY2ggdG8gY29tcHV0ZSBleHRlbmRzLlxuICovXG5cbmZ1bmN0aW9uIEV4dGVudChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSwgcGFyYW1zKTtcbn1cbkV4dGVudC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdFeHRlbnQnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoRXh0ZW50LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgbW9kID0gcHVsc2UuY2hhbmdlZCgpIHx8IHB1bHNlLm1vZGlmaWVkKGZpZWxkLmZpZWxkcykgfHwgXy5tb2RpZmllZCgnZmllbGQnKTtcblxuICAgIGxldCBtaW4gPSBleHRlbnRbMF0sXG4gICAgICAgIG1heCA9IGV4dGVudFsxXTtcblxuICAgIGlmIChtb2QgfHwgbWluID09IG51bGwpIHtcbiAgICAgIG1pbiA9ICtJbmZpbml0eTtcbiAgICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChtb2QgPyBwdWxzZS5TT1VSQ0UgOiBwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgdiA9IHRvTnVtYmVyKGZpZWxkKHQpKTtcblxuICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAvLyBOYU5zIHdpbGwgZmFpbCBhbGwgY29tcGFyaXNvbnMhXG4gICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2O1xuICAgICAgICBpZiAodiA+IG1heCkgbWF4ID0gdjtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbikgfHwgIU51bWJlci5pc0Zpbml0ZShtYXgpKSB7XG4gICAgICBsZXQgbmFtZSA9IGFjY2Vzc29yTmFtZShmaWVsZCk7XG4gICAgICBpZiAobmFtZSkgbmFtZSA9IGAgZm9yIGZpZWxkIFwiJHtuYW1lfVwiYDtcbiAgICAgIHB1bHNlLmRhdGFmbG93Lndhcm4oYEluZmluaXRlIGV4dGVudCR7bmFtZX06IFske21pbn0sICR7bWF4fV1gKTtcbiAgICAgIG1pbiA9IG1heCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gW21pbiwgbWF4XTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIGEgcGFyZW50IHRyYW5zZm9ybSBhbmQgYSB0YXJnZXQgc3ViZmxvdyB0aGF0XG4gKiBjb25zdW1lcyBvbmx5IGEgc3Vic2V0IG9mIHRoZSB0dXBsZXMgdGhhdCBwYXNzIHRocm91Z2ggdGhlIHBhcmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBBIHB1bHNlIHRvIHVzZSBhcyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgLSBUaGUgcGFyZW50IHRyYW5zZm9ybSAodHlwaWNhbGx5IGEgRmFjZXQgaW5zdGFuY2UpLlxuICovXG5cbmZ1bmN0aW9uIFN1YmZsb3cocHVsc2UsIHBhcmVudCkge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIHB1bHNlKTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuaW5oZXJpdHMoU3ViZmxvdywgT3BlcmF0b3IsIHtcbiAgLyoqXG4gICAqIFJvdXRlcyBwdWxzZXMgZnJvbSB0aGlzIHN1YmZsb3cgdG8gYSB0YXJnZXQgdHJhbnNmb3JtLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybX0gdGFyZ2V0IC0gQSB0cmFuc2Zvcm0gdGhhdCByZWNlaXZlcyB0aGUgc3ViZmxvdyBvZiB0dXBsZXMuXG4gICAqL1xuICBjb25uZWN0KHRhcmdldCkge1xuICAgIHRoaXMuZGV0YWNoU3ViZmxvdyA9IHRhcmdldC5kZXRhY2hTdWJmbG93O1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZCh0YXJnZXQpO1xuICAgIHJldHVybiB0YXJnZXQuc291cmNlID0gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGFuICdhZGQnIHR1cGxlIHRvIHRoZSBzdWJmbG93IHB1bHNlLlxuICAgKiBAcGFyYW0ge1R1cGxlfSB0IC0gVGhlIHR1cGxlIGJlaW5nIGFkZGVkLlxuICAgKi9cbiAgYWRkKHQpIHtcbiAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgdGhpcy52YWx1ZS5hZGQucHVzaCh0KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGEgJ3JlbScgdHVwbGUgdG8gdGhlIHN1YmZsb3cgcHVsc2UuXG4gICAqIEBwYXJhbSB7VHVwbGV9IHQgLSBUaGUgdHVwbGUgYmVpbmcgcmVtb3ZlZC5cbiAgICovXG4gIHJlbSh0KSB7XG4gICAgdGhpcy5jb3VudCAtPSAxO1xuICAgIHRoaXMudmFsdWUucmVtLnB1c2godCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBhICdtb2QnIHR1cGxlIHRvIHRoZSBzdWJmbG93IHB1bHNlLlxuICAgKiBAcGFyYW0ge1R1cGxlfSB0IC0gVGhlIHR1cGxlIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cbiAgbW9kKHQpIHtcbiAgICB0aGlzLnZhbHVlLm1vZC5wdXNoKHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZS1pbml0aWFsaXplIHRoaXMgb3BlcmF0b3IncyBwdWxzZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBUaGUgcHVsc2UgdG8gY29weSBmcm9tLlxuICAgKiBAc2VlIFB1bHNlLmluaXRcbiAgICovXG4gIGluaXQocHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlLmluaXQocHVsc2UsIHB1bHNlLk5PX1NPVVJDRSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoaXMgb3BlcmF0b3IuIFRoaXMgbWV0aG9kIG92ZXJyaWRlcyB0aGVcbiAgICogZGVmYXVsdCBiZWhhdmlvciB0byBzaW1wbHkgcmV0dXJuIHRoZSBjb250YWluZWQgcHVsc2UgdmFsdWUuXG4gICAqIEByZXR1cm4ge1B1bHNlfVxuICAgKi9cbiAgZXZhbHVhdGUoKSB7XG4gICAgLy8gYXNzZXJ0OiB0aGlzLnZhbHVlLnN0YW1wID09PSBwdWxzZS5zdGFtcFxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEZhY2V0cyBhIGRhdGFmbG93IGludG8gYSBzZXQgb2Ygc3ViZmxvd3MgYmFzZWQgb24gYSBrZXkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3csIHN0cmluZyk6IE9wZXJhdG9yfSBwYXJhbXMuc3ViZmxvdyAtIEEgZnVuY3Rpb25cbiAqICAgdGhhdCBnZW5lcmF0ZXMgYSBzdWJmbG93IG9mIG9wZXJhdG9ycyBhbmQgcmV0dXJucyBpdHMgcm9vdCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmtleSAtIFRoZSBrZXkgZmllbGQgdG8gZmFjZXQgYnkuXG4gKi9cblxuZnVuY3Rpb24gRmFjZXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHt9LCBwYXJhbXMpO1xuICB0aGlzLl9rZXlzID0gZmFzdG1hcCgpOyAvLyBjYWNoZSBwcmV2aW91c2x5IGNhbGN1bGF0ZWQga2V5IHZhbHVlc1xuICAvLyBrZWVwIHRyYWNrIG9mIGFjdGl2ZSBzdWJmbG93cywgdXNlIGFzIHRhcmdldHMgYXJyYXkgZm9yIGxpc3RlbmVyc1xuICAvLyB0aGlzIGFsbG93cyB1cyB0byBsaW1pdCBwcm9wYWdhdGlvbiB0byBvbmx5IHVwZGF0ZWQgc3ViZmxvd3NcblxuICBjb25zdCBhID0gdGhpcy5fdGFyZ2V0cyA9IFtdO1xuICBhLmFjdGl2ZSA9IDA7XG5cbiAgYS5mb3JFYWNoID0gZiA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhLmFjdGl2ZTsgaSA8IG47ICsraSkge1xuICAgICAgZihhW2ldLCBpLCBhKTtcbiAgICB9XG4gIH07XG59XG5pbmhlcml0cyhGYWNldCwgVHJhbnNmb3JtLCB7XG4gIGFjdGl2YXRlKGZsb3cpIHtcbiAgICB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMuYWN0aXZlKytdID0gZmxvdztcbiAgfSxcblxuICAvLyBwYXJlbnQgYXJndW1lbnQgcHJvdmlkZWQgYnkgUHJlRmFjZXQgc3ViY2xhc3NcbiAgc3ViZmxvdyhrZXksIGZsb3csIHB1bHNlLCBwYXJlbnQpIHtcbiAgICBjb25zdCBmbG93cyA9IHRoaXMudmFsdWU7XG4gICAgbGV0IHNmID0gaGFzT3duUHJvcGVydHkoZmxvd3MsIGtleSkgJiYgZmxvd3Nba2V5XSxcbiAgICAgICAgZGYsXG4gICAgICAgIHA7XG5cbiAgICBpZiAoIXNmKSB7XG4gICAgICBwID0gcGFyZW50IHx8IChwID0gdGhpcy5fZ3JvdXBba2V5XSkgJiYgcC50dXBsZTtcbiAgICAgIGRmID0gcHVsc2UuZGF0YWZsb3c7XG4gICAgICBzZiA9IG5ldyBTdWJmbG93KHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSwgdGhpcyk7XG4gICAgICBkZi5hZGQoc2YpLmNvbm5lY3QoZmxvdyhkZiwga2V5LCBwKSk7XG4gICAgICBmbG93c1trZXldID0gc2Y7XG4gICAgICB0aGlzLmFjdGl2YXRlKHNmKTtcbiAgICB9IGVsc2UgaWYgKHNmLnZhbHVlLnN0YW1wIDwgcHVsc2Uuc3RhbXApIHtcbiAgICAgIHNmLmluaXQocHVsc2UpO1xuICAgICAgdGhpcy5hY3RpdmF0ZShzZik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmO1xuICB9LFxuXG4gIGNsZWFuKCkge1xuICAgIGNvbnN0IGZsb3dzID0gdGhpcy52YWx1ZTtcbiAgICBsZXQgZGV0YWNoZWQgPSAwO1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmxvd3MpIHtcbiAgICAgIGlmIChmbG93c1trZXldLmNvdW50ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGRldGFjaCA9IGZsb3dzW2tleV0uZGV0YWNoU3ViZmxvdztcbiAgICAgICAgaWYgKGRldGFjaCkgZGV0YWNoKCk7XG4gICAgICAgIGRlbGV0ZSBmbG93c1trZXldO1xuICAgICAgICArK2RldGFjaGVkO1xuICAgICAgfVxuICAgIH0gLy8gcmVtb3ZlIGluYWN0aXZlIHRhcmdldHMgZnJvbSB0aGUgYWN0aXZlIHRhcmdldHMgYXJyYXlcblxuXG4gICAgaWYgKGRldGFjaGVkKSB7XG4gICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl90YXJnZXRzLmZpbHRlcihzZiA9PiBzZiAmJiBzZi5jb3VudCA+IDApO1xuXG4gICAgICB0aGlzLmluaXRUYXJnZXRzKGFjdGl2ZSk7XG4gICAgfVxuICB9LFxuXG4gIGluaXRUYXJnZXRzKGFjdCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICAgIG4gPSBhLmxlbmd0aCxcbiAgICAgICAgICBtID0gYWN0ID8gYWN0Lmxlbmd0aCA6IDA7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgIGFbaV0gPSBhY3RbaV07XG4gICAgfVxuXG4gICAgZm9yICg7IGkgPCBuICYmIGFbaV0gIT0gbnVsbDsgKytpKSB7XG4gICAgICBhW2ldID0gbnVsbDsgLy8gZW5zdXJlIG9sZCBmbG93cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICB9XG5cbiAgICBhLmFjdGl2ZSA9IG07XG4gIH0sXG5cbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZGYgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgICBrZXkgPSBfLmtleSxcbiAgICAgICAgICBmbG93ID0gXy5zdWJmbG93LFxuICAgICAgICAgIGNhY2hlID0gdGhpcy5fa2V5cyxcbiAgICAgICAgICByZWtleSA9IF8ubW9kaWZpZWQoJ2tleScpLFxuICAgICAgICAgIHN1YmZsb3cgPSBrZXkgPT4gdGhpcy5zdWJmbG93KGtleSwgZmxvdywgcHVsc2UpO1xuXG4gICAgdGhpcy5fZ3JvdXAgPSBfLmdyb3VwIHx8IHt9O1xuICAgIHRoaXMuaW5pdFRhcmdldHMoKTsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgc3ViZmxvd3NcblxuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICBrID0gY2FjaGUuZ2V0KGlkKTtcblxuICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWNoZS5kZWxldGUoaWQpO1xuICAgICAgICBzdWJmbG93KGspLnJlbSh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KTtcbiAgICAgIGNhY2hlLnNldCh0dXBsZWlkKHQpLCBrKTtcbiAgICAgIHN1YmZsb3coaykuYWRkKHQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHJla2V5IHx8IHB1bHNlLm1vZGlmaWVkKGtleS5maWVsZHMpKSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICAgIGswID0gY2FjaGUuZ2V0KGlkKSxcbiAgICAgICAgICAgICAgazEgPSBrZXkodCk7XG5cbiAgICAgICAgaWYgKGswID09PSBrMSkge1xuICAgICAgICAgIHN1YmZsb3coazEpLm1vZCh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZS5zZXQoaWQsIGsxKTtcbiAgICAgICAgICBzdWJmbG93KGswKS5yZW0odCk7XG4gICAgICAgICAgc3ViZmxvdyhrMSkuYWRkKHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuTU9EKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgc3ViZmxvdyhjYWNoZS5nZXQodHVwbGVpZCh0KSkpLm1vZCh0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZWtleSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVGTE9XLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICAgICAgICBrMCA9IGNhY2hlLmdldChpZCksXG4gICAgICAgICAgICAgIGsxID0ga2V5KHQpO1xuXG4gICAgICAgIGlmIChrMCAhPT0gazEpIHtcbiAgICAgICAgICBjYWNoZS5zZXQoaWQsIGsxKTtcbiAgICAgICAgICBzdWJmbG93KGswKS5yZW0odCk7XG4gICAgICAgICAgc3ViZmxvdyhrMSkuYWRkKHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSkge1xuICAgICAgZGYucnVuQWZ0ZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFuKCk7XG4gICAgICAgIGNhY2hlLmNsZWFuKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIHtcbiAgICAgIGRmLnJ1bkFmdGVyKGNhY2hlLmNsZWFuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIG9uZSBvciBtb3JlIGZpZWxkIGFjY2Vzc29yIGZ1bmN0aW9ucy5cbiAqIElmIHRoZSAnbmFtZScgcGFyYW1ldGVyIGlzIGFuIGFycmF5LCBhbiBhcnJheSBvZiBmaWVsZCBhY2Nlc3NvcnNcbiAqIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlICdhcycgcGFyYW1ldGVyIHdpbGwgYmUgaWdub3JlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIGZpZWxkIG5hbWUocykgdG8gYWNjZXNzLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hcyAtIFRoZSBhY2Nlc3NvciBmdW5jdGlvbiBuYW1lLlxuICovXG5cbmZ1bmN0aW9uIEZpZWxkKHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIG51bGwsIHVwZGF0ZSQzLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoRmllbGQsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDMoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGlzQXJyYXkoXy5uYW1lKSA/IGFycmF5KF8ubmFtZSkubWFwKGYgPT4gZmllbGQoZikpIDogZmllbGQoXy5uYW1lLCBfLmFzKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXJzIGRhdGEgdHVwbGVzIGFjY29yZGluZyB0byBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZXhwciAtIFRoZSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmdW5jdGlvblxuICogICB0aGF0IGRldGVybWluZXMgYSB0dXBsZSdzIGZpbHRlciBzdGF0dXMuIFRydXRoeSB2YWx1ZXMgcGFzcyB0aGUgZmlsdGVyLlxuICovXG5cbmZ1bmN0aW9uIEZpbHRlcihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgZmFzdG1hcCgpLCBwYXJhbXMpO1xufVxuRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZpbHRlcicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXhwcicsXG4gICAgJ3R5cGUnOiAnZXhwcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKEZpbHRlciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAgY2FjaGUgPSB0aGlzLnZhbHVlLFxuICAgICAgICAgIC8vIGNhY2hlIGlkcyBvZiBmaWx0ZXJlZCB0dXBsZXNcbiAgICBvdXRwdXQgPSBwdWxzZS5mb3JrKCksXG4gICAgICAgICAgYWRkID0gb3V0cHV0LmFkZCxcbiAgICAgICAgICByZW0gPSBvdXRwdXQucmVtLFxuICAgICAgICAgIG1vZCA9IG91dHB1dC5tb2QsXG4gICAgICAgICAgdGVzdCA9IF8uZXhwcjtcbiAgICBsZXQgaXNNb2QgPSB0cnVlO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG4gICAgICBpZiAoIWNhY2hlLmhhcyhpZCkpIHJlbS5wdXNoKHQpO2Vsc2UgY2FjaGUuZGVsZXRlKGlkKTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgaWYgKHRlc3QodCwgXykpIGFkZC5wdXNoKHQpO2Vsc2UgY2FjaGUuc2V0KHR1cGxlaWQodCksIDEpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gcmV2aXNpdCh0KSB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgICBiID0gdGVzdCh0LCBfKSxcbiAgICAgICAgICAgIHMgPSBjYWNoZS5nZXQoaWQpO1xuXG4gICAgICBpZiAoYiAmJiBzKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgIGFkZC5wdXNoKHQpO1xuICAgICAgfSBlbHNlIGlmICghYiAmJiAhcykge1xuICAgICAgICBjYWNoZS5zZXQoaWQsIDEpO1xuICAgICAgICByZW0ucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2QgJiYgYiAmJiAhcykge1xuICAgICAgICBtb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHJldmlzaXQpO1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoKSkge1xuICAgICAgaXNNb2QgPSBmYWxzZTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFRkxPVywgcmV2aXNpdCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIGRmLnJ1bkFmdGVyKGNhY2hlLmNsZWFuKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGFycmF5LXR5cGVkIGZpZWxkIHZhbHVlcyBpbnRvIG5ldyBkYXRhIG9iamVjdHMuXG4gKiBJZiBtdWx0aXBsZSBmaWVsZHMgYXJlIHNwZWNpZmllZCwgdGhleSBhcmUgdHJlYXRlZCBhcyBwYXJhbGxlbCBhcnJheXMsXG4gKiB3aXRoIG91dHB1dCB2YWx1ZXMgaW5jbHVkZWQgZm9yIGVhY2ggbWF0Y2hpbmcgaW5kZXggKG9yIG51bGwgaWYgbWlzc2luZykuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IHBhcmFtcy5maWVsZHMgLSBBbiBhcnJheSBvZiBmaWVsZFxuICogICBhY2Nlc3NvcnMgZm9yIHRoZSB0dXBsZSBmaWVsZHMgdGhhdCBzaG91bGQgYmUgZmxhdHRlbmVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuaW5kZXhdIC0gT3B0aW9uYWwgb3V0cHV0IGZpZWxkIG5hbWUgZm9yIGluZGV4XG4gKiAgIHZhbHVlLiBJZiB1bnNwZWNpZmllZCwgbm8gaW5kZXggZmllbGQgaXMgaW5jbHVkZWQgaW4gdGhlIG91dHB1dC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGZsYXR0ZW5lZFxuICogICBhcnJheSBmaWVsZHMuIEFueSB1bnNwZWNpZmllZCBmaWVsZHMgd2lsbCB1c2UgdGhlIGZpZWxkIG5hbWUgcHJvdmlkZWRcbiAqICAgYnkgdGhlIGZpZWxkcyBhY2Nlc3NvcnMuXG4gKi9cblxuZnVuY3Rpb24gRmxhdHRlbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5GbGF0dGVuLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZsYXR0ZW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpbmRleCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9XVxufTtcbmluaGVyaXRzKEZsYXR0ZW4sIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICAgICAgYXMgPSBmaWVsZE5hbWVzKGZpZWxkcywgXy5hcyB8fCBbXSksXG4gICAgICAgICAgaW5kZXggPSBfLmluZGV4IHx8IG51bGwsXG4gICAgICAgICAgbSA9IGFzLmxlbmd0aDsgLy8gcmVtb3ZlIGFueSBwcmV2aW91cyByZXN1bHRzXG5cbiAgICBvdXQucmVtID0gdGhpcy52YWx1ZTsgLy8gZ2VuZXJhdGUgZmxhdHRlbmVkIHR1cGxlc1xuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGNvbnN0IGFycmF5cyA9IGZpZWxkcy5tYXAoZiA9PiBmKHQpKSxcbiAgICAgICAgICAgIG1heGxlbiA9IGFycmF5cy5yZWR1Y2UoKGwsIGEpID0+IE1hdGgubWF4KGwsIGEubGVuZ3RoKSwgMCk7XG4gICAgICBsZXQgaSA9IDAsXG4gICAgICAgICAgaixcbiAgICAgICAgICBkLFxuICAgICAgICAgIHY7XG5cbiAgICAgIGZvciAoOyBpIDwgbWF4bGVuOyArK2kpIHtcbiAgICAgICAgZCA9IGRlcml2ZSh0KTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgZFthc1tqXV0gPSAodiA9IGFycmF5c1tqXVtpXSkgPT0gbnVsbCA/IG51bGwgOiB2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgZFtpbmRleF0gPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0LmFkZC5wdXNoKGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZDtcbiAgICBpZiAoaW5kZXgpIG91dC5tb2RpZmllcyhpbmRleCk7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogRm9sZHMgb25lIG1vcmUgdHVwbGUgZmllbGRzIGludG8gbXVsdGlwbGUgdHVwbGVzIGluIHdoaWNoIHRoZSBmaWVsZFxuICogbmFtZSBhbmQgdmFsdWVzIGFyZSBhdmFpbGFibGUgdW5kZXIgbmV3ICdrZXknIGFuZCAndmFsdWUnIGZpZWxkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzXG4gKiAgIGZvciB0aGUgdHVwbGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGZvbGRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGZvbGRlZCBrZXlcbiAqICAgYW5kIHZhbHVlIGZpZWxkcywgZGVmYXVsdHMgdG8gWydrZXknLCAndmFsdWUnXS5cbiAqL1xuXG5mdW5jdGlvbiBGb2xkKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbkZvbGQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRm9sZCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbJ2tleScsICd2YWx1ZSddXG4gIH1dXG59O1xuaW5oZXJpdHMoRm9sZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBmbmFtZXMgPSBmaWVsZHMubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IFsna2V5JywgJ3ZhbHVlJ10sXG4gICAgICAgICAgayA9IGFzWzBdLFxuICAgICAgICAgIHYgPSBhc1sxXSxcbiAgICAgICAgICBuID0gZmllbGRzLmxlbmd0aDtcbiAgICBvdXQucmVtID0gdGhpcy52YWx1ZTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGQ7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZCA9IGRlcml2ZSh0KTtcbiAgICAgICAgZFtrXSA9IGZuYW1lc1tpXTtcbiAgICAgICAgZFt2XSA9IGZpZWxkc1tpXSh0KTtcbiAgICAgICAgb3V0LmFkZC5wdXNoKGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZDtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBJbnZva2VzIGEgZnVuY3Rpb24gZm9yIGVhY2ggZGF0YSB0dXBsZSBhbmQgc2F2ZXMgdGhlIHJlc3VsdHMgYXMgYSBuZXcgZmllbGQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmV4cHIgLSBUaGUgZm9ybXVsYSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHVwbGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmFzIC0gVGhlIGZpZWxkIG5hbWUgdW5kZXIgd2hpY2ggdG8gc2F2ZSB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmluaXRvbmx5PWZhbHNlXSAtIElmIHRydWUsIHRoZSBmb3JtdWxhIGlzIGFwcGxpZWQgdG9cbiAqICAgYWRkZWQgdHVwbGVzIG9ubHksIGFuZCBkb2VzIG5vdCB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gbW9kaWZpY2F0aW9ucy5cbiAqL1xuXG5mdW5jdGlvbiBGb3JtdWxhKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRm9ybXVsYS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGb3JtdWxhJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXhwcicsXG4gICAgJ3R5cGUnOiAnZXhwcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW5pdG9ubHknLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nXG4gIH1dXG59O1xuaW5oZXJpdHMoRm9ybXVsYSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZ1bmMgPSBfLmV4cHIsXG4gICAgICAgICAgYXMgPSBfLmFzLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgICBmbGFnID0gXy5pbml0b25seSA/IHB1bHNlLkFERCA6IG1vZCA/IHB1bHNlLlNPVVJDRSA6IHB1bHNlLm1vZGlmaWVkKGZ1bmMuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZChhcykgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQUREO1xuXG4gICAgaWYgKG1vZCkge1xuICAgICAgLy8gcGFyYW1ldGVycyB1cGRhdGVkLCBuZWVkIHRvIHJlZmxvd1xuICAgICAgcHVsc2UgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLnJlZmxvdyh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaW5pdG9ubHkpIHtcbiAgICAgIHB1bHNlLm1vZGlmaWVzKGFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2UudmlzaXQoZmxhZywgdCA9PiB0W2FzXSA9IGZ1bmModCwgXykpO1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBkYXRhIHR1cGxlcyB1c2luZyBhIHByb3ZpZGVkIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihQYXJhbWV0ZXJzKTogb2JqZWN0fSBwYXJhbXMuZ2VuZXJhdG9yIC0gQSB0dXBsZSBnZW5lcmF0b3JcbiAqICAgZnVuY3Rpb24uIFRoaXMgZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlIG9wZXJhdG9yIHBhcmFtZXRlcnMgYXMgaW5wdXQuXG4gKiAgIENoYW5nZXMgdG8gYW55IGFkZGl0aW9uYWwgcGFyYW1ldGVycyB3aWxsIG5vdCB0cmlnZ2VyIHJlLWNhbGN1bGF0aW9uXG4gKiAgIG9mIHByZXZpb3VzbHkgZ2VuZXJhdGVkIHR1cGxlcy4gT25seSBmdXR1cmUgdHVwbGVzIGFyZSBhZmZlY3RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc2l6ZSAtIFRoZSBudW1iZXIgb2YgdHVwbGVzIHRvIHByb2R1Y2UuXG4gKi9cblxuZnVuY3Rpb24gR2VuZXJhdGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoR2VuZXJhdGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICAgICAgZ2VuID0gXy5nZW5lcmF0b3I7XG4gICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlLFxuICAgICAgICBudW0gPSBfLnNpemUgLSBkYXRhLmxlbmd0aCxcbiAgICAgICAgYWRkLFxuICAgICAgICByZW0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAobnVtID4gMCkge1xuICAgICAgLy8gbmVlZCBtb3JlIHR1cGxlcywgZ2VuZXJhdGUgYW5kIGFkZFxuICAgICAgZm9yIChhZGQgPSBbXTsgLS1udW0gPj0gMDspIHtcbiAgICAgICAgYWRkLnB1c2godCA9IGluZ2VzdChnZW4oXykpKTtcbiAgICAgICAgZGF0YS5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICBvdXQuYWRkID0gb3V0LmFkZC5sZW5ndGggPyBvdXQubWF0ZXJpYWxpemUob3V0LkFERCkuYWRkLmNvbmNhdChhZGQpIDogYWRkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZWVkIGZld2VyIHR1cGxlcywgcmVtb3ZlXG4gICAgICByZW0gPSBkYXRhLnNsaWNlKDAsIC1udW0pO1xuICAgICAgb3V0LnJlbSA9IG91dC5yZW0ubGVuZ3RoID8gb3V0Lm1hdGVyaWFsaXplKG91dC5SRU0pLnJlbS5jb25jYXQocmVtKSA6IHJlbTtcbiAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKC1udW0pO1xuICAgIH1cblxuICAgIG91dC5zb3VyY2UgPSB0aGlzLnZhbHVlID0gZGF0YTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5jb25zdCBNZXRob2RzID0ge1xuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgbWVkaWFuOiBtZWRpYW4sXG4gIG1lYW46IG1lYW4sXG4gIG1pbjogbWluLFxuICBtYXg6IG1heFxufTtcbmNvbnN0IEVtcHR5ID0gW107XG4vKipcbiAqIEltcHV0ZSBtaXNzaW5nIHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gaW1wdXRlLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mXG4gKiAgIGFjY2Vzc29ycyB0byBkZXRlcm1pbmUgc2VyaWVzIHdpdGhpbiB3aGljaCB0byBwZXJmb3JtIGltcHV0YXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5rZXkgLSBBbiBhY2Nlc3NvciBmb3IgYSBrZXkgdmFsdWUuXG4gKiAgIEVhY2gga2V5IHZhbHVlIHNob3VsZCBiZSB1bmlxdWUgd2l0aGluIGEgZ3JvdXAuIE5ldyB0dXBsZXMgd2lsbCBiZVxuICogICBpbXB1dGVkIGZvciBhbnkga2V5IHZhbHVlcyB0aGF0IGFyZSBub3QgZm91bmQgd2l0aGluIGEgZ3JvdXAuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBbcGFyYW1zLmtleXZhbHNdIC0gT3B0aW9uYWwgYXJyYXkgb2YgcmVxdWlyZWQga2V5XG4gKiAgIHZhbHVlcy4gTmV3IHR1cGxlcyB3aWxsIGJlIGltcHV0ZWQgZm9yIGFueSBrZXkgdmFsdWVzIHRoYXQgYXJlIG5vdFxuICogICBmb3VuZCB3aXRoaW4gYSBncm91cC4gSW4gYWRkaXRpb24sIHRoZXNlIHZhbHVlcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcbiAqICAgYXVnbWVudGVkIHdpdGggdGhlIGtleSB2YWx1ZXMgb2JzZXJ2ZWQgaW4gdGhlIGlucHV0IGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0ndmFsdWUnXSAtIFRoZSBpbXB1dGF0aW9uIG1ldGhvZCB0byB1c2UuIE9uZSBvZlxuICogICAndmFsdWUnLCAnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbicuXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT0wXSAtIFRoZSBjb25zdGFudCB2YWx1ZSB0byB1c2UgZm9yIGltcHV0YXRpb25cbiAqICAgd2hlbiB1c2luZyBtZXRob2QgJ3ZhbHVlJy5cbiAqL1xuXG5mdW5jdGlvbiBJbXB1dGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuSW1wdXRlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ltcHV0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXl2YWxzJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd2YWx1ZScsXG4gICAgJ3ZhbHVlcyc6IFsndmFsdWUnLCAnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbiddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZScsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH1dXG59O1xuXG5mdW5jdGlvbiBnZXRWYWx1ZShfKSB7XG4gIHZhciBtID0gXy5tZXRob2QgfHwgTWV0aG9kcy52YWx1ZSxcbiAgICAgIHY7XG5cbiAgaWYgKE1ldGhvZHNbbV0gPT0gbnVsbCkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgaW1wdXRhdGlvbiBtZXRob2Q6ICcgKyBtKTtcbiAgfSBlbHNlIGlmIChtID09PSBNZXRob2RzLnZhbHVlKSB7XG4gICAgdiA9IF8udmFsdWUgIT09IHVuZGVmaW5lZCA/IF8udmFsdWUgOiAwO1xuICAgIHJldHVybiAoKSA9PiB2O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNZXRob2RzW21dO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpZWxkKF8pIHtcbiAgY29uc3QgZiA9IF8uZmllbGQ7XG4gIHJldHVybiB0ID0+IHQgPyBmKHQpIDogTmFOO1xufVxuXG5pbmhlcml0cyhJbXB1dGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgICBpbXB1dGUgPSBnZXRWYWx1ZShfKSxcbiAgICAgICAgZmllbGQgPSBnZXRGaWVsZChfKSxcbiAgICAgICAgZk5hbWUgPSBhY2Nlc3Nvck5hbWUoXy5maWVsZCksXG4gICAgICAgIGtOYW1lID0gYWNjZXNzb3JOYW1lKF8ua2V5KSxcbiAgICAgICAgZ05hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihwdWxzZS5zb3VyY2UsIF8uZ3JvdXBieSwgXy5rZXksIF8ua2V5dmFscyksXG4gICAgICAgIGN1cnIgPSBbXSxcbiAgICAgICAgcHJldiA9IHRoaXMudmFsdWUsXG4gICAgICAgIG0gPSBncm91cHMuZG9tYWluLmxlbmd0aCxcbiAgICAgICAgZ3JvdXAsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBnVmFscyxcbiAgICAgICAga1ZhbCxcbiAgICAgICAgZyxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgbCxcbiAgICAgICAgbixcbiAgICAgICAgdDtcblxuICAgIGZvciAoZyA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBnIDwgbDsgKytnKSB7XG4gICAgICBncm91cCA9IGdyb3Vwc1tnXTtcbiAgICAgIGdWYWxzID0gZ3JvdXAudmFsdWVzO1xuICAgICAgdmFsdWUgPSBOYU47IC8vIGFkZCB0dXBsZXMgZm9yIG1pc3NpbmcgdmFsdWVzXG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgaWYgKGdyb3VwW2pdICE9IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBrVmFsID0gZ3JvdXBzLmRvbWFpbltqXTtcbiAgICAgICAgdCA9IHtcbiAgICAgICAgICBfaW1wdXRlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGdWYWxzLmxlbmd0aDsgaSA8IG47ICsraSkgdFtnTmFtZXNbaV1dID0gZ1ZhbHNbaV07XG5cbiAgICAgICAgdFtrTmFtZV0gPSBrVmFsO1xuICAgICAgICB0W2ZOYW1lXSA9IE51bWJlci5pc05hTih2YWx1ZSkgPyB2YWx1ZSA9IGltcHV0ZShncm91cCwgZmllbGQpIDogdmFsdWU7XG4gICAgICAgIGN1cnIucHVzaChpbmdlc3QodCkpO1xuICAgICAgfVxuICAgIH0gLy8gdXBkYXRlIHB1bHNlIHdpdGggaW1wdXRlZCB0dXBsZXNcblxuXG4gICAgaWYgKGN1cnIubGVuZ3RoKSBvdXQuYWRkID0gb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZC5jb25jYXQoY3Vycik7XG4gICAgaWYgKHByZXYubGVuZ3RoKSBvdXQucmVtID0gb3V0Lm1hdGVyaWFsaXplKG91dC5SRU0pLnJlbS5jb25jYXQocHJldik7XG4gICAgdGhpcy52YWx1ZSA9IGN1cnI7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIGtleSwga2V5dmFscykge1xuICB2YXIgZ2V0ID0gZiA9PiBmKHQpLFxuICAgICAgZ3JvdXBzID0gW10sXG4gICAgICBkb21haW4gPSBrZXl2YWxzID8ga2V5dmFscy5zbGljZSgpIDogW10sXG4gICAgICBrTWFwID0ge30sXG4gICAgICBnTWFwID0ge30sXG4gICAgICBnVmFscyxcbiAgICAgIGdLZXksXG4gICAgICBncm91cCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIG4sXG4gICAgICB0O1xuXG4gIGRvbWFpbi5mb3JFYWNoKChrLCBpKSA9PiBrTWFwW2tdID0gaSArIDEpO1xuXG4gIGZvciAoaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHQgPSBkYXRhW2ldO1xuICAgIGsgPSBrZXkodCk7XG4gICAgaiA9IGtNYXBba10gfHwgKGtNYXBba10gPSBkb21haW4ucHVzaChrKSk7XG4gICAgZ0tleSA9IChnVmFscyA9IGdyb3VwYnkgPyBncm91cGJ5Lm1hcChnZXQpIDogRW1wdHkpICsgJyc7XG5cbiAgICBpZiAoIShncm91cCA9IGdNYXBbZ0tleV0pKSB7XG4gICAgICBncm91cCA9IGdNYXBbZ0tleV0gPSBbXTtcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgIGdyb3VwLnZhbHVlcyA9IGdWYWxzO1xuICAgIH1cblxuICAgIGdyb3VwW2ogLSAxXSA9IHQ7XG4gIH1cblxuICBncm91cHMuZG9tYWluID0gZG9tYWluO1xuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIEV4dGVuZCBpbnB1dCB0dXBsZXMgd2l0aCBhZ2dyZWdhdGUgdmFsdWVzLlxuICogQ2FsY3VhdGVzIGFnZ3JlZ2F0ZSB2YWx1ZXMgYW5kIGpvaW5zIHRoZW0gd2l0aCB0aGUgaW5wdXQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gSm9pbkFnZ3JlZ2F0ZShwYXJhbXMpIHtcbiAgQWdncmVnYXRlLmNhbGwodGhpcywgcGFyYW1zKTtcbn1cbkpvaW5BZ2dyZWdhdGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnSm9pbkFnZ3JlZ2F0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BzJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wc1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoSm9pbkFnZ3JlZ2F0ZSwgQWdncmVnYXRlLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFnZ3IgPSB0aGlzLFxuICAgICAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKTtcblxuICAgIGxldCBjZWxsczsgLy8gcHJvY2VzcyBhbGwgaW5wdXQgdHVwbGVzIHRvIGNhbGN1bGF0ZSBhZ2dyZWdhdGVzXG5cbiAgICBpZiAoYWdnci52YWx1ZSAmJiAobW9kIHx8IHB1bHNlLm1vZGlmaWVkKGFnZ3IuX2lucHV0cywgdHJ1ZSkpKSB7XG4gICAgICBjZWxscyA9IGFnZ3IudmFsdWUgPSBtb2QgPyBhZ2dyLmluaXQoXykgOiB7fTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxzID0gYWdnci52YWx1ZSA9IGFnZ3IudmFsdWUgfHwgdGhpcy5pbml0KF8pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGFnZ3IucmVtKHQpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiBhZ2dyLmFkZCh0KSk7XG4gICAgfSAvLyB1cGRhdGUgYWdncmVnYXRpb24gY2VsbHNcblxuXG4gICAgYWdnci5jaGFuZ2VzKCk7IC8vIHdyaXRlIGFnZ3JlZ2F0ZSB2YWx1ZXMgdG8gaW5wdXQgdHVwbGVzXG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgZXh0ZW5kKHQsIGNlbGxzW2FnZ3IuY2VsbGtleSh0KV0udHVwbGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyh0aGlzLl9vdXRwdXRzKTtcbiAgfSxcblxuICBjaGFuZ2VzKCkge1xuICAgIGNvbnN0IGFkZHMgPSB0aGlzLl9hZGRzLFxuICAgICAgICAgIG1vZHMgPSB0aGlzLl9tb2RzO1xuICAgIGxldCBpLCBuO1xuXG4gICAgZm9yIChpID0gMCwgbiA9IHRoaXMuX2FsZW47IGkgPCBuOyArK2kpIHtcbiAgICAgIHRoaXMuY2VsbHR1cGxlKGFkZHNbaV0pO1xuICAgICAgYWRkc1tpXSA9IG51bGw7IC8vIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fbWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgdGhpcy5jZWxsdHVwbGUobW9kc1tpXSk7XG4gICAgICBtb2RzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cblxuICAgIHRoaXMuX2FsZW4gPSB0aGlzLl9tbGVuID0gMDsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgY2VsbHNcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBDb21wdXRlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRlcyAoS0RFKSBmb3Igb25lIG9yIG1vcmUgZGF0YSBncm91cHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnNcbiAqICAgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBkYXRhIGZpZWxkXG4gKiAgIHRvIGVzdGltYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuYmFuZHdpZHRoPTBdIC0gVGhlIEtERSBrZXJuZWwgYmFuZHdpZHRoLlxuICogICBJZiB6ZXJvIG9yIHVuc3BlY2lmaWVkLCB0aGUgYmFuZHdpZHRoIGlzIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jb3VudHM9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGVcbiAqICAgb3V0cHV0IHZhbHVlcyBzaG91bGQgYmUgcHJvYmFiaWxpdHkgZXN0aW1hdGVzIChmYWxzZSwgZGVmYXVsdCkgb3JcbiAqICAgc21vb3RoZWQgY291bnRzICh0cnVlKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmN1bXVsYXRpdmU9ZmFsc2VdIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiBhXG4gKiAgIGRlbnNpdHkgKGZhbHNlKSBvciBjdW11bGF0aXZlIGRpc3RyaWJ1dGlvbiAodHJ1ZSkgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5leHRlbnRdIC0gVGhlIGRvbWFpbiBleHRlbnQgb3ZlciB3aGljaCB0b1xuICogICBwbG90IHRoZSBkZW5zaXR5LiBJZiB1bnNwZWNpZmllZCwgdGhlIFttaW4sIG1heF0gZGF0YSBleHRlbnQgaXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmU9J2luZGVwZW5kZW50J10gLSBJbmRpY2F0ZXMgaG93IHBhcmFtZXRlcnMgZm9yXG4gKiAgIG11bHRpcGxlIGRlbnNpdGllcyBzaG91bGQgYmUgcmVzb2x2ZWQuIElmIFwiaW5kZXBlbmRlbnRcIiAodGhlIGRlZmF1bHQpLCBlYWNoXG4gKiAgIGRlbnNpdHkgbWF5IGhhdmUgaXRzIG93biBkb21haW4gZXh0ZW50IGFuZCBkeW5hbWljIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVcbiAqICAgc3RlcHMuIElmIFwic2hhcmVkXCIsIHRoZSBLREUgdHJhbnNmb3JtIHdpbGwgZW5zdXJlIHRoYXQgYWxsIGRlbnNpdGllcyBhcmVcbiAqICAgZGVmaW5lZCBvdmVyIGEgc2hhcmVkIGRvbWFpbiBhbmQgY3VydmUgc3RlcHMsIGVuYWJsaW5nIHN0YWNraW5nLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWluc3RlcHM9MjVdIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWF4c3RlcHM9MjAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBzXSAtIFRoZSBleGFjdCBudW1iZXIgb2YgY3VydmUgc2FtcGxlcyBmb3JcbiAqICAgcGxvdHRpbmcgdGhlIGRlbnNpdHkuIElmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGJvdGggbWluc3RlcHMgYW5kIG1heHN0ZXBzXG4gKiAgIHRvIHNldCBhbiBleGFjdCBudW1iZXIgb2YgdW5pZm9ybSBzYW1wbGVzLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICBhIGZpeGVkIGV4dGVudCB0byBlbnN1cmUgY29uc2lzdGVudCBzYW1wbGUgcG9pbnRzIGZvciBzdGFja2VkIGRlbnNpdGllcy5cbiAqL1xuXG5mdW5jdGlvbiBLREUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5LREUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnS0RFJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2N1bXVsYXRpdmUnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50cycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjVcbiAgfSwge1xuICAgICduYW1lJzogJ21heHN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWyd2YWx1ZScsICdkZW5zaXR5J11cbiAgfV1cbn07XG5pbmhlcml0cyhLREUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG5cbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShzb3VyY2UsIF8uZ3JvdXBieSwgXy5maWVsZCksXG4gICAgICAgICAgICBuYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgICAgICAgYmFuZHdpZHRoID0gXy5iYW5kd2lkdGgsXG4gICAgICAgICAgICBtZXRob2QgPSBfLmN1bXVsYXRpdmUgPyAnY2RmJyA6ICdwZGYnLFxuICAgICAgICAgICAgYXMgPSBfLmFzIHx8IFsndmFsdWUnLCAnZGVuc2l0eSddLFxuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBsZXQgZG9tYWluID0gXy5leHRlbnQsXG4gICAgICAgICAgbWluc3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWluc3RlcHMgfHwgMjUsXG4gICAgICAgICAgbWF4c3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWF4c3RlcHMgfHwgMjAwO1xuXG4gICAgICBpZiAobWV0aG9kICE9PSAncGRmJyAmJiBtZXRob2QgIT09ICdjZGYnKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGRlbnNpdHkgbWV0aG9kOiAnICsgbWV0aG9kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8ucmVzb2x2ZSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgaWYgKCFkb21haW4pIGRvbWFpbiA9IGV4dGVudChzb3VyY2UsIF8uZmllbGQpO1xuICAgICAgICBtaW5zdGVwcyA9IG1heHN0ZXBzID0gXy5zdGVwcyB8fCBtYXhzdGVwcztcbiAgICAgIH1cblxuICAgICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICAgIGNvbnN0IGRlbnNpdHkgPSByYW5kb21LREUoZywgYmFuZHdpZHRoKVttZXRob2RdLFxuICAgICAgICAgICAgICBzY2FsZSA9IF8uY291bnRzID8gZy5sZW5ndGggOiAxLFxuICAgICAgICAgICAgICBsb2NhbCA9IGRvbWFpbiB8fCBleHRlbnQoZyk7XG4gICAgICAgIHNhbXBsZUN1cnZlKGRlbnNpdHksIGxvY2FsLCBtaW5zdGVwcywgbWF4c3RlcHMpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHt9O1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdFtuYW1lc1tpXV0gPSBnLmRpbXNbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFthc1swXV0gPSB2WzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gdlsxXSAqIHNjYWxlO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXkgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZCBuYW1lKHMpIGZvciB0aGUga2V5IGZ1bmN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMuZmxhdCAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGZpZWxkIG5hbWVzXG4gKiAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZmxhdCBwcm9wZXJ0eSBuYW1lcywgc2lkZS1zdGVwcGluZyBuZXN0ZWQgZmllbGRcbiAqICBsb29rdXBzIG5vcm1hbGx5IGluZGljYXRlZCBieSBkb3Qgb3IgYnJhY2tldCBub3RhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBLZXkocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDIsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhLZXksIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlJDIoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGtleShfLmZpZWxkcywgXy5mbGF0KTtcbn1cblxuLyoqXG4gKiBMb2FkIGFuZCBwYXJzZSBkYXRhIGZyb20gYW4gZXh0ZXJuYWwgc291cmNlLiBNYXJzaGFsbHMgcGFyYW1ldGVyXG4gKiB2YWx1ZXMgYW5kIHRoZW4gaW52b2tlcyB0aGUgRGF0YWZsb3cgcmVxdWVzdCBtZXRob2QuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMudXJsIC0gVGhlIFVSTCB0byBsb2FkIGZyb20uXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmZvcm1hdCAtIFRoZSBkYXRhIGZvcm1hdCBvcHRpb25zLlxuICovXG5cbmZ1bmN0aW9uIExvYWQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xuICB0aGlzLl9wZW5kaW5nID0gbnVsbDtcbn1cbmluaGVyaXRzKExvYWQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93O1xuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuIHB1bHNlXG4gICAgICByZXR1cm4gb3V0cHV0KHRoaXMsIHB1bHNlLCB0aGlzLl9wZW5kaW5nKTtcbiAgICB9XG5cbiAgICBpZiAoc3RvcChfKSkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcblxuICAgIGlmIChfLnZhbHVlcykge1xuICAgICAgLy8gcGFyc2UgYW5kIGluZ2VzdCB2YWx1ZXMsIHJldHVybiBvdXRwdXQgcHVsc2VcbiAgICAgIHJldHVybiBvdXRwdXQodGhpcywgcHVsc2UsIGRmLnBhcnNlKF8udmFsdWVzLCBfLmZvcm1hdCkpO1xuICAgIH0gZWxzZSBpZiAoXy5hc3luYykge1xuICAgICAgLy8gcmV0dXJuIHByb21pc2UgZm9yIG5vbi1ibG9ja2luZyBhc3luYyBsb2FkaW5nXG4gICAgICBjb25zdCBwID0gZGYucmVxdWVzdChfLnVybCwgXy5mb3JtYXQpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IGFycmF5KHJlcy5kYXRhKTtcbiAgICAgICAgcmV0dXJuIGRmID0+IGRmLnRvdWNoKHRoaXMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYzogcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIHByb21pc2UgZm9yIHN5bmNocm9ub3VzIGxvYWRpbmdcbiAgICAgIHJldHVybiBkZi5yZXF1ZXN0KF8udXJsLCBfLmZvcm1hdCkudGhlbihyZXMgPT4gb3V0cHV0KHRoaXMsIHB1bHNlLCBhcnJheShyZXMuZGF0YSkpKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIHN0b3AoXykge1xuICByZXR1cm4gXy5tb2RpZmllZCgnYXN5bmMnKSAmJiAhKF8ubW9kaWZpZWQoJ3ZhbHVlcycpIHx8IF8ubW9kaWZpZWQoJ3VybCcpIHx8IF8ubW9kaWZpZWQoJ2Zvcm1hdCcpKTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0KG9wLCBwdWxzZSwgZGF0YSkge1xuICBkYXRhLmZvckVhY2goaW5nZXN0KTtcbiAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19GSUVMRFMgJiBwdWxzZS5OT19TT1VSQ0UpO1xuICBvdXQucmVtID0gb3AudmFsdWU7XG4gIG9wLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQgPSBkYXRhO1xuICBvcC5fcGVuZGluZyA9IG51bGw7XG4gIGlmIChvdXQucmVtLmxlbmd0aCkgb3V0LmNsZWFuKHRydWUpO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIEV4dGVuZCB0dXBsZXMgYnkgam9pbmluZyB0aGVtIHdpdGggdmFsdWVzIGZyb20gYSBsb29rdXAgdGFibGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7TWFwfSBwYXJhbXMuaW5kZXggLSBUaGUgbG9va3VwIHRhYmxlIG1hcC5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZHMgdG8gbG9va3VwLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJhbXMuYXMgLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGVhY2ggbG9va3VwIHZhbHVlLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmRlZmF1bHRdIC0gQSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiBsb29rdXAgZmFpbHMuXG4gKi9cblxuZnVuY3Rpb24gTG9va3VwKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbn1cbkxvb2t1cC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMb29rdXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdpbmRleCcsXG4gICAgJ3R5cGUnOiAnaW5kZXgnLFxuICAgICdwYXJhbXMnOiBbe1xuICAgICAgJ25hbWUnOiAnZnJvbScsXG4gICAgICAndHlwZSc6ICdkYXRhJyxcbiAgICAgICdyZXF1aXJlZCc6IHRydWVcbiAgICB9LCB7XG4gICAgICAnbmFtZSc6ICdrZXknLFxuICAgICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICAgIH1dXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2RlZmF1bHQnLFxuICAgICdkZWZhdWx0JzogbnVsbFxuICB9XVxufTtcbmluaGVyaXRzKExvb2t1cCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBfLmZpZWxkcyxcbiAgICAgICAgICBpbmRleCA9IF8uaW5kZXgsXG4gICAgICAgICAgdmFsdWVzID0gXy52YWx1ZXMsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gXy5kZWZhdWx0ID09IG51bGwgPyBudWxsIDogXy5kZWZhdWx0LFxuICAgICAgICAgIHJlc2V0ID0gXy5tb2RpZmllZCgpLFxuICAgICAgICAgIG4gPSBrZXlzLmxlbmd0aDtcblxuICAgIGxldCBmbGFnID0gcmVzZXQgPyBwdWxzZS5TT1VSQ0UgOiBwdWxzZS5BREQsXG4gICAgICAgIG91dCA9IHB1bHNlLFxuICAgICAgICBhcyA9IF8uYXMsXG4gICAgICAgIHNldCxcbiAgICAgICAgbSxcbiAgICAgICAgbW9kcztcblxuICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgIG0gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobiA+IDEgJiYgIWFzKSB7XG4gICAgICAgIGVycm9yKCdNdWx0aS1maWVsZCBsb29rdXAgcmVxdWlyZXMgZXhwbGljaXQgXCJhc1wiIHBhcmFtZXRlci4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFzICYmIGFzLmxlbmd0aCAhPT0gbiAqIG0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBcImFzXCIgcGFyYW1ldGVyIGhhcyB0b28gZmV3IG91dHB1dCBmaWVsZCBuYW1lcy4nKTtcbiAgICAgIH1cblxuICAgICAgYXMgPSBhcyB8fCB2YWx1ZXMubWFwKGFjY2Vzc29yTmFtZSk7XG5cbiAgICAgIHNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrID0gMCwgaiwgdjsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHYgPSBpbmRleC5nZXQoa2V5c1tpXSh0KSk7XG4gICAgICAgICAgaWYgKHYgPT0gbnVsbCkgZm9yIChqID0gMDsgaiA8IG07ICsraiwgKytrKSB0W2FzW2tdXSA9IGRlZmF1bHRWYWx1ZTtlbHNlIGZvciAoaiA9IDA7IGogPCBtOyArK2osICsraykgdFthc1trXV0gPSB2YWx1ZXNbal0odik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYXMpIHtcbiAgICAgICAgZXJyb3IoJ01pc3Npbmcgb3V0cHV0IGZpZWxkIG5hbWVzLicpO1xuICAgICAgfVxuXG4gICAgICBzZXQgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgdjsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHYgPSBpbmRleC5nZXQoa2V5c1tpXSh0KSk7XG4gICAgICAgICAgdFthc1tpXV0gPSB2ID09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiB2O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChyZXNldCkge1xuICAgICAgb3V0ID0gcHVsc2UucmVmbG93KHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RzID0ga2V5cy5zb21lKGsgPT4gcHVsc2UubW9kaWZpZWQoay5maWVsZHMpKTtcbiAgICAgIGZsYWcgfD0gbW9kcyA/IHB1bHNlLk1PRCA6IDA7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgc2V0KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBDb21wdXRlcyBnbG9iYWwgbWluL21heCBleHRlbnRzIG92ZXIgYSBjb2xsZWN0aW9uIG9mIGV4dGVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IHBhcmFtcy5leHRlbnRzIC0gVGhlIGlucHV0IGV4dGVudHMuXG4gKi9cblxuZnVuY3Rpb24gTXVsdGlFeHRlbnQocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDEsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhNdWx0aUV4dGVudCwgT3BlcmF0b3IpO1xuXG5mdW5jdGlvbiB1cGRhdGUkMShfKSB7XG4gIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIGNvbnN0IGV4dCA9IF8uZXh0ZW50cyxcbiAgICAgICAgbiA9IGV4dC5sZW5ndGg7XG4gIGxldCBtaW4gPSArSW5maW5pdHksXG4gICAgICBtYXggPSAtSW5maW5pdHksXG4gICAgICBpLFxuICAgICAgZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZSA9IGV4dFtpXTtcbiAgICBpZiAoZVswXSA8IG1pbikgbWluID0gZVswXTtcbiAgICBpZiAoZVsxXSA+IG1heCkgbWF4ID0gZVsxXTtcbiAgfVxuXG4gIHJldHVybiBbbWluLCBtYXhdO1xufVxuXG4vKipcbiAqIE1lcmdlIGEgY29sbGVjdGlvbiBvZiB2YWx1ZSBhcnJheXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8Kj4+fSBwYXJhbXMudmFsdWVzIC0gVGhlIGlucHV0IHZhbHVlIGFycnJheXMuXG4gKi9cblxuZnVuY3Rpb24gTXVsdGlWYWx1ZXMocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTXVsdGlWYWx1ZXMsIE9wZXJhdG9yKTtcblxuZnVuY3Rpb24gdXBkYXRlKF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBfLnZhbHVlcy5yZWR1Y2UoKGRhdGEsIF8pID0+IGRhdGEuY29uY2F0KF8pLCBbXSk7XG59XG5cbi8qKlxuICogT3BlcmF0b3Igd2hvc2UgdmFsdWUgaXMgc2ltcGx5IGl0cyBwYXJhbWV0ZXIgaGFzaC4gVGhpcyBvcGVyYXRvciBpc1xuICogdXNlZnVsIGZvciBlbmFibGluZyByZWFjdGl2ZSB1cGRhdGVzIHRvIHZhbHVlcyBvZiBuZXN0ZWQgb2JqZWN0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFBhcmFtcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFBhcmFtcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHRoaXMubW9kaWZpZWQoXy5tb2RpZmllZCgpKTtcbiAgICB0aGlzLnZhbHVlID0gXztcbiAgICByZXR1cm4gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpOyAvLyBkbyBub3QgcGFzcyB0dXBsZXNcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgYW5kIHBpdm90IHNlbGVjdGVkIGZpZWxkIHZhbHVlcyB0byBiZWNvbWUgbmV3IGZpZWxkcy5cbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIHRvIGNvbnN0cnVjdGlvbiBjcm9zcy10YWJ1bGF0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogIHRvIGdyb3VwYnkuIFRoZXNlIGZpZWxkcyBhY3QganVzdCBsaWtlIGdyb3VwYnkgZmllbGRzIG9mIGFuIEFnZ3JlZ2F0ZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZCB0byBwaXZvdCBvbi4gVGhlIHVuaXF1ZVxuICogIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSBuZXcgZmllbGQgbmFtZXMgaW4gdGhlIG91dHB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy52YWx1ZSAtIFRoZSBmaWVsZCB0byBwb3B1bGF0ZSBwaXZvdGVkIGZpZWxkcy5cbiAqICBUaGUgYWdncmVnYXRlIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSB0aGUgdmFsdWVzIG9mIHRoZSBuZXcgcGl2b3RlZCBmaWVsZHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5vcF0gLSBUaGUgYWdncmVnYXRpb24gb3BlcmF0aW9uIGZvciB0aGUgdmFsdWUgZmllbGQsXG4gKiAgYXBwbGllZCBwZXIgY2VsbCBpbiB0aGUgb3V0cHV0IHN0cmVhbS4gVGhlIGRlZmF1bHQgaXMgXCJzdW1cIi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmxpbWl0XSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtXG4gKiAgbnVtYmVyIG9mIHBpdm90ZWQgZmllbGRzIHRvIGdlbmVyYXRlLiBUaGUgcGl2b3RlZCBmaWVsZCBuYW1lcyBhcmUgc29ydGVkIGluXG4gKiAgYXNjZW5kaW5nIG9yZGVyIHByaW9yIHRvIGVuZm9yY2luZyB0aGUgbGltaXQuXG4gKi9cblxuZnVuY3Rpb24gUGl2b3QocGFyYW1zKSB7XG4gIEFnZ3JlZ2F0ZS5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5QaXZvdC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdQaXZvdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWUnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkQWdncmVnYXRlT3BzLFxuICAgICdkZWZhdWx0JzogJ3N1bSdcbiAgfSwge1xuICAgICduYW1lJzogJ2xpbWl0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfV1cbn07XG5pbmhlcml0cyhQaXZvdCwgQWdncmVnYXRlLCB7XG4gIF90cmFuc2Zvcm06IEFnZ3JlZ2F0ZS5wcm90b3R5cGUudHJhbnNmb3JtLFxuXG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0oYWdncmVnYXRlUGFyYW1zKF8sIHB1bHNlKSwgcHVsc2UpO1xuICB9XG5cbn0pOyAvLyBTaG9laG9ybiBhIHBpdm90IHRyYW5zZm9ybSBpbnRvIGFuIGFnZ3JlZ2F0ZSB0cmFuc2Zvcm0hXG4vLyBGaXJzdCBjb2xsZWN0IGFsbCB1bmlxdWUgcGl2b3QgZmllbGQgdmFsdWVzLlxuLy8gVGhlbiBnZW5lcmF0ZSBhZ2dyZWdhdGUgZmllbGRzIGZvciBlYWNoIG91dHB1dCBwaXZvdCBmaWVsZC5cblxuZnVuY3Rpb24gYWdncmVnYXRlUGFyYW1zKF8sIHB1bHNlKSB7XG4gIGNvbnN0IGtleSA9IF8uZmllbGQsXG4gICAgICAgIHZhbHVlID0gXy52YWx1ZSxcbiAgICAgICAgb3AgPSAoXy5vcCA9PT0gJ2NvdW50JyA/ICdfX2NvdW50X18nIDogXy5vcCkgfHwgJ3N1bScsXG4gICAgICAgIGZpZWxkcyA9IGFjY2Vzc29yRmllbGRzKGtleSkuY29uY2F0KGFjY2Vzc29yRmllbGRzKHZhbHVlKSksXG4gICAgICAgIGtleXMgPSBwaXZvdEtleXMoa2V5LCBfLmxpbWl0IHx8IDAsIHB1bHNlKTsgLy8gaWYgZGF0YSBzdHJlYW0gY29udGVudCBjaGFuZ2VzLCBwaXZvdCBmaWVsZHMgbWF5IGNoYW5nZVxuICAvLyBmbGFnIHBhcmFtZXRlciBtb2RpZmljYXRpb24gdG8gZW5zdXJlIHJlLWluaXRpYWxpemF0aW9uXG5cbiAgaWYgKHB1bHNlLmNoYW5nZWQoKSkgXy5zZXQoJ19fcGl2b3RfXycsIG51bGwsIG51bGwsIHRydWUpO1xuICByZXR1cm4ge1xuICAgIGtleTogXy5rZXksXG4gICAgZ3JvdXBieTogXy5ncm91cGJ5LFxuICAgIG9wczoga2V5cy5tYXAoKCkgPT4gb3ApLFxuICAgIGZpZWxkczoga2V5cy5tYXAoayA9PiBnZXQoaywga2V5LCB2YWx1ZSwgZmllbGRzKSksXG4gICAgYXM6IGtleXMubWFwKGsgPT4gayArICcnKSxcbiAgICBtb2RpZmllZDogXy5tb2RpZmllZC5iaW5kKF8pXG4gIH07XG59IC8vIEdlbmVyYXRlIGFnZ3JlZ2F0ZSBmaWVsZCBhY2Nlc3Nvci5cbi8vIE91dHB1dCBOYU4gZm9yIG5vbi1leGlzdGVudCB2YWx1ZXM7IGFnZ3JlZ2F0b3Igd2lsbCBpZ25vcmUhXG5cblxuZnVuY3Rpb24gZ2V0KGssIGtleSwgdmFsdWUsIGZpZWxkcykge1xuICByZXR1cm4gYWNjZXNzb3IoZCA9PiBrZXkoZCkgPT09IGsgPyB2YWx1ZShkKSA6IE5hTiwgZmllbGRzLCBrICsgJycpO1xufSAvLyBDb2xsZWN0IChhbmQgb3B0aW9uYWxseSBsaW1pdCkgYWxsIHVuaXF1ZSBwaXZvdCB2YWx1ZXMuXG5cblxuZnVuY3Rpb24gcGl2b3RLZXlzKGtleSwgbGltaXQsIHB1bHNlKSB7XG4gIGNvbnN0IG1hcCA9IHt9LFxuICAgICAgICBsaXN0ID0gW107XG4gIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgY29uc3QgayA9IGtleSh0KTtcblxuICAgIGlmICghbWFwW2tdKSB7XG4gICAgICBtYXBba10gPSAxO1xuICAgICAgbGlzdC5wdXNoKGspO1xuICAgIH1cbiAgfSk7XG4gIGxpc3Quc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gbGltaXQgPyBsaXN0LnNsaWNlKDAsIGxpbWl0KSA6IGxpc3Q7XG59XG5cbi8qKlxuICogUGFydGl0aW9ucyBwcmUtZmFjZXRlZCBkYXRhIGludG8gdHVwbGUgc3ViZmxvd3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YWZsb3csIHN0cmluZyk6IE9wZXJhdG9yfSBwYXJhbXMuc3ViZmxvdyAtIEEgZnVuY3Rpb25cbiAqICAgdGhhdCBnZW5lcmF0ZXMgYSBzdWJmbG93IG9mIG9wZXJhdG9ycyBhbmQgcmV0dXJucyBpdHMgcm9vdCBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogQXJyYXk8b2JqZWN0Pn0gcGFyYW1zLmZpZWxkIC0gVGhlIGZpZWxkXG4gKiAgIGFjY2Vzc29yIGZvciBhbiBhcnJheSBvZiBzdWJmbG93IHR1cGxlIG9iamVjdHMuXG4gKi9cblxuZnVuY3Rpb24gUHJlRmFjZXQocGFyYW1zKSB7XG4gIEZhY2V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFByZUZhY2V0LCBGYWNldCwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBmbG93ID0gXy5zdWJmbG93LFxuICAgICAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgICAgICBzdWJmbG93ID0gdCA9PiB0aGlzLnN1YmZsb3codHVwbGVpZCh0KSwgZmxvdywgcHVsc2UsIHQpO1xuXG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgZmllbGQgJiYgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMoZmllbGQpKSkge1xuICAgICAgZXJyb3IoJ1ByZUZhY2V0IGRvZXMgbm90IHN1cHBvcnQgZmllbGQgbW9kaWZpY2F0aW9uLicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFRhcmdldHMoKTsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgc3ViZmxvd3NcblxuICAgIGlmIChmaWVsZCkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgY29uc3Qgc2YgPSBzdWJmbG93KHQpO1xuICAgICAgICBmaWVsZCh0KS5mb3JFYWNoKF8gPT4gc2YubW9kKF8pKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgY29uc3Qgc2YgPSBzdWJmbG93KHQpO1xuICAgICAgICBmaWVsZCh0KS5mb3JFYWNoKF8gPT4gc2YuYWRkKGluZ2VzdChfKSkpO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBjb25zdCBzZiA9IHN1YmZsb3codCk7XG4gICAgICAgIGZpZWxkKHQpLmZvckVhY2goXyA9PiBzZi5yZW0oXykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiBzdWJmbG93KHQpLm1vZCh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gc3ViZmxvdyh0KS5hZGQodCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHN1YmZsb3codCkucmVtKHQpKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UuY2xlYW4oKSkge1xuICAgICAgcHVsc2UucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUGVyZm9ybXMgYSByZWxhdGlvbmFsIHByb2plY3Rpb24sIGNvcHlpbmcgc2VsZWN0ZWQgZmllbGRzIGZyb20gc291cmNlXG4gKiB0dXBsZXMgdG8gYSBuZXcgc2V0IG9mIGRlcml2ZWQgdHVwbGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZHMgLSBUaGUgZmllbGRzIHRvIHByb2plY3QsXG4gKiAgIGFzIGFuIGFycmF5IG9mIGZpZWxkIGFjY2Vzc29ycy4gSWYgdW5zcGVjaWZpZWQsIGFsbCBmaWVsZHMgd2lsbCBiZVxuICogICBjb3BpZWQgd2l0aCBuYW1lcyB1bmNoYW5nZWQuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBlYWNoIHByb2plY3RlZFxuICogICBmaWVsZC4gQW55IHVuc3BlY2lmaWVkIGZpZWxkcyB3aWxsIHVzZSB0aGUgZmllbGQgbmFtZSBwcm92aWRlZCBieVxuICogICB0aGUgZmllbGQgYWNjZXNzb3IuXG4gKi9cblxuZnVuY3Rpb24gUHJvamVjdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblByb2plY3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUHJvamVjdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhQcm9qZWN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgICAgIGFzID0gZmllbGROYW1lcyhfLmZpZWxkcywgXy5hcyB8fCBbXSksXG4gICAgICAgICAgZGVyaXZlID0gZmllbGRzID8gKHMsIHQpID0+IHByb2plY3QocywgdCwgZmllbGRzLCBhcykgOiByZWRlcml2ZTtcbiAgICBsZXQgbHV0O1xuXG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgIGx1dCA9IHRoaXMudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlID0gcHVsc2UuYWRkQWxsKCk7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlID0ge307XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KTtcbiAgICAgIG91dC5yZW0ucHVzaChsdXRbaWRdKTtcbiAgICAgIGx1dFtpZF0gPSBudWxsO1xuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICBjb25zdCBkdCA9IGRlcml2ZSh0LCBpbmdlc3Qoe30pKTtcbiAgICAgIGx1dFt0dXBsZWlkKHQpXSA9IGR0O1xuICAgICAgb3V0LmFkZC5wdXNoKGR0KTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgb3V0Lm1vZC5wdXNoKGRlcml2ZSh0LCBsdXRbdHVwbGVpZCh0KV0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBwcm9qZWN0KHMsIHQsIGZpZWxkcywgYXMpIHtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBmaWVsZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdFthc1tpXV0gPSBmaWVsZHNbaV0ocyk7XG4gIH1cblxuICByZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBQcm94eSB0aGUgdmFsdWUgb2YgYW5vdGhlciBvcGVyYXRvciBhcyBhIHB1cmUgc2lnbmFsIHZhbHVlLlxuICogRW5zdXJlcyBubyB0dXBsZXMgYXJlIHByb3BhZ2F0ZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7Kn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRvIHByb3h5LCBiZWNvbWVzIHRoZSB2YWx1ZSBvZiB0aGlzIG9wZXJhdG9yLlxuICovXG5cbmZ1bmN0aW9uIFByb3h5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUHJveHksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gXy52YWx1ZTtcbiAgICByZXR1cm4gXy5tb2RpZmllZCgndmFsdWUnKSA/IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSA6IHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgc2FtcGxlIHF1YW50aWxlIHZhbHVlcyBmcm9tIGFuIGlucHV0IGRhdGEgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgZGF0YSBmaWVsZFxuICogICBvdmVyIHdoaWNoIHRvIGNhbGN1bGF0ZSBxdWFudGlsZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMucHJvYnNdIC0gQW4gYXJyYXkgb2YgcHJvYmFiaWxpdGllcyBpblxuICogICB0aGUgcmFuZ2UgKDAsIDEpIGZvciB3aGljaCB0byBjb21wdXRlIHF1YW50aWxlIHZhbHVlcy4gSWYgbm90IHNwZWNpZmllZCxcbiAqICAgdGhlICpzdGVwKiBwYXJhbWV0ZXIgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnN0ZXA9MC4wMV0gLSBBIHByb2JhYmlsaXR5IHN0ZXAgc2l6ZSBmb3JcbiAqICAgc2FtcGxpbmcgcXVhbnRpbGUgdmFsdWVzLiBBbGwgdmFsdWVzIGZyb20gb25lLWhhbGYgdGhlIHN0ZXAgc2l6ZSB1cCB0b1xuICogICAxIChleGNsdXNpdmUpIHdpbGwgYmUgc2FtcGxlZC4gVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGlmIHRoZVxuICogICAqcXVhbnRpbGVzKiBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkLlxuICovXG5cbmZ1bmN0aW9uIFF1YW50aWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuUXVhbnRpbGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUXVhbnRpbGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3Byb2JzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWydwcm9iJywgJ3ZhbHVlJ11cbiAgfV1cbn07XG5jb25zdCBFUFNJTE9OID0gMWUtMTQ7XG5pbmhlcml0cyhRdWFudGlsZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgICAgICBhcyA9IF8uYXMgfHwgWydwcm9iJywgJ3ZhbHVlJ107XG5cbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpICYmICFwdWxzZS5jaGFuZ2VkKCkpIHtcbiAgICAgIG91dC5zb3VyY2UgPSB0aGlzLnZhbHVlO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShzb3VyY2UsIF8uZ3JvdXBieSwgXy5maWVsZCksXG4gICAgICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICBzdGVwID0gXy5zdGVwIHx8IDAuMDEsXG4gICAgICAgICAgcCA9IF8ucHJvYnMgfHwgcmFuZ2Uoc3RlcCAvIDIsIDEgLSBFUFNJTE9OLCBzdGVwKSxcbiAgICAgICAgICBuID0gcC5sZW5ndGg7XG4gICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICBjb25zdCBxID0gcXVhbnRpbGVzKGcsIHApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB0ID0ge307XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgdFthc1swXV0gPSBwW2ldO1xuICAgICAgICB0W2FzWzFdXSA9IHFbaV07XG4gICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFJlbGF5cyBhIGRhdGEgc3RyZWFtIGJldHdlZW4gZGF0YSBwcm9jZXNzaW5nIHBpcGVsaW5lcy5cbiAqIElmIHRoZSBkZXJpdmUgcGFyYW1ldGVyIGlzIHNldCwgdGhpcyB0cmFuc2Zvcm0gd2lsbCBjcmVhdGUgZGVyaXZlZFxuICogY29waWVzIG9mIG9ic2VydmVkIHR1cGxlcy4gVGhpcyBwcm92aWRlcyBkZXJpdmVkIGRhdGEgc3RyZWFtcyBpbiB3aGljaFxuICogbW9kaWZpY2F0aW9ucyB0byB0aGUgdHVwbGVzIGRvIG5vdCBwb2xsdXRlIGFuIHVwc3RyZWFtIGRhdGEgc291cmNlLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuZGVyaXZlPWZhbHNlXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmXG4gKiAgIHRoZSB0cmFuc2Zvcm0gc2hvdWxkIG1ha2UgZGVyaXZlZCBjb3BpZXMgb2YgaW5jb21pbmcgdHVwbGVzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVsYXkocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhSZWxheSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGxldCBvdXQsIGx1dDtcblxuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChfLmRlcml2ZSkge1xuICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuICAgICAgICBvdXQucmVtLnB1c2gobHV0W2lkXSk7XG4gICAgICAgIGx1dFtpZF0gPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IGRlcml2ZSh0KTtcbiAgICAgICAgbHV0W3R1cGxlaWQodCldID0gZHQ7XG4gICAgICAgIG91dC5hZGQucHVzaChkdCk7XG4gICAgICB9KTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIGNvbnN0IGR0ID0gbHV0W3R1cGxlaWQodCldO1xuXG4gICAgICAgIGZvciAoY29uc3QgayBpbiB0KSB7XG4gICAgICAgICAgZHRba10gPSB0W2tdOyAvLyBkb3duIHN0cmVhbSB3cml0ZXMgbWF5IG92ZXJ3cml0ZSByZS1kZXJpdmVkIHR1cGxlc1xuICAgICAgICAgIC8vIGNvbnNlcnZhdGl2ZWx5IG1hcmsgYWxsIHNvdXJjZSBmaWVsZHMgYXMgbW9kaWZpZWRcblxuICAgICAgICAgIG91dC5tb2RpZmllcyhrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5tb2QucHVzaChkdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbn0pO1xuXG4vKipcbiAqIFNhbXBsZXMgdHVwbGVzIHBhc3NpbmcgdGhyb3VnaCB0aGlzIG9wZXJhdG9yLlxuICogVXNlcyByZXNlcnZvaXIgc2FtcGxpbmcgdG8gbWFpbnRhaW4gYSByZXByZXNlbnRhdGl2ZSBzYW1wbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnNpemU9MTAwMF0gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAqL1xuXG5mdW5jdGlvbiBTYW1wbGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblNhbXBsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTYW1wbGUnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEwMDBcbiAgfV1cbn07XG5pbmhlcml0cyhTYW1wbGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICAgICAgbW9kID0gXy5tb2RpZmllZCgnc2l6ZScpLFxuICAgICAgICAgIG51bSA9IF8uc2l6ZSxcbiAgICAgICAgICBtYXAgPSB0aGlzLnZhbHVlLnJlZHVjZSgobSwgdCkgPT4gKG1bdHVwbGVpZCh0KV0gPSAxLCBtKSwge30pO1xuXG4gICAgbGV0IHJlcyA9IHRoaXMudmFsdWUsXG4gICAgICAgIGNudCA9IHRoaXMuY291bnQsXG4gICAgICAgIGNhcCA9IDA7IC8vIHNhbXBsZSByZXNlcnZvaXIgdXBkYXRlIGZ1bmN0aW9uXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUodCkge1xuICAgICAgbGV0IHAsIGlkeDtcblxuICAgICAgaWYgKHJlcy5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgcmVzLnB1c2godCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSB+figoY250ICsgMSkgKiByYW5kb20oKSk7XG5cbiAgICAgICAgaWYgKGlkeCA8IHJlcy5sZW5ndGggJiYgaWR4ID49IGNhcCkge1xuICAgICAgICAgIHAgPSByZXNbaWR4XTtcbiAgICAgICAgICBpZiAobWFwW3R1cGxlaWQocCldKSBvdXQucmVtLnB1c2gocCk7IC8vIGV2aWN0aW9uXG5cbiAgICAgICAgICByZXNbaWR4XSA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKytjbnQ7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLnJlbS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpbmQgYWxsIHR1cGxlcyB0aGF0IHNob3VsZCBiZSByZW1vdmVkLCBhZGQgdG8gb3V0cHV0XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG5cbiAgICAgICAgaWYgKG1hcFtpZF0pIHtcbiAgICAgICAgICBtYXBbaWRdID0gLTE7XG4gICAgICAgICAgb3V0LnJlbS5wdXNoKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLS1jbnQ7XG4gICAgICB9KTsgLy8gZmlsdGVyIHJlbW92ZWQgdHVwbGVzIG91dCBvZiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuXG4gICAgICByZXMgPSByZXMuZmlsdGVyKHQgPT4gbWFwW3R1cGxlaWQodCldICE9PSAtMSk7XG4gICAgfVxuXG4gICAgaWYgKChwdWxzZS5yZW0ubGVuZ3RoIHx8IG1vZCkgJiYgcmVzLmxlbmd0aCA8IG51bSAmJiBwdWxzZS5zb3VyY2UpIHtcbiAgICAgIC8vIHJlcGxlbmlzaCBzYW1wbGUgaWYgYmFja2luZyBkYXRhIHNvdXJjZSBpcyBhdmFpbGFibGVcbiAgICAgIGNhcCA9IGNudCA9IHJlcy5sZW5ndGg7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgICAvLyB1cGRhdGUsIGJ1dCBza2lwIHByZXZpb3VzbHkgc2FtcGxlZCB0dXBsZXNcbiAgICAgICAgaWYgKCFtYXBbdHVwbGVpZCh0KV0pIHVwZGF0ZSh0KTtcbiAgICAgIH0pO1xuICAgICAgY2FwID0gLTE7XG4gICAgfVxuXG4gICAgaWYgKG1vZCAmJiByZXMubGVuZ3RoID4gbnVtKSB7XG4gICAgICBjb25zdCBuID0gcmVzLmxlbmd0aCAtIG51bTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbWFwW3R1cGxlaWQocmVzW2ldKV0gPSAtMTtcbiAgICAgICAgb3V0LnJlbS5wdXNoKHJlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHJlcy5zbGljZShuKTtcbiAgICB9XG5cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgLy8gcHJvcGFnYXRlIG1vZGlmaWVkIHR1cGxlcyBpbiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgaWYgKG1hcFt0dXBsZWlkKHQpXSkgb3V0Lm1vZC5wdXNoKHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGgpIHtcbiAgICAgIC8vIHVwZGF0ZSBzYW1wbGUgcmVzZXJ2b2lyXG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHVwZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlLmFkZC5sZW5ndGggfHwgY2FwIDwgMCkge1xuICAgICAgLy8gb3V0cHV0IG5ld2x5IGFkZGVkIHR1cGxlc1xuICAgICAgb3V0LmFkZCA9IHJlcy5maWx0ZXIodCA9PiAhbWFwW3R1cGxlaWQodCldKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvdW50ID0gY250O1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gcmVzO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGRhdGEgdHVwbGVzIGZvciBhIHNwZWNpZmllZCBzZXF1ZW5jZSByYW5nZSBvZiBudW1iZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gVGhlIGZpcnN0IG51bWJlciBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0b3AgLSBUaGUgbGFzdCBudW1iZXIgKGV4Y2x1c2l2ZSkgaW4gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuc3RlcD0xXSAtIFRoZSBzdGVwIHNpemUgYmV0d2VlbiBudW1iZXJzIGluIHRoZSBzZXF1ZW5jZS5cbiAqL1xuXG5mdW5jdGlvbiBTZXF1ZW5jZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblNlcXVlbmNlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1NlcXVlbmNlJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzdGFydCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdG9wJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdkYXRhJ1xuICB9XVxufTtcbmluaGVyaXRzKFNlcXVlbmNlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSkgcmV0dXJuO1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yayhwdWxzZS5NT0QpLFxuICAgICAgICAgIGFzID0gXy5hcyB8fCAnZGF0YSc7XG4gICAgb3V0LnJlbSA9IHRoaXMudmFsdWUgPyBwdWxzZS5yZW0uY29uY2F0KHRoaXMudmFsdWUpIDogcHVsc2UucmVtO1xuICAgIHRoaXMudmFsdWUgPSByYW5nZShfLnN0YXJ0LCBfLnN0b3AsIF8uc3RlcCB8fCAxKS5tYXAodiA9PiB7XG4gICAgICBjb25zdCB0ID0ge307XG4gICAgICB0W2FzXSA9IHY7XG4gICAgICByZXR1cm4gaW5nZXN0KHQpO1xuICAgIH0pO1xuICAgIG91dC5hZGQgPSBwdWxzZS5hZGQuY29uY2F0KHRoaXMudmFsdWUpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUHJvcGFnYXRlcyBhIG5ldyBwdWxzZSB3aXRob3V0IGFueSB0dXBsZXMgc28gbG9uZyBhcyB0aGUgaW5wdXRcbiAqIHB1bHNlIGNvbnRhaW5zIHNvbWUgYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQgdHVwbGVzLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gU2lldmUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMubW9kaWZpZWQodHJ1ZSk7IC8vIGFsd2F5cyB0cmVhdCBhcyBtb2RpZmllZFxufVxuaW5oZXJpdHMoU2lldmUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gcHVsc2Uuc291cmNlO1xuICAgIHJldHVybiBwdWxzZS5jaGFuZ2VkKCkgPyBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUykgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cblxufSk7XG5cbi8qKlxuICogRGlzY3JldGl6ZSBkYXRlcyB0byBzcGVjaWZpYyB0aW1lIHVuaXRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBkYXRhIGZpZWxkIGNvbnRhaW5pbmcgZGF0ZS90aW1lIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBUaW1lVW5pdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmNvbnN0IE9VVFBVVCA9IFsndW5pdDAnLCAndW5pdDEnXTtcblRpbWVVbml0LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1RpbWVVbml0JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpbnRlcnZhbCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd1bml0cycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ3ZhbHVlcyc6IFRJTUVfVU5JVFMsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfSwge1xuICAgICduYW1lJzogJ21heGJpbnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiA0MFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdkYXRlJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0aW1lem9uZScsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiAnbG9jYWwnLFxuICAgICd2YWx1ZXMnOiBbJ2xvY2FsJywgJ3V0YyddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogT1VUUFVUXG4gIH1dXG59O1xuaW5oZXJpdHMoVGltZVVuaXQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBmaWVsZCA9IF8uZmllbGQsXG4gICAgICAgICAgYmFuZCA9IF8uaW50ZXJ2YWwgIT09IGZhbHNlLFxuICAgICAgICAgIHV0YyA9IF8udGltZXpvbmUgPT09ICd1dGMnLFxuICAgICAgICAgIGZsb29yID0gdGhpcy5fZmxvb3IoXywgcHVsc2UpLFxuICAgICAgICAgIG9mZnNldCA9ICh1dGMgPyB1dGNJbnRlcnZhbCA6IHRpbWVJbnRlcnZhbCkoZmxvb3IudW5pdCkub2Zmc2V0LFxuICAgICAgICAgIGFzID0gXy5hcyB8fCBPVVRQVVQsXG4gICAgICAgICAgdTAgPSBhc1swXSxcbiAgICAgICAgICB1MSA9IGFzWzFdLFxuICAgICAgICAgIHN0ZXAgPSBmbG9vci5zdGVwO1xuXG4gICAgbGV0IG1pbiA9IGZsb29yLnN0YXJ0IHx8IEluZmluaXR5LFxuICAgICAgICBtYXggPSBmbG9vci5zdG9wIHx8IC1JbmZpbml0eSxcbiAgICAgICAgZmxhZyA9IHB1bHNlLkFERDtcblxuICAgIGlmIChfLm1vZGlmaWVkKCkgfHwgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMoZmllbGQpKSkge1xuICAgICAgcHVsc2UgPSBwdWxzZS5yZWZsb3codHJ1ZSk7XG4gICAgICBmbGFnID0gcHVsc2UuU09VUkNFO1xuICAgICAgbWluID0gSW5maW5pdHk7XG4gICAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICBjb25zdCB2ID0gZmllbGQodCk7XG4gICAgICBsZXQgYSwgYjtcblxuICAgICAgaWYgKHYgPT0gbnVsbCkge1xuICAgICAgICB0W3UwXSA9IG51bGw7XG4gICAgICAgIGlmIChiYW5kKSB0W3UxXSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0W3UwXSA9IGEgPSBiID0gZmxvb3Iodik7XG4gICAgICAgIGlmIChiYW5kKSB0W3UxXSA9IGIgPSBvZmZzZXQoYSwgc3RlcCk7XG4gICAgICAgIGlmIChhIDwgbWluKSBtaW4gPSBhO1xuICAgICAgICBpZiAoYiA+IG1heCkgbWF4ID0gYjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmbG9vci5zdGFydCA9IG1pbjtcbiAgICBmbG9vci5zdG9wID0gbWF4O1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhiYW5kID8gYXMgOiB1MCk7XG4gIH0sXG5cbiAgX2Zsb29yKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdXRjID0gXy50aW1lem9uZSA9PT0gJ3V0Yyc7IC8vIGdldCBwYXJhbWV0ZXJzXG5cbiAgICBjb25zdCB7XG4gICAgICB1bml0cyxcbiAgICAgIHN0ZXBcbiAgICB9ID0gXy51bml0cyA/IHtcbiAgICAgIHVuaXRzOiBfLnVuaXRzLFxuICAgICAgc3RlcDogXy5zdGVwIHx8IDFcbiAgICB9IDogdGltZUJpbih7XG4gICAgICBleHRlbnQ6IF8uZXh0ZW50IHx8IGV4dGVudChwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSwgXy5maWVsZCksXG4gICAgICBtYXhiaW5zOiBfLm1heGJpbnNcbiAgICB9KTsgLy8gY2hlY2sgLyBzdGFuZGFyZGl6ZSB0aW1lIHVuaXRzXG5cbiAgICBjb25zdCB0dW5pdHMgPSB0aW1lVW5pdHModW5pdHMpLFxuICAgICAgICAgIHByZXYgPSB0aGlzLnZhbHVlIHx8IHt9LFxuICAgICAgICAgIGZsb29yID0gKHV0YyA/IHV0Y0Zsb29yIDogdGltZUZsb29yKSh0dW5pdHMsIHN0ZXApO1xuICAgIGZsb29yLnVuaXQgPSBwZWVrKHR1bml0cyk7XG4gICAgZmxvb3IudW5pdHMgPSB0dW5pdHM7XG4gICAgZmxvb3Iuc3RlcCA9IHN0ZXA7XG4gICAgZmxvb3Iuc3RhcnQgPSBwcmV2LnN0YXJ0O1xuICAgIGZsb29yLnN0b3AgPSBwcmV2LnN0b3A7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBmbG9vcjtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBBbiBpbmRleCB0aGF0IG1hcHMgZnJvbSB1bmlxdWUsIHN0cmluZy1jb2VyY2VkLCBmaWVsZCB2YWx1ZXMgdG8gdHVwbGVzLlxuICogQXNzdW1lcyB0aGF0IHRoZSBmaWVsZCBzZXJ2ZXMgYXMgYSB1bmlxdWUga2V5IHdpdGggbm8gZHVwbGljYXRlIHZhbHVlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZmllbGQgYWNjZXNzb3IgdG8gaW5kZXguXG4gKi9cblxuZnVuY3Rpb24gVHVwbGVJbmRleChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgZmFzdG1hcCgpLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVHVwbGVJbmRleCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICAgICAgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgICAgIGluZGV4ID0gdGhpcy52YWx1ZSxcbiAgICAgICAgICBzZXQgPSB0ID0+IGluZGV4LnNldChmaWVsZCh0KSwgdCk7XG5cbiAgICBsZXQgbW9kID0gdHJ1ZTtcblxuICAgIGlmIChfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IHB1bHNlLm1vZGlmaWVkKGZpZWxkLmZpZWxkcykpIHtcbiAgICAgIGluZGV4LmNsZWFyKCk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHNldCk7XG4gICAgfSBlbHNlIGlmIChwdWxzZS5jaGFuZ2VkKCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiBpbmRleC5kZWxldGUoZmllbGQodCkpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIGlmIChpbmRleC5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSBkZi5ydW5BZnRlcihpbmRleC5jbGVhbik7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsoKTtcbiAgfVxuXG59KTtcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBhcnJheSBvZiB2YWx1ZXMuIEFzc3VtZXMgdGhlIHNvdXJjZSBkYXRhIGhhcyBhbHJlYWR5IGJlZW5cbiAqIHJlZHVjZWQgYXMgbmVlZGVkIChlLmcuLCBieSBhbiB1cHN0cmVhbSBBZ2dyZWdhdGUgdHJhbnNmb3JtKS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZG9tYWluIGZpZWxkIHRvIGV4dHJhY3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEFuIG9wdGlvbmFsXG4gKiAgIGNvbXBhcmF0b3IgZnVuY3Rpb24gZm9yIHNvcnRpbmcgdGhlIHZhbHVlcy4gVGhlIGNvbXBhcmF0b3Igd2lsbCBiZVxuICogICBhcHBsaWVkIHRvIGJhY2tpbmcgdHVwbGVzIHByaW9yIHRvIHZhbHVlIGV4dHJhY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gVmFsdWVzKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVmFsdWVzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgcnVuID0gIXRoaXMudmFsdWUgfHwgXy5tb2RpZmllZCgnZmllbGQnKSB8fCBfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8uc29ydCAmJiBwdWxzZS5tb2RpZmllZChfLnNvcnQuZmllbGRzKTtcblxuICAgIGlmIChydW4pIHtcbiAgICAgIHRoaXMudmFsdWUgPSAoXy5zb3J0ID8gcHVsc2Uuc291cmNlLnNsaWNlKCkuc29ydChzdGFibGVDb21wYXJlKF8uc29ydCkpIDogcHVsc2Uuc291cmNlKS5tYXAoXy5maWVsZCk7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBXaW5kb3dPcChvcCwgZmllbGQsIHBhcmFtLCBhcykge1xuICBjb25zdCBmbiA9IFdpbmRvd09wc1tvcF0oZmllbGQsIHBhcmFtKTtcbiAgcmV0dXJuIHtcbiAgICBpbml0OiBmbi5pbml0IHx8IHplcm8sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAodywgdCkge1xuICAgICAgdFthc10gPSBmbi5uZXh0KHcpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFdpbmRvd09wcyA9IHtcbiAgcm93X251bWJlcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHcuaW5kZXggKyAxXG4gICAgfTtcbiAgfSxcbiAgcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGxldCByYW5rO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiByYW5rID0gMSxcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCxcbiAgICAgICAgICAgICAgZGF0YSA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgJiYgdy5jb21wYXJlKGRhdGFbaSAtIDFdLCBkYXRhW2ldKSA/IHJhbmsgPSBpICsgMSA6IHJhbms7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZGVuc2VfcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGxldCBkcmFuaztcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gZHJhbmsgPSAxLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4LFxuICAgICAgICAgICAgICBkID0gdy5kYXRhO1xuICAgICAgICByZXR1cm4gaSAmJiB3LmNvbXBhcmUoZFtpIC0gMV0sIGRbaV0pID8gKytkcmFuayA6IGRyYW5rO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBlcmNlbnRfcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJhbmsgPSBXaW5kb3dPcHMucmFuaygpLFxuICAgICAgICAgIG5leHQgPSByYW5rLm5leHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IHJhbmsuaW5pdCxcbiAgICAgIG5leHQ6IHcgPT4gKG5leHQodykgLSAxKSAvICh3LmRhdGEubGVuZ3RoIC0gMSlcbiAgICB9O1xuICB9LFxuICBjdW1lX2Rpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgY3VtZTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gY3VtZSA9IDAsXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHcuZGF0YSxcbiAgICAgICAgICAgICAgYyA9IHcuY29tcGFyZTtcbiAgICAgICAgbGV0IGkgPSB3LmluZGV4O1xuXG4gICAgICAgIGlmIChjdW1lIDwgaSkge1xuICAgICAgICAgIHdoaWxlIChpICsgMSA8IGQubGVuZ3RoICYmICFjKGRbaV0sIGRbaSArIDFdKSkgKytpO1xuXG4gICAgICAgICAgY3VtZSA9IGk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKDEgKyBjdW1lKSAvIGQubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG50aWxlOiBmdW5jdGlvbiAoZmllbGQsIG51bSkge1xuICAgIG51bSA9ICtudW07XG4gICAgaWYgKCEobnVtID4gMCkpIGVycm9yKCdudGlsZSBudW0gbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICBjb25zdCBjdW1lID0gV2luZG93T3BzLmN1bWVfZGlzdCgpLFxuICAgICAgICAgIG5leHQgPSBjdW1lLm5leHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6IGN1bWUuaW5pdCxcbiAgICAgIG5leHQ6IHcgPT4gTWF0aC5jZWlsKG51bSAqIG5leHQodykpXG4gICAgfTtcbiAgfSxcbiAgbGFnOiBmdW5jdGlvbiAoZmllbGQsIG9mZnNldCkge1xuICAgIG9mZnNldCA9ICtvZmZzZXQgfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4IC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gaSA+PSAwID8gZmllbGQody5kYXRhW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgbGVhZDogZnVuY3Rpb24gKGZpZWxkLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSArb2Zmc2V0IHx8IDE7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pbmRleCArIG9mZnNldCxcbiAgICAgICAgICAgICAgZCA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgPCBkLmxlbmd0aCA/IGZpZWxkKGRbaV0pIDogbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBmaXJzdF92YWx1ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4gZmllbGQody5kYXRhW3cuaTBdKVxuICAgIH07XG4gIH0sXG4gIGxhc3RfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IGZpZWxkKHcuZGF0YVt3LmkxIC0gMV0pXG4gICAgfTtcbiAgfSxcbiAgbnRoX3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQsIG50aCkge1xuICAgIG50aCA9ICtudGg7XG4gICAgaWYgKCEobnRoID4gMCkpIGVycm9yKCdudGhfdmFsdWUgbnRoIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCBpID0gdy5pMCArIChudGggLSAxKTtcbiAgICAgICAgcmV0dXJuIGkgPCB3LmkxID8gZmllbGQody5kYXRhW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcHJldl92YWx1ZTogZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgbGV0IHByZXY7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6ICgpID0+IHByZXYgPSBudWxsLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBmaWVsZCh3LmRhdGFbdy5pbmRleF0pO1xuICAgICAgICByZXR1cm4gdiAhPSBudWxsID8gcHJldiA9IHYgOiBwcmV2O1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG5leHRfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGxldCB2LCBpO1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiAodiA9IG51bGwsIGkgPSAtMSksXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgZCA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIHcuaW5kZXggPD0gaSA/IHYgOiAoaSA9IGZpbmQoZmllbGQsIGQsIHcuaW5kZXgpKSA8IDAgPyAoaSA9IGQubGVuZ3RoLCB2ID0gbnVsbCkgOiB2ID0gZmllbGQoZFtpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZChmaWVsZCwgZGF0YSwgaW5kZXgpIHtcbiAgZm9yIChsZXQgbiA9IGRhdGEubGVuZ3RoOyBpbmRleCA8IG47ICsraW5kZXgpIHtcbiAgICBjb25zdCB2ID0gZmllbGQoZGF0YVtpbmRleF0pO1xuICAgIGlmICh2ICE9IG51bGwpIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuY29uc3QgVmFsaWRXaW5kb3dPcHMgPSBPYmplY3Qua2V5cyhXaW5kb3dPcHMpO1xuXG5mdW5jdGlvbiBXaW5kb3dTdGF0ZShfKSB7XG4gIGNvbnN0IG9wcyA9IGFycmF5KF8ub3BzKSxcbiAgICAgICAgZmllbGRzID0gYXJyYXkoXy5maWVsZHMpLFxuICAgICAgICBwYXJhbXMgPSBhcnJheShfLnBhcmFtcyksXG4gICAgICAgIGFzID0gYXJyYXkoXy5hcyksXG4gICAgICAgIG91dHB1dHMgPSB0aGlzLm91dHB1dHMgPSBbXSxcbiAgICAgICAgd2luZG93cyA9IHRoaXMud2luZG93cyA9IFtdLFxuICAgICAgICBpbnB1dHMgPSB7fSxcbiAgICAgICAgbWFwID0ge30sXG4gICAgICAgIGNvdW50cyA9IFtdLFxuICAgICAgICBtZWFzdXJlcyA9IFtdO1xuICBsZXQgY291bnRPbmx5ID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB2aXNpdElucHV0cyhmKSB7XG4gICAgYXJyYXkoYWNjZXNzb3JGaWVsZHMoZikpLmZvckVhY2goXyA9PiBpbnB1dHNbX10gPSAxKTtcbiAgfVxuXG4gIHZpc2l0SW5wdXRzKF8uc29ydCk7XG4gIG9wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ldLFxuICAgICAgICAgIG1uYW1lID0gYWNjZXNzb3JOYW1lKGZpZWxkKSxcbiAgICAgICAgICBuYW1lID0gbWVhc3VyZU5hbWUob3AsIG1uYW1lLCBhc1tpXSk7XG4gICAgdmlzaXRJbnB1dHMoZmllbGQpO1xuICAgIG91dHB1dHMucHVzaChuYW1lKTsgLy8gV2luZG93IG9wZXJhdGlvblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5KFdpbmRvd09wcywgb3ApKSB7XG4gICAgICB3aW5kb3dzLnB1c2goV2luZG93T3Aob3AsIGZpZWxkc1tpXSwgcGFyYW1zW2ldLCBuYW1lKSk7XG4gICAgfSAvLyBBZ2dyZWdhdGUgb3BlcmF0aW9uXG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChmaWVsZCA9PSBudWxsICYmIG9wICE9PSAnY291bnQnKSB7XG4gICAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcCA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgIGNvdW50cy5wdXNoKG5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvdW50T25seSA9IGZhbHNlO1xuICAgICAgICBsZXQgbSA9IG1hcFttbmFtZV07XG5cbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgbSA9IG1hcFttbmFtZV0gPSBbXTtcbiAgICAgICAgICBtLmZpZWxkID0gZmllbGQ7XG4gICAgICAgICAgbWVhc3VyZXMucHVzaChtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG0ucHVzaChjcmVhdGVNZWFzdXJlKG9wLCBuYW1lKSk7XG4gICAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudHMubGVuZ3RoIHx8IG1lYXN1cmVzLmxlbmd0aCkge1xuICAgIHRoaXMuY2VsbCA9IGNlbGwobWVhc3VyZXMsIGNvdW50cywgY291bnRPbmx5KTtcbiAgfVxuXG4gIHRoaXMuaW5wdXRzID0gT2JqZWN0LmtleXMoaW5wdXRzKTtcbn1cbmNvbnN0IHByb3RvdHlwZSA9IFdpbmRvd1N0YXRlLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud2luZG93cy5mb3JFYWNoKF8gPT4gXy5pbml0KCkpO1xuICBpZiAodGhpcy5jZWxsKSB0aGlzLmNlbGwuaW5pdCgpO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh3LCB0KSB7XG4gIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGwsXG4gICAgICAgIHdpbmQgPSB0aGlzLndpbmRvd3MsXG4gICAgICAgIGRhdGEgPSB3LmRhdGEsXG4gICAgICAgIG0gPSB3aW5kICYmIHdpbmQubGVuZ3RoO1xuICBsZXQgajtcblxuICBpZiAoY2VsbCkge1xuICAgIGZvciAoaiA9IHcucDA7IGogPCB3LmkwOyArK2opIGNlbGwucmVtKGRhdGFbal0pO1xuXG4gICAgZm9yIChqID0gdy5wMTsgaiA8IHcuaTE7ICsraikgY2VsbC5hZGQoZGF0YVtqXSk7XG5cbiAgICBjZWxsLnNldCh0KTtcbiAgfVxuXG4gIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHdpbmRbal0udXBkYXRlKHcsIHQpO1xufTtcblxuZnVuY3Rpb24gY2VsbChtZWFzdXJlcywgY291bnRzLCBjb3VudE9ubHkpIHtcbiAgbWVhc3VyZXMgPSBtZWFzdXJlcy5tYXAobSA9PiBjb21waWxlTWVhc3VyZXMobSwgbS5maWVsZCkpO1xuICBjb25zdCBjZWxsID0ge1xuICAgIG51bTogMCxcbiAgICBhZ2c6IG51bGwsXG4gICAgc3RvcmU6IGZhbHNlLFxuICAgIGNvdW50OiBjb3VudHNcbiAgfTtcblxuICBpZiAoIWNvdW50T25seSkge1xuICAgIHZhciBuID0gbWVhc3VyZXMubGVuZ3RoLFxuICAgICAgICBhID0gY2VsbC5hZ2cgPSBBcnJheShuKSxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IG47ICsraSkgYVtpXSA9IG5ldyBtZWFzdXJlc1tpXShjZWxsKTtcbiAgfVxuXG4gIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgdmFyIHN0b3JlID0gY2VsbC5kYXRhID0gbmV3IFR1cGxlU3RvcmUoKTtcbiAgfVxuXG4gIGNlbGwuYWRkID0gZnVuY3Rpb24gKHQpIHtcbiAgICBjZWxsLm51bSArPSAxO1xuICAgIGlmIChjb3VudE9ubHkpIHJldHVybjtcbiAgICBpZiAoc3RvcmUpIHN0b3JlLmFkZCh0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhW2ldLmFkZChhW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9O1xuXG4gIGNlbGwucmVtID0gZnVuY3Rpb24gKHQpIHtcbiAgICBjZWxsLm51bSAtPSAxO1xuICAgIGlmIChjb3VudE9ubHkpIHJldHVybjtcbiAgICBpZiAoc3RvcmUpIHN0b3JlLnJlbSh0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhW2ldLnJlbShhW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9O1xuXG4gIGNlbGwuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBsZXQgaSwgbjsgLy8gY29uc29saWRhdGUgc3RvcmVkIHZhbHVlc1xuXG4gICAgaWYgKHN0b3JlKSBzdG9yZS52YWx1ZXMoKTsgLy8gdXBkYXRlIHR1cGxlIHByb3BlcnRpZXNcblxuICAgIGZvciAoaSA9IDAsIG4gPSBjb3VudHMubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2NvdW50c1tpXV0gPSBjZWxsLm51bTtcblxuICAgIGlmICghY291bnRPbmx5KSBmb3IgKGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyArK2kpIGFbaV0uc2V0KHQpO1xuICB9O1xuXG4gIGNlbGwuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjZWxsLm51bSA9IDA7XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5yZXNldCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGFbaV0uaW5pdCgpO1xuICB9O1xuXG4gIHJldHVybiBjZWxsO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gd2luZG93IGNhbGN1bGF0aW9ucyBhbmQgd3JpdGUgcmVzdWx0cyB0byB0aGUgaW5wdXQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvciBmdW5jdGlvbiBmb3Igc29ydGluZyB0dXBsZXMgd2l0aGluIGEgd2luZG93LlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29ycyBieSB3aGljaCB0byBwYXJ0aXRpb24gdHVwbGVzIGludG8gc2VwYXJhdGUgd2luZG93cy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gcGFyYW1zLm9wcyAtIEFuIGFycmF5IG9mIHN0cmluZ3MgaW5kaWNhdGluZyB3aW5kb3cgb3BlcmF0aW9ucyB0byBwZXJmb3JtLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5maWVsZHNdIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzXG4gKiAgIGZvciBkYXRhIGZpZWxkcyB0byB1c2UgYXMgaW5wdXRzIHRvIHdpbmRvdyBvcGVyYXRpb25zLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy5wYXJhbXNdIC0gQW4gYXJyYXkgb2YgcGFyYW1ldGVyIHZhbHVlcyBmb3Igd2luZG93IG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciB3aW5kb3cgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5mcmFtZV0gLSBXaW5kb3cgZnJhbWUgZGVmaW5pdGlvbiBhcyB0d28tZWxlbWVudCBhcnJheS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5pZ25vcmVQZWVycz1mYWxzZV0gLSBJZiB0cnVlLCBiYXNlIHdpbmRvdyBmcmFtZSBib3VuZGFyaWVzIG9uIHJvd1xuICogICBudW1iZXIgYWxvbmUsIGlnbm9yaW5nIHBlZXJzIHdpdGggaWRlbnRpY2FsIHNvcnQgdmFsdWVzLiBJZiBmYWxzZSAoZGVmYXVsdCksXG4gKiAgIHRoZSB3aW5kb3cgYm91bmRhcmllcyB3aWxsIGJlIGFkanVzdGVkIHRvIGluY2x1ZGUgcGVlciB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gV2luZG93KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbiAgdGhpcy5fbWxlbiA9IDA7XG4gIHRoaXMuX21vZHMgPSBbXTtcbn1cbldpbmRvdy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdXaW5kb3cnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ29wcycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAndmFsdWVzJzogVmFsaWRXaW5kb3dPcHMuY29uY2F0KFZhbGlkQWdncmVnYXRlT3BzKVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyYW1zJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZyYW1lJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogW251bGwsIDBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdpZ25vcmVQZWVycycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9XVxufTtcbmluaGVyaXRzKFdpbmRvdywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHRoaXMuc3RhbXAgPSBwdWxzZS5zdGFtcDtcblxuICAgIGNvbnN0IG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgICAgICBjbXAgPSBzdGFibGVDb21wYXJlKF8uc29ydCksXG4gICAgICAgICAga2V5ID0gZ3JvdXBrZXkoXy5ncm91cGJ5KSxcbiAgICAgICAgICBncm91cCA9IHQgPT4gdGhpcy5ncm91cChrZXkodCkpOyAvLyBpbml0aWFsaXplIHdpbmRvdyBzdGF0ZVxuXG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgaWYgKCFzdGF0ZSB8fCBtb2QpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZSA9IG5ldyBXaW5kb3dTdGF0ZShfKTtcbiAgICB9IC8vIHBhcnRpdGlvbiBpbnB1dCB0dXBsZXNcblxuXG4gICAgaWYgKG1vZCB8fCBwdWxzZS5tb2RpZmllZChzdGF0ZS5pbnB1dHMpKSB7XG4gICAgICB0aGlzLnZhbHVlID0ge307XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGdyb3VwKHQpLnJlbW92ZSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9IC8vIHBlcmZvcm0gd2luZG93IGNhbGN1bGF0aW9ucyBmb3IgZWFjaCBtb2RpZmllZCBwYXJ0aXRpb25cblxuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBwcm9jZXNzUGFydGl0aW9uKHRoaXMuX21vZHNbaV0sIHN0YXRlLCBjbXAsIF8pO1xuICAgIH1cblxuICAgIHRoaXMuX21sZW4gPSAwO1xuICAgIHRoaXMuX21vZHMgPSBbXTsgLy8gVE9ETyBkb24ndCByZWZsb3cgZXZlcnl0aGluZz9cblxuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyhzdGF0ZS5vdXRwdXRzKTtcbiAgfSxcblxuICBncm91cChrZXkpIHtcbiAgICBsZXQgZ3JvdXAgPSB0aGlzLnZhbHVlW2tleV07XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICBncm91cCA9IHRoaXMudmFsdWVba2V5XSA9IFNvcnRlZExpc3QodHVwbGVpZCk7XG4gICAgICBncm91cC5zdGFtcCA9IC0xO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGdyb3VwLnN0YW1wID0gdGhpcy5zdGFtcDtcbiAgICAgIHRoaXMuX21vZHNbdGhpcy5fbWxlbisrXSA9IGdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcHJvY2Vzc1BhcnRpdGlvbihsaXN0LCBzdGF0ZSwgY21wLCBfKSB7XG4gIGNvbnN0IHNvcnQgPSBfLnNvcnQsXG4gICAgICAgIHJhbmdlID0gc29ydCAmJiAhXy5pZ25vcmVQZWVycyxcbiAgICAgICAgZnJhbWUgPSBfLmZyYW1lIHx8IFtudWxsLCAwXSxcbiAgICAgICAgZGF0YSA9IGxpc3QuZGF0YShjbXApLFxuICAgICAgICAvLyB1c2UgY21wIGZvciBzdGFibGUgc29ydFxuICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGIgPSByYW5nZSA/IGJpc2VjdG9yKHNvcnQpIDogbnVsbCxcbiAgICAgICAgdyA9IHtcbiAgICBpMDogMCxcbiAgICBpMTogMCxcbiAgICBwMDogMCxcbiAgICBwMTogMCxcbiAgICBpbmRleDogMCxcbiAgICBkYXRhOiBkYXRhLFxuICAgIGNvbXBhcmU6IHNvcnQgfHwgY29uc3RhbnQoLTEpXG4gIH07XG4gIHN0YXRlLmluaXQoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHNldFdpbmRvdyh3LCBmcmFtZSwgaSwgbik7XG4gICAgaWYgKHJhbmdlKSBhZGp1c3RSYW5nZSh3LCBiKTtcbiAgICBzdGF0ZS51cGRhdGUodywgZGF0YVtpXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0V2luZG93KHcsIGYsIGksIG4pIHtcbiAgdy5wMCA9IHcuaTA7XG4gIHcucDEgPSB3LmkxO1xuICB3LmkwID0gZlswXSA9PSBudWxsID8gMCA6IE1hdGgubWF4KDAsIGkgLSBNYXRoLmFicyhmWzBdKSk7XG4gIHcuaTEgPSBmWzFdID09IG51bGwgPyBuIDogTWF0aC5taW4obiwgaSArIE1hdGguYWJzKGZbMV0pICsgMSk7XG4gIHcuaW5kZXggPSBpO1xufSAvLyBpZiBmcmFtZSB0eXBlIGlzICdyYW5nZScsIGFkanVzdCB3aW5kb3cgZm9yIHBlZXIgdmFsdWVzXG5cblxuZnVuY3Rpb24gYWRqdXN0UmFuZ2UodywgYmlzZWN0KSB7XG4gIGNvbnN0IHIwID0gdy5pMCxcbiAgICAgICAgcjEgPSB3LmkxIC0gMSxcbiAgICAgICAgYyA9IHcuY29tcGFyZSxcbiAgICAgICAgZCA9IHcuZGF0YSxcbiAgICAgICAgbiA9IGQubGVuZ3RoIC0gMTtcbiAgaWYgKHIwID4gMCAmJiAhYyhkW3IwXSwgZFtyMCAtIDFdKSkgdy5pMCA9IGJpc2VjdC5sZWZ0KGQsIGRbcjBdKTtcbiAgaWYgKHIxIDwgbiAmJiAhYyhkW3IxXSwgZFtyMSArIDFdKSkgdy5pMSA9IGJpc2VjdC5yaWdodChkLCBkW3IxXSk7XG59XG5cbmV4cG9ydCB7IEFnZ3JlZ2F0ZSBhcyBhZ2dyZWdhdGUsIEJpbiBhcyBiaW4sIENvbGxlY3QgYXMgY29sbGVjdCwgQ29tcGFyZSBhcyBjb21wYXJlLCBDb3VudFBhdHRlcm4gYXMgY291bnRwYXR0ZXJuLCBDcm9zcyBhcyBjcm9zcywgRGVuc2l0eSBhcyBkZW5zaXR5LCBEb3RCaW4gYXMgZG90YmluLCBFeHByZXNzaW9uIGFzIGV4cHJlc3Npb24sIEV4dGVudCBhcyBleHRlbnQsIEZhY2V0IGFzIGZhY2V0LCBGaWVsZCBhcyBmaWVsZCwgRmlsdGVyIGFzIGZpbHRlciwgRmxhdHRlbiBhcyBmbGF0dGVuLCBGb2xkIGFzIGZvbGQsIEZvcm11bGEgYXMgZm9ybXVsYSwgR2VuZXJhdGUgYXMgZ2VuZXJhdGUsIEltcHV0ZSBhcyBpbXB1dGUsIEpvaW5BZ2dyZWdhdGUgYXMgam9pbmFnZ3JlZ2F0ZSwgS0RFIGFzIGtkZSwgS2V5IGFzIGtleSwgTG9hZCBhcyBsb2FkLCBMb29rdXAgYXMgbG9va3VwLCBNdWx0aUV4dGVudCBhcyBtdWx0aWV4dGVudCwgTXVsdGlWYWx1ZXMgYXMgbXVsdGl2YWx1ZXMsIFBhcmFtcyBhcyBwYXJhbXMsIFBpdm90IGFzIHBpdm90LCBQcmVGYWNldCBhcyBwcmVmYWNldCwgUHJvamVjdCBhcyBwcm9qZWN0LCBQcm94eSBhcyBwcm94eSwgUXVhbnRpbGUgYXMgcXVhbnRpbGUsIFJlbGF5IGFzIHJlbGF5LCBTYW1wbGUgYXMgc2FtcGxlLCBTZXF1ZW5jZSBhcyBzZXF1ZW5jZSwgU2lldmUgYXMgc2lldmUsIFN1YmZsb3cgYXMgc3ViZmxvdywgVGltZVVuaXQgYXMgdGltZXVuaXQsIFR1cGxlSW5kZXggYXMgdHVwbGVpbmRleCwgVmFsdWVzIGFzIHZhbHVlcywgV2luZG93IGFzIHdpbmRvdyB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBNYXJrcywgYm91bmRDbGlwLCBHcm91cEl0ZW0sIEl0ZW0sIEJvdW5kcywgbXVsdGlMaW5lT2Zmc2V0LCBib3VuZFN0cm9rZSB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBpbmhlcml0cywgcGVlaywgaXNPYmplY3QgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBUb3AgPSAndG9wJztcbmNvbnN0IExlZnQgPSAnbGVmdCc7XG5jb25zdCBSaWdodCA9ICdyaWdodCc7XG5jb25zdCBCb3R0b20gPSAnYm90dG9tJztcbmNvbnN0IFRvcExlZnQgPSAndG9wLWxlZnQnO1xuY29uc3QgVG9wUmlnaHQgPSAndG9wLXJpZ2h0JztcbmNvbnN0IEJvdHRvbUxlZnQgPSAnYm90dG9tLWxlZnQnO1xuY29uc3QgQm90dG9tUmlnaHQgPSAnYm90dG9tLXJpZ2h0JztcbmNvbnN0IFN0YXJ0ID0gJ3N0YXJ0JztcbmNvbnN0IE1pZGRsZSA9ICdtaWRkbGUnO1xuY29uc3QgRW5kID0gJ2VuZCc7XG5jb25zdCBYID0gJ3gnO1xuY29uc3QgWSA9ICd5JztcbmNvbnN0IEdyb3VwID0gJ2dyb3VwJztcbmNvbnN0IEF4aXNSb2xlID0gJ2F4aXMnO1xuY29uc3QgVGl0bGVSb2xlID0gJ3RpdGxlJztcbmNvbnN0IEZyYW1lUm9sZSA9ICdmcmFtZSc7XG5jb25zdCBTY29wZVJvbGUgPSAnc2NvcGUnO1xuY29uc3QgTGVnZW5kUm9sZSA9ICdsZWdlbmQnO1xuY29uc3QgUm93SGVhZGVyID0gJ3Jvdy1oZWFkZXInO1xuY29uc3QgUm93Rm9vdGVyID0gJ3Jvdy1mb290ZXInO1xuY29uc3QgUm93VGl0bGUgPSAncm93LXRpdGxlJztcbmNvbnN0IENvbEhlYWRlciA9ICdjb2x1bW4taGVhZGVyJztcbmNvbnN0IENvbEZvb3RlciA9ICdjb2x1bW4tZm9vdGVyJztcbmNvbnN0IENvbFRpdGxlID0gJ2NvbHVtbi10aXRsZSc7XG5jb25zdCBQYWRkaW5nID0gJ3BhZGRpbmcnO1xuY29uc3QgU3ltYm9scyA9ICdzeW1ib2wnO1xuY29uc3QgRml0ID0gJ2ZpdCc7XG5jb25zdCBGaXRYID0gJ2ZpdC14JztcbmNvbnN0IEZpdFkgPSAnZml0LXknO1xuY29uc3QgUGFkID0gJ3BhZCc7XG5jb25zdCBOb25lID0gJ25vbmUnO1xuY29uc3QgQWxsID0gJ2FsbCc7XG5jb25zdCBFYWNoID0gJ2VhY2gnO1xuY29uc3QgRmx1c2ggPSAnZmx1c2gnO1xuY29uc3QgQ29sdW1uID0gJ2NvbHVtbic7XG5jb25zdCBSb3cgPSAncm93JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94ZXMgZm9yIHNjZW5lZ3JhcGggaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFRoZSBzY2VuZWdyYXBoIG1hcmsgaW5zdGFuY2UgdG8gYm91bmQuXG4gKi9cblxuZnVuY3Rpb24gQm91bmQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhCb3VuZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZpZXcgPSBwdWxzZS5kYXRhZmxvdyxcbiAgICAgICAgICBtYXJrID0gXy5tYXJrLFxuICAgICAgICAgIHR5cGUgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgICAgIGVudHJ5ID0gTWFya3NbdHlwZV0sXG4gICAgICAgICAgYm91bmQgPSBlbnRyeS5ib3VuZDtcbiAgICBsZXQgbWFya0JvdW5kcyA9IG1hcmsuYm91bmRzLFxuICAgICAgICByZWJvdW5kO1xuXG4gICAgaWYgKGVudHJ5Lm5lc3RlZCkge1xuICAgICAgLy8gbXVsdGktaXRlbSBtYXJrcyBoYXZlIGEgc2luZ2xlIGJvdW5kcyBpbnN0YW5jZVxuICAgICAgaWYgKG1hcmsuaXRlbXMubGVuZ3RoKSB2aWV3LmRpcnR5KG1hcmsuaXRlbXNbMF0pO1xuICAgICAgbWFya0JvdW5kcyA9IGJvdW5kSXRlbShtYXJrLCBib3VuZCk7XG4gICAgICBtYXJrLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGl0ZW0uYm91bmRzLmNsZWFyKCkudW5pb24obWFya0JvdW5kcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdyb3VwIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgLy8gb3BlcmF0b3IgcGFyYW1ldGVycyBtb2RpZmllZCAtPiByZS1ib3VuZCBhbGwgaXRlbXNcbiAgICAgIC8vIHVwZGF0ZXMgZ3JvdXAgYm91bmRzIGluIHJlc3BvbnNlIHRvIG1vZGlmaWVkIGdyb3VwIGNvbnRlbnRcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgaXRlbSA9PiB2aWV3LmRpcnR5KGl0ZW0pKTtcbiAgICAgIG1hcmtCb3VuZHMuY2xlYXIoKTtcbiAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpdGVtID0+IG1hcmtCb3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW0sIGJvdW5kKSkpOyAvLyBmb3JjZSByZWZsb3cgZm9yIGF4ZXMvbGVnZW5kcy90aXRsZXMgdG8gcHJvcGFnYXRlIGFueSBsYXlvdXQgY2hhbmdlc1xuXG4gICAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgICBjYXNlIEF4aXNSb2xlOlxuICAgICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICAgIHB1bHNlLnJlZmxvdygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBib3VuZHMsIHJlLWJvdW5kIG1hcmsgYXMgbmVlZGVkXG4gICAgICByZWJvdW5kID0gcHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBpdGVtID0+IHtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCBpdGVtID0+IHtcbiAgICAgICAgcmVib3VuZCA9IHJlYm91bmQgfHwgbWFya0JvdW5kcy5hbGlnbnNXaXRoKGl0ZW0uYm91bmRzKTtcbiAgICAgICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVib3VuZCkge1xuICAgICAgICBtYXJrQm91bmRzLmNsZWFyKCk7XG4gICAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpdGVtID0+IG1hcmtCb3VuZHMudW5pb24oaXRlbS5ib3VuZHMpKTtcbiAgICAgIH1cbiAgICB9IC8vIGVuc3VyZSBtYXJrIGJvdW5kcyBkbyBub3QgZXhjZWVkIGFueSBjbGlwcGluZyByZWdpb25cblxuXG4gICAgYm91bmRDbGlwKG1hcmspO1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcygnYm91bmRzJyk7XG4gIH1cblxufSk7XG5cbmZ1bmN0aW9uIGJvdW5kSXRlbShpdGVtLCBib3VuZCwgb3B0KSB7XG4gIHJldHVybiBib3VuZChpdGVtLmJvdW5kcy5jbGVhcigpLCBpdGVtLCBvcHQpO1xufVxuXG5jb25zdCBDT1VOVEVSX05BTUUgPSAnOnZlZ2FfaWRlbnRpZmllcjonO1xuLyoqXG4gKiBBZGRzIGEgdW5pcXVlIGlkZW50aWZpZXIgdG8gYWxsIGFkZGVkIHR1cGxlcy5cbiAqIFRoaXMgdHJhbnNmb3JtIGNyZWF0ZXMgYSBuZXcgc2lnbmFsIHRoYXQgc2VydmVzIGFzIGFuIGlkIGNvdW50ZXIuXG4gKiBBcyBhIHJlc3VsdCwgdGhlIGlkIGNvdW50ZXIgaXMgc2hhcmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIHRoaXNcbiAqIHRyYW5zZm9ybSwgZ2VuZXJhdGluZyB1bmlxdWUgaWRzIGFjcm9zcyBtdWx0aXBsZSBkYXRhIHN0cmVhbXMuIEluXG4gKiBhZGRpdGlvbiwgdGhpcyBzaWduYWwgdmFsdWUgY2FuIGJlIGluY2x1ZGVkIGluIGEgc25hcHNob3Qgb2YgdGhlXG4gKiBkYXRhZmxvdyBzdGF0ZSwgZW5hYmxpbmcgY29ycmVjdCByZXN1bXB0aW9uIG9mIGlkIGFsbG9jYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXMgLSBUaGUgZmllbGQgbmFtZSBmb3IgdGhlIGdlbmVyYXRlZCBpZGVudGlmaWVyLlxuICovXG5cbmZ1bmN0aW9uIElkZW50aWZpZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIDAsIHBhcmFtcyk7XG59XG5JZGVudGlmaWVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoSWRlbnRpZmllciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBnZXRDb3VudGVyKHB1bHNlLmRhdGFmbG93KSxcbiAgICAgICAgICBhcyA9IF8uYXM7XG4gICAgbGV0IGlkID0gY291bnRlci52YWx1ZTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gdFthc10gPSB0W2FzXSB8fCArK2lkKTtcbiAgICBjb3VudGVyLnNldCh0aGlzLnZhbHVlID0gaWQpO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gZ2V0Q291bnRlcih2aWV3KSB7XG4gIHJldHVybiB2aWV3Ll9zaWduYWxzW0NPVU5URVJfTkFNRV0gfHwgKHZpZXcuX3NpZ25hbHNbQ09VTlRFUl9OQU1FXSA9IHZpZXcuYWRkKDApKTtcbn1cblxuLyoqXG4gKiBCaW5kIHNjZW5lZ3JhcGggaXRlbXMgdG8gYSBzY2VuZWdyYXBoIG1hcmsgaW5zdGFuY2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFya2RlZiAtIFRoZSBtYXJrIGRlZmluaXRpb24gZm9yIGNyZWF0aW5nIHRoZSBtYXJrLlxuICogICBUaGlzIGlzIGFuIG9iamVjdCBvZiBsZWdhbCBzY2VuZWdyYXBoIG1hcmsgcHJvcGVydGllcyB3aGljaCAqbXVzdCogaW5jbHVkZVxuICogICB0aGUgJ21hcmt0eXBlJyBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBNYXJrKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTWFyaywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGxldCBtYXJrID0gdGhpcy52YWx1ZTsgLy8gYWNxdWlyZSBtYXJrIG9uIGZpcnN0IGludm9jYXRpb24sIGJpbmQgY29udGV4dCBhbmQgZ3JvdXBcblxuICAgIGlmICghbWFyaykge1xuICAgICAgbWFyayA9IHB1bHNlLmRhdGFmbG93LnNjZW5lZ3JhcGgoKS5tYXJrKF8ubWFya2RlZiwgbG9va3VwKF8pLCBfLmluZGV4KTtcbiAgICAgIG1hcmsuZ3JvdXAuY29udGV4dCA9IF8uY29udGV4dDtcbiAgICAgIGlmICghXy5jb250ZXh0Lmdyb3VwKSBfLmNvbnRleHQuZ3JvdXAgPSBtYXJrLmdyb3VwO1xuICAgICAgbWFyay5zb3VyY2UgPSB0aGlzLnNvdXJjZTsgLy8gcG9pbnQgdG8gdXBzdHJlYW0gY29sbGVjdG9yXG5cbiAgICAgIG1hcmsuY2xpcCA9IF8uY2xpcDtcbiAgICAgIG1hcmsuaW50ZXJhY3RpdmUgPSBfLmludGVyYWN0aXZlO1xuICAgICAgdGhpcy52YWx1ZSA9IG1hcms7XG4gICAgfSAvLyBpbml0aWFsaXplIGVudGVyaW5nIGl0ZW1zXG5cblxuICAgIGNvbnN0IEluaXQgPSBtYXJrLm1hcmt0eXBlID09PSBHcm91cCA/IEdyb3VwSXRlbSA6IEl0ZW07XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBpdGVtID0+IEluaXQuY2FsbChpdGVtLCBtYXJrKSk7IC8vIHVwZGF0ZSBjbGlwcGluZyBhbmQvb3IgaW50ZXJhY3RpdmUgc3RhdHVzXG5cbiAgICBpZiAoXy5tb2RpZmllZCgnY2xpcCcpIHx8IF8ubW9kaWZpZWQoJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgIG1hcmsuY2xpcCA9IF8uY2xpcDtcbiAgICAgIG1hcmsuaW50ZXJhY3RpdmUgPSAhIV8uaW50ZXJhY3RpdmU7XG4gICAgICBtYXJrLnpkaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHNjZW5lZ3JhcGggcmUtZXZhbFxuXG4gICAgICBwdWxzZS5yZWZsb3coKTtcbiAgICB9IC8vIGJpbmQgaXRlbXMgYXJyYXkgdG8gc2NlbmVncmFwaCBtYXJrXG5cblxuICAgIG1hcmsuaXRlbXMgPSBwdWxzZS5zb3VyY2U7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBsb29rdXAoXykge1xuICBjb25zdCBnID0gXy5ncm91cHMsXG4gICAgICAgIHAgPSBfLnBhcmVudDtcbiAgcmV0dXJuIGcgJiYgZy5zaXplID09PSAxID8gZy5nZXQoT2JqZWN0LmtleXMoZy5vYmplY3QpWzBdKSA6IGcgJiYgcCA/IGcubG9va3VwKHApIDogbnVsbDtcbn1cblxuLyoqXG4gKiBBbmFseXplIGl0ZW1zIGZvciBvdmVybGFwLCBjaGFuZ2luZyBvcGFjaXR5IHRvIGhpZGUgaXRlbXMgd2l0aFxuICogb3ZlcmxhcHBpbmcgYm91bmRpbmcgYm94ZXMuIFRoaXMgdHJhbnNmb3JtIHdpbGwgcHJlc2VydmUgYXQgbGVhc3RcbiAqIHR3byBpdGVtcyAoZS5nLiwgZmlyc3QgYW5kIGxhc3QpIGV2ZW4gaWYgb3ZlcmxhcCBwZXJzaXN0cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwqKTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yXG4gKiAgIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGl0ZW1zLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMubWV0aG9kXSAtIFRoZSBvdmVybGFwIHJlbW92YWwgbWV0aG9kIHRvIGFwcGx5LlxuICogICBPbmUgb2YgJ3Bhcml0eScgKGRlZmF1bHQsIGhpZGUgZXZlcnkgb3RoZXIgaXRlbSB1bnRpbCB0aGVyZSBpcyBub1xuICogICBtb3JlIG92ZXJsYXApIG9yICdncmVlZHknIChzZXF1ZW50aWFsbHkgc2NhbiBhbmQgaGlkZSBhbmQgaXRlbXMgdGhhdFxuICogICBvdmVybGFwIHdpdGggdGhlIGxhc3QgdmlzaWJsZSBpdGVtKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmJvdW5kU2NhbGVdIC0gQSBzY2FsZSB3aG9zZSByYW5nZSBzaG91bGQgYmUgdXNlZFxuICogICB0byBib3VuZCB0aGUgaXRlbXMuIEl0ZW1zIGV4Y2VlZGluZyB0aGUgYm91bmRzIG9mIHRoZSBzY2FsZSByYW5nZVxuICogICB3aWxsIGJlIHRyZWF0ZWQgYXMgb3ZlcmxhcHBpbmcuIElmIG51bGwgb3IgdW5kZWZpbmVkLCBubyBib3VuZHMgY2hlY2tcbiAqICAgd2lsbCBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuYm91bmRPcmllbnRdIC0gVGhlIG9yaWVudGF0aW9uIG9mIHRoZSBzY2FsZVxuICogICAodG9wLCBib3R0b20sIGxlZnQsIG9yIHJpZ2h0KSB1c2VkIHRvIGJvdW5kIGl0ZW1zLiBUaGlzIHBhcmFtZXRlciBpc1xuICogICBpZ25vcmVkIGlmIGJvdW5kU2NhbGUgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5ib3VuZFRvbGVyYW5jZV0gLSBUaGUgdG9sZXJhbmNlIGluIHBpeGVscyBmb3JcbiAqICAgYm91bmQgaW5jbHVzaW9uIHRlc3RpbmcgKGRlZmF1bHQgMSkuIFRoaXMgc3BlY2lmaWVzIGJ5IGhvdyBtYW55IHBpeGVsc1xuICogICBhbiBpdGVtJ3MgYm91bmRzIG1heSBleGNlZWQgdGhlIHNjYWxlIHJhbmdlIGJvdW5kcyBhbmQgbm90IGJlIGN1bGxlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIE92ZXJsYXAocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5jb25zdCBtZXRob2RzID0ge1xuICBwYXJpdHk6IGl0ZW1zID0+IGl0ZW1zLmZpbHRlcigoaXRlbSwgaSkgPT4gaSAlIDIgPyBpdGVtLm9wYWNpdHkgPSAwIDogMSksXG4gIGdyZWVkeTogKGl0ZW1zLCBzZXApID0+IHtcbiAgICBsZXQgYTtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKChiLCBpKSA9PiAhaSB8fCAhaW50ZXJzZWN0KGEuYm91bmRzLCBiLmJvdW5kcywgc2VwKSA/IChhID0gYiwgMSkgOiBiLm9wYWNpdHkgPSAwKTtcbiAgfVxufTsgLy8gY29tcHV0ZSBib3VuZGluZyBib3ggaW50ZXJzZWN0aW9uXG4vLyBpbmNsdWRpbmcgcGFkZGluZyBwaXhlbHMgb2Ygc2VwYXJhdGlvblxuXG5jb25zdCBpbnRlcnNlY3QgPSAoYSwgYiwgc2VwKSA9PiBzZXAgPiBNYXRoLm1heChiLngxIC0gYS54MiwgYS54MSAtIGIueDIsIGIueTEgLSBhLnkyLCBhLnkxIC0gYi55Mik7XG5cbmNvbnN0IGhhc092ZXJsYXAgPSAoaXRlbXMsIHBhZCkgPT4ge1xuICBmb3IgKHZhciBpID0gMSwgbiA9IGl0ZW1zLmxlbmd0aCwgYSA9IGl0ZW1zWzBdLmJvdW5kcywgYjsgaSA8IG47IGEgPSBiLCArK2kpIHtcbiAgICBpZiAoaW50ZXJzZWN0KGEsIGIgPSBpdGVtc1tpXS5ib3VuZHMsIHBhZCkpIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5jb25zdCBoYXNCb3VuZHMgPSBpdGVtID0+IHtcbiAgY29uc3QgYiA9IGl0ZW0uYm91bmRzO1xuICByZXR1cm4gYi53aWR0aCgpID4gMSAmJiBiLmhlaWdodCgpID4gMTtcbn07XG5cbmNvbnN0IGJvdW5kVGVzdCA9IChzY2FsZSwgb3JpZW50LCB0b2xlcmFuY2UpID0+IHtcbiAgdmFyIHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgIGIgPSBuZXcgQm91bmRzKCk7XG5cbiAgaWYgKG9yaWVudCA9PT0gVG9wIHx8IG9yaWVudCA9PT0gQm90dG9tKSB7XG4gICAgYi5zZXQocmFuZ2VbMF0sIC1JbmZpbml0eSwgcmFuZ2VbMV0sICtJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgYi5zZXQoLUluZmluaXR5LCByYW5nZVswXSwgK0luZmluaXR5LCByYW5nZVsxXSk7XG4gIH1cblxuICBiLmV4cGFuZCh0b2xlcmFuY2UgfHwgMSk7XG4gIHJldHVybiBpdGVtID0+IGIuZW5jbG9zZXMoaXRlbS5ib3VuZHMpO1xufTsgLy8gcmVzZXQgYWxsIGl0ZW1zIHRvIGJlIGZ1bGx5IG9wYXF1ZVxuXG5cbmNvbnN0IHJlc2V0ID0gc291cmNlID0+IHtcbiAgc291cmNlLmZvckVhY2goaXRlbSA9PiBpdGVtLm9wYWNpdHkgPSAxKTtcbiAgcmV0dXJuIHNvdXJjZTtcbn07IC8vIGFkZCBhbGwgdHVwbGVzIHRvIG1vZCwgZm9yayBwdWxzZSBpZiBwYXJhbWV0ZXJzIHdlcmUgbW9kaWZpZWRcbi8vIGZvcmsgcHJldmVudHMgY3Jvc3Mtc3RyZWFtIHR1cGxlIHBvbGx1dGlvbiAoZS5nLiwgcHVsc2UgZnJvbSBzY2FsZSlcblxuXG5jb25zdCByZWZsb3cgPSAocHVsc2UsIF8pID0+IHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKCdvcGFjaXR5Jyk7XG5cbmluaGVyaXRzKE92ZXJsYXAsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCByZWR1Y2UgPSBtZXRob2RzW18ubWV0aG9kXSB8fCBtZXRob2RzLnBhcml0eSxcbiAgICAgICAgICBzZXAgPSBfLnNlcGFyYXRpb24gfHwgMDtcbiAgICBsZXQgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICB0ZXN0O1xuICAgIGlmICghc291cmNlIHx8ICFzb3VyY2UubGVuZ3RoKSByZXR1cm47XG5cbiAgICBpZiAoIV8ubWV0aG9kKSB7XG4gICAgICAvLyBlYXJseSBleGl0IGlmIG1ldGhvZCBpcyBmYWxzeVxuICAgICAgaWYgKF8ubW9kaWZpZWQoJ21ldGhvZCcpKSB7XG4gICAgICAgIHJlc2V0KHNvdXJjZSk7XG4gICAgICAgIHB1bHNlID0gcmVmbG93KHB1bHNlLCBfKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB1bHNlO1xuICAgIH0gLy8gc2tpcCBsYWJlbHMgd2l0aCBubyBjb250ZW50XG5cblxuICAgIHNvdXJjZSA9IHNvdXJjZS5maWx0ZXIoaGFzQm91bmRzKTsgLy8gZWFybHkgZXhpdCwgbm90aGluZyB0byBkb1xuXG4gICAgaWYgKCFzb3VyY2UubGVuZ3RoKSByZXR1cm47XG5cbiAgICBpZiAoXy5zb3J0KSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2Uuc2xpY2UoKS5zb3J0KF8uc29ydCk7XG4gICAgfVxuXG4gICAgaXRlbXMgPSByZXNldChzb3VyY2UpO1xuICAgIHB1bHNlID0gcmVmbG93KHB1bHNlLCBfKTtcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPj0gMyAmJiBoYXNPdmVybGFwKGl0ZW1zLCBzZXApKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGl0ZW1zID0gcmVkdWNlKGl0ZW1zLCBzZXApO1xuICAgICAgfSB3aGlsZSAoaXRlbXMubGVuZ3RoID49IDMgJiYgaGFzT3ZlcmxhcChpdGVtcywgc2VwKSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAzICYmICFwZWVrKHNvdXJjZSkub3BhY2l0eSkge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkgcGVlayhpdGVtcykub3BhY2l0eSA9IDA7XG4gICAgICAgIHBlZWsoc291cmNlKS5vcGFjaXR5ID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXy5ib3VuZFNjYWxlICYmIF8uYm91bmRUb2xlcmFuY2UgPj0gMCkge1xuICAgICAgdGVzdCA9IGJvdW5kVGVzdChfLmJvdW5kU2NhbGUsIF8uYm91bmRPcmllbnQsICtfLmJvdW5kVG9sZXJhbmNlKTtcbiAgICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIXRlc3QoaXRlbSkpIGl0ZW0ub3BhY2l0eSA9IDA7XG4gICAgICB9KTtcbiAgICB9IC8vIHJlLWNhbGN1bGF0ZSBtYXJrIGJvdW5kc1xuXG5cbiAgICBjb25zdCBib3VuZHMgPSBpdGVtc1swXS5tYXJrLmJvdW5kcy5jbGVhcigpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0ub3BhY2l0eSkgYm91bmRzLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cblxufSk7XG5cbi8qKlxuICogUXVldWUgbW9kaWZpZWQgc2NlbmVncmFwaCBpdGVtcyBmb3IgcmVuZGVyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gUmVuZGVyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUmVuZGVyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdmlldyA9IHB1bHNlLmRhdGFmbG93O1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFMTCwgaXRlbSA9PiB2aWV3LmRpcnR5KGl0ZW0pKTsgLy8gc2V0IHotaW5kZXggZGlydHkgZmxhZyBhcyBuZWVkZWRcblxuICAgIGlmIChwdWxzZS5maWVsZHMgJiYgcHVsc2UuZmllbGRzWyd6aW5kZXgnXSkge1xuICAgICAgY29uc3QgaXRlbSA9IHB1bHNlLnNvdXJjZSAmJiBwdWxzZS5zb3VyY2VbMF07XG4gICAgICBpZiAoaXRlbSkgaXRlbS5tYXJrLnpkaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG5cbn0pO1xuXG5jb25zdCB0ZW1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuZnVuY3Rpb24gc2V0KGl0ZW0sIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gaXRlbVtwcm9wZXJ0eV0gPT09IHZhbHVlID8gMCA6IChpdGVtW3Byb3BlcnR5XSA9IHZhbHVlLCAxKTtcbn1cblxuZnVuY3Rpb24gaXNZQXhpcyhtYXJrKSB7XG4gIHZhciBvcmllbnQgPSBtYXJrLml0ZW1zWzBdLm9yaWVudDtcbiAgcmV0dXJuIG9yaWVudCA9PT0gTGVmdCB8fCBvcmllbnQgPT09IFJpZ2h0O1xufVxuXG5mdW5jdGlvbiBheGlzSW5kaWNlcyhkYXR1bSkge1xuICBsZXQgaW5kZXggPSArZGF0dW0uZ3JpZDtcbiAgcmV0dXJuIFtkYXR1bS50aWNrcyA/IGluZGV4KysgOiAtMSwgLy8gdGlja3MgaW5kZXhcbiAgZGF0dW0ubGFiZWxzID8gaW5kZXgrKyA6IC0xLCAvLyBsYWJlbHMgaW5kZXhcbiAgaW5kZXggKyArZGF0dW0uZG9tYWluIC8vIHRpdGxlIGluZGV4XG4gIF07XG59XG5cbmZ1bmN0aW9uIGF4aXNMYXlvdXQodmlldywgYXhpcywgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaXRlbSA9IGF4aXMuaXRlbXNbMF0sXG4gICAgICBkYXR1bSA9IGl0ZW0uZGF0dW0sXG4gICAgICBkZWx0YSA9IGl0ZW0udHJhbnNsYXRlICE9IG51bGwgPyBpdGVtLnRyYW5zbGF0ZSA6IDAuNSxcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50LFxuICAgICAgaW5kaWNlcyA9IGF4aXNJbmRpY2VzKGRhdHVtKSxcbiAgICAgIHJhbmdlID0gaXRlbS5yYW5nZSxcbiAgICAgIG9mZnNldCA9IGl0ZW0ub2Zmc2V0LFxuICAgICAgcG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uLFxuICAgICAgbWluRXh0ZW50ID0gaXRlbS5taW5FeHRlbnQsXG4gICAgICBtYXhFeHRlbnQgPSBpdGVtLm1heEV4dGVudCxcbiAgICAgIHRpdGxlID0gZGF0dW0udGl0bGUgJiYgaXRlbS5pdGVtc1tpbmRpY2VzWzJdXS5pdGVtc1swXSxcbiAgICAgIHRpdGxlUGFkZGluZyA9IGl0ZW0udGl0bGVQYWRkaW5nLFxuICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHMsXG4gICAgICBkbCA9IHRpdGxlICYmIG11bHRpTGluZU9mZnNldCh0aXRsZSksXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgaSxcbiAgICAgIHM7XG4gIHRlbXBCb3VuZHMuY2xlYXIoKS51bmlvbihib3VuZHMpO1xuICBib3VuZHMuY2xlYXIoKTtcbiAgaWYgKChpID0gaW5kaWNlc1swXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTtcbiAgaWYgKChpID0gaW5kaWNlc1sxXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTsgLy8gcG9zaXRpb24gYXhpcyBncm91cCBhbmQgdGl0bGVcblxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgVG9wOlxuICAgICAgeCA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICB5ID0gLW9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgLWJvdW5kcy55MSkpO1xuICAgICAgYm91bmRzLmFkZCgwLCAtcykuYWRkKHJhbmdlLCAwKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAwLCAtMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMZWZ0OlxuICAgICAgeCA9IC1vZmZzZXQ7XG4gICAgICB5ID0gcG9zaXRpb24gfHwgMDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgLWJvdW5kcy54MSkpO1xuICAgICAgYm91bmRzLmFkZCgtcywgMCkuYWRkKDAsIHJhbmdlKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAxLCAtMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSaWdodDpcbiAgICAgIHggPSB3aWR0aCArIG9mZnNldDtcbiAgICAgIHkgPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgcyA9IE1hdGgubWF4KG1pbkV4dGVudCwgTWF0aC5taW4obWF4RXh0ZW50LCBib3VuZHMueDIpKTtcbiAgICAgIGJvdW5kcy5hZGQoMCwgMCkuYWRkKHMsIHJhbmdlKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAxLCAxLCBib3VuZHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbTpcbiAgICAgIHggPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgeSA9IGhlaWdodCArIG9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgYm91bmRzLnkyKSk7XG4gICAgICBib3VuZHMuYWRkKDAsIDApLmFkZChyYW5nZSwgcyk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCAwLCAwLCAxLCBib3VuZHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgeCA9IGl0ZW0ueDtcbiAgICAgIHkgPSBpdGVtLnk7XG4gIH0gLy8gdXBkYXRlIGJvdW5kc1xuXG5cbiAgYm91bmRTdHJva2UoYm91bmRzLnRyYW5zbGF0ZSh4LCB5KSwgaXRlbSk7XG5cbiAgaWYgKHNldChpdGVtLCAneCcsIHggKyBkZWx0YSkgfCBzZXQoaXRlbSwgJ3knLCB5ICsgZGVsdGEpKSB7XG4gICAgaXRlbS5ib3VuZHMgPSB0ZW1wQm91bmRzO1xuICAgIHZpZXcuZGlydHkoaXRlbSk7XG4gICAgaXRlbS5ib3VuZHMgPSBib3VuZHM7XG4gICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgfVxuXG4gIHJldHVybiBpdGVtLm1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBvZmZzZXQsIHBhZCwgZGwsIGlzWUF4aXMsIHNpZ24sIGJvdW5kcykge1xuICBjb25zdCBiID0gdGl0bGUuYm91bmRzO1xuXG4gIGlmICh0aXRsZS5hdXRvKSB7XG4gICAgY29uc3QgdiA9IHNpZ24gKiAob2Zmc2V0ICsgZGwgKyBwYWQpO1xuICAgIGxldCBkeCA9IDAsXG4gICAgICAgIGR5ID0gMDtcbiAgICB2aWV3LmRpcnR5KHRpdGxlKTtcbiAgICBpc1lBeGlzID8gZHggPSAodGl0bGUueCB8fCAwKSAtICh0aXRsZS54ID0gdikgOiBkeSA9ICh0aXRsZS55IHx8IDApIC0gKHRpdGxlLnkgPSB2KTtcbiAgICB0aXRsZS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGIudHJhbnNsYXRlKC1keCwgLWR5KSk7XG4gICAgdmlldy5kaXJ0eSh0aXRsZSk7XG4gIH1cblxuICBib3VuZHMudW5pb24oYik7XG59XG5cbmNvbnN0IG1pbiA9IChhLCBiKSA9PiBNYXRoLmZsb29yKE1hdGgubWluKGEsIGIpKTtcblxuY29uc3QgbWF4ID0gKGEsIGIpID0+IE1hdGguY2VpbChNYXRoLm1heChhLCBiKSk7XG5cbmZ1bmN0aW9uIGdyaWRMYXlvdXRHcm91cHMoZ3JvdXApIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwLml0ZW1zLFxuICAgICAgbiA9IGdyb3Vwcy5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIG1hcmssXG4gICAgICBpdGVtcztcbiAgY29uc3Qgdmlld3MgPSB7XG4gICAgbWFya3M6IFtdLFxuICAgIHJvd2hlYWRlcnM6IFtdLFxuICAgIHJvd2Zvb3RlcnM6IFtdLFxuICAgIGNvbGhlYWRlcnM6IFtdLFxuICAgIGNvbGZvb3RlcnM6IFtdLFxuICAgIHJvd3RpdGxlOiBudWxsLFxuICAgIGNvbHRpdGxlOiBudWxsXG4gIH07IC8vIGxheW91dCBheGVzLCBnYXRoZXIgbGVnZW5kcywgY29sbGVjdCBib3VuZHNcblxuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIG1hcmsgPSBncm91cHNbaV07XG4gICAgaXRlbXMgPSBtYXJrLml0ZW1zO1xuXG4gICAgaWYgKG1hcmsubWFya3R5cGUgPT09IEdyb3VwKSB7XG4gICAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgICBjYXNlIEF4aXNSb2xlOlxuICAgICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUm93SGVhZGVyOlxuICAgICAgICAgIHZpZXdzLnJvd2hlYWRlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSb3dGb290ZXI6XG4gICAgICAgICAgdmlld3Mucm93Zm9vdGVycy5wdXNoKC4uLml0ZW1zKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbEhlYWRlcjpcbiAgICAgICAgICB2aWV3cy5jb2xoZWFkZXJzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ29sRm9vdGVyOlxuICAgICAgICAgIHZpZXdzLmNvbGZvb3RlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSb3dUaXRsZTpcbiAgICAgICAgICB2aWV3cy5yb3d0aXRsZSA9IGl0ZW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ29sVGl0bGU6XG4gICAgICAgICAgdmlld3MuY29sdGl0bGUgPSBpdGVtc1swXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZpZXdzLm1hcmtzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2aWV3cztcbn1cblxuZnVuY3Rpb24gYmJveEZsdXNoKGl0ZW0pIHtcbiAgcmV0dXJuIG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgaXRlbS53aWR0aCB8fCAwLCBpdGVtLmhlaWdodCB8fCAwKTtcbn1cblxuZnVuY3Rpb24gYmJveEZ1bGwoaXRlbSkge1xuICBjb25zdCBiID0gaXRlbS5ib3VuZHMuY2xvbmUoKTtcbiAgcmV0dXJuIGIuZW1wdHkoKSA/IGIuc2V0KDAsIDAsIDAsIDApIDogYi50cmFuc2xhdGUoLShpdGVtLnggfHwgMCksIC0oaXRlbS55IHx8IDApKTtcbn1cblxuZnVuY3Rpb24gZ2V0KG9wdCwga2V5LCBkKSB7XG4gIGNvbnN0IHYgPSBpc09iamVjdChvcHQpID8gb3B0W2tleV0gOiBvcHQ7XG4gIHJldHVybiB2ICE9IG51bGwgPyB2IDogZCAhPT0gdW5kZWZpbmVkID8gZCA6IDA7XG59XG5cbmZ1bmN0aW9uIG9mZnNldFZhbHVlKHYpIHtcbiAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKC12KSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpIHtcbiAgdmFyIGRpcnR5ID0gIW9wdC5ub2RpcnR5LFxuICAgICAgYmJveCA9IG9wdC5ib3VuZHMgPT09IEZsdXNoID8gYmJveEZsdXNoIDogYmJveEZ1bGwsXG4gICAgICBib3VuZHMgPSB0ZW1wQm91bmRzLnNldCgwLCAwLCAwLCAwKSxcbiAgICAgIGFsaWduQ29sID0gZ2V0KG9wdC5hbGlnbiwgQ29sdW1uKSxcbiAgICAgIGFsaWduUm93ID0gZ2V0KG9wdC5hbGlnbiwgUm93KSxcbiAgICAgIHBhZENvbCA9IGdldChvcHQucGFkZGluZywgQ29sdW1uKSxcbiAgICAgIHBhZFJvdyA9IGdldChvcHQucGFkZGluZywgUm93KSxcbiAgICAgIG5jb2xzID0gb3B0LmNvbHVtbnMgfHwgZ3JvdXBzLmxlbmd0aCxcbiAgICAgIG5yb3dzID0gbmNvbHMgPD0gMCA/IDEgOiBNYXRoLmNlaWwoZ3JvdXBzLmxlbmd0aCAvIG5jb2xzKSxcbiAgICAgIG4gPSBncm91cHMubGVuZ3RoLFxuICAgICAgeE9mZnNldCA9IEFycmF5KG4pLFxuICAgICAgeEV4dGVudCA9IEFycmF5KG5jb2xzKSxcbiAgICAgIHhNYXggPSAwLFxuICAgICAgeU9mZnNldCA9IEFycmF5KG4pLFxuICAgICAgeUV4dGVudCA9IEFycmF5KG5yb3dzKSxcbiAgICAgIHlNYXggPSAwLFxuICAgICAgZHggPSBBcnJheShuKSxcbiAgICAgIGR5ID0gQXJyYXkobiksXG4gICAgICBib3hlcyA9IEFycmF5KG4pLFxuICAgICAgbSxcbiAgICAgIGksXG4gICAgICBjLFxuICAgICAgcixcbiAgICAgIGIsXG4gICAgICBnLFxuICAgICAgcHgsXG4gICAgICBweSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgb2Zmc2V0O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuY29sczsgKytpKSB4RXh0ZW50W2ldID0gMDtcblxuICBmb3IgKGkgPSAwOyBpIDwgbnJvd3M7ICsraSkgeUV4dGVudFtpXSA9IDA7IC8vIGRldGVybWluZSBvZmZzZXRzIGZvciBlYWNoIGdyb3VwXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZyA9IGdyb3Vwc1tpXTtcbiAgICBiID0gYm94ZXNbaV0gPSBiYm94KGcpO1xuICAgIGcueCA9IGcueCB8fCAwO1xuICAgIGR4W2ldID0gMDtcbiAgICBnLnkgPSBnLnkgfHwgMDtcbiAgICBkeVtpXSA9IDA7XG4gICAgYyA9IGkgJSBuY29scztcbiAgICByID0gfn4oaSAvIG5jb2xzKTtcbiAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgcHggPSBNYXRoLmNlaWwoYi54MikpO1xuICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBweSA9IE1hdGguY2VpbChiLnkyKSk7XG4gICAgeEV4dGVudFtjXSA9IE1hdGgubWF4KHhFeHRlbnRbY10sIHB4KTtcbiAgICB5RXh0ZW50W3JdID0gTWF0aC5tYXgoeUV4dGVudFtyXSwgcHkpO1xuICAgIHhPZmZzZXRbaV0gPSBwYWRDb2wgKyBvZmZzZXRWYWx1ZShiLngxKTtcbiAgICB5T2Zmc2V0W2ldID0gcGFkUm93ICsgb2Zmc2V0VmFsdWUoYi55MSk7XG4gICAgaWYgKGRpcnR5KSB2aWV3LmRpcnR5KGdyb3Vwc1tpXSk7XG4gIH0gLy8gc2V0IGluaXRpYWwgYWxpZ25tZW50IG9mZnNldHNcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaSAlIG5jb2xzID09PSAwKSB4T2Zmc2V0W2ldID0gMDtcbiAgICBpZiAoaSA8IG5jb2xzKSB5T2Zmc2V0W2ldID0gMDtcbiAgfSAvLyBlbmZvcmNlIGNvbHVtbiBhbGlnbm1lbnQgY29uc3RyYWludHNcblxuXG4gIGlmIChhbGlnbkNvbCA9PT0gRWFjaCkge1xuICAgIGZvciAoYyA9IDE7IGMgPCBuY29sczsgKytjKSB7XG4gICAgICBmb3IgKG9mZnNldCA9IDAsIGkgPSBjOyBpIDwgbjsgaSArPSBuY29scykge1xuICAgICAgICBpZiAob2Zmc2V0IDwgeE9mZnNldFtpXSkgb2Zmc2V0ID0geE9mZnNldFtpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgeE9mZnNldFtpXSA9IG9mZnNldCArIHhFeHRlbnRbYyAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhbGlnbkNvbCA9PT0gQWxsKSB7XG4gICAgZm9yIChvZmZzZXQgPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGkgJSBuY29scyAmJiBvZmZzZXQgPCB4T2Zmc2V0W2ldKSBvZmZzZXQgPSB4T2Zmc2V0W2ldO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChpICUgbmNvbHMpIHhPZmZzZXRbaV0gPSBvZmZzZXQgKyB4TWF4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGFsaWduQ29sID0gZmFsc2UsIGMgPSAxOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgZm9yIChpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgeE9mZnNldFtpXSArPSB4RXh0ZW50W2MgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZW5mb3JjZSByb3cgYWxpZ25tZW50IGNvbnN0cmFpbnRzXG5cblxuICBpZiAoYWxpZ25Sb3cgPT09IEVhY2gpIHtcbiAgICBmb3IgKHIgPSAxOyByIDwgbnJvd3M7ICsrcikge1xuICAgICAgZm9yIChvZmZzZXQgPSAwLCBpID0gciAqIG5jb2xzLCBtID0gaSArIG5jb2xzOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCB5T2Zmc2V0W2ldKSBvZmZzZXQgPSB5T2Zmc2V0W2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSByICogbmNvbHM7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgeU9mZnNldFtpXSA9IG9mZnNldCArIHlFeHRlbnRbciAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhbGlnblJvdyA9PT0gQWxsKSB7XG4gICAgZm9yIChvZmZzZXQgPSAwLCBpID0gbmNvbHM7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvZmZzZXQgPCB5T2Zmc2V0W2ldKSBvZmZzZXQgPSB5T2Zmc2V0W2ldO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG5jb2xzOyBpIDwgbjsgKytpKSB7XG4gICAgICB5T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeU1heDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChhbGlnblJvdyA9IGZhbHNlLCByID0gMTsgciA8IG5yb3dzOyArK3IpIHtcbiAgICAgIGZvciAoaSA9IHIgKiBuY29scywgbSA9IGkgKyBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICB5T2Zmc2V0W2ldICs9IHlFeHRlbnRbciAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBwZXJmb3JtIGhvcml6b250YWwgZ3JpZCBsYXlvdXRcblxuXG4gIGZvciAoeCA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgeCA9IHhPZmZzZXRbaV0gKyAoaSAlIG5jb2xzID8geCA6IDApO1xuICAgIGR4W2ldICs9IHggLSBncm91cHNbaV0ueDtcbiAgfSAvLyBwZXJmb3JtIHZlcnRpY2FsIGdyaWQgbGF5b3V0XG5cblxuICBmb3IgKGMgPSAwOyBjIDwgbmNvbHM7ICsrYykge1xuICAgIGZvciAoeSA9IDAsIGkgPSBjOyBpIDwgbjsgaSArPSBuY29scykge1xuICAgICAgeSArPSB5T2Zmc2V0W2ldO1xuICAgICAgZHlbaV0gKz0geSAtIGdyb3Vwc1tpXS55O1xuICAgIH1cbiAgfSAvLyBwZXJmb3JtIGhvcml6b250YWwgY2VudGVyaW5nXG5cblxuICBpZiAoYWxpZ25Db2wgJiYgZ2V0KG9wdC5jZW50ZXIsIENvbHVtbikgJiYgbnJvd3MgPiAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IGFsaWduQ29sID09PSBBbGwgPyB4TWF4IDogeEV4dGVudFtpICUgbmNvbHNdO1xuICAgICAgeCA9IGIgLSBib3hlc1tpXS54MiAtIGdyb3Vwc1tpXS54IC0gZHhbaV07XG4gICAgICBpZiAoeCA+IDApIGR4W2ldICs9IHggLyAyO1xuICAgIH1cbiAgfSAvLyBwZXJmb3JtIHZlcnRpY2FsIGNlbnRlcmluZ1xuXG5cbiAgaWYgKGFsaWduUm93ICYmIGdldChvcHQuY2VudGVyLCBSb3cpICYmIG5jb2xzICE9PSAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IGFsaWduUm93ID09PSBBbGwgPyB5TWF4IDogeUV4dGVudFt+fihpIC8gbmNvbHMpXTtcbiAgICAgIHkgPSBiIC0gYm94ZXNbaV0ueTIgLSBncm91cHNbaV0ueSAtIGR5W2ldO1xuICAgICAgaWYgKHkgPiAwKSBkeVtpXSArPSB5IC8gMjtcbiAgICB9XG4gIH0gLy8gcG9zaXRpb24gZ3JpZCByZWxhdGl2ZSB0byBhbmNob3JcblxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBib3VuZHMudW5pb24oYm94ZXNbaV0udHJhbnNsYXRlKGR4W2ldLCBkeVtpXSkpO1xuICB9XG5cbiAgeCA9IGdldChvcHQuYW5jaG9yLCBYKTtcbiAgeSA9IGdldChvcHQuYW5jaG9yLCBZKTtcblxuICBzd2l0Y2ggKGdldChvcHQuYW5jaG9yLCBDb2x1bW4pKSB7XG4gICAgY2FzZSBFbmQ6XG4gICAgICB4IC09IGJvdW5kcy53aWR0aCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE1pZGRsZTpcbiAgICAgIHggLT0gYm91bmRzLndpZHRoKCkgLyAyO1xuICB9XG5cbiAgc3dpdGNoIChnZXQob3B0LmFuY2hvciwgUm93KSkge1xuICAgIGNhc2UgRW5kOlxuICAgICAgeSAtPSBib3VuZHMuaGVpZ2h0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTWlkZGxlOlxuICAgICAgeSAtPSBib3VuZHMuaGVpZ2h0KCkgLyAyO1xuICB9XG5cbiAgeCA9IE1hdGgucm91bmQoeCk7XG4gIHkgPSBNYXRoLnJvdW5kKHkpOyAvLyB1cGRhdGUgbWFyayBwb3NpdGlvbnMsIGJvdW5kcywgZGlydHlcblxuICBib3VuZHMuY2xlYXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZ3JvdXBzW2ldLm1hcmsuYm91bmRzLmNsZWFyKCk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZyA9IGdyb3Vwc1tpXTtcbiAgICBnLnggKz0gZHhbaV0gKz0geDtcbiAgICBnLnkgKz0gZHlbaV0gKz0geTtcbiAgICBib3VuZHMudW5pb24oZy5tYXJrLmJvdW5kcy51bmlvbihnLmJvdW5kcy50cmFuc2xhdGUoZHhbaV0sIGR5W2ldKSkpO1xuICAgIGlmIChkaXJ0eSkgdmlldy5kaXJ0eShnKTtcbiAgfVxuXG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiB0cmVsbGlzTGF5b3V0KHZpZXcsIGdyb3VwLCBvcHQpIHtcbiAgdmFyIHZpZXdzID0gZ3JpZExheW91dEdyb3Vwcyhncm91cCksXG4gICAgICBncm91cHMgPSB2aWV3cy5tYXJrcyxcbiAgICAgIGJib3ggPSBvcHQuYm91bmRzID09PSBGbHVzaCA/IGJvdW5kRmx1c2ggOiBib3VuZEZ1bGwsXG4gICAgICBvZmYgPSBvcHQub2Zmc2V0LFxuICAgICAgbmNvbHMgPSBvcHQuY29sdW1ucyB8fCBncm91cHMubGVuZ3RoLFxuICAgICAgbnJvd3MgPSBuY29scyA8PSAwID8gMSA6IE1hdGguY2VpbChncm91cHMubGVuZ3RoIC8gbmNvbHMpLFxuICAgICAgY2VsbHMgPSBucm93cyAqIG5jb2xzLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgYW5jaG9yLFxuICAgICAgYmFuZCxcbiAgICAgIG9mZnNldDsgLy8gLS0gaW5pdGlhbCBncmlkIGxheW91dFxuXG4gIGNvbnN0IGJvdW5kcyA9IGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpO1xuICBpZiAoYm91bmRzLmVtcHR5KCkpIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7IC8vIGVtcHR5IGdyaWRcbiAgLy8gLS0gbGF5b3V0IGdyaWQgaGVhZGVycyBhbmQgZm9vdGVycyAtLVxuICAvLyBwZXJmb3JtIHJvdyBoZWFkZXIgbGF5b3V0XG5cbiAgaWYgKHZpZXdzLnJvd2hlYWRlcnMpIHtcbiAgICBiYW5kID0gZ2V0KG9wdC5oZWFkZXJCYW5kLCBSb3csIG51bGwpO1xuICAgIHggPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLnJvd2hlYWRlcnMsIGdyb3VwcywgbmNvbHMsIG5yb3dzLCAtZ2V0KG9mZiwgJ3Jvd0hlYWRlcicpLCBtaW4sIDAsIGJib3gsICd4MScsIDAsIG5jb2xzLCAxLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIGNvbHVtbiBoZWFkZXIgbGF5b3V0XG5cblxuICBpZiAodmlld3MuY29saGVhZGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmhlYWRlckJhbmQsIENvbHVtbiwgbnVsbCk7XG4gICAgeSA9IGxheW91dEhlYWRlcnModmlldywgdmlld3MuY29saGVhZGVycywgZ3JvdXBzLCBuY29scywgbmNvbHMsIC1nZXQob2ZmLCAnY29sdW1uSGVhZGVyJyksIG1pbiwgMSwgYmJveCwgJ3kxJywgMCwgMSwgbmNvbHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gcm93IGZvb3RlciBsYXlvdXRcblxuXG4gIGlmICh2aWV3cy5yb3dmb290ZXJzKSB7XG4gICAgYmFuZCA9IGdldChvcHQuZm9vdGVyQmFuZCwgUm93LCBudWxsKTtcbiAgICB4MiA9IGxheW91dEhlYWRlcnModmlldywgdmlld3Mucm93Zm9vdGVycywgZ3JvdXBzLCBuY29scywgbnJvd3MsIGdldChvZmYsICdyb3dGb290ZXInKSwgbWF4LCAwLCBiYm94LCAneDInLCBuY29scyAtIDEsIG5jb2xzLCAxLCBiYW5kKTtcbiAgfSAvLyBwZXJmb3JtIGNvbHVtbiBmb290ZXIgbGF5b3V0XG5cblxuICBpZiAodmlld3MuY29sZm9vdGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmZvb3RlckJhbmQsIENvbHVtbiwgbnVsbCk7XG4gICAgeTIgPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLmNvbGZvb3RlcnMsIGdyb3VwcywgbmNvbHMsIG5jb2xzLCBnZXQob2ZmLCAnY29sdW1uRm9vdGVyJyksIG1heCwgMSwgYmJveCwgJ3kyJywgY2VsbHMgLSBuY29scywgMSwgbmNvbHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gcm93IHRpdGxlIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLnJvd3RpdGxlKSB7XG4gICAgYW5jaG9yID0gZ2V0KG9wdC50aXRsZUFuY2hvciwgUm93KTtcbiAgICBvZmZzZXQgPSBnZXQob2ZmLCAncm93VGl0bGUnKTtcbiAgICBvZmZzZXQgPSBhbmNob3IgPT09IEVuZCA/IHgyICsgb2Zmc2V0IDogeCAtIG9mZnNldDtcbiAgICBiYW5kID0gZ2V0KG9wdC50aXRsZUJhbmQsIFJvdywgMC41KTtcbiAgICBsYXlvdXRUaXRsZSh2aWV3LCB2aWV3cy5yb3d0aXRsZSwgb2Zmc2V0LCAwLCBib3VuZHMsIGJhbmQpO1xuICB9IC8vIHBlcmZvcm0gY29sdW1uIHRpdGxlIGxheW91dFxuXG5cbiAgaWYgKHZpZXdzLmNvbHRpdGxlKSB7XG4gICAgYW5jaG9yID0gZ2V0KG9wdC50aXRsZUFuY2hvciwgQ29sdW1uKTtcbiAgICBvZmZzZXQgPSBnZXQob2ZmLCAnY29sdW1uVGl0bGUnKTtcbiAgICBvZmZzZXQgPSBhbmNob3IgPT09IEVuZCA/IHkyICsgb2Zmc2V0IDogeSAtIG9mZnNldDtcbiAgICBiYW5kID0gZ2V0KG9wdC50aXRsZUJhbmQsIENvbHVtbiwgMC41KTtcbiAgICBsYXlvdXRUaXRsZSh2aWV3LCB2aWV3cy5jb2x0aXRsZSwgb2Zmc2V0LCAxLCBib3VuZHMsIGJhbmQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kRmx1c2goaXRlbSwgZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkID09PSAneDEnID8gaXRlbS54IHx8IDAgOiBmaWVsZCA9PT0gJ3kxJyA/IGl0ZW0ueSB8fCAwIDogZmllbGQgPT09ICd4MicgPyAoaXRlbS54IHx8IDApICsgKGl0ZW0ud2lkdGggfHwgMCkgOiBmaWVsZCA9PT0gJ3kyJyA/IChpdGVtLnkgfHwgMCkgKyAoaXRlbS5oZWlnaHQgfHwgMCkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJvdW5kRnVsbChpdGVtLCBmaWVsZCkge1xuICByZXR1cm4gaXRlbS5ib3VuZHNbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBsYXlvdXRIZWFkZXJzKHZpZXcsIGhlYWRlcnMsIGdyb3VwcywgbmNvbHMsIGxpbWl0LCBvZmZzZXQsIGFnZywgaXNYLCBib3VuZCwgYmYsIHN0YXJ0LCBzdHJpZGUsIGJhY2ssIGJhbmQpIHtcbiAgdmFyIG4gPSBncm91cHMubGVuZ3RoLFxuICAgICAgaW5pdCA9IDAsXG4gICAgICBlZGdlID0gMCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgayxcbiAgICAgIG0sXG4gICAgICBiLFxuICAgICAgaCxcbiAgICAgIGcsXG4gICAgICB4LFxuICAgICAgeTsgLy8gaWYgbm8gZ3JvdXBzLCBlYXJseSBleGl0IGFuZCByZXR1cm4gMFxuXG4gIGlmICghbikgcmV0dXJuIGluaXQ7IC8vIGNvbXB1dGUgbWFyZ2luXG5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBuOyBpICs9IHN0cmlkZSkge1xuICAgIGlmIChncm91cHNbaV0pIGluaXQgPSBhZ2coaW5pdCwgYm91bmQoZ3JvdXBzW2ldLCBiZikpO1xuICB9IC8vIGlmIG5vIGhlYWRlcnMsIHJldHVybiBtYXJnaW4gY2FsY3VsYXRpb25cblxuXG4gIGlmICghaGVhZGVycy5sZW5ndGgpIHJldHVybiBpbml0OyAvLyBjaGVjayBpZiBudW1iZXIgb2YgaGVhZGVycyBleGNlZWRzIG51bWJlciBvZiByb3dzIG9yIGNvbHVtbnNcblxuICBpZiAoaGVhZGVycy5sZW5ndGggPiBsaW1pdCkge1xuICAgIHZpZXcud2FybignR3JpZCBoZWFkZXJzIGV4Y2VlZCBsaW1pdDogJyArIGxpbWl0KTtcbiAgICBoZWFkZXJzID0gaGVhZGVycy5zbGljZSgwLCBsaW1pdCk7XG4gIH0gLy8gYXBwbHkgb2Zmc2V0XG5cblxuICBpbml0ICs9IG9mZnNldDsgLy8gY2xlYXIgbWFyayBib3VuZHMgZm9yIGFsbCBoZWFkZXJzXG5cbiAgZm9yIChqID0gMCwgbSA9IGhlYWRlcnMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgdmlldy5kaXJ0eShoZWFkZXJzW2pdKTtcbiAgICBoZWFkZXJzW2pdLm1hcmsuYm91bmRzLmNsZWFyKCk7XG4gIH0gLy8gbGF5b3V0IGVhY2ggaGVhZGVyXG5cblxuICBmb3IgKGkgPSBzdGFydCwgaiA9IDAsIG0gPSBoZWFkZXJzLmxlbmd0aDsgaiA8IG07ICsraiwgaSArPSBzdHJpZGUpIHtcbiAgICBoID0gaGVhZGVyc1tqXTtcbiAgICBiID0gaC5tYXJrLmJvdW5kczsgLy8gc2VhcmNoIGZvciBuZWFyZXN0IGdyb3VwIHRvIGFsaWduIHRvXG4gICAgLy8gbmVjZXNzYXJ5IGlmIHRhYmxlIGhhcyBlbXB0eSBjZWxsc1xuXG4gICAgZm9yIChrID0gaTsgayA+PSAwICYmIChnID0gZ3JvdXBzW2tdKSA9PSBudWxsOyBrIC09IGJhY2spOyAvLyBhc3NpZ24gY29vcmRpbmF0ZXMgYW5kIHVwZGF0ZSBib3VuZHNcblxuXG4gICAgaWYgKGlzWCkge1xuICAgICAgeCA9IGJhbmQgPT0gbnVsbCA/IGcueCA6IE1hdGgucm91bmQoZy5ib3VuZHMueDEgKyBiYW5kICogZy5ib3VuZHMud2lkdGgoKSk7XG4gICAgICB5ID0gaW5pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IGluaXQ7XG4gICAgICB5ID0gYmFuZCA9PSBudWxsID8gZy55IDogTWF0aC5yb3VuZChnLmJvdW5kcy55MSArIGJhbmQgKiBnLmJvdW5kcy5oZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgYi51bmlvbihoLmJvdW5kcy50cmFuc2xhdGUoeCAtIChoLnggfHwgMCksIHkgLSAoaC55IHx8IDApKSk7XG4gICAgaC54ID0geDtcbiAgICBoLnkgPSB5O1xuICAgIHZpZXcuZGlydHkoaCk7IC8vIHVwZGF0ZSBjdXJyZW50IGVkZ2Ugb2YgbGF5b3V0IGJvdW5kc1xuXG4gICAgZWRnZSA9IGFnZyhlZGdlLCBiW2JmXSk7XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gbGF5b3V0VGl0bGUodmlldywgZywgb2Zmc2V0LCBpc1gsIGJvdW5kcywgYmFuZCkge1xuICBpZiAoIWcpIHJldHVybjtcbiAgdmlldy5kaXJ0eShnKTsgLy8gY29tcHV0ZSB0aXRsZSBjb29yZGluYXRlc1xuXG4gIHZhciB4ID0gb2Zmc2V0LFxuICAgICAgeSA9IG9mZnNldDtcbiAgaXNYID8geCA9IE1hdGgucm91bmQoYm91bmRzLngxICsgYmFuZCAqIGJvdW5kcy53aWR0aCgpKSA6IHkgPSBNYXRoLnJvdW5kKGJvdW5kcy55MSArIGJhbmQgKiBib3VuZHMuaGVpZ2h0KCkpOyAvLyBhc3NpZ24gY29vcmRpbmF0ZXMgYW5kIHVwZGF0ZSBib3VuZHNcblxuICBnLmJvdW5kcy50cmFuc2xhdGUoeCAtIChnLnggfHwgMCksIHkgLSAoZy55IHx8IDApKTtcbiAgZy5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGcuYm91bmRzKTtcbiAgZy54ID0geDtcbiAgZy55ID0geTsgLy8gcXVldWUgdGl0bGUgZm9yIHJlZHJhd1xuXG4gIHZpZXcuZGlydHkoZyk7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cCQxKGNvbmZpZywgb3JpZW50KSB7XG4gIGNvbnN0IG9wdCA9IGNvbmZpZ1tvcmllbnRdIHx8IHt9O1xuICByZXR1cm4gKGtleSwgZCkgPT4gb3B0W2tleV0gIT0gbnVsbCA/IG9wdFtrZXldIDogY29uZmlnW2tleV0gIT0gbnVsbCA/IGNvbmZpZ1trZXldIDogZDtcbn0gLy8gaWYgbGVnZW5kcyBzcGVjaWZ5IG9mZnNldCBkaXJlY3RseSwgdXNlIHRoZSBtYXhpbXVtIHNwZWNpZmllZCB2YWx1ZVxuXG5cbmZ1bmN0aW9uIG9mZnNldHMobGVnZW5kcywgdmFsdWUpIHtcbiAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgbGVnZW5kcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLm9mZnNldCAhPSBudWxsKSBtYXggPSBNYXRoLm1heChtYXgsIGl0ZW0ub2Zmc2V0KTtcbiAgfSk7XG4gIHJldHVybiBtYXggPiAtSW5maW5pdHkgPyBtYXggOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbGVnZW5kUGFyYW1zKGcsIG9yaWVudCwgY29uZmlnLCB4YiwgeWIsIHcsIGgpIHtcbiAgY29uc3QgXyA9IGxvb2t1cCQxKGNvbmZpZywgb3JpZW50KSxcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0cyhnLCBfKCdvZmZzZXQnLCAwKSksXG4gICAgICAgIGFuY2hvciA9IF8oJ2FuY2hvcicsIFN0YXJ0KSxcbiAgICAgICAgbXVsdCA9IGFuY2hvciA9PT0gRW5kID8gMSA6IGFuY2hvciA9PT0gTWlkZGxlID8gMC41IDogMDtcblxuICBjb25zdCBwID0ge1xuICAgIGFsaWduOiBFYWNoLFxuICAgIGJvdW5kczogXygnYm91bmRzJywgRmx1c2gpLFxuICAgIGNvbHVtbnM6IF8oJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnID8gMSA6IGcubGVuZ3RoLFxuICAgIHBhZGRpbmc6IF8oJ21hcmdpbicsIDgpLFxuICAgIGNlbnRlcjogXygnY2VudGVyJyksXG4gICAgbm9kaXJ0eTogdHJ1ZVxuICB9O1xuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBMZWZ0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IoeGIueDEpIC0gb2Zmc2V0LFxuICAgICAgICBjb2x1bW46IEVuZCxcbiAgICAgICAgeTogbXVsdCAqIChoIHx8IHhiLmhlaWdodCgpICsgMiAqIHhiLnkxKSxcbiAgICAgICAgcm93OiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUmlnaHQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogTWF0aC5jZWlsKHhiLngyKSArIG9mZnNldCxcbiAgICAgICAgeTogbXVsdCAqIChoIHx8IHhiLmhlaWdodCgpICsgMiAqIHhiLnkxKSxcbiAgICAgICAgcm93OiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVG9wOlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHk6IE1hdGguZmxvb3IoeWIueTEpIC0gb2Zmc2V0LFxuICAgICAgICByb3c6IEVuZCxcbiAgICAgICAgeDogbXVsdCAqICh3IHx8IHliLndpZHRoKCkgKyAyICogeWIueDEpLFxuICAgICAgICBjb2x1bW46IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBCb3R0b206XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeTogTWF0aC5jZWlsKHliLnkyKSArIG9mZnNldCxcbiAgICAgICAgeDogbXVsdCAqICh3IHx8IHliLndpZHRoKCkgKyAyICogeWIueDEpLFxuICAgICAgICBjb2x1bW46IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUb3BMZWZ0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IG9mZnNldCxcbiAgICAgICAgeTogb2Zmc2V0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRvcFJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IHcgLSBvZmZzZXQsXG4gICAgICAgIHk6IG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQm90dG9tTGVmdDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBvZmZzZXQsXG4gICAgICAgIHk6IGggLSBvZmZzZXQsXG4gICAgICAgIHJvdzogRW5kXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEJvdHRvbVJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IHcgLSBvZmZzZXQsXG4gICAgICAgIHk6IGggLSBvZmZzZXQsXG4gICAgICAgIGNvbHVtbjogRW5kLFxuICAgICAgICByb3c6IEVuZFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBsZWdlbmRMYXlvdXQodmlldywgbGVnZW5kKSB7XG4gIHZhciBpdGVtID0gbGVnZW5kLml0ZW1zWzBdLFxuICAgICAgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgICAgb3JpZW50ID0gaXRlbS5vcmllbnQsXG4gICAgICBib3VuZHMgPSBpdGVtLmJvdW5kcyxcbiAgICAgIHggPSBpdGVtLngsXG4gICAgICB5ID0gaXRlbS55LFxuICAgICAgdyxcbiAgICAgIGg7IC8vIGNhY2hlIGN1cnJlbnQgYm91bmRzIGZvciBsYXRlciBjb21wYXJpc29uXG5cbiAgaXRlbS5fYm91bmRzID8gaXRlbS5fYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKSA6IGl0ZW0uX2JvdW5kcyA9IGJvdW5kcy5jbG9uZSgpO1xuICBib3VuZHMuY2xlYXIoKTsgLy8gYWRqdXN0IGxlZ2VuZCB0byBhY2NvbW1vZGF0ZSBwYWRkaW5nIGFuZCB0aXRsZVxuXG4gIGxlZ2VuZEdyb3VwTGF5b3V0KHZpZXcsIGl0ZW0sIGl0ZW0uaXRlbXNbMF0uaXRlbXNbMF0pOyAvLyBhZ2dyZWdhdGUgYm91bmRzIHRvIGRldGVybWluZSBzaXplLCBhbmQgaW5jbHVkZSBvcmlnaW5cblxuICBib3VuZHMgPSBsZWdlbmRCb3VuZHMoaXRlbSwgYm91bmRzKTtcbiAgdyA9IDIgKiBpdGVtLnBhZGRpbmc7XG4gIGggPSAyICogaXRlbS5wYWRkaW5nO1xuXG4gIGlmICghYm91bmRzLmVtcHR5KCkpIHtcbiAgICB3ID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCgpICsgdyk7XG4gICAgaCA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KCkgKyBoKTtcbiAgfVxuXG4gIGlmIChkYXR1bS50eXBlID09PSBTeW1ib2xzKSB7XG4gICAgbGVnZW5kRW50cnlMYXlvdXQoaXRlbS5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pdGVtcyk7XG4gIH1cblxuICBpZiAob3JpZW50ICE9PSBOb25lKSB7XG4gICAgaXRlbS54ID0geCA9IDA7XG4gICAgaXRlbS55ID0geSA9IDA7XG4gIH1cblxuICBpdGVtLndpZHRoID0gdztcbiAgaXRlbS5oZWlnaHQgPSBoO1xuICBib3VuZFN0cm9rZShib3VuZHMuc2V0KHgsIHksIHggKyB3LCB5ICsgaCksIGl0ZW0pO1xuICBpdGVtLm1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24oYm91bmRzKTtcbiAgcmV0dXJuIGl0ZW07XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEJvdW5kcyhpdGVtLCBiKSB7XG4gIC8vIGFnZ3JlZ2F0ZSBpdGVtIGJvdW5kc1xuICBpdGVtLml0ZW1zLmZvckVhY2goXyA9PiBiLnVuaW9uKF8uYm91bmRzKSk7IC8vIGFuY2hvciB0byBsZWdlbmQgb3JpZ2luXG5cbiAgYi54MSA9IGl0ZW0ucGFkZGluZztcbiAgYi55MSA9IGl0ZW0ucGFkZGluZztcbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZEdyb3VwTGF5b3V0KHZpZXcsIGl0ZW0sIGVudHJ5KSB7XG4gIHZhciBwYWQgPSBpdGVtLnBhZGRpbmcsXG4gICAgICBleCA9IHBhZCAtIGVudHJ5LngsXG4gICAgICBleSA9IHBhZCAtIGVudHJ5Lnk7XG5cbiAgaWYgKCFpdGVtLmRhdHVtLnRpdGxlKSB7XG4gICAgaWYgKGV4IHx8IGV5KSB0cmFuc2xhdGUodmlldywgZW50cnksIGV4LCBleSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRpdGxlID0gaXRlbS5pdGVtc1sxXS5pdGVtc1swXSxcbiAgICAgICAgYW5jaG9yID0gdGl0bGUuYW5jaG9yLFxuICAgICAgICB0cGFkID0gaXRlbS50aXRsZVBhZGRpbmcgfHwgMCxcbiAgICAgICAgdHggPSBwYWQgLSB0aXRsZS54LFxuICAgICAgICB0eSA9IHBhZCAtIHRpdGxlLnk7XG5cbiAgICBzd2l0Y2ggKHRpdGxlLm9yaWVudCkge1xuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICBleCArPSBNYXRoLmNlaWwodGl0bGUuYm91bmRzLndpZHRoKCkpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUmlnaHQ6XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV5ICs9IHRpdGxlLmJvdW5kcy5oZWlnaHQoKSArIHRwYWQ7XG4gICAgfVxuXG4gICAgaWYgKGV4IHx8IGV5KSB0cmFuc2xhdGUodmlldywgZW50cnksIGV4LCBleSk7XG5cbiAgICBzd2l0Y2ggKHRpdGxlLm9yaWVudCkge1xuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMSwgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICB0eCArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIEVuZCwgMCwgMCkgKyB0cGFkO1xuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMSwgMSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgdHggKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDAsIDApO1xuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIEVuZCwgLTEsIDAsIDEpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHR4ICs9IGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCAwLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodHggfHwgdHkpIHRyYW5zbGF0ZSh2aWV3LCB0aXRsZSwgdHgsIHR5KTsgLy8gdHJhbnNsYXRlIGxlZ2VuZCBpZiB0aXRsZSBwdXNoZXMgaW50byBuZWdhdGl2ZSBjb29yZGluYXRlc1xuXG4gICAgaWYgKCh0eCA9IE1hdGgucm91bmQodGl0bGUuYm91bmRzLngxIC0gcGFkKSkgPCAwKSB7XG4gICAgICB0cmFuc2xhdGUodmlldywgZW50cnksIC10eCwgMCk7XG4gICAgICB0cmFuc2xhdGUodmlldywgdGl0bGUsIC10eCwgMCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCB5LCBsciwgbm9CYXIpIHtcbiAgY29uc3QgZ3JhZCA9IGl0ZW0uZGF0dW0udHlwZSAhPT0gJ3N5bWJvbCcsXG4gICAgICAgIHZncmFkID0gdGl0bGUuZGF0dW0udmdyYWQsXG4gICAgICAgIGUgPSBncmFkICYmIChsciB8fCAhdmdyYWQpICYmICFub0JhciA/IGVudHJ5Lml0ZW1zWzBdIDogZW50cnksXG4gICAgICAgIHMgPSBlLmJvdW5kc1t5ID8gJ3kyJyA6ICd4MiddIC0gaXRlbS5wYWRkaW5nLFxuICAgICAgICB1ID0gdmdyYWQgJiYgbHIgPyBzIDogMCxcbiAgICAgICAgdiA9IHZncmFkICYmIGxyID8gMCA6IHMsXG4gICAgICAgIG8gPSB5IDw9IDAgPyAwIDogbXVsdGlMaW5lT2Zmc2V0KHRpdGxlKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoYW5jaG9yID09PSBTdGFydCA/IHUgOiBhbmNob3IgPT09IEVuZCA/IHYgLSBvIDogMC41ICogKHMgLSBvKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2aWV3LCBpdGVtLCBkeCwgZHkpIHtcbiAgaXRlbS54ICs9IGR4O1xuICBpdGVtLnkgKz0gZHk7XG4gIGl0ZW0uYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICBpdGVtLm1hcmsuYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICB2aWV3LmRpcnR5KGl0ZW0pO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRFbnRyeUxheW91dChlbnRyaWVzKSB7XG4gIC8vIGdldCBtYXggd2lkdGhzIGZvciBlYWNoIGNvbHVtblxuICBjb25zdCB3aWR0aHMgPSBlbnRyaWVzLnJlZHVjZSgodywgZykgPT4ge1xuICAgIHdbZy5jb2x1bW5dID0gTWF0aC5tYXgoZy5ib3VuZHMueDIgLSBnLngsIHdbZy5jb2x1bW5dIHx8IDApO1xuICAgIHJldHVybiB3O1xuICB9LCB7fSk7IC8vIHNldCBkaW1lbnNpb25zIG9mIGxlZ2VuZCBlbnRyeSBncm91cHNcblxuICBlbnRyaWVzLmZvckVhY2goZyA9PiB7XG4gICAgZy53aWR0aCA9IHdpZHRoc1tnLmNvbHVtbl07XG4gICAgZy5oZWlnaHQgPSBnLmJvdW5kcy55MiAtIGcueTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRpdGxlTGF5b3V0KHZpZXcsIG1hcmssIHdpZHRoLCBoZWlnaHQsIHZpZXdCb3VuZHMpIHtcbiAgdmFyIGdyb3VwID0gbWFyay5pdGVtc1swXSxcbiAgICAgIGZyYW1lID0gZ3JvdXAuZnJhbWUsXG4gICAgICBvcmllbnQgPSBncm91cC5vcmllbnQsXG4gICAgICBhbmNob3IgPSBncm91cC5hbmNob3IsXG4gICAgICBvZmZzZXQgPSBncm91cC5vZmZzZXQsXG4gICAgICBwYWRkaW5nID0gZ3JvdXAucGFkZGluZyxcbiAgICAgIHRpdGxlID0gZ3JvdXAuaXRlbXNbMF0uaXRlbXNbMF0sXG4gICAgICBzdWJ0aXRsZSA9IGdyb3VwLml0ZW1zWzFdICYmIGdyb3VwLml0ZW1zWzFdLml0ZW1zWzBdLFxuICAgICAgZW5kID0gb3JpZW50ID09PSBMZWZ0IHx8IG9yaWVudCA9PT0gUmlnaHQgPyBoZWlnaHQgOiB3aWR0aCxcbiAgICAgIHN0YXJ0ID0gMCxcbiAgICAgIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBzeCA9IDAsXG4gICAgICBzeSA9IDAsXG4gICAgICBwb3M7XG5cbiAgaWYgKGZyYW1lICE9PSBHcm91cCkge1xuICAgIG9yaWVudCA9PT0gTGVmdCA/IChzdGFydCA9IHZpZXdCb3VuZHMueTIsIGVuZCA9IHZpZXdCb3VuZHMueTEpIDogb3JpZW50ID09PSBSaWdodCA/IChzdGFydCA9IHZpZXdCb3VuZHMueTEsIGVuZCA9IHZpZXdCb3VuZHMueTIpIDogKHN0YXJ0ID0gdmlld0JvdW5kcy54MSwgZW5kID0gdmlld0JvdW5kcy54Mik7XG4gIH0gZWxzZSBpZiAob3JpZW50ID09PSBMZWZ0KSB7XG4gICAgc3RhcnQgPSBoZWlnaHQsIGVuZCA9IDA7XG4gIH1cblxuICBwb3MgPSBhbmNob3IgPT09IFN0YXJ0ID8gc3RhcnQgOiBhbmNob3IgPT09IEVuZCA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuXG4gIGlmIChzdWJ0aXRsZSAmJiBzdWJ0aXRsZS50ZXh0KSB7XG4gICAgLy8gcG9zaXRpb24gc3VidGl0bGVcbiAgICBzd2l0Y2ggKG9yaWVudCkge1xuICAgICAgY2FzZSBUb3A6XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgc3kgPSB0aXRsZS5ib3VuZHMuaGVpZ2h0KCkgKyBwYWRkaW5nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICBzeCA9IHRpdGxlLmJvdW5kcy53aWR0aCgpICsgcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUmlnaHQ6XG4gICAgICAgIHN4ID0gLXRpdGxlLmJvdW5kcy53aWR0aCgpIC0gcGFkZGluZztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGVtcEJvdW5kcy5jbGVhcigpLnVuaW9uKHN1YnRpdGxlLmJvdW5kcyk7XG4gICAgdGVtcEJvdW5kcy50cmFuc2xhdGUoc3ggLSAoc3VidGl0bGUueCB8fCAwKSwgc3kgLSAoc3VidGl0bGUueSB8fCAwKSk7XG5cbiAgICBpZiAoc2V0KHN1YnRpdGxlLCAneCcsIHN4KSB8IHNldChzdWJ0aXRsZSwgJ3knLCBzeSkpIHtcbiAgICAgIHZpZXcuZGlydHkoc3VidGl0bGUpO1xuICAgICAgc3VidGl0bGUuYm91bmRzLmNsZWFyKCkudW5pb24odGVtcEJvdW5kcyk7XG4gICAgICBzdWJ0aXRsZS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgICAgdmlldy5kaXJ0eShzdWJ0aXRsZSk7XG4gICAgfVxuXG4gICAgdGVtcEJvdW5kcy5jbGVhcigpLnVuaW9uKHN1YnRpdGxlLmJvdW5kcyk7XG4gIH0gZWxzZSB7XG4gICAgdGVtcEJvdW5kcy5jbGVhcigpO1xuICB9XG5cbiAgdGVtcEJvdW5kcy51bmlvbih0aXRsZS5ib3VuZHMpOyAvLyBwb3NpdGlvbiB0aXRsZSBncm91cFxuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBUb3A6XG4gICAgICB4ID0gcG9zO1xuICAgICAgeSA9IHZpZXdCb3VuZHMueTEgLSB0ZW1wQm91bmRzLmhlaWdodCgpIC0gb2Zmc2V0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExlZnQ6XG4gICAgICB4ID0gdmlld0JvdW5kcy54MSAtIHRlbXBCb3VuZHMud2lkdGgoKSAtIG9mZnNldDtcbiAgICAgIHkgPSBwb3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUmlnaHQ6XG4gICAgICB4ID0gdmlld0JvdW5kcy54MiArIHRlbXBCb3VuZHMud2lkdGgoKSArIG9mZnNldDtcbiAgICAgIHkgPSBwb3M7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQm90dG9tOlxuICAgICAgeCA9IHBvcztcbiAgICAgIHkgPSB2aWV3Qm91bmRzLnkyICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgeCA9IGdyb3VwLng7XG4gICAgICB5ID0gZ3JvdXAueTtcbiAgfVxuXG4gIGlmIChzZXQoZ3JvdXAsICd4JywgeCkgfCBzZXQoZ3JvdXAsICd5JywgeSkpIHtcbiAgICB0ZW1wQm91bmRzLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB2aWV3LmRpcnR5KGdyb3VwKTtcbiAgICBncm91cC5ib3VuZHMuY2xlYXIoKS51bmlvbih0ZW1wQm91bmRzKTtcbiAgICBtYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgIHZpZXcuZGlydHkoZ3JvdXApO1xuICB9XG5cbiAgcmV0dXJuIGdyb3VwLmJvdW5kcztcbn1cblxuLyoqXG4gKiBMYXlvdXQgdmlldyBlbGVtZW50cyBzdWNoIGFzIGF4ZXMgYW5kIGxlZ2VuZHMuXG4gKiBBbHNvIHBlcmZvcm1zIHNpemUgYWRqdXN0bWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFNjZW5lZ3JhcGggbWFyayBvZiBncm91cHMgdG8gbGF5b3V0LlxuICovXG5cbmZ1bmN0aW9uIFZpZXdMYXlvdXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhWaWV3TGF5b3V0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdmlldyA9IHB1bHNlLmRhdGFmbG93O1xuXG4gICAgXy5tYXJrLml0ZW1zLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgaWYgKF8ubGF5b3V0KSB0cmVsbGlzTGF5b3V0KHZpZXcsIGdyb3VwLCBfLmxheW91dCk7XG4gICAgICBsYXlvdXRHcm91cCh2aWV3LCBncm91cCwgXyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gc2hvdWxkUmVmbG93KF8ubWFyay5ncm91cCkgPyBwdWxzZS5yZWZsb3coKSA6IHB1bHNlO1xuICB9XG5cbn0pO1xuXG5mdW5jdGlvbiBzaG91bGRSZWZsb3coZ3JvdXApIHtcbiAgLy8gV2UgdHlwaWNhbGx5IHNob3VsZCByZWZsb3cgaWYgbGF5b3V0IGlzIGludm9rZWQgKCMyNTY4KSwgYXMgY2hpbGQgaXRlbXNcbiAgLy8gbWF5IGhhdmUgcmVzaXplZCBhbmQgcmVmbG93IGVuc3VyZXMgZ3JvdXAgYm91bmRzIGFyZSByZS1jYWxjdWxhdGVkLlxuICAvLyBIb3dldmVyLCBsZWdlbmQgZW50cmllcyBoYXZlIGEgc3BlY2lhbCBleGNlcHRpb24gdG8gYXZvaWQgaW5zdGFiaWxpdHkuXG4gIC8vIEZvciBleGFtcGxlLCBpZiBhIHNlbGVjdGVkIGxlZ2VuZCBzeW1ib2wgZ2FpbnMgYSBzdHJva2Ugb24gaG92ZXIsXG4gIC8vIHdlIGRvbid0IHdhbnQgdG8gcmUtcG9zaXRpb24gc3Vic2VxdWVudCBlbGVtZW50cyBpbiB0aGUgbGVnZW5kLlxuICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAubWFyay5yb2xlICE9PSAnbGVnZW5kLWVudHJ5Jztcbn1cblxuZnVuY3Rpb24gbGF5b3V0R3JvdXAodmlldywgZ3JvdXAsIF8pIHtcbiAgdmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXMsXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgZ3JvdXAuaGVpZ2h0IHx8IDApLFxuICAgICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCksXG4gICAgICB4Qm91bmRzID0gdmlld0JvdW5kcy5jbG9uZSgpLFxuICAgICAgeUJvdW5kcyA9IHZpZXdCb3VuZHMuY2xvbmUoKSxcbiAgICAgIGxlZ2VuZHMgPSBbXSxcbiAgICAgIHRpdGxlLFxuICAgICAgbWFyayxcbiAgICAgIG9yaWVudCxcbiAgICAgIGIsXG4gICAgICBpLFxuICAgICAgbjsgLy8gbGF5b3V0IGF4ZXMsIGdhdGhlciBsZWdlbmRzLCBjb2xsZWN0IGJvdW5kc1xuXG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBtYXJrID0gaXRlbXNbaV07XG5cbiAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgY2FzZSBBeGlzUm9sZTpcbiAgICAgICAgYiA9IGlzWUF4aXMobWFyaykgPyB4Qm91bmRzIDogeUJvdW5kcztcbiAgICAgICAgYi51bmlvbihheGlzTGF5b3V0KHZpZXcsIG1hcmssIHdpZHRoLCBoZWlnaHQpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICB0aXRsZSA9IG1hcms7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGxlZ2VuZHMucHVzaChsZWdlbmRMYXlvdXQodmlldywgbWFyaykpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGcmFtZVJvbGU6XG4gICAgICBjYXNlIFNjb3BlUm9sZTpcbiAgICAgIGNhc2UgUm93SGVhZGVyOlxuICAgICAgY2FzZSBSb3dGb290ZXI6XG4gICAgICBjYXNlIFJvd1RpdGxlOlxuICAgICAgY2FzZSBDb2xIZWFkZXI6XG4gICAgICBjYXNlIENvbEZvb3RlcjpcbiAgICAgIGNhc2UgQ29sVGl0bGU6XG4gICAgICAgIHhCb3VuZHMudW5pb24obWFyay5ib3VuZHMpO1xuICAgICAgICB5Qm91bmRzLnVuaW9uKG1hcmsuYm91bmRzKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZpZXdCb3VuZHMudW5pb24obWFyay5ib3VuZHMpO1xuICAgIH1cbiAgfSAvLyBsYXlvdXQgbGVnZW5kcywgYWRqdXN0IHZpZXdCb3VuZHNcblxuXG4gIGlmIChsZWdlbmRzLmxlbmd0aCkge1xuICAgIC8vIGdyb3VwIGxlZ2VuZHMgYnkgb3JpZW50XG4gICAgY29uc3QgbCA9IHt9O1xuICAgIGxlZ2VuZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50IHx8IFJpZ2h0O1xuICAgICAgaWYgKG9yaWVudCAhPT0gTm9uZSkgKGxbb3JpZW50XSB8fCAobFtvcmllbnRdID0gW10pKS5wdXNoKGl0ZW0pO1xuICAgIH0pOyAvLyBwZXJmb3JtIGdyaWQgbGF5b3V0IGZvciBlYWNoIG9yaWVudCBncm91cFxuXG4gICAgZm9yIChjb25zdCBvcmllbnQgaW4gbCkge1xuICAgICAgY29uc3QgZyA9IGxbb3JpZW50XTtcbiAgICAgIGdyaWRMYXlvdXQodmlldywgZywgbGVnZW5kUGFyYW1zKGcsIG9yaWVudCwgXy5sZWdlbmRzLCB4Qm91bmRzLCB5Qm91bmRzLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfSAvLyB1cGRhdGUgdmlldyBib3VuZHNcblxuXG4gICAgbGVnZW5kcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgYiA9IGl0ZW0uYm91bmRzO1xuXG4gICAgICBpZiAoIWIuZXF1YWxzKGl0ZW0uX2JvdW5kcykpIHtcbiAgICAgICAgaXRlbS5ib3VuZHMgPSBpdGVtLl9ib3VuZHM7XG4gICAgICAgIHZpZXcuZGlydHkoaXRlbSk7IC8vIGRpcnR5IHByZXZpb3VzIGxvY2F0aW9uXG5cbiAgICAgICAgaXRlbS5ib3VuZHMgPSBiO1xuICAgICAgICB2aWV3LmRpcnR5KGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5hdXRvc2l6ZSAmJiBfLmF1dG9zaXplLnR5cGUgPT09IEZpdCkge1xuICAgICAgICAvLyBGb3IgYXV0b3NpemUgZml0LCBpbmNvcnBvcmF0ZSB0aGUgb3J0aG9nb25hbCBkaW1lbnNpb24gb25seS5cbiAgICAgICAgLy8gTGVnZW5kcyB0aGF0IG92ZXJydW4gdGhlIGNoYXJ0IGFyZWEgd2lsbCB0aGVuIGJlIGNsaXBwZWQ7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgY2hhcnQgYXJlYSBnZXRzIHJlZHVjZWQgdG8gbm90aGluZyFcbiAgICAgICAgc3dpdGNoIChpdGVtLm9yaWVudCkge1xuICAgICAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICAgICAgdmlld0JvdW5kcy5hZGQoYi54MSwgMCkuYWRkKGIueDIsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFRvcDpcbiAgICAgICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgICAgIHZpZXdCb3VuZHMuYWRkKDAsIGIueTEpLmFkZCgwLCBiLnkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlld0JvdW5kcy51bmlvbihiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSAvLyBjb21iaW5lIGJvdW5kaW5nIGJveGVzXG5cblxuICB2aWV3Qm91bmRzLnVuaW9uKHhCb3VuZHMpLnVuaW9uKHlCb3VuZHMpOyAvLyBsYXlvdXQgdGl0bGUsIGFkanVzdCBib3VuZHNcblxuICBpZiAodGl0bGUpIHtcbiAgICB2aWV3Qm91bmRzLnVuaW9uKHRpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm91bmRzKSk7XG4gIH0gLy8gb3ZlcnJpZGUgYWdncmVnYXRlZCB2aWV3IGJvdW5kcyBpZiBjb250ZW50IGlzIGNsaXBwZWRcblxuXG4gIGlmIChncm91cC5jbGlwKSB7XG4gICAgdmlld0JvdW5kcy5zZXQoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICB9IC8vIHBlcmZvcm0gc2l6ZSBhZGp1c3RtZW50XG5cblxuICB2aWV3U2l6ZUxheW91dCh2aWV3LCBncm91cCwgdmlld0JvdW5kcywgXyk7XG59XG5cbmZ1bmN0aW9uIHZpZXdTaXplTGF5b3V0KHZpZXcsIGdyb3VwLCB2aWV3Qm91bmRzLCBfKSB7XG4gIGNvbnN0IGF1dG8gPSBfLmF1dG9zaXplIHx8IHt9LFxuICAgICAgICB0eXBlID0gYXV0by50eXBlO1xuICBpZiAodmlldy5fYXV0b3NpemUgPCAxIHx8ICF0eXBlKSByZXR1cm47XG4gIGxldCB2aWV3V2lkdGggPSB2aWV3Ll93aWR0aCxcbiAgICAgIHZpZXdIZWlnaHQgPSB2aWV3Ll9oZWlnaHQsXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgbGVmdCA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgtdmlld0JvdW5kcy54MSkpLFxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgZ3JvdXAuaGVpZ2h0IHx8IDApLFxuICAgICAgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKC12aWV3Qm91bmRzLnkxKSk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHZpZXdCb3VuZHMueDIgLSB3aWR0aCkpLFxuICAgICAgICBib3R0b20gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwodmlld0JvdW5kcy55MiAtIGhlaWdodCkpO1xuXG4gIGlmIChhdXRvLmNvbnRhaW5zID09PSBQYWRkaW5nKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICAgIHZpZXdXaWR0aCAtPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgIHZpZXdIZWlnaHQgLT0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBOb25lKSB7XG4gICAgbGVmdCA9IDA7XG4gICAgdG9wID0gMDtcbiAgICB3aWR0aCA9IHZpZXdXaWR0aDtcbiAgICBoZWlnaHQgPSB2aWV3SGVpZ2h0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZpdCkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgdmlld1dpZHRoIC0gbGVmdCAtIHJpZ2h0KTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCB2aWV3SGVpZ2h0IC0gdG9wIC0gYm90dG9tKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGaXRYKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB2aWV3V2lkdGggLSBsZWZ0IC0gcmlnaHQpO1xuICAgIHZpZXdIZWlnaHQgPSBoZWlnaHQgKyB0b3AgKyBib3R0b207XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRml0WSkge1xuICAgIHZpZXdXaWR0aCA9IHdpZHRoICsgbGVmdCArIHJpZ2h0O1xuICAgIGhlaWdodCA9IE1hdGgubWF4KDAsIHZpZXdIZWlnaHQgLSB0b3AgLSBib3R0b20pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFBhZCkge1xuICAgIHZpZXdXaWR0aCA9IHdpZHRoICsgbGVmdCArIHJpZ2h0O1xuICAgIHZpZXdIZWlnaHQgPSBoZWlnaHQgKyB0b3AgKyBib3R0b207XG4gIH1cblxuICB2aWV3Ll9yZXNpemVWaWV3KHZpZXdXaWR0aCwgdmlld0hlaWdodCwgd2lkdGgsIGhlaWdodCwgW2xlZnQsIHRvcF0sIGF1dG8ucmVzaXplKTtcbn1cblxuZXhwb3J0IHsgQm91bmQgYXMgYm91bmQsIElkZW50aWZpZXIgYXMgaWRlbnRpZmllciwgTWFyayBhcyBtYXJrLCBPdmVybGFwIGFzIG92ZXJsYXAsIFJlbmRlciBhcyByZW5kZXIsIFZpZXdMYXlvdXQgYXMgdmlld2xheW91dCB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGhhc093blByb3BlcnR5LCBlcnJvciwgdHJ1dGh5LCBjb25zdGFudCwgZXh0ZW5kLCBpc0FycmF5LCB0b1NldCwgYXJyYXksIGlzT2JqZWN0LCBkZWJvdW5jZSwgaXNEYXRlLCBpbmhlcml0cywgc3RyaW5nVmFsdWUgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgY2hhbmdlc2V0LCBpc0NoYW5nZVNldCwgRXZlbnRTdHJlYW0sIHRyYW5zZm9ybXMsIERhdGFmbG93LCBhc3luY0NhbGxiYWNrIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBwb2ludCwgcmVuZGVyTW9kdWxlLCBDYW52YXNIYW5kbGVyLCBSZW5kZXJUeXBlLCBTY2VuZWdyYXBoIH0gZnJvbSAndmVnYS1zY2VuZWdyYXBoJztcbmltcG9ydCB7IHRpY2tTdGVwIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgZnVuY3Rpb25Db250ZXh0IH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgY29udGV4dCB9IGZyb20gJ3ZlZ2EtcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcnZhbCB9IGZyb20gJ2QzLXRpbWVyJztcbmltcG9ydCB7IGxvY2FsZSB9IGZyb20gJ3ZlZ2EtZm9ybWF0JztcblxuLy8gaW5pdGlhbGl6ZSBhcmlhIHJvbGUgYW5kIGxhYmVsIGF0dHJpYnV0ZXNcbmZ1bmN0aW9uIGluaXRpYWxpemVBcmlhKHZpZXcpIHtcbiAgY29uc3QgZWwgPSB2aWV3LmNvbnRhaW5lcigpO1xuXG4gIGlmIChlbCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdncmFwaGljcy1kb2N1bWVudCcpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlRGVzY3JpcHRpb24nLCAndmlzdWFsaXphdGlvbicpO1xuICAgIGFyaWFMYWJlbChlbCwgdmlldy5kZXNjcmlwdGlvbigpKTtcbiAgfVxufSAvLyB1cGRhdGUgYXJpYS1sYWJlbCBpZiB3ZSBoYXZlIGEgRE9NIGNvbnRhaW5lciBlbGVtZW50XG5cbmZ1bmN0aW9uIGFyaWFMYWJlbChlbCwgZGVzYykge1xuICBpZiAoZWwpIGRlc2MgPT0gbnVsbCA/IGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpIDogZWwuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgZGVzYyk7XG59XG5cbmZ1bmN0aW9uIGJhY2tncm91bmQgKHZpZXcpIHtcbiAgLy8gcmVzcG9uZCB0byBiYWNrZ3JvdW5kIHNpZ25hbFxuICB2aWV3LmFkZChudWxsLCBfID0+IHtcbiAgICB2aWV3Ll9iYWNrZ3JvdW5kID0gXy5iZztcbiAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgIHJldHVybiBfLmJnO1xuICB9LCB7XG4gICAgYmc6IHZpZXcuX3NpZ25hbHMuYmFja2dyb3VuZFxuICB9KTtcbn1cblxuY29uc3QgRGVmYXVsdCA9ICdkZWZhdWx0JztcbmZ1bmN0aW9uIGN1cnNvciAodmlldykge1xuICAvLyBnZXQgY3Vyc29yIHNpZ25hbCwgYWRkIHRvIGRhdGFmbG93IGlmIG5lZWRlZFxuICBjb25zdCBjdXJzb3IgPSB2aWV3Ll9zaWduYWxzLmN1cnNvciB8fCAodmlldy5fc2lnbmFscy5jdXJzb3IgPSB2aWV3LmFkZCh7XG4gICAgdXNlcjogRGVmYXVsdCxcbiAgICBpdGVtOiBudWxsXG4gIH0pKTsgLy8gZXZhbHVhdGUgY3Vyc29yIG9uIGVhY2ggbW91c2Vtb3ZlIGV2ZW50XG5cbiAgdmlldy5vbih2aWV3LmV2ZW50cygndmlldycsICdtb3VzZW1vdmUnKSwgY3Vyc29yLCAoXywgZXZlbnQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci52YWx1ZSxcbiAgICAgICAgICB1c2VyID0gdmFsdWUgPyBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZSA6IHZhbHVlLnVzZXIgOiBEZWZhdWx0LFxuICAgICAgICAgIGl0ZW0gPSBldmVudC5pdGVtICYmIGV2ZW50Lml0ZW0uY3Vyc29yIHx8IG51bGw7XG4gICAgcmV0dXJuIHZhbHVlICYmIHVzZXIgPT09IHZhbHVlLnVzZXIgJiYgaXRlbSA9PSB2YWx1ZS5pdGVtID8gdmFsdWUgOiB7XG4gICAgICB1c2VyOiB1c2VyLFxuICAgICAgaXRlbTogaXRlbVxuICAgIH07XG4gIH0pOyAvLyB3aGVuIGN1cnNvciBzaWduYWwgdXBkYXRlcywgc2V0IHZpc2libGUgY3Vyc29yXG5cbiAgdmlldy5hZGQobnVsbCwgZnVuY3Rpb24gKF8pIHtcbiAgICBsZXQgdXNlciA9IF8uY3Vyc29yLFxuICAgICAgICBpdGVtID0gdGhpcy52YWx1ZTtcblxuICAgIGlmICghaXNTdHJpbmcodXNlcikpIHtcbiAgICAgIGl0ZW0gPSB1c2VyLml0ZW07XG4gICAgICB1c2VyID0gdXNlci51c2VyO1xuICAgIH1cblxuICAgIHNldEN1cnNvcih2aWV3LCB1c2VyICYmIHVzZXIgIT09IERlZmF1bHQgPyB1c2VyIDogaXRlbSB8fCB1c2VyKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSwge1xuICAgIGN1cnNvcjogY3Vyc29yXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0Q3Vyc29yKHZpZXcsIGN1cnNvcikge1xuICBjb25zdCBlbCA9IHZpZXcuZ2xvYmFsQ3Vyc29yKCkgPyB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmJvZHkgOiB2aWV3LmNvbnRhaW5lcigpO1xuXG4gIGlmIChlbCkge1xuICAgIHJldHVybiBjdXJzb3IgPT0gbnVsbCA/IGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdjdXJzb3InKSA6IGVsLnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhcmVmKHZpZXcsIG5hbWUpIHtcbiAgdmFyIGRhdGEgPSB2aWV3Ll9ydW50aW1lLmRhdGE7XG5cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShkYXRhLCBuYW1lKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgZGF0YSBzZXQ6ICcgKyBuYW1lKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhW25hbWVdO1xufVxuZnVuY3Rpb24gZGF0YShuYW1lLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZGF0YXJlZih0aGlzLCBuYW1lKS52YWx1ZXMudmFsdWUgOiBjaGFuZ2UuY2FsbCh0aGlzLCBuYW1lLCBjaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQodmFsdWVzKSk7XG59XG5mdW5jdGlvbiBjaGFuZ2UobmFtZSwgY2hhbmdlcykge1xuICBpZiAoIWlzQ2hhbmdlU2V0KGNoYW5nZXMpKSB7XG4gICAgZXJyb3IoJ1NlY29uZCBhcmd1bWVudCB0byBjaGFuZ2VzIG11c3QgYmUgYSBjaGFuZ2VzZXQuJyk7XG4gIH1cblxuICBjb25zdCBkYXRhc2V0ID0gZGF0YXJlZih0aGlzLCBuYW1lKTtcbiAgZGF0YXNldC5tb2RpZmllZCA9IHRydWU7XG4gIHJldHVybiB0aGlzLnB1bHNlKGRhdGFzZXQuaW5wdXQsIGNoYW5nZXMpO1xufVxuZnVuY3Rpb24gaW5zZXJ0KG5hbWUsIF8pIHtcbiAgcmV0dXJuIGNoYW5nZS5jYWxsKHRoaXMsIG5hbWUsIGNoYW5nZXNldCgpLmluc2VydChfKSk7XG59XG5mdW5jdGlvbiByZW1vdmUobmFtZSwgXykge1xuICByZXR1cm4gY2hhbmdlLmNhbGwodGhpcywgbmFtZSwgY2hhbmdlc2V0KCkucmVtb3ZlKF8pKTtcbn1cblxuZnVuY3Rpb24gd2lkdGgodmlldykge1xuICB2YXIgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdmlldy5fdmlld1dpZHRoICsgcGFkZGluZy5sZWZ0ICsgcGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiBoZWlnaHQodmlldykge1xuICB2YXIgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdmlldy5fdmlld0hlaWdodCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20pO1xufVxuZnVuY3Rpb24gb2Zmc2V0KHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKSxcbiAgICAgIG9yaWdpbiA9IHZpZXcuX29yaWdpbjtcbiAgcmV0dXJuIFtwYWRkaW5nLmxlZnQgKyBvcmlnaW5bMF0sIHBhZGRpbmcudG9wICsgb3JpZ2luWzFdXTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZVJlbmRlcmVyKHZpZXcpIHtcbiAgdmFyIG9yaWdpbiA9IG9mZnNldCh2aWV3KSxcbiAgICAgIHcgPSB3aWR0aCh2aWV3KSxcbiAgICAgIGggPSBoZWlnaHQodmlldyk7XG5cbiAgdmlldy5fcmVuZGVyZXIuYmFja2dyb3VuZCh2aWV3LmJhY2tncm91bmQoKSk7XG5cbiAgdmlldy5fcmVuZGVyZXIucmVzaXplKHcsIGgsIG9yaWdpbik7XG5cbiAgdmlldy5faGFuZGxlci5vcmlnaW4ob3JpZ2luKTtcblxuICB2aWV3Ll9yZXNpemVMaXN0ZW5lcnMuZm9yRWFjaChoYW5kbGVyID0+IHtcbiAgICB0cnkge1xuICAgICAgaGFuZGxlcih3LCBoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmlldy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBFeHRlbmQgYW4gZXZlbnQgd2l0aCBhZGRpdGlvbmFsIHZpZXctc3BlY2lmaWMgbWV0aG9kcy5cbiAqIEFkZHMgYSBuZXcgcHJvcGVydHkgKCd2ZWdhJykgdG8gYW4gZXZlbnQgdGhhdCBwcm92aWRlcyBhIG51bWJlclxuICogb2YgbWV0aG9kcyBmb3IgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24uXG4gKiBUaGUgdmVnYSBvYmplY3QgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICogICB2aWV3IC0gUmV0dXJucyB0aGUgYmFja2luZyBWaWV3IGluc3RhbmNlLlxuICogICBpdGVtIC0gUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY2VuZWdyYXBoIGl0ZW0gKGlmIGFueSkuXG4gKiAgIGdyb3VwIC0gUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSBzY2VuZWdyYXBoIGdyb3VwIChpZiBhbnkpLlxuICogICAgIFRoaXMgbWV0aG9kIGFjY2VwdHMgYSBzaW5nbGUgc3RyaW5nLXR5cGVkIGFyZ3VtZW50IGluZGljYXRpbmcgdGhlIG5hbWVcbiAqICAgICBvZiB0aGUgZGVzaXJlZCBwYXJlbnQgZ3JvdXAuIFRoZSBzY2VuZWdyYXBoIHdpbGwgYmUgdHJhdmVyc2VkIGZyb21cbiAqICAgICB0aGUgaXRlbSB1cCB0b3dhcmRzIHRoZSByb290IHRvIHNlYXJjaCBmb3IgYSBtYXRjaGluZyBncm91cC4gSWYgbm9cbiAqICAgICBhcmd1bWVudCBpcyBwcm92aWRlZCB0aGUgZW5jbG9zaW5nIGdyb3VwIGZvciB0aGUgYWN0aXZlIGl0ZW0gaXNcbiAqICAgICByZXR1cm5lZCwgdW5sZXNzIHRoZSBpdGVtIGl0IGl0c2VsZiBhIGdyb3VwLCBpbiB3aGljaCBjYXNlIGl0IGlzXG4gKiAgICAgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiAgIHh5IC0gUmV0dXJucyBhIHR3by1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZm9yXG4gKiAgICAgbW91c2Ugb3IgdG91Y2ggZXZlbnRzLiBGb3IgdG91Y2ggZXZlbnRzLCB0aGlzIGlzIGJhc2VkIG9uIHRoZSBmaXJzdFxuICogICAgIGVsZW1lbnRzIGluIHRoZSBjaGFuZ2VkVG91Y2hlcyBhcnJheS4gVGhpcyBtZXRob2QgYWNjZXB0cyBhIHNpbmdsZVxuICogICAgIGFyZ3VtZW50OiBlaXRoZXIgYW4gaXRlbSBpbnN0YW5jZSBvciBtYXJrIG5hbWUgdGhhdCBzaG91bGQgc2VydmUgYXNcbiAqICAgICB0aGUgcmVmZXJlbmNlIGNvb3JkaW5hdGUgc3lzdGVtLiBJZiBubyBhcmd1bWVudCBpcyBwcm92aWRlZCB0aGVcbiAqICAgICB0b3AtbGV2ZWwgdmlldyBjb29yZGluYXRlIHN5c3RlbSBpcyBhc3N1bWVkLlxuICogICB4IC0gUmV0dXJucyB0aGUgY3VycmVudCB4LWNvb3JkaW5hdGUsIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHh5LlxuICogICB5IC0gUmV0dXJucyB0aGUgY3VycmVudCB5LWNvb3JkaW5hdGUsIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHh5LlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgaW5wdXQgZXZlbnQgdG8gZXh0ZW5kLlxuICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIGN1cnJlbnRseSBhY3RpdmUgc2NlbmVncmFwaCBpdGVtIChpZiBhbnkpLlxuICogQHJldHVybiB7RXZlbnR9IC0gVGhlIGV4dGVuZGVkIGlucHV0IGV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV2ZW50RXh0ZW5kICh2aWV3LCBldmVudCwgaXRlbSkge1xuICB2YXIgciA9IHZpZXcuX3JlbmRlcmVyLFxuICAgICAgZWwgPSByICYmIHIuY2FudmFzKCksXG4gICAgICBwLFxuICAgICAgZSxcbiAgICAgIHRyYW5zbGF0ZTtcblxuICBpZiAoZWwpIHtcbiAgICB0cmFuc2xhdGUgPSBvZmZzZXQodmlldyk7XG4gICAgZSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICBwID0gcG9pbnQoZSwgZWwpO1xuICAgIHBbMF0gLT0gdHJhbnNsYXRlWzBdO1xuICAgIHBbMV0gLT0gdHJhbnNsYXRlWzFdO1xuICB9XG5cbiAgZXZlbnQuZGF0YWZsb3cgPSB2aWV3O1xuICBldmVudC5pdGVtID0gaXRlbTtcbiAgZXZlbnQudmVnYSA9IGV4dGVuc2lvbih2aWV3LCBpdGVtLCBwKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBleHRlbnNpb24odmlldywgaXRlbSwgcG9pbnQpIHtcbiAgY29uc3QgaXRlbUdyb3VwID0gaXRlbSA/IGl0ZW0ubWFyay5tYXJrdHlwZSA9PT0gJ2dyb3VwJyA/IGl0ZW0gOiBpdGVtLm1hcmsuZ3JvdXAgOiBudWxsO1xuXG4gIGZ1bmN0aW9uIGdyb3VwKG5hbWUpIHtcbiAgICB2YXIgZyA9IGl0ZW1Hcm91cCxcbiAgICAgICAgaTtcbiAgICBpZiAobmFtZSkgZm9yIChpID0gaXRlbTsgaTsgaSA9IGkubWFyay5ncm91cCkge1xuICAgICAgaWYgKGkubWFyay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGcgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGcgJiYgZy5tYXJrICYmIGcubWFyay5pbnRlcmFjdGl2ZSA/IGcgOiB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHh5KGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHJldHVybiBwb2ludDtcbiAgICBpZiAoaXNTdHJpbmcoaXRlbSkpIGl0ZW0gPSBncm91cChpdGVtKTtcbiAgICBjb25zdCBwID0gcG9pbnQuc2xpY2UoKTtcblxuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICBwWzBdIC09IGl0ZW0ueCB8fCAwO1xuICAgICAgcFsxXSAtPSBpdGVtLnkgfHwgMDtcbiAgICAgIGl0ZW0gPSBpdGVtLm1hcmsgJiYgaXRlbS5tYXJrLmdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2aWV3OiBjb25zdGFudCh2aWV3KSxcbiAgICBpdGVtOiBjb25zdGFudChpdGVtIHx8IHt9KSxcbiAgICBncm91cDogZ3JvdXAsXG4gICAgeHk6IHh5LFxuICAgIHg6IGl0ZW0gPT4geHkoaXRlbSlbMF0sXG4gICAgeTogaXRlbSA9PiB4eShpdGVtKVsxXVxuICB9O1xufVxuXG5jb25zdCBWSUVXID0gJ3ZpZXcnLFxuICAgICAgVElNRVIgPSAndGltZXInLFxuICAgICAgV0lORE9XID0gJ3dpbmRvdycsXG4gICAgICBOT19UUkFQID0ge1xuICB0cmFwOiBmYWxzZVxufTtcbi8qKlxuICogSW5pdGlhbGl6ZSBldmVudCBoYW5kbGluZyBjb25maWd1cmF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIFRoZSBjb25maWd1cmF0aW9uIHNldHRpbmdzLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGluaXRpYWxpemVFdmVudENvbmZpZyhjb25maWcpIHtcbiAgY29uc3QgZXZlbnRzID0gZXh0ZW5kKHtcbiAgICBkZWZhdWx0czoge31cbiAgfSwgY29uZmlnKTtcblxuICBjb25zdCB1bnBhY2sgPSAob2JqLCBrZXlzKSA9PiB7XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkgb2JqW2tdID0gdG9TZXQob2JqW2tdKTtcbiAgICB9KTtcbiAgfTtcblxuICB1bnBhY2soZXZlbnRzLmRlZmF1bHRzLCBbJ3ByZXZlbnQnLCAnYWxsb3cnXSk7XG4gIHVucGFjayhldmVudHMsIFsndmlldycsICd3aW5kb3cnLCAnc2VsZWN0b3InXSk7XG4gIHJldHVybiBldmVudHM7XG59XG5mdW5jdGlvbiB0cmFja0V2ZW50TGlzdGVuZXIodmlldywgc291cmNlcywgdHlwZSwgaGFuZGxlcikge1xuICB2aWV3Ll9ldmVudExpc3RlbmVycy5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNvdXJjZXM6IGFycmF5KHNvdXJjZXMpLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnQodmlldywgdHlwZSkge1xuICB2YXIgZGVmID0gdmlldy5fZXZlbnRDb25maWcuZGVmYXVsdHMsXG4gICAgICBwcmV2ZW50ID0gZGVmLnByZXZlbnQsXG4gICAgICBhbGxvdyA9IGRlZi5hbGxvdztcbiAgcmV0dXJuIHByZXZlbnQgPT09IGZhbHNlIHx8IGFsbG93ID09PSB0cnVlID8gZmFsc2UgOiBwcmV2ZW50ID09PSB0cnVlIHx8IGFsbG93ID09PSBmYWxzZSA/IHRydWUgOiBwcmV2ZW50ID8gcHJldmVudFt0eXBlXSA6IGFsbG93ID8gIWFsbG93W3R5cGVdIDogdmlldy5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBwZXJtaXQodmlldywga2V5LCB0eXBlKSB7XG4gIGNvbnN0IHJ1bGUgPSB2aWV3Ll9ldmVudENvbmZpZyAmJiB2aWV3Ll9ldmVudENvbmZpZ1trZXldO1xuXG4gIGlmIChydWxlID09PSBmYWxzZSB8fCBpc09iamVjdChydWxlKSAmJiAhcnVsZVt0eXBlXSkge1xuICAgIHZpZXcud2FybihgQmxvY2tlZCAke2tleX0gJHt0eXBlfSBldmVudCBsaXN0ZW5lci5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0V2ZW50U3RyZWFtfVxuICovXG5cblxuZnVuY3Rpb24gZXZlbnRzKHNvdXJjZSwgdHlwZSwgZmlsdGVyKSB7XG4gIHZhciB2aWV3ID0gdGhpcyxcbiAgICAgIHMgPSBuZXcgRXZlbnRTdHJlYW0oZmlsdGVyKSxcbiAgICAgIHNlbmQgPSBmdW5jdGlvbiAoZSwgaXRlbSkge1xuICAgIHZpZXcucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHNvdXJjZSA9PT0gVklFVyAmJiBwcmV2ZW50KHZpZXcsIHR5cGUpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgcy5yZWNlaXZlKGV2ZW50RXh0ZW5kKHZpZXcsIGUsIGl0ZW0pKTtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHNvdXJjZXM7XG5cbiAgaWYgKHNvdXJjZSA9PT0gVElNRVIpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd0aW1lcicsIHR5cGUpKSB7XG4gICAgICB2aWV3LnRpbWVyKHNlbmQsIHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFZJRVcpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd2aWV3JywgdHlwZSkpIHtcbiAgICAgIC8vIHNlbmQgdHJhcHMgZXJyb3JzLCBzbyB1c2Uge3RyYXA6IGZhbHNlfSBvcHRpb25cbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kLCBOT19UUkFQKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gV0lORE9XKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICd3aW5kb3cnLCB0eXBlKSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3VyY2VzID0gW3dpbmRvd107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICdzZWxlY3RvcicsIHR5cGUpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzb3VyY2VzKSB7XG4gICAgICB2aWV3Lndhcm4oJ0NhbiBub3QgcmVzb2x2ZSBldmVudCBzb3VyY2U6ICcgKyBzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHNvdXJjZXNbaV0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIHNvdXJjZXMsIHR5cGUsIHNlbmQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpdGVtRmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5pdGVtO1xufVxuXG5mdW5jdGlvbiBtYXJrVGFyZ2V0KGV2ZW50KSB7XG4gIC8vIGdyYWIgdXBzdHJlYW0gY29sbGVjdG9yIGZlZWRpbmcgdGhlIG1hcmsgb3BlcmF0b3JcbiAgcmV0dXJuIGV2ZW50Lml0ZW0ubWFyay5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGludm9rZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXywgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudmVnYS52aWV3KCkuY2hhbmdlc2V0KCkuZW5jb2RlKGV2ZW50Lml0ZW0sIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBob3ZlciAoaG92ZXJTZXQsIGxlYXZlU2V0KSB7XG4gIGhvdmVyU2V0ID0gW2hvdmVyU2V0IHx8ICdob3ZlciddO1xuICBsZWF2ZVNldCA9IFtsZWF2ZVNldCB8fCAndXBkYXRlJywgaG92ZXJTZXRbMF1dOyAvLyBpbnZva2UgaG92ZXIgc2V0IHVwb24gbW91c2VvdmVyXG5cbiAgdGhpcy5vbih0aGlzLmV2ZW50cygndmlldycsICdtb3VzZW92ZXInLCBpdGVtRmlsdGVyKSwgbWFya1RhcmdldCwgaW52b2tlKGhvdmVyU2V0KSk7IC8vIGludm9rZSBsZWF2ZSBzZXQgdXBvbiBtb3VzZW91dFxuXG4gIHRoaXMub24odGhpcy5ldmVudHMoJ3ZpZXcnLCAnbW91c2VvdXQnLCBpdGVtRmlsdGVyKSwgbWFya1RhcmdldCwgaW52b2tlKGxlYXZlU2V0KSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEZpbmFsaXplIGEgVmlldyBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHJlbW92ZWQuXG4gKiBDYW5jZWwgYW55IHJ1bm5pbmcgdGltZXJzLlxuICogUmVtb3ZlIGFsbCBleHRlcm5hbCBldmVudCBsaXN0ZW5lcnMuXG4gKiBSZW1vdmUgYW55IGN1cnJlbnRseSBkaXNwbGF5ZWQgdG9vbHRpcC5cbiAqL1xuZnVuY3Rpb24gZmluYWxpemUgKCkge1xuICB2YXIgdG9vbHRpcCA9IHRoaXMuX3Rvb2x0aXAsXG4gICAgICB0aW1lcnMgPSB0aGlzLl90aW1lcnMsXG4gICAgICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycyxcbiAgICAgIG4sXG4gICAgICBtLFxuICAgICAgZTtcbiAgbiA9IHRpbWVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdGltZXJzW25dLnN0b3AoKTtcbiAgfVxuXG4gIG4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLW4gPj0gMCkge1xuICAgIGUgPSBsaXN0ZW5lcnNbbl07XG4gICAgbSA9IGUuc291cmNlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIGUuc291cmNlc1ttXS5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgZS5oYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9vbHRpcCkge1xuICAgIHRvb2x0aXAuY2FsbCh0aGlzLCB0aGlzLl9oYW5kbGVyLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50ICh0YWcsIGF0dHIsIHRleHQpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYXR0cikgZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cltrZXldKTtcblxuICBpZiAodGV4dCAhPSBudWxsKSBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBlbDtcbn1cblxuY29uc3QgQmluZENsYXNzID0gJ3ZlZ2EtYmluZCcsXG4gICAgICBOYW1lQ2xhc3MgPSAndmVnYS1iaW5kLW5hbWUnLFxuICAgICAgUmFkaW9DbGFzcyA9ICd2ZWdhLWJpbmQtcmFkaW8nO1xuLyoqXG4gKiBCaW5kIGEgc2lnbmFsIHRvIGFuIGV4dGVybmFsIEhUTUwgaW5wdXQgZWxlbWVudC4gVGhlIHJlc3VsdGluZyB0d28td2F5XG4gKiBiaW5kaW5nIHdpbGwgcHJvcGFnYXRlIGlucHV0IGNoYW5nZXMgdG8gc2lnbmFscywgYW5kIHByb3BhZ2F0ZSBzaWduYWxcbiAqIGNoYW5nZXMgdG8gdGhlIGlucHV0IGVsZW1lbnQgc3RhdGUuIElmIHRoaXMgdmlldyBpbnN0YW5jZSBoYXMgbm8gcGFyZW50XG4gKiBlbGVtZW50LCB3ZSBhc3N1bWUgdGhlIHZpZXcgaXMgaGVhZGxlc3MgYW5kIG5vIGJpbmRpbmdzIGFyZSBjcmVhdGVkLlxuICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWwgLSBUaGUgcGFyZW50IERPTSBlbGVtZW50IHRvIHdoaWNoIHRoZSBpbnB1dFxuICogICBlbGVtZW50IHNob3VsZCBiZSBhcHBlbmRlZCBhcyBhIGNoaWxkLiBJZiBzdHJpbmctdmFsdWVkLCB0aGlzIGFyZ3VtZW50XG4gKiAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIENTUyBzZWxlY3Rvci4gSWYgbnVsbCBvciB1bmRlZmluZWQsIHRoZSBwYXJlbnRcbiAqICAgZWxlbWVudCBvZiB0aGlzIHZpZXcgd2lsbCBiZSB1c2VkIGFzIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gVGhlIGJpbmRpbmcgcGFyYW1ldGVycyB3aGljaCBzcGVjaWZ5IHRoZSBzaWduYWxcbiAqICAgdG8gYmluZCB0bywgdGhlIGlucHV0IGVsZW1lbnQgdHlwZSwgYW5kIHR5cGUtc3BlY2lmaWMgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm4ge1ZpZXd9IC0gVGhpcyB2aWV3IGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGJpbmQgKHZpZXcsIGVsLCBiaW5kaW5nKSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgY29uc3QgcGFyYW0gPSBiaW5kaW5nLnBhcmFtO1xuICBsZXQgYmluZCA9IGJpbmRpbmcuc3RhdGU7XG5cbiAgaWYgKCFiaW5kKSB7XG4gICAgYmluZCA9IGJpbmRpbmcuc3RhdGUgPSB7XG4gICAgICBlbGVtZW50czogbnVsbCxcbiAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICBzZXQ6IG51bGwsXG4gICAgICB1cGRhdGU6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9IHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCkpIHtcbiAgICAgICAgICB2aWV3LnJ1bkFzeW5jKG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGJpbmQuc291cmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCwgdmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChwYXJhbS5kZWJvdW5jZSkge1xuICAgICAgYmluZC51cGRhdGUgPSBkZWJvdW5jZShwYXJhbS5kZWJvdW5jZSwgYmluZC51cGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZSA9IHBhcmFtLmlucHV0ID09IG51bGwgJiYgcGFyYW0uZWxlbWVudCA/IHRhcmdldCA6IGdlbmVyYXRlO1xuICBjcmVhdGUoYmluZCwgZWwsIHBhcmFtLCB2aWV3KTtcblxuICBpZiAoIWJpbmQuYWN0aXZlKSB7XG4gICAgdmlldy5vbih2aWV3Ll9zaWduYWxzW3BhcmFtLnNpZ25hbF0sIG51bGwsICgpID0+IHtcbiAgICAgIGJpbmQuc291cmNlID8gYmluZC5zb3VyY2UgPSBmYWxzZSA6IGJpbmQuc2V0KHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCkpO1xuICAgIH0pO1xuICAgIGJpbmQuYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBiaW5kO1xufVxuLyoqXG4gKiBCaW5kIHRoZSBzaWduYWwgdG8gYW4gZXh0ZXJuYWwgRXZlbnRUYXJnZXQuXG4gKi9cblxuZnVuY3Rpb24gdGFyZ2V0KGJpbmQsIG5vZGUsIHBhcmFtLCB2aWV3KSB7XG4gIGNvbnN0IHR5cGUgPSBwYXJhbS5ldmVudCB8fCAnaW5wdXQnO1xuXG4gIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLnZhbHVlKTsgLy8gaW5pdGlhbGl6ZSBzaWduYWwgdmFsdWUgdG8gZXh0ZXJuYWwgaW5wdXQgdmFsdWVcblxuXG4gIHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCwgbm9kZS52YWx1ZSk7IC8vIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGUgZWxlbWVudFxuXG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTsgLy8gcmVnaXN0ZXIgd2l0aCB2aWV3LCBzbyB3ZSBjYW4gcmVtb3ZlIGl0IHVwb24gZmluYWxpemF0aW9uXG5cbiAgdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIG5vZGUsIHR5cGUsIGhhbmRsZXIpOyAvLyBwcm9wYWdhdGUgY2hhbmdlIHRvIGVsZW1lbnRcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KHR5cGUpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBFdmVudCh0eXBlKSA6IHtcbiAgICB0eXBlXG4gIH07XG59XG4vKipcbiAqIEdlbmVyYXRlIGFuIEhUTUwgaW5wdXQgZm9ybSBlbGVtZW50IGFuZCBiaW5kIGl0IHRvIGEgc2lnbmFsLlxuICovXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUoYmluZCwgZWwsIHBhcmFtLCB2aWV3KSB7XG4gIGNvbnN0IHZhbHVlID0gdmlldy5zaWduYWwocGFyYW0uc2lnbmFsKTtcbiAgY29uc3QgZGl2ID0gZWxlbWVudCgnZGl2Jywge1xuICAgICdjbGFzcyc6IEJpbmRDbGFzc1xuICB9KTtcbiAgY29uc3Qgd3JhcHBlciA9IHBhcmFtLmlucHV0ID09PSAncmFkaW8nID8gZGl2IDogZGl2LmFwcGVuZENoaWxkKGVsZW1lbnQoJ2xhYmVsJykpO1xuICB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQoJ3NwYW4nLCB7XG4gICAgJ2NsYXNzJzogTmFtZUNsYXNzXG4gIH0sIHBhcmFtLm5hbWUgfHwgcGFyYW0uc2lnbmFsKSk7XG4gIGVsLmFwcGVuZENoaWxkKGRpdik7XG4gIGxldCBpbnB1dCA9IGZvcm07XG5cbiAgc3dpdGNoIChwYXJhbS5pbnB1dCkge1xuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgIGlucHV0ID0gY2hlY2tib3g7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbnB1dCA9IHNlbGVjdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgaW5wdXQgPSByYWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmFuZ2UnOlxuICAgICAgaW5wdXQgPSByYW5nZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaW5wdXQoYmluZCwgd3JhcHBlciwgcGFyYW0sIHZhbHVlKTtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFyYml0cmFyeSBpbnB1dCBmb3JtIGVsZW1lbnQuXG4gKiBUaGUgaW5wdXQgdHlwZSBpcyBjb250cm9sbGVkIHZpYSB1c2VyLXByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ2lucHV0Jyk7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW0pIHtcbiAgICBpZiAoa2V5ICE9PSAnc2lnbmFsJyAmJiBrZXkgIT09ICdlbGVtZW50Jykge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5ID09PSAnaW5wdXQnID8gJ3R5cGUnIDoga2V5LCBwYXJhbVtrZXldKTtcbiAgICB9XG4gIH1cblxuICBub2RlLnNldEF0dHJpYnV0ZSgnbmFtZScsIHBhcmFtLnNpZ25hbCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLnZhbHVlKSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiBub2RlLnZhbHVlID0gdmFsdWU7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja2JveChiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIGNvbnN0IGF0dHIgPSB7XG4gICAgdHlwZTogJ2NoZWNrYm94JyxcbiAgICBuYW1lOiBwYXJhbS5zaWduYWxcbiAgfTtcbiAgaWYgKHZhbHVlKSBhdHRyLmNoZWNrZWQgPSB0cnVlO1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnaW5wdXQnLCBhdHRyKTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4gYmluZC51cGRhdGUobm9kZS5jaGVja2VkKSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG5cbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiBub2RlLmNoZWNrZWQgPSAhIXZhbHVlIHx8IG51bGw7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNlbGVjdGlvbiBsaXN0IGlucHV0IGVsZW1lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBzZWxlY3QoYmluZCwgZWwsIHBhcmFtLCB2YWx1ZSkge1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnc2VsZWN0Jywge1xuICAgIG5hbWU6IHBhcmFtLnNpZ25hbFxuICB9KSxcbiAgICAgICAgbGFiZWxzID0gcGFyYW0ubGFiZWxzIHx8IFtdO1xuICBwYXJhbS5vcHRpb25zLmZvckVhY2goKG9wdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICB2YWx1ZTogb3B0aW9uXG4gICAgfTtcbiAgICBpZiAodmFsdWVzRXF1YWwob3B0aW9uLCB2YWx1ZSkpIGF0dHIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudCgnb3B0aW9uJywgYXR0ciwgKGxhYmVsc1tpXSB8fCBvcHRpb24pICsgJycpKTtcbiAgfSk7XG4gIGVsLmFwcGVuZENoaWxkKG5vZGUpO1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHtcbiAgICBiaW5kLnVwZGF0ZShwYXJhbS5vcHRpb25zW25vZGUuc2VsZWN0ZWRJbmRleF0pO1xuICB9KTtcbiAgYmluZC5lbGVtZW50cyA9IFtub2RlXTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBhcmFtLm9wdGlvbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAodmFsdWVzRXF1YWwocGFyYW0ub3B0aW9uc1tpXSwgdmFsdWUpKSB7XG4gICAgICAgIG5vZGUuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhZGlvIGJ1dHRvbiBncm91cC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhZGlvKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3QgZ3JvdXAgPSBlbGVtZW50KCdzcGFuJywge1xuICAgICdjbGFzcyc6IFJhZGlvQ2xhc3NcbiAgfSksXG4gICAgICAgIGxhYmVscyA9IHBhcmFtLmxhYmVscyB8fCBbXTtcbiAgZWwuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICBiaW5kLmVsZW1lbnRzID0gcGFyYW0ub3B0aW9ucy5tYXAoKG9wdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgbmFtZTogcGFyYW0uc2lnbmFsLFxuICAgICAgdmFsdWU6IG9wdGlvblxuICAgIH07XG4gICAgaWYgKHZhbHVlc0VxdWFsKG9wdGlvbiwgdmFsdWUpKSBhdHRyLmNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlucHV0ID0gZWxlbWVudCgnaW5wdXQnLCBhdHRyKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBiaW5kLnVwZGF0ZShvcHRpb24pKTtcbiAgICBjb25zdCBsYWJlbCA9IGVsZW1lbnQoJ2xhYmVsJywge30sIChsYWJlbHNbaV0gfHwgb3B0aW9uKSArICcnKTtcbiAgICBsYWJlbC5wcmVwZW5kKGlucHV0KTtcbiAgICBncm91cC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9KTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBjb25zdCBub2RlcyA9IGJpbmQuZWxlbWVudHMsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAodmFsdWVzRXF1YWwobm9kZXNbaV0udmFsdWUsIHZhbHVlKSkgbm9kZXNbaV0uY2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzbGlkZXIgaW5wdXQgZWxlbWVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJhbmdlKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgdmFsdWUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiAoK3BhcmFtLm1heCArICtwYXJhbS5taW4pIC8gMjtcbiAgY29uc3QgbWF4ID0gcGFyYW0ubWF4ICE9IG51bGwgPyBwYXJhbS5tYXggOiBNYXRoLm1heCgxMDAsICt2YWx1ZSkgfHwgMTAwLFxuICAgICAgICBtaW4gPSBwYXJhbS5taW4gfHwgTWF0aC5taW4oMCwgbWF4LCArdmFsdWUpIHx8IDAsXG4gICAgICAgIHN0ZXAgPSBwYXJhbS5zdGVwIHx8IHRpY2tTdGVwKG1pbiwgbWF4LCAxMDApO1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnaW5wdXQnLCB7XG4gICAgdHlwZTogJ3JhbmdlJyxcbiAgICBuYW1lOiBwYXJhbS5zaWduYWwsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgc3RlcDogc3RlcFxuICB9KTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBjb25zdCBzcGFuID0gZWxlbWVudCgnc3BhbicsIHt9LCArdmFsdWUpO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgZWwuYXBwZW5kQ2hpbGQoc3Bhbik7XG5cbiAgY29uc3QgdXBkYXRlID0gKCkgPT4ge1xuICAgIHNwYW4udGV4dENvbnRlbnQgPSBub2RlLnZhbHVlO1xuICAgIGJpbmQudXBkYXRlKCtub2RlLnZhbHVlKTtcbiAgfTsgLy8gc3Vic2NyaWJlIHRvIGJvdGggaW5wdXQgYW5kIGNoYW5nZVxuXG5cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlKTtcbiAgYmluZC5lbGVtZW50cyA9IFtub2RlXTtcblxuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWx1ZXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgKyAnJyA9PT0gYiArICcnO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplUmVuZGVyZXIgKHZpZXcsIHIsIGVsLCBjb25zdHJ1Y3Rvciwgc2NhbGVGYWN0b3IsIG9wdCkge1xuICByID0gciB8fCBuZXcgY29uc3RydWN0b3Iodmlldy5sb2FkZXIoKSk7XG4gIHJldHVybiByLmluaXRpYWxpemUoZWwsIHdpZHRoKHZpZXcpLCBoZWlnaHQodmlldyksIG9mZnNldCh2aWV3KSwgc2NhbGVGYWN0b3IsIG9wdCkuYmFja2dyb3VuZCh2aWV3LmJhY2tncm91bmQoKSk7XG59XG5cbmZ1bmN0aW9uIHRyYXAgKHZpZXcsIGZuKSB7XG4gIHJldHVybiAhZm4gPyBudWxsIDogZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2aWV3LmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVIYW5kbGVyICh2aWV3LCBwcmV2SGFuZGxlciwgZWwsIGNvbnN0cnVjdG9yKSB7XG4gIC8vIGluc3RhbnRpYXRlIHNjZW5lZ3JhcGggaGFuZGxlclxuICBjb25zdCBoYW5kbGVyID0gbmV3IGNvbnN0cnVjdG9yKHZpZXcubG9hZGVyKCksIHRyYXAodmlldywgdmlldy50b29sdGlwKCkpKS5zY2VuZSh2aWV3LnNjZW5lZ3JhcGgoKS5yb290KS5pbml0aWFsaXplKGVsLCBvZmZzZXQodmlldyksIHZpZXcpOyAvLyB0cmFuc2ZlciBldmVudCBoYW5kbGVyc1xuXG4gIGlmIChwcmV2SGFuZGxlcikge1xuICAgIHByZXZIYW5kbGVyLmhhbmRsZXJzKCkuZm9yRWFjaChoID0+IHtcbiAgICAgIGhhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZXI7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUgKGVsLCBlbEJpbmQpIHtcbiAgY29uc3QgdmlldyA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSB2aWV3Ll9yZW5kZXJUeXBlLFxuICAgICAgICBjb25maWcgPSB2aWV3Ll9ldmVudENvbmZpZy5iaW5kLFxuICAgICAgICBtb2R1bGUgPSByZW5kZXJNb2R1bGUodHlwZSk7IC8vIGNvbnRhaW5pbmcgZG9tIGVsZW1lbnRcblxuICBlbCA9IHZpZXcuX2VsID0gZWwgPyBsb29rdXAodmlldywgZWwsIHRydWUpIDogbnVsbDsgLy8gaW5pdGlhbGl6ZSBhcmlhIGF0dHJpYnV0ZXNcblxuICBpbml0aWFsaXplQXJpYSh2aWV3KTsgLy8gc2VsZWN0IGFwcHJvcHJpYXRlIHJlbmRlcmVyICYgaGFuZGxlclxuXG4gIGlmICghbW9kdWxlKSB2aWV3LmVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICBjb25zdCBIYW5kbGVyID0gbW9kdWxlLmhhbmRsZXIgfHwgQ2FudmFzSGFuZGxlcixcbiAgICAgICAgUmVuZGVyZXIgPSBlbCA/IG1vZHVsZS5yZW5kZXJlciA6IG1vZHVsZS5oZWFkbGVzczsgLy8gaW5pdGlhbGl6ZSByZW5kZXJlciBhbmQgaW5wdXQgaGFuZGxlclxuXG4gIHZpZXcuX3JlbmRlcmVyID0gIVJlbmRlcmVyID8gbnVsbCA6IGluaXRpYWxpemVSZW5kZXJlcih2aWV3LCB2aWV3Ll9yZW5kZXJlciwgZWwsIFJlbmRlcmVyKTtcbiAgdmlldy5faGFuZGxlciA9IGluaXRpYWxpemVIYW5kbGVyKHZpZXcsIHZpZXcuX2hhbmRsZXIsIGVsLCBIYW5kbGVyKTtcbiAgdmlldy5fcmVkcmF3ID0gdHJ1ZTsgLy8gaW5pdGlhbGl6ZSBzaWduYWwgYmluZGluZ3NcblxuICBpZiAoZWwgJiYgY29uZmlnICE9PSAnbm9uZScpIHtcbiAgICBlbEJpbmQgPSBlbEJpbmQgPyB2aWV3Ll9lbEJpbmQgPSBsb29rdXAodmlldywgZWxCaW5kLCB0cnVlKSA6IGVsLmFwcGVuZENoaWxkKGVsZW1lbnQoJ2Zvcm0nLCB7XG4gICAgICAnY2xhc3MnOiAndmVnYS1iaW5kaW5ncydcbiAgICB9KSk7XG5cbiAgICB2aWV3Ll9iaW5kLmZvckVhY2goXyA9PiB7XG4gICAgICBpZiAoXy5wYXJhbS5lbGVtZW50ICYmIGNvbmZpZyAhPT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgXy5lbGVtZW50ID0gbG9va3VwKHZpZXcsIF8ucGFyYW0uZWxlbWVudCwgISFfLnBhcmFtLmlucHV0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZpZXcuX2JpbmQuZm9yRWFjaChfID0+IHtcbiAgICAgIGJpbmQodmlldywgXy5lbGVtZW50IHx8IGVsQmluZCwgXyk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmlldztcbn1cblxuZnVuY3Rpb24gbG9va3VwKHZpZXcsIGVsLCBjbGVhcikge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHZpZXcuZXJyb3IoJ1NpZ25hbCBiaW5kIGVsZW1lbnQgbm90IGZvdW5kOiAnICsgZWwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5lcnJvcignRE9NIGRvY3VtZW50IGluc3RhbmNlIG5vdCBmb3VuZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbCAmJiBjbGVhcikge1xuICAgIHRyeSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSAnJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbCA9IG51bGw7XG4gICAgICB2aWV3LmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cblxuY29uc3QgbnVtYmVyID0gXyA9PiArXyB8fCAwO1xuXG5jb25zdCBwYWRkaW5nT2JqZWN0ID0gXyA9PiAoe1xuICB0b3A6IF8sXG4gIGJvdHRvbTogXyxcbiAgbGVmdDogXyxcbiAgcmlnaHQ6IF9cbn0pO1xuXG5mdW5jdGlvbiBwYWRkaW5nIChfKSB7XG4gIHJldHVybiBpc09iamVjdChfKSA/IHtcbiAgICB0b3A6IG51bWJlcihfLnRvcCksXG4gICAgYm90dG9tOiBudW1iZXIoXy5ib3R0b20pLFxuICAgIGxlZnQ6IG51bWJlcihfLmxlZnQpLFxuICAgIHJpZ2h0OiBudW1iZXIoXy5yaWdodClcbiAgfSA6IHBhZGRpbmdPYmplY3QobnVtYmVyKF8pKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgaW4gYSBoZWFkbGVzcyBmYXNoaW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHJlbmRlcmVyLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckhlYWRsZXNzICh2aWV3LCB0eXBlLCBzY2FsZUZhY3Rvciwgb3B0KSB7XG4gIGNvbnN0IG1vZHVsZSA9IHJlbmRlck1vZHVsZSh0eXBlKSxcbiAgICAgICAgY3RyID0gbW9kdWxlICYmIG1vZHVsZS5oZWFkbGVzcztcbiAgaWYgKCFjdHIpIGVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICBhd2FpdCB2aWV3LnJ1bkFzeW5jKCk7XG4gIHJldHVybiBpbml0aWFsaXplUmVuZGVyZXIodmlldywgbnVsbCwgbnVsbCwgY3RyLCBzY2FsZUZhY3Rvciwgb3B0KS5yZW5kZXJBc3luYyh2aWV3Ll9zY2VuZWdyYXBoLnJvb3QpO1xufVxuXG4vKipcbiAqIFByb2R1Y2UgYW4gaW1hZ2UgVVJMIGZvciB0aGUgdmlzdWFsaXphdGlvbi4gRGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gKiBwYXJhbWV0ZXIsIHRoZSBnZW5lcmF0ZWQgVVJMIGNvbnRhaW5zIGRhdGEgZm9yIGVpdGhlciBhIFBORyBvciBTVkcgaW1hZ2UuXG4gKiBUaGUgVVJMIGNhbiBiZSB1c2VkIChmb3IgZXhhbXBsZSkgdG8gZG93bmxvYWQgaW1hZ2VzIG9mIHRoZSB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgaW1hZ2UgdHlwZS4gT25lIG9mICdzdmcnLCAncG5nJyBvciAnY2FudmFzJy5cbiAqICAgVGhlICdjYW52YXMnIGFuZCAncG5nJyB0eXBlcyBhcmUgc3lub255bXMgZm9yIGEgUE5HIGltYWdlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBpbWFnZSBVUkwuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9JbWFnZVVSTCAodHlwZSwgc2NhbGVGYWN0b3IpIHtcbiAgaWYgKHR5cGUgIT09IFJlbmRlclR5cGUuQ2FudmFzICYmIHR5cGUgIT09IFJlbmRlclR5cGUuU1ZHICYmIHR5cGUgIT09IFJlbmRlclR5cGUuUE5HKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBpbWFnZSB0eXBlOiAnICsgdHlwZSk7XG4gIH1cblxuICBjb25zdCByID0gYXdhaXQgcmVuZGVySGVhZGxlc3ModGhpcywgdHlwZSwgc2NhbGVGYWN0b3IpO1xuICByZXR1cm4gdHlwZSA9PT0gUmVuZGVyVHlwZS5TVkcgPyB0b0Jsb2JVUkwoci5zdmcoKSwgJ2ltYWdlL3N2Zyt4bWwnKSA6IHIuY2FudmFzKCkudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbn1cblxuZnVuY3Rpb24gdG9CbG9iVVJMKGRhdGEsIG1pbWUpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgIHR5cGU6IG1pbWVcbiAgfSk7XG4gIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgQ2FudmFzIGluc3RhbmNlIGNvbnRhaW5pbmcgYSByZW5kZXJlZCB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIENhbnZhcyBpbnN0YW5jZS5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJUb0NhbnZhcyAoc2NhbGVGYWN0b3IsIG9wdCkge1xuICBjb25zdCByID0gYXdhaXQgcmVuZGVySGVhZGxlc3ModGhpcywgUmVuZGVyVHlwZS5DYW52YXMsIHNjYWxlRmFjdG9yLCBvcHQpO1xuICByZXR1cm4gci5jYW52YXMoKTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgcmVuZGVyZWQgU1ZHIHN0cmluZyBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAqIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cywgcmV0dXJuaW5nIGEgUHJvbWlzZSBpbnN0YW5jZS5cbiAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gU1ZHIHN0cmluZy5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZW5kZXJUb1NWRyAoc2NhbGVGYWN0b3IpIHtcbiAgY29uc3QgciA9IGF3YWl0IHJlbmRlckhlYWRsZXNzKHRoaXMsIFJlbmRlclR5cGUuU1ZHLCBzY2FsZUZhY3Rvcik7XG4gIHJldHVybiByLnN2ZygpO1xufVxuXG5mdW5jdGlvbiBydW50aW1lICh2aWV3LCBzcGVjLCBleHByKSB7XG4gIHJldHVybiBjb250ZXh0KHZpZXcsIHRyYW5zZm9ybXMsIGZ1bmN0aW9uQ29udGV4dCwgZXhwcikucGFyc2Uoc3BlYyk7XG59XG5cbmZ1bmN0aW9uIHNjYWxlKG5hbWUpIHtcbiAgdmFyIHNjYWxlcyA9IHRoaXMuX3J1bnRpbWUuc2NhbGVzO1xuXG4gIGlmICghaGFzT3duUHJvcGVydHkoc2NhbGVzLCBuYW1lKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgb3IgcHJvamVjdGlvbjogJyArIG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIHNjYWxlc1tuYW1lXS52YWx1ZTtcbn1cblxudmFyIFdpZHRoID0gJ3dpZHRoJyxcbiAgICBIZWlnaHQgPSAnaGVpZ2h0JyxcbiAgICBQYWRkaW5nID0gJ3BhZGRpbmcnLFxuICAgIFNraXAgPSB7XG4gIHNraXA6IHRydWVcbn07XG5mdW5jdGlvbiB2aWV3V2lkdGgodmlldywgd2lkdGgpIHtcbiAgdmFyIGEgPSB2aWV3LmF1dG9zaXplKCksXG4gICAgICBwID0gdmlldy5wYWRkaW5nKCk7XG4gIHJldHVybiB3aWR0aCAtIChhICYmIGEuY29udGFpbnMgPT09IFBhZGRpbmcgPyBwLmxlZnQgKyBwLnJpZ2h0IDogMCk7XG59XG5mdW5jdGlvbiB2aWV3SGVpZ2h0KHZpZXcsIGhlaWdodCkge1xuICB2YXIgYSA9IHZpZXcuYXV0b3NpemUoKSxcbiAgICAgIHAgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIGhlaWdodCAtIChhICYmIGEuY29udGFpbnMgPT09IFBhZGRpbmcgPyBwLnRvcCArIHAuYm90dG9tIDogMCk7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplUmVzaXplKHZpZXcpIHtcbiAgdmFyIHMgPSB2aWV3Ll9zaWduYWxzLFxuICAgICAgdyA9IHNbV2lkdGhdLFxuICAgICAgaCA9IHNbSGVpZ2h0XSxcbiAgICAgIHAgPSBzW1BhZGRpbmddO1xuXG4gIGZ1bmN0aW9uIHJlc2V0U2l6ZSgpIHtcbiAgICB2aWV3Ll9hdXRvc2l6ZSA9IHZpZXcuX3Jlc2l6ZSA9IDE7XG4gIH0gLy8gcmVzcG9uZCB0byB3aWR0aCBzaWduYWxcblxuXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoID0gdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5fd2lkdGggPSBfLnNpemU7XG4gICAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoKHZpZXcsIF8uc2l6ZSk7XG4gICAgcmVzZXRTaXplKCk7XG4gIH0sIHtcbiAgICBzaXplOiB3XG4gIH0pOyAvLyByZXNwb25kIHRvIGhlaWdodCBzaWduYWxcblxuICB2aWV3Ll9yZXNpemVIZWlnaHQgPSB2aWV3LmFkZChudWxsLCBfID0+IHtcbiAgICB2aWV3Ll9oZWlnaHQgPSBfLnNpemU7XG4gICAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQodmlldywgXy5zaXplKTtcbiAgICByZXNldFNpemUoKTtcbiAgfSwge1xuICAgIHNpemU6IGhcbiAgfSk7IC8vIHJlc3BvbmQgdG8gcGFkZGluZyBzaWduYWxcblxuICBjb25zdCByZXNpemVQYWRkaW5nID0gdmlldy5hZGQobnVsbCwgcmVzZXRTaXplLCB7XG4gICAgcGFkOiBwXG4gIH0pOyAvLyBzZXQgcmFuayB0byBydW4gaW1tZWRpYXRlbHkgYWZ0ZXIgc291cmNlIHNpZ25hbFxuXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoLnJhbmsgPSB3LnJhbmsgKyAxO1xuICB2aWV3Ll9yZXNpemVIZWlnaHQucmFuayA9IGgucmFuayArIDE7XG4gIHJlc2l6ZVBhZGRpbmcucmFuayA9IHAucmFuayArIDE7XG59XG5mdW5jdGlvbiByZXNpemVWaWV3KHZpZXdXaWR0aCwgdmlld0hlaWdodCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBhdXRvKSB7XG4gIHRoaXMucnVuQWZ0ZXIodmlldyA9PiB7XG4gICAgbGV0IHJlcnVuID0gMDsgLy8gcmVzZXQgYXV0b3NpemUgZmxhZ1xuXG4gICAgdmlldy5fYXV0b3NpemUgPSAwOyAvLyB3aWR0aCB2YWx1ZSBjaGFuZ2VkOiB1cGRhdGUgc2lnbmFsLCBza2lwIHJlc2l6ZSBvcFxuXG4gICAgaWYgKHZpZXcud2lkdGgoKSAhPT0gd2lkdGgpIHtcbiAgICAgIHJlcnVuID0gMTtcbiAgICAgIHZpZXcuc2lnbmFsKFdpZHRoLCB3aWR0aCwgU2tpcCk7IC8vIHNldCB3aWR0aCwgc2tpcCB1cGRhdGUgY2FsY1xuXG4gICAgICB2aWV3Ll9yZXNpemVXaWR0aC5za2lwKHRydWUpOyAvLyBza2lwIHdpZHRoIHJlc2l6ZSBoYW5kbGVyXG5cbiAgICB9IC8vIGhlaWdodCB2YWx1ZSBjaGFuZ2VkOiB1cGRhdGUgc2lnbmFsLCBza2lwIHJlc2l6ZSBvcFxuXG5cbiAgICBpZiAodmlldy5oZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XG4gICAgICByZXJ1biA9IDE7XG4gICAgICB2aWV3LnNpZ25hbChIZWlnaHQsIGhlaWdodCwgU2tpcCk7IC8vIHNldCBoZWlnaHQsIHNraXAgdXBkYXRlIGNhbGNcblxuICAgICAgdmlldy5fcmVzaXplSGVpZ2h0LnNraXAodHJ1ZSk7IC8vIHNraXAgaGVpZ2h0IHJlc2l6ZSBoYW5kbGVyXG5cbiAgICB9IC8vIHZpZXcgd2lkdGggY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuXG5cbiAgICBpZiAodmlldy5fdmlld1dpZHRoICE9PSB2aWV3V2lkdGgpIHtcbiAgICAgIHZpZXcuX3Jlc2l6ZSA9IDE7XG4gICAgICB2aWV3Ll92aWV3V2lkdGggPSB2aWV3V2lkdGg7XG4gICAgfSAvLyB2aWV3IGhlaWdodCBjaGFuZ2VkOiB1cGRhdGUgdmlldyBwcm9wZXJ0eSwgc2V0IHJlc2l6ZSBmbGFnXG5cblxuICAgIGlmICh2aWV3Ll92aWV3SGVpZ2h0ICE9PSB2aWV3SGVpZ2h0KSB7XG4gICAgICB2aWV3Ll9yZXNpemUgPSAxO1xuICAgICAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQ7XG4gICAgfSAvLyBvcmlnaW4gY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuXG5cbiAgICBpZiAodmlldy5fb3JpZ2luWzBdICE9PSBvcmlnaW5bMF0gfHwgdmlldy5fb3JpZ2luWzFdICE9PSBvcmlnaW5bMV0pIHtcbiAgICAgIHZpZXcuX3Jlc2l6ZSA9IDE7XG4gICAgICB2aWV3Ll9vcmlnaW4gPSBvcmlnaW47XG4gICAgfSAvLyBydW4gZGF0YWZsb3cgb24gd2lkdGgvaGVpZ2h0IHNpZ25hbCBjaGFuZ2VcblxuXG4gICAgaWYgKHJlcnVuKSB2aWV3LnJ1bignZW50ZXInKTtcbiAgICBpZiAoYXV0bykgdmlldy5ydW5BZnRlcih2ID0+IHYucmVzaXplKCkpO1xuICB9LCBmYWxzZSwgMSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZpZXcgc3RhdGUsIGNvbnNpc3Rpbmcgb2Ygc2lnbmFsIHZhbHVlcyBhbmQvb3IgZGF0YSBzZXRzLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZmxhZ3MgaW5kaWNhdGluZyB3aGljaCBzdGF0ZSB0byBleHBvcnQuXG4gKiAgIElmIHVuc3BlY2lmaWVkLCBhbGwgc2lnbmFscyBhbmQgZGF0YSBzZXRzIHdpbGwgYmUgZXhwb3J0ZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgT3BlcmF0b3IpOmJvb2xlYW59IFtvcHRpb25zLnNpZ25hbHNdIC0gT3B0aW9uYWxcbiAqICAgcHJlZGljYXRlIGZ1bmN0aW9uIGZvciB0ZXN0aW5nIGlmIGEgc2lnbmFsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAqICAgZXhwb3J0ZWQgc3RhdGUuIElmIHVuc3BlY2lmaWVkLCBhbGwgc2lnbmFscyB3aWxsIGJlIGluY2x1ZGVkLCBleGNlcHQgZm9yXG4gKiAgIHRob3NlIG5hbWVkICdwYXJlbnQnIG9yIHRob3NlIHdoaWNoIHJlZmVyIHRvIGEgVHJhbnNmb3JtIHZhbHVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCk6Ym9vbGVhbn0gW29wdGlvbnMuZGF0YV0gLSBPcHRpb25hbFxuICogICBwcmVkaWNhdGUgZnVuY3Rpb24gZm9yIHRlc3RpbmcgaWYgYSBkYXRhIHNldCdzIGlucHV0IHNob3VsZCBiZSBpbmNsdWRlZFxuICogICBpbiB0aGUgZXhwb3J0ZWQgc3RhdGUuIElmIHVuc3BlY2lmaWVkLCBhbGwgZGF0YSBzZXRzIHRoYXQgaGF2ZSBiZWVuXG4gKiAgIGV4cGxpY2l0bHkgbW9kaWZpZWQgd2lsbCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVjdXJzZT10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZXhwb3J0ZWRcbiAqICAgc3RhdGUgc2hvdWxkIHJlY3Vyc2l2ZWx5IGluY2x1ZGUgc3RhdGUgZnJvbSBncm91cCBtYXJrIHN1Yi1jb250ZXh0cy5cbiAqIEByZXR1cm4ge29iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXhwb3J0ZWQgc3RhdGUgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX3J1bnRpbWUuZ2V0U3RhdGUob3B0aW9ucyB8fCB7XG4gICAgZGF0YTogZGF0YVRlc3QsXG4gICAgc2lnbmFsczogc2lnbmFsVGVzdCxcbiAgICByZWN1cnNlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkYXRhVGVzdChuYW1lLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLm1vZGlmaWVkICYmIGlzQXJyYXkoZGF0YS5pbnB1dC52YWx1ZSkgJiYgbmFtZS5pbmRleE9mKCdfOnZlZ2E6XycpO1xufVxuXG5mdW5jdGlvbiBzaWduYWxUZXN0KG5hbWUsIG9wKSB7XG4gIHJldHVybiAhKG5hbWUgPT09ICdwYXJlbnQnIHx8IG9wIGluc3RhbmNlb2YgdHJhbnNmb3Jtcy5wcm94eSk7XG59XG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSBhbmQgdXBkYXRlcyB0aGUgdmlldyBieSBpbnZva2luZyBydW4uXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIHN0YXRlIG9iamVjdCBjb250YWluaW5nIHNpZ25hbCBhbmQvb3JcbiAqICAgZGF0YSBzZXQgdmFsdWVzLCBmb2xsb3dpbmcgdGhlIGZvcm1hdCB1c2VkIGJ5IHRoZSBnZXRTdGF0ZSBtZXRob2QuXG4gKiBAcmV0dXJuIHtWaWV3fSAtIFRoaXMgdmlldyBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gIHRoaXMucnVuQXN5bmMobnVsbCwgdiA9PiB7XG4gICAgdi5fdHJpZ2dlciA9IGZhbHNlO1xuXG4gICAgdi5fcnVudGltZS5zZXRTdGF0ZShzdGF0ZSk7XG4gIH0sIHYgPT4ge1xuICAgIHYuX3RyaWdnZXIgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHRpbWVyIChjYWxsYmFjaywgZGVsYXkpIHtcbiAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgY2FsbGJhY2soe1xuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgZWxhcHNlZDogZWxhcHNlZFxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fdGltZXJzLnB1c2goaW50ZXJ2YWwodGljaywgZGVsYXkpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvb2x0aXAgKGhhbmRsZXIsIGV2ZW50LCBpdGVtLCB2YWx1ZSkge1xuICBjb25zdCBlbCA9IGhhbmRsZXIuZWxlbWVudCgpO1xuICBpZiAoZWwpIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBmb3JtYXRUb29sdGlwKHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFRvb2x0aXAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGlzQXJyYXkodmFsdWUpID8gZm9ybWF0QXJyYXkodmFsdWUpIDogaXNPYmplY3QodmFsdWUpICYmICFpc0RhdGUodmFsdWUpID8gZm9ybWF0T2JqZWN0KHZhbHVlKSA6IHZhbHVlICsgJyc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGtleSA9PiB7XG4gICAgY29uc3QgdiA9IG9ialtrZXldO1xuICAgIHJldHVybiBrZXkgKyAnOiAnICsgKGlzQXJyYXkodikgPyBmb3JtYXRBcnJheSh2KSA6IGZvcm1hdFZhbHVlKHYpKTtcbiAgfSkuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyB2YWx1ZS5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oJywgJykgKyAnXSc7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/ICdbXFx1MjAyNl0nIDogaXNPYmplY3QodmFsdWUpICYmICFpc0RhdGUodmFsdWUpID8gJ3tcXHUyMDI2fScgOiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVmlldyBpbnN0YW5jZSBmcm9tIGEgVmVnYSBkYXRhZmxvdyBydW50aW1lIHNwZWNpZmljYXRpb24uXG4gKiBUaGUgZ2VuZXJhdGVkIFZpZXcgd2lsbCBub3QgaW1tZWRpYXRlbHkgYmUgcmVhZHkgZm9yIGRpc3BsYXkuIENhbGxlcnNcbiAqIHNob3VsZCBhbHNvIGludm9rZSB0aGUgaW5pdGlhbGl6ZSBtZXRob2QgKGUuZy4sIHRvIHNldCB0aGUgcGFyZW50XG4gKiBET00gZWxlbWVudCBpbiBicm93c2VyLWJhc2VkIGRlcGxveW1lbnQpIGFuZCB0aGVuIGludm9rZSB0aGUgcnVuXG4gKiBtZXRob2QgdG8gZXZhbHVhdGUgdGhlIGRhdGFmbG93IGdyYXBoLiBSZW5kZXJpbmcgd2lsbCBhdXRvbWF0aWNhbGx5XG4gKiBiZSBwZXJmb3JtZWQgdXBvbiBkYXRhZmxvdyBydW5zLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gc3BlYyAtIFRoZSBWZWdhIGRhdGFmbG93IHJ1bnRpbWUgc3BlY2lmaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBWaWV3KHNwZWMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdmlldyA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBEYXRhZmxvdy5jYWxsKHZpZXcpO1xuICBpZiAob3B0aW9ucy5sb2FkZXIpIHZpZXcubG9hZGVyKG9wdGlvbnMubG9hZGVyKTtcbiAgaWYgKG9wdGlvbnMubG9nZ2VyKSB2aWV3LmxvZ2dlcihvcHRpb25zLmxvZ2dlcik7XG4gIGlmIChvcHRpb25zLmxvZ0xldmVsICE9IG51bGwpIHZpZXcubG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCk7XG5cbiAgaWYgKG9wdGlvbnMubG9jYWxlIHx8IHNwZWMubG9jYWxlKSB7XG4gICAgY29uc3QgbG9jID0gZXh0ZW5kKHt9LCBzcGVjLmxvY2FsZSwgb3B0aW9ucy5sb2NhbGUpO1xuICAgIHZpZXcubG9jYWxlKGxvY2FsZShsb2MubnVtYmVyLCBsb2MudGltZSkpO1xuICB9XG5cbiAgdmlldy5fZWwgPSBudWxsO1xuICB2aWV3Ll9lbEJpbmQgPSBudWxsO1xuICB2aWV3Ll9yZW5kZXJUeXBlID0gb3B0aW9ucy5yZW5kZXJlciB8fCBSZW5kZXJUeXBlLkNhbnZhcztcbiAgdmlldy5fc2NlbmVncmFwaCA9IG5ldyBTY2VuZWdyYXBoKCk7XG4gIGNvbnN0IHJvb3QgPSB2aWV3Ll9zY2VuZWdyYXBoLnJvb3Q7IC8vIGluaXRpYWxpemUgcmVuZGVyZXIsIGhhbmRsZXIgYW5kIGV2ZW50IG1hbmFnZW1lbnRcblxuICB2aWV3Ll9yZW5kZXJlciA9IG51bGw7XG4gIHZpZXcuX3Rvb2x0aXAgPSBvcHRpb25zLnRvb2x0aXAgfHwgZGVmYXVsdFRvb2x0aXAsIHZpZXcuX3JlZHJhdyA9IHRydWU7XG4gIHZpZXcuX2hhbmRsZXIgPSBuZXcgQ2FudmFzSGFuZGxlcigpLnNjZW5lKHJvb3QpO1xuICB2aWV3Ll9nbG9iYWxDdXJzb3IgPSBmYWxzZTtcbiAgdmlldy5fcHJldmVudERlZmF1bHQgPSBmYWxzZTtcbiAgdmlldy5fdGltZXJzID0gW107XG4gIHZpZXcuX2V2ZW50TGlzdGVuZXJzID0gW107XG4gIHZpZXcuX3Jlc2l6ZUxpc3RlbmVycyA9IFtdOyAvLyBpbml0aWFsaXplIGV2ZW50IGNvbmZpZ3VyYXRpb25cblxuICB2aWV3Ll9ldmVudENvbmZpZyA9IGluaXRpYWxpemVFdmVudENvbmZpZyhzcGVjLmV2ZW50Q29uZmlnKTtcbiAgdmlldy5nbG9iYWxDdXJzb3Iodmlldy5fZXZlbnRDb25maWcuZ2xvYmFsQ3Vyc29yKTsgLy8gaW5pdGlhbGl6ZSBkYXRhZmxvdyBncmFwaFxuXG4gIGNvbnN0IGN0eCA9IHJ1bnRpbWUodmlldywgc3BlYywgb3B0aW9ucy5leHByKTtcbiAgdmlldy5fcnVudGltZSA9IGN0eDtcbiAgdmlldy5fc2lnbmFscyA9IGN0eC5zaWduYWxzO1xuICB2aWV3Ll9iaW5kID0gKHNwZWMuYmluZGluZ3MgfHwgW10pLm1hcChfID0+ICh7XG4gICAgc3RhdGU6IG51bGwsXG4gICAgcGFyYW06IGV4dGVuZCh7fSwgXylcbiAgfSkpOyAvLyBpbml0aWFsaXplIHNjZW5lZ3JhcGhcblxuICBpZiAoY3R4LnJvb3QpIGN0eC5yb290LnNldChyb290KTtcbiAgcm9vdC5zb3VyY2UgPSBjdHguZGF0YS5yb290LmlucHV0O1xuICB2aWV3LnB1bHNlKGN0eC5kYXRhLnJvb3QuaW5wdXQsIHZpZXcuY2hhbmdlc2V0KCkuaW5zZXJ0KHJvb3QuaXRlbXMpKTsgLy8gaW5pdGlhbGl6ZSB2aWV3IHNpemVcblxuICB2aWV3Ll93aWR0aCA9IHZpZXcud2lkdGgoKTtcbiAgdmlldy5faGVpZ2h0ID0gdmlldy5oZWlnaHQoKTtcbiAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoKHZpZXcsIHZpZXcuX3dpZHRoKTtcbiAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQodmlldywgdmlldy5faGVpZ2h0KTtcbiAgdmlldy5fb3JpZ2luID0gWzAsIDBdO1xuICB2aWV3Ll9yZXNpemUgPSAwO1xuICB2aWV3Ll9hdXRvc2l6ZSA9IDE7XG4gIGluaXRpYWxpemVSZXNpemUodmlldyk7IC8vIGluaXRpYWxpemUgYmFja2dyb3VuZCBjb2xvclxuXG4gIGJhY2tncm91bmQodmlldyk7IC8vIGluaXRpYWxpemUgY3Vyc29yXG5cbiAgY3Vyc29yKHZpZXcpOyAvLyBpbml0aWFsaXplIHZpZXcgZGVzY3JpcHRpb25cblxuICB2aWV3LmRlc2NyaXB0aW9uKHNwZWMuZGVzY3JpcHRpb24pOyAvLyBpbml0aWFsaXplIGhvdmVyIHByb2Vzc2luZywgaWYgcmVxdWVzdGVkXG5cbiAgaWYgKG9wdGlvbnMuaG92ZXIpIHZpZXcuaG92ZXIoKTsgLy8gaW5pdGlhbGl6ZSBET00gY29udGFpbmVyKHMpIGFuZCByZW5kZXJlclxuXG4gIGlmIChvcHRpb25zLmNvbnRhaW5lcikgdmlldy5pbml0aWFsaXplKG9wdGlvbnMuY29udGFpbmVyLCBvcHRpb25zLmJpbmQpO1xufVxuXG5mdW5jdGlvbiBsb29rdXBTaWduYWwodmlldywgbmFtZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodmlldy5fc2lnbmFscywgbmFtZSkgPyB2aWV3Ll9zaWduYWxzW25hbWVdIDogZXJyb3IoJ1VucmVjb2duaXplZCBzaWduYWwgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn1cblxuZnVuY3Rpb24gZmluZE9wZXJhdG9ySGFuZGxlcihvcCwgaGFuZGxlcikge1xuICBjb25zdCBoID0gKG9wLl90YXJnZXRzIHx8IFtdKS5maWx0ZXIob3AgPT4gb3AuX3VwZGF0ZSAmJiBvcC5fdXBkYXRlLmhhbmRsZXIgPT09IGhhbmRsZXIpO1xuICByZXR1cm4gaC5sZW5ndGggPyBoWzBdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gYWRkT3BlcmF0b3JMaXN0ZW5lcih2aWV3LCBuYW1lLCBvcCwgaGFuZGxlcikge1xuICBsZXQgaCA9IGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpO1xuXG4gIGlmICghaCkge1xuICAgIGggPSB0cmFwKHZpZXcsICgpID0+IGhhbmRsZXIobmFtZSwgb3AudmFsdWUpKTtcbiAgICBoLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZpZXcub24ob3AsIG51bGwsIGgpO1xuICB9XG5cbiAgcmV0dXJuIHZpZXc7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9wZXJhdG9yTGlzdGVuZXIodmlldywgb3AsIGhhbmRsZXIpIHtcbiAgY29uc3QgaCA9IGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpO1xuICBpZiAoaCkgb3AuX3RhcmdldHMucmVtb3ZlKGgpO1xuICByZXR1cm4gdmlldztcbn1cblxuaW5oZXJpdHMoVmlldywgRGF0YWZsb3csIHtcbiAgLy8gLS0gREFUQUZMT1cgLyBSRU5ERVJJTkcgLS0tLVxuICBhc3luYyBldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICAgIC8vIGV2YWx1YXRlIGRhdGFmbG93IGFuZCBwcmVydW5cbiAgICBhd2FpdCBEYXRhZmxvdy5wcm90b3R5cGUuZXZhbHVhdGUuY2FsbCh0aGlzLCBlbmNvZGUsIHByZXJ1bik7IC8vIHJlbmRlciBhcyBuZWVkZWRcblxuICAgIGlmICh0aGlzLl9yZWRyYXcgfHwgdGhpcy5fcmVzaXplKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemUgPSAwO1xuICAgICAgICAgICAgcmVzaXplUmVuZGVyZXIodGhpcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgdGhpcy5fcmVuZGVyZXIucmVuZGVyQXN5bmModGhpcy5fc2NlbmVncmFwaC5yb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlZHJhdyA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0gLy8gZXZhbHVhdGUgcG9zdHJ1blxuXG5cbiAgICBpZiAocG9zdHJ1bikgYXN5bmNDYWxsYmFjayh0aGlzLCBwb3N0cnVuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBkaXJ0eShpdGVtKSB7XG4gICAgdGhpcy5fcmVkcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW5kZXJlciAmJiB0aGlzLl9yZW5kZXJlci5kaXJ0eShpdGVtKTtcbiAgfSxcblxuICAvLyAtLSBHRVQgLyBTRVQgLS0tLVxuICBkZXNjcmlwdGlvbih0ZXh0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSB0ZXh0ICE9IG51bGwgPyB0ZXh0ICsgJycgOiBudWxsO1xuICAgICAgaWYgKGRlc2MgIT09IHRoaXMuX2Rlc2MpIGFyaWFMYWJlbCh0aGlzLl9lbCwgdGhpcy5fZGVzYyA9IGRlc2MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rlc2M7XG4gIH0sXG5cbiAgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcblxuICBzY2VuZWdyYXBoKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2VuZWdyYXBoO1xuICB9LFxuXG4gIG9yaWdpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JpZ2luLnNsaWNlKCk7XG4gIH0sXG5cbiAgc2lnbmFsKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3AgPSBsb29rdXBTaWduYWwodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBvcC52YWx1ZSA6IHRoaXMudXBkYXRlKG9wLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH0sXG5cbiAgd2lkdGgoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ3dpZHRoJywgXykgOiB0aGlzLnNpZ25hbCgnd2lkdGgnKTtcbiAgfSxcblxuICBoZWlnaHQoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ2hlaWdodCcsIF8pIDogdGhpcy5zaWduYWwoJ2hlaWdodCcpO1xuICB9LFxuXG4gIHBhZGRpbmcoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ3BhZGRpbmcnLCBwYWRkaW5nKF8pKSA6IHBhZGRpbmcodGhpcy5zaWduYWwoJ3BhZGRpbmcnKSk7XG4gIH0sXG5cbiAgYXV0b3NpemUoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ2F1dG9zaXplJywgXykgOiB0aGlzLnNpZ25hbCgnYXV0b3NpemUnKTtcbiAgfSxcblxuICBiYWNrZ3JvdW5kKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdiYWNrZ3JvdW5kJywgXykgOiB0aGlzLnNpZ25hbCgnYmFja2dyb3VuZCcpO1xuICB9LFxuXG4gIHJlbmRlcmVyKHR5cGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZW5kZXJUeXBlO1xuICAgIGlmICghcmVuZGVyTW9kdWxlKHR5cGUpKSBlcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcblxuICAgIGlmICh0eXBlICE9PSB0aGlzLl9yZW5kZXJUeXBlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJUeXBlID0gdHlwZTtcblxuICAgICAgdGhpcy5fcmVzZXRSZW5kZXJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHRvb2x0aXAoaGFuZGxlcikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3Rvb2x0aXA7XG5cbiAgICBpZiAoaGFuZGxlciAhPT0gdGhpcy5fdG9vbHRpcCkge1xuICAgICAgdGhpcy5fdG9vbHRpcCA9IGhhbmRsZXI7XG5cbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBsb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbG9hZGVyO1xuXG4gICAgaWYgKGxvYWRlciAhPT0gdGhpcy5fbG9hZGVyKSB7XG4gICAgICBEYXRhZmxvdy5wcm90b3R5cGUubG9hZGVyLmNhbGwodGhpcywgbG9hZGVyKTtcblxuICAgICAgdGhpcy5fcmVzZXRSZW5kZXJlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlc2l6ZSgpIHtcbiAgICAvLyBzZXQgZmxhZyB0byBwZXJmb3JtIGF1dG9zaXplXG4gICAgdGhpcy5fYXV0b3NpemUgPSAxOyAvLyB0b3VjaCBhdXRvc2l6ZSBzaWduYWwgdG8gZW5zdXJlIHRvcC1sZXZlbCBWaWV3TGF5b3V0IHJ1bnNcblxuICAgIHJldHVybiB0aGlzLnRvdWNoKGxvb2t1cFNpZ25hbCh0aGlzLCAnYXV0b3NpemUnKSk7XG4gIH0sXG5cbiAgX3Jlc2V0UmVuZGVyZXIoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgICB0aGlzLmluaXRpYWxpemUodGhpcy5fZWwsIHRoaXMuX2VsQmluZCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIC0tIFNJWklORyAtLS0tXG4gIF9yZXNpemVWaWV3OiByZXNpemVWaWV3LFxuXG4gIC8vIC0tIEVWRU5UIEhBTkRMSU5HIC0tLS1cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbGV0IGNhbGxiYWNrID0gaGFuZGxlcjtcblxuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFwID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHdyYXAgY2FsbGJhY2sgaW4gZXJyb3IgaGFuZGxlclxuICAgICAgY2FsbGJhY2sgPSB0cmFwKHRoaXMsIGhhbmRsZXIpO1xuICAgICAgY2FsbGJhY2sucmF3ID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVyLm9uKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlcnModHlwZSksXG4gICAgICAgIGkgPSBoYW5kbGVycy5sZW5ndGgsXG4gICAgICAgIGgsXG4gICAgICAgIHQ7IC8vIHNlYXJjaCByZWdpc3RlcmVkIGhhbmRsZXJzLCByZW1vdmUgaWYgbWF0Y2ggZm91bmRcblxuXG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICB0ID0gaGFuZGxlcnNbaV0udHlwZTtcbiAgICAgIGggPSBoYW5kbGVyc1tpXS5oYW5kbGVyO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdCAmJiAoaGFuZGxlciA9PT0gaCB8fCBoYW5kbGVyID09PSBoLnJhdykpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlci5vZmYodCwgaCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkUmVzaXplTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9yZXNpemVMaXN0ZW5lcnM7XG5cbiAgICBpZiAobC5pbmRleE9mKGhhbmRsZXIpIDwgMCkge1xuICAgICAgLy8gYWRkIGhhbmRsZXIgaWYgaXQgaXNuJ3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAvLyBub3RlOiBlcnJvciB0cmFwcGluZyBoYW5kbGVkIGVsc2V3aGVyZSwgc29cbiAgICAgIC8vIG5vIG5lZWQgdG8gd3JhcCBoYW5kbGVycyBoZXJlXG4gICAgICBsLnB1c2goaGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVtb3ZlUmVzaXplTGlzdGVuZXIoaGFuZGxlcikge1xuICAgIHZhciBsID0gdGhpcy5fcmVzaXplTGlzdGVuZXJzLFxuICAgICAgICBpID0gbC5pbmRleE9mKGhhbmRsZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgbC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBhZGRPcGVyYXRvckxpc3RlbmVyKHRoaXMsIG5hbWUsIGxvb2t1cFNpZ25hbCh0aGlzLCBuYW1lKSwgaGFuZGxlcik7XG4gIH0sXG5cbiAgcmVtb3ZlU2lnbmFsTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiByZW1vdmVPcGVyYXRvckxpc3RlbmVyKHRoaXMsIGxvb2t1cFNpZ25hbCh0aGlzLCBuYW1lKSwgaGFuZGxlcik7XG4gIH0sXG5cbiAgYWRkRGF0YUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gYWRkT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBuYW1lLCBkYXRhcmVmKHRoaXMsIG5hbWUpLnZhbHVlcywgaGFuZGxlcik7XG4gIH0sXG5cbiAgcmVtb3ZlRGF0YUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBkYXRhcmVmKHRoaXMsIG5hbWUpLnZhbHVlcywgaGFuZGxlcik7XG4gIH0sXG5cbiAgZ2xvYmFsQ3Vyc29yKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX2dsb2JhbEN1cnNvciAhPT0gISFfKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBzZXRDdXJzb3IodGhpcywgbnVsbCk7IC8vIGNsZWFyIHByZXZpb3VzIGN1cnNvclxuXG4gICAgICAgIHRoaXMuX2dsb2JhbEN1cnNvciA9ICEhXztcbiAgICAgICAgaWYgKHByZXYpIHNldEN1cnNvcih0aGlzLCBwcmV2KTsgLy8gc3dhcCBjdXJzb3JcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxDdXJzb3I7XG4gICAgfVxuICB9LFxuXG4gIHByZXZlbnREZWZhdWx0KF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcHJldmVudERlZmF1bHQgPSBfO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2ZW50RGVmYXVsdDtcbiAgICB9XG4gIH0sXG5cbiAgdGltZXIsXG4gIGV2ZW50cyxcbiAgZmluYWxpemUsXG4gIGhvdmVyLFxuICAvLyAtLSBEQVRBIC0tLS1cbiAgZGF0YSxcbiAgY2hhbmdlLFxuICBpbnNlcnQsXG4gIHJlbW92ZSxcbiAgLy8gLS0gU0NBTEVTIC0tXG4gIHNjYWxlLFxuICAvLyAtLSBJTklUSUFMSVpBVElPTiAtLS0tXG4gIGluaXRpYWxpemUsXG4gIC8vIC0tIEhFQURMRVNTIFJFTkRFUklORyAtLS0tXG4gIHRvSW1hZ2VVUkw6IHJlbmRlclRvSW1hZ2VVUkwsXG4gIHRvQ2FudmFzOiByZW5kZXJUb0NhbnZhcyxcbiAgdG9TVkc6IHJlbmRlclRvU1ZHLFxuICAvLyAtLSBTQVZFIC8gUkVTVE9SRSBTVEFURSAtLS0tXG4gIGdldFN0YXRlLFxuICBzZXRTdGF0ZVxufSk7XG5cbmV4cG9ydCB7IFZpZXcgfTtcbiIsImltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgRGVsYXVuYXkgfSBmcm9tICdkMy1kZWxhdW5heSc7XG5cbmZ1bmN0aW9uIFZvcm9ub2kocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Wb3Jvbm9pLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Zvcm9ub2knLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFtbLTFlNSwgLTFlNV0sIFsxZTUsIDFlNV1dLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BhdGgnXG4gIH1dXG59O1xuY29uc3QgZGVmYXVsdEV4dGVudCA9IFstMWU1LCAtMWU1LCAxZTUsIDFlNV07XG5pbmhlcml0cyhWb3Jvbm9pLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgYXMgPSBfLmFzIHx8ICdwYXRoJyxcbiAgICAgICAgICBkYXRhID0gcHVsc2Uuc291cmNlOyAvLyBub3RoaW5nIHRvIGRvIGlmIG5vIGRhdGFcblxuICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGgpIHJldHVybiBwdWxzZTsgLy8gY29uZmlndXJlIGFuZCBjb25zdHJ1Y3Qgdm9yb25vaSBkaWFncmFtXG5cbiAgICBsZXQgcyA9IF8uc2l6ZTtcbiAgICBzID0gcyA/IFswLCAwLCBzWzBdLCBzWzFdXSA6IChzID0gXy5leHRlbnQpID8gW3NbMF1bMF0sIHNbMF1bMV0sIHNbMV1bMF0sIHNbMV1bMV1dIDogZGVmYXVsdEV4dGVudDtcbiAgICBjb25zdCB2b3Jvbm9pID0gdGhpcy52YWx1ZSA9IERlbGF1bmF5LmZyb20oZGF0YSwgXy54LCBfLnkpLnZvcm9ub2kocyk7IC8vIG1hcCBwb2x5Z29ucyB0byBwYXRoc1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgcG9seWdvbiA9IHZvcm9ub2kuY2VsbFBvbHlnb24oaSk7XG4gICAgICBkYXRhW2ldW2FzXSA9IHBvbHlnb24gPyB0b1BhdGhTdHJpbmcocG9seWdvbikgOiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcyhhcyk7XG4gIH1cblxufSk7IC8vIHN1cHByZXNzIGR1cGxpY2F0ZWQgZW5kIHBvaW50IHZlcnRpY2VzXG5cbmZ1bmN0aW9uIHRvUGF0aFN0cmluZyhwKSB7XG4gIGNvbnN0IHggPSBwWzBdWzBdLFxuICAgICAgICB5ID0gcFswXVsxXTtcbiAgbGV0IG4gPSBwLmxlbmd0aCAtIDE7XG5cbiAgZm9yICg7IHBbbl1bMF0gPT09IHggJiYgcFtuXVsxXSA9PT0geTsgLS1uKTtcblxuICByZXR1cm4gJ00nICsgcC5zbGljZSgwLCBuICsgMSkuam9pbignTCcpICsgJ1onO1xufVxuXG5leHBvcnQgeyBWb3Jvbm9pIGFzIHZvcm9ub2kgfTtcbiIsImltcG9ydCB7IGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGVycm9yLCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgZXh0ZW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHNjYWxlIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyByYW5kb20gfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDEzLCBKYXNvbiBEYXZpZXMuXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICogVGhlIG5hbWUgSmFzb24gRGF2aWVzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkFTT04gREFWSUVTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG5JTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG5MSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcblBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0Vcbk9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbkFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbi8vIFdvcmQgY2xvdWQgbGF5b3V0IGJ5IEphc29uIERhdmllcywgaHR0cHM6Ly93d3cuamFzb25kYXZpZXMuY29tL3dvcmRjbG91ZC9cbi8vIEFsZ29yaXRobSBkdWUgdG8gSm9uYXRoYW4gRmVpbmJlcmcsIGh0dHA6Ly9zdGF0aWMubXJmZWluYmVyZy5jb20vYnZfY2gwMy5wZGZcblxudmFyIGNsb3VkUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXG4gICAgY3cgPSAxIDw8IDExID4+IDUsXG4gICAgY2ggPSAxIDw8IDExO1xuZnVuY3Rpb24gY2xvdWQgKCkge1xuICB2YXIgc2l6ZSA9IFsyNTYsIDI1Nl0sXG4gICAgICB0ZXh0LFxuICAgICAgZm9udCxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodCxcbiAgICAgIHJvdGF0ZSxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBzcGlyYWwgPSBhcmNoaW1lZGVhblNwaXJhbCxcbiAgICAgIHdvcmRzID0gW10sXG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcbiAgICAgIGNsb3VkID0ge307XG5cbiAgY2xvdWQubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250ZXh0QW5kUmF0aW8gPSBnZXRDb250ZXh0KGNhbnZhcygpKSxcbiAgICAgICAgYm9hcmQgPSB6ZXJvQXJyYXkoKHNpemVbMF0gPj4gNSkgKiBzaXplWzFdKSxcbiAgICAgICAgYm91bmRzID0gbnVsbCxcbiAgICAgICAgbiA9IHdvcmRzLmxlbmd0aCxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICB0YWdzID0gW10sXG4gICAgICAgIGRhdGEgPSB3b3Jkcy5tYXAoZCA9PiAoe1xuICAgICAgdGV4dDogdGV4dChkKSxcbiAgICAgIGZvbnQ6IGZvbnQoZCksXG4gICAgICBzdHlsZTogZm9udFN0eWxlKGQpLFxuICAgICAgd2VpZ2h0OiBmb250V2VpZ2h0KGQpLFxuICAgICAgcm90YXRlOiByb3RhdGUoZCksXG4gICAgICBzaXplOiB+fihmb250U2l6ZShkKSArIDFlLTE0KSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcoZCksXG4gICAgICB4b2ZmOiAwLFxuICAgICAgeW9mZjogMCxcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4MDogMCxcbiAgICAgIHkwOiAwLFxuICAgICAgaGFzVGV4dDogZmFsc2UsXG4gICAgICBzcHJpdGU6IG51bGwsXG4gICAgICBkYXR1bTogZFxuICAgIH0pKS5zb3J0KChhLCBiKSA9PiBiLnNpemUgLSBhLnNpemUpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHZhciBkID0gZGF0YVtpXTtcbiAgICAgIGQueCA9IHNpemVbMF0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGQueSA9IHNpemVbMV0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGNsb3VkU3ByaXRlKGNvbnRleHRBbmRSYXRpbywgZCwgZGF0YSwgaSk7XG5cbiAgICAgIGlmIChkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIGQsIGJvdW5kcykpIHtcbiAgICAgICAgdGFncy5wdXNoKGQpO1xuICAgICAgICBpZiAoYm91bmRzKSBjbG91ZEJvdW5kcyhib3VuZHMsIGQpO2Vsc2UgYm91bmRzID0gW3tcbiAgICAgICAgICB4OiBkLnggKyBkLngwLFxuICAgICAgICAgIHk6IGQueSArIGQueTBcbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IGQueCArIGQueDEsXG4gICAgICAgICAgeTogZC55ICsgZC55MVxuICAgICAgICB9XTsgLy8gVGVtcG9yYXJ5IGhhY2tcblxuICAgICAgICBkLnggLT0gc2l6ZVswXSA+PiAxO1xuICAgICAgICBkLnkgLT0gc2l6ZVsxXSA+PiAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzKSB7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDE7XG4gICAgdmFyIHJhdGlvID0gTWF0aC5zcXJ0KGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmxlbmd0aCA+PiAyKTtcbiAgICBjYW52YXMud2lkdGggPSAoY3cgPDwgNSkgLyByYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2ggLyByYXRpbztcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICByYXRpbzogcmF0aW9cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2UoYm9hcmQsIHRhZywgYm91bmRzKSB7XG4gICAgdmFyIHN0YXJ0WCA9IHRhZy54LFxuICAgICAgICBzdGFydFkgPSB0YWcueSxcbiAgICAgICAgbWF4RGVsdGEgPSBNYXRoLnNxcnQoc2l6ZVswXSAqIHNpemVbMF0gKyBzaXplWzFdICogc2l6ZVsxXSksXG4gICAgICAgIHMgPSBzcGlyYWwoc2l6ZSksXG4gICAgICAgIGR0ID0gcmFuZG9tKCkgPCAuNSA/IDEgOiAtMSxcbiAgICAgICAgdCA9IC1kdCxcbiAgICAgICAgZHhkeSxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGR4ZHkgPSBzKHQgKz0gZHQpKSB7XG4gICAgICBkeCA9IH5+ZHhkeVswXTtcbiAgICAgIGR5ID0gfn5keGR5WzFdO1xuICAgICAgaWYgKE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhEZWx0YSkgYnJlYWs7XG4gICAgICB0YWcueCA9IHN0YXJ0WCArIGR4O1xuICAgICAgdGFnLnkgPSBzdGFydFkgKyBkeTtcbiAgICAgIGlmICh0YWcueCArIHRhZy54MCA8IDAgfHwgdGFnLnkgKyB0YWcueTAgPCAwIHx8IHRhZy54ICsgdGFnLngxID4gc2l6ZVswXSB8fCB0YWcueSArIHRhZy55MSA+IHNpemVbMV0pIGNvbnRpbnVlOyAvLyBUT0RPIG9ubHkgY2hlY2sgZm9yIGNvbGxpc2lvbnMgd2l0aGluIGN1cnJlbnQgYm91bmRzLlxuXG4gICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XG4gICAgICAgIGlmICghYm91bmRzIHx8IGNvbGxpZGVSZWN0cyh0YWcsIGJvdW5kcykpIHtcbiAgICAgICAgICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICAgICAgICBzdyA9IHNpemVbMF0gPj4gNSxcbiAgICAgICAgICAgICAgbHggPSB0YWcueCAtICh3IDw8IDQpLFxuICAgICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgICAgICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgICAgICAgICAgaCA9IHRhZy55MSAtIHRhZy55MCxcbiAgICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgICAgICAgICAgbGFzdDtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgICAgICAgICBsYXN0ID0gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICAgICAgICAgIGJvYXJkW3ggKyBpXSB8PSBsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4ICs9IHN3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhZy5zcHJpdGUgPSBudWxsO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY2xvdWQud29yZHMgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB3b3JkcyA9IF87XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNpemUgPSBbK19bMF0sICtfWzFdXTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnRTdHlsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvbnRTdHlsZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250U3R5bGU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLmZvbnRXZWlnaHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250V2VpZ2h0ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvbnRXZWlnaHQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJvdGF0ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGU7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0ZXh0ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9O1xuXG4gIGNsb3VkLnNwaXJhbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNwaXJhbCA9IHNwaXJhbHNbX10gfHwgXztcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNwaXJhbDtcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQuZm9udFNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250U2l6ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQucGFkZGluZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmcgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZztcbiAgICB9XG4gIH07XG5cbiAgY2xvdWQucmFuZG9tID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmFuZG9tID0gXztcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmRvbTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGNsb3VkO1xufSAvLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuXG5mdW5jdGlvbiBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGRpKSB7XG4gIGlmIChkLnNwcml0ZSkgcmV0dXJuO1xuICB2YXIgYyA9IGNvbnRleHRBbmRSYXRpby5jb250ZXh0LFxuICAgICAgcmF0aW8gPSBjb250ZXh0QW5kUmF0aW8ucmF0aW87XG4gIGMuY2xlYXJSZWN0KDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKTtcbiAgdmFyIHggPSAwLFxuICAgICAgeSA9IDAsXG4gICAgICBtYXhoID0gMCxcbiAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHcsXG4gICAgICB3MzIsXG4gICAgICBoLFxuICAgICAgaSxcbiAgICAgIGo7XG4gIC0tZGk7XG5cbiAgd2hpbGUgKCsrZGkgPCBuKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuZm9udCA9IGQuc3R5bGUgKyAnICcgKyBkLndlaWdodCArICcgJyArIH5+KChkLnNpemUgKyAxKSAvIHJhdGlvKSArICdweCAnICsgZC5mb250O1xuICAgIHcgPSBjLm1lYXN1cmVUZXh0KGQudGV4dCArICdtJykud2lkdGggKiByYXRpbztcbiAgICBoID0gZC5zaXplIDw8IDE7XG5cbiAgICBpZiAoZC5yb3RhdGUpIHtcbiAgICAgIHZhciBzciA9IE1hdGguc2luKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgICBjciA9IE1hdGguY29zKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgICB3Y3IgPSB3ICogY3IsXG4gICAgICAgICAgd3NyID0gdyAqIHNyLFxuICAgICAgICAgIGhjciA9IGggKiBjcixcbiAgICAgICAgICBoc3IgPSBoICogc3I7XG4gICAgICB3ID0gTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSkgKyAweDFmID4+IDUgPDwgNTtcbiAgICAgIGggPSB+fk1hdGgubWF4KE1hdGguYWJzKHdzciArIGhjciksIE1hdGguYWJzKHdzciAtIGhjcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gdyArIDB4MWYgPj4gNSA8PCA1O1xuICAgIH1cblxuICAgIGlmIChoID4gbWF4aCkgbWF4aCA9IGg7XG5cbiAgICBpZiAoeCArIHcgPj0gY3cgPDwgNSkge1xuICAgICAgeCA9IDA7XG4gICAgICB5ICs9IG1heGg7XG4gICAgICBtYXhoID0gMDtcbiAgICB9XG5cbiAgICBpZiAoeSArIGggPj0gY2gpIGJyZWFrO1xuICAgIGMudHJhbnNsYXRlKCh4ICsgKHcgPj4gMSkpIC8gcmF0aW8sICh5ICsgKGggPj4gMSkpIC8gcmF0aW8pO1xuICAgIGlmIChkLnJvdGF0ZSkgYy5yb3RhdGUoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpO1xuICAgIGMuZmlsbFRleHQoZC50ZXh0LCAwLCAwKTtcblxuICAgIGlmIChkLnBhZGRpbmcpIHtcbiAgICAgIGMubGluZVdpZHRoID0gMiAqIGQucGFkZGluZztcbiAgICAgIGMuc3Ryb2tlVGV4dChkLnRleHQsIDAsIDApO1xuICAgIH1cblxuICAgIGMucmVzdG9yZSgpO1xuICAgIGQud2lkdGggPSB3O1xuICAgIGQuaGVpZ2h0ID0gaDtcbiAgICBkLnhvZmYgPSB4O1xuICAgIGQueW9mZiA9IHk7XG4gICAgZC54MSA9IHcgPj4gMTtcbiAgICBkLnkxID0gaCA+PiAxO1xuICAgIGQueDAgPSAtZC54MTtcbiAgICBkLnkwID0gLWQueTE7XG4gICAgZC5oYXNUZXh0ID0gdHJ1ZTtcbiAgICB4ICs9IHc7XG4gIH1cblxuICB2YXIgcGl4ZWxzID0gYy5nZXRJbWFnZURhdGEoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pLmRhdGEsXG4gICAgICBzcHJpdGUgPSBbXTtcblxuICB3aGlsZSAoLS1kaSA+PSAwKSB7XG4gICAgZCA9IGRhdGFbZGldO1xuICAgIGlmICghZC5oYXNUZXh0KSBjb250aW51ZTtcbiAgICB3ID0gZC53aWR0aDtcbiAgICB3MzIgPSB3ID4+IDU7XG4gICAgaCA9IGQueTEgLSBkLnkwOyAvLyBaZXJvIHRoZSBidWZmZXJcblxuICAgIGZvciAoaSA9IDA7IGkgPCBoICogdzMyOyBpKyspIHNwcml0ZVtpXSA9IDA7XG5cbiAgICB4ID0gZC54b2ZmO1xuICAgIGlmICh4ID09IG51bGwpIHJldHVybjtcbiAgICB5ID0gZC55b2ZmO1xuICAgIHZhciBzZWVuID0gMCxcbiAgICAgICAgc2VlblJvdyA9IC0xO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHc7IGkrKykge1xuICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSxcbiAgICAgICAgICAgIG0gPSBwaXhlbHNbKHkgKyBqKSAqIChjdyA8PCA1KSArICh4ICsgaSkgPDwgMl0gPyAxIDw8IDMxIC0gaSAlIDMyIDogMDtcbiAgICAgICAgc3ByaXRlW2tdIHw9IG07XG4gICAgICAgIHNlZW4gfD0gbTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlZW4pIHNlZW5Sb3cgPSBqO2Vsc2Uge1xuICAgICAgICBkLnkwKys7XG4gICAgICAgIGgtLTtcbiAgICAgICAgai0tO1xuICAgICAgICB5Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZC55MSA9IGQueTAgKyBzZWVuUm93O1xuICAgIGQuc3ByaXRlID0gc3ByaXRlLnNsaWNlKDAsIChkLnkxIC0gZC55MCkgKiB3MzIpO1xuICB9XG59IC8vIFVzZSBtYXNrLWJhc2VkIGNvbGxpc2lvbiBkZXRlY3Rpb24uXG5cblxuZnVuY3Rpb24gY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHN3KSB7XG4gIHN3ID4+PSA1O1xuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICAgIHcgPSB0YWcud2lkdGggPj4gNSxcbiAgICAgIGx4ID0gdGFnLnggLSAodyA8PCA0KSxcbiAgICAgIHN4ID0gbHggJiAweDdmLFxuICAgICAgbXN4ID0gMzIgLSBzeCxcbiAgICAgIGggPSB0YWcueTEgLSB0YWcueTAsXG4gICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgICAgbGFzdDtcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgIGxhc3QgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICBpZiAoKGxhc3QgPDwgbXN4IHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCkpICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB4ICs9IHN3O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjbG91ZEJvdW5kcyhib3VuZHMsIGQpIHtcbiAgdmFyIGIwID0gYm91bmRzWzBdLFxuICAgICAgYjEgPSBib3VuZHNbMV07XG4gIGlmIChkLnggKyBkLngwIDwgYjAueCkgYjAueCA9IGQueCArIGQueDA7XG4gIGlmIChkLnkgKyBkLnkwIDwgYjAueSkgYjAueSA9IGQueSArIGQueTA7XG4gIGlmIChkLnggKyBkLngxID4gYjEueCkgYjEueCA9IGQueCArIGQueDE7XG4gIGlmIChkLnkgKyBkLnkxID4gYjEueSkgYjEueSA9IGQueSArIGQueTE7XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGVSZWN0cyhhLCBiKSB7XG4gIHJldHVybiBhLnggKyBhLngxID4gYlswXS54ICYmIGEueCArIGEueDAgPCBiWzFdLnggJiYgYS55ICsgYS55MSA+IGJbMF0ueSAmJiBhLnkgKyBhLnkwIDwgYlsxXS55O1xufVxuXG5mdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChzaXplKSB7XG4gIHZhciBlID0gc2l6ZVswXSAvIHNpemVbMV07XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbZSAqICh0ICo9IC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0YW5ndWxhclNwaXJhbChzaXplKSB7XG4gIHZhciBkeSA9IDQsXG4gICAgICBkeCA9IGR5ICogc2l6ZVswXSAvIHNpemVbMV0sXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgc2lnbiA9IHQgPCAwID8gLTEgOiAxOyAvLyBTZWUgdHJpYW5ndWxhciBudW1iZXJzOiBUX24gPSBuICogKG4gKyAxKSAvIDIuXG5cbiAgICBzd2l0Y2ggKE1hdGguc3FydCgxICsgNCAqIHNpZ24gKiB0KSAtIHNpZ24gJiAzKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHggKz0gZHg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHkgKz0gZHk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggLT0gZHg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB5IC09IGR5O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gW3gsIHldO1xuICB9O1xufSAvLyBUT0RPIHJldXNlIGFycmF5cz9cblxuXG5mdW5jdGlvbiB6ZXJvQXJyYXkobikge1xuICB2YXIgYSA9IFtdLFxuICAgICAgaSA9IC0xO1xuXG4gIHdoaWxlICgrK2kgPCBuKSBhW2ldID0gMDtcblxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gZnVuY3RvcihkKSB7XG4gIHJldHVybiB0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJyA/IGQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH07XG59XG5cbnZhciBzcGlyYWxzID0ge1xuICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gIHJlY3Rhbmd1bGFyOiByZWN0YW5ndWxhclNwaXJhbFxufTtcblxuY29uc3QgT3V0cHV0ID0gWyd4JywgJ3knLCAnZm9udCcsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdhbmdsZSddO1xuY29uc3QgUGFyYW1zID0gWyd0ZXh0JywgJ2ZvbnQnLCAncm90YXRlJywgJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0J107XG5mdW5jdGlvbiBXb3JkY2xvdWQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGNsb3VkKCksIHBhcmFtcyk7XG59XG5Xb3JkY2xvdWQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnV29yZGNsb3VkJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdzYW5zLXNlcmlmJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFN0eWxlJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250V2VpZ2h0JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250U2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAxNFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFNpemVSYW5nZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiAnbnVsbGFibGUnLFxuICAgICdkZWZhdWx0JzogWzEwLCA1MF1cbiAgfSwge1xuICAgICduYW1lJzogJ3JvdGF0ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0ZXh0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NwaXJhbCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAndmFsdWVzJzogWydhcmNoaW1lZGVhbicsICdyZWN0YW5ndWxhciddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogNyxcbiAgICAnZGVmYXVsdCc6IE91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKFdvcmRjbG91ZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmIChfLnNpemUgJiYgIShfLnNpemVbMF0gJiYgXy5zaXplWzFdKSkge1xuICAgICAgZXJyb3IoJ1dvcmRjbG91ZCBzaXplIGRpbWVuc2lvbnMgbXVzdCBiZSBub24temVyby4nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2RwKHBhcmFtKSB7XG4gICAgICBjb25zdCBwID0gX1twYXJhbV07XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihwKSAmJiBwdWxzZS5tb2RpZmllZChwLmZpZWxkcyk7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpO1xuXG4gICAgaWYgKCEobW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgUGFyYW1zLnNvbWUobW9kcCkpKSByZXR1cm47XG4gICAgY29uc3QgZGF0YSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICAgIGxheW91dCA9IHRoaXMudmFsdWUsXG4gICAgICAgICAgYXMgPSBfLmFzIHx8IE91dHB1dDtcbiAgICBsZXQgZm9udFNpemUgPSBfLmZvbnRTaXplIHx8IDE0LFxuICAgICAgICByYW5nZTtcbiAgICBpc0Z1bmN0aW9uKGZvbnRTaXplKSA/IHJhbmdlID0gXy5mb250U2l6ZVJhbmdlIDogZm9udFNpemUgPSBjb25zdGFudChmb250U2l6ZSk7IC8vIGNyZWF0ZSBmb250IHNpemUgc2NhbGluZyBmdW5jdGlvbiBhcyBuZWVkZWRcblxuICAgIGlmIChyYW5nZSkge1xuICAgICAgY29uc3QgZnNpemUgPSBmb250U2l6ZSxcbiAgICAgICAgICAgIHNpemVTY2FsZSA9IHNjYWxlKCdzcXJ0JykoKS5kb21haW4oZXh0ZW50KGRhdGEsIGZzaXplKSkucmFuZ2UocmFuZ2UpO1xuXG4gICAgICBmb250U2l6ZSA9IHggPT4gc2l6ZVNjYWxlKGZzaXplKHgpKTtcbiAgICB9XG5cbiAgICBkYXRhLmZvckVhY2godCA9PiB7XG4gICAgICB0W2FzWzBdXSA9IE5hTjtcbiAgICAgIHRbYXNbMV1dID0gTmFOO1xuICAgICAgdFthc1szXV0gPSAwO1xuICAgIH0pOyAvLyBjb25maWd1cmUgbGF5b3V0XG5cbiAgICBjb25zdCB3b3JkcyA9IGxheW91dC53b3JkcyhkYXRhKS50ZXh0KF8udGV4dCkuc2l6ZShfLnNpemUgfHwgWzUwMCwgNTAwXSkucGFkZGluZyhfLnBhZGRpbmcgfHwgMSkuc3BpcmFsKF8uc3BpcmFsIHx8ICdhcmNoaW1lZGVhbicpLnJvdGF0ZShfLnJvdGF0ZSB8fCAwKS5mb250KF8uZm9udCB8fCAnc2Fucy1zZXJpZicpLmZvbnRTdHlsZShfLmZvbnRTdHlsZSB8fCAnbm9ybWFsJykuZm9udFdlaWdodChfLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcpLmZvbnRTaXplKGZvbnRTaXplKS5yYW5kb20ocmFuZG9tKS5sYXlvdXQoKTtcbiAgICBjb25zdCBzaXplID0gbGF5b3V0LnNpemUoKSxcbiAgICAgICAgICBkeCA9IHNpemVbMF0gPj4gMSxcbiAgICAgICAgICBkeSA9IHNpemVbMV0gPj4gMSxcbiAgICAgICAgICBuID0gd29yZHMubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHcsIHQ7IGkgPCBuOyArK2kpIHtcbiAgICAgIHcgPSB3b3Jkc1tpXTtcbiAgICAgIHQgPSB3LmRhdHVtO1xuICAgICAgdFthc1swXV0gPSB3LnggKyBkeDtcbiAgICAgIHRbYXNbMV1dID0gdy55ICsgZHk7XG4gICAgICB0W2FzWzJdXSA9IHcuZm9udDtcbiAgICAgIHRbYXNbM11dID0gdy5zaXplO1xuICAgICAgdFthc1s0XV0gPSB3LnN0eWxlO1xuICAgICAgdFthc1s1XV0gPSB3LndlaWdodDtcbiAgICAgIHRbYXNbNl1dID0gdy5yb3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhtb2QpLm1vZGlmaWVzKGFzKTtcbiAgfVxuXG59KTtcblxuZXhwb3J0IHsgV29yZGNsb3VkIGFzIHdvcmRjbG91ZCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kIH0gZnJvbSAndmVnYS11dGlsJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1zIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5leHBvcnQgeyBEYXRhZmxvdywgRXZlbnRTdHJlYW0sIE11bHRpUHVsc2UsIE9wZXJhdG9yLCBQYXJhbWV0ZXJzLCBQdWxzZSwgVHJhbnNmb3JtLCBjaGFuZ2VzZXQsIGRlZmluaXRpb24sIGluZ2VzdCwgaXNUdXBsZSwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1zLCB0dXBsZWlkIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgKiBhcyB0eCBmcm9tICd2ZWdhLXRyYW5zZm9ybXMnO1xuaW1wb3J0ICogYXMgdnR4IGZyb20gJ3ZlZ2Etdmlldy10cmFuc2Zvcm1zJztcbmltcG9ydCAqIGFzIGVuY29kZSBmcm9tICd2ZWdhLWVuY29kZSc7XG5pbXBvcnQgKiBhcyBnZW8gZnJvbSAndmVnYS1nZW8nO1xuaW1wb3J0ICogYXMgZm9yY2UgZnJvbSAndmVnYS1mb3JjZSc7XG5pbXBvcnQgKiBhcyB0cmVlIGZyb20gJ3ZlZ2EtaGllcmFyY2h5JztcbmltcG9ydCAqIGFzIGxhYmVsIGZyb20gJ3ZlZ2EtbGFiZWwnO1xuaW1wb3J0ICogYXMgcmVnIGZyb20gJ3ZlZ2EtcmVncmVzc2lvbic7XG5pbXBvcnQgKiBhcyB2b3Jvbm9pIGZyb20gJ3ZlZ2Etdm9yb25vaSc7XG5pbXBvcnQgKiBhcyB3b3JkY2xvdWQgZnJvbSAndmVnYS13b3JkY2xvdWQnO1xuaW1wb3J0ICogYXMgeGYgZnJvbSAndmVnYS1jcm9zc2ZpbHRlcic7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuZXhwb3J0ICogZnJvbSAndmVnYS10aW1lJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtbG9hZGVyJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5leHBvcnQgeyBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVDb2xvcnMsIGludGVycG9sYXRlUmFuZ2UsIHF1YW50aXplSW50ZXJwb2xhdG9yLCBzY2FsZSwgc2NoZW1lIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5leHBvcnQgeyBwcm9qZWN0aW9uIH0gZnJvbSAndmVnYS1wcm9qZWN0aW9uJztcbmV4cG9ydCB7IFZpZXcgfSBmcm9tICd2ZWdhLXZpZXcnO1xuZXhwb3J0IHsgZGVmYXVsdExvY2FsZSwgbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSBhcyBmb3JtYXRMb2NhbGUsIGxvY2FsZSwgcmVzZXREZWZhdWx0TG9jYWxlLCB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZSBhcyB0aW1lRm9ybWF0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuZXhwb3J0IHsgZXhwcmVzc2lvbkZ1bmN0aW9uIH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuZXhwb3J0IHsgcGFyc2UgfSBmcm9tICd2ZWdhLXBhcnNlcic7XG5leHBvcnQgeyBjb250ZXh0IGFzIHJ1bnRpbWVDb250ZXh0IH0gZnJvbSAndmVnYS1ydW50aW1lJztcbmV4cG9ydCB7IGNvZGVnZW5FeHByZXNzaW9uLCBwYXJzZUV4cHJlc3Npb24gfSBmcm9tICd2ZWdhLWV4cHJlc3Npb24nO1xuZXhwb3J0IHsgcGFyc2VTZWxlY3RvciB9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuXG52YXIgbmFtZSA9IFwidmVnYVwiO1xudmFyIHZlcnNpb24kMSA9IFwiNS4yMS4wXCI7XG52YXIgZGVzY3JpcHRpb24gPSBcIlRoZSBWZWdhIHZpc3VhbGl6YXRpb24gZ3JhbW1hci5cIjtcbnZhciBrZXl3b3JkcyA9IFtcblx0XCJ2ZWdhXCIsXG5cdFwidmlzdWFsaXphdGlvblwiLFxuXHRcImludGVyYWN0aW9uXCIsXG5cdFwiZGF0YWZsb3dcIixcblx0XCJsaWJyYXJ5XCIsXG5cdFwiZGF0YVwiLFxuXHRcImQzXCJcbl07XG52YXIgbGljZW5zZSA9IFwiQlNELTMtQ2xhdXNlXCI7XG52YXIgYXV0aG9yID0gXCJVVyBJbnRlcmFjdGl2ZSBEYXRhIExhYiAoaHR0cDovL2lkbC5jcy53YXNoaW5ndG9uLmVkdSlcIjtcbnZhciBtYWluID0gXCJidWlsZC92ZWdhLW5vZGUuanNcIjtcbnZhciBtb2R1bGUgPSBcImJ1aWxkL3ZlZ2EubW9kdWxlLmpzXCI7XG52YXIgdW5wa2cgPSBcImJ1aWxkL3ZlZ2EubWluLmpzXCI7XG52YXIganNkZWxpdnIgPSBcImJ1aWxkL3ZlZ2EubWluLmpzXCI7XG52YXIgdHlwZXMgPSBcImluZGV4LmQudHNcIjtcbnZhciByZXBvc2l0b3J5ID0gXCJ2ZWdhL3ZlZ2FcIjtcbnZhciBzY3JpcHRzID0ge1xuXHRidW5kbGU6IFwicm9sbHVwIC1jIC0tY29uZmlnLWJ1bmRsZVwiLFxuXHRwcmVidWlsZDogXCJyaW1yYWYgYnVpbGQgJiYgcmltcmFmIGJ1aWxkLWVzNVwiLFxuXHRidWlsZDogXCJyb2xsdXAgLWMgLS1jb25maWctY29yZSAtLWNvbmZpZy1idW5kbGUgLS1jb25maWctaWVcIixcblx0cG9zdGJ1aWxkOiBcIm5vZGUgc2NoZW1hLWNvcHlcIixcblx0cHJldGVzdDogXCJ5YXJuIGJ1aWxkIC0tY29uZmlnLXRlc3RcIixcblx0dGVzdDogXCJUWj1BbWVyaWNhL0xvc19BbmdlbGVzIHRhcGUgJ3Rlc3QvKiovKi10ZXN0LmpzJ1wiLFxuXHRwcmVwdWJsaXNoT25seTogXCJ5YXJuIHRlc3QgJiYgeWFybiBidWlsZFwiLFxuXHRwb3N0cHVibGlzaDogXCIuL3NjaGVtYS1kZXBsb3kuc2hcIlxufTtcbnZhciBkZXBlbmRlbmNpZXMgPSB7XG5cdFwidmVnYS1jcm9zc2ZpbHRlclwiOiBcIn40LjAuNVwiLFxuXHRcInZlZ2EtZGF0YWZsb3dcIjogXCJ+NS43LjRcIixcblx0XCJ2ZWdhLWVuY29kZVwiOiBcIn40LjguM1wiLFxuXHRcInZlZ2EtZXZlbnQtc2VsZWN0b3JcIjogXCJ+My4wLjBcIixcblx0XCJ2ZWdhLWV4cHJlc3Npb25cIjogXCJ+NS4wLjBcIixcblx0XCJ2ZWdhLWZvcmNlXCI6IFwifjQuMC43XCIsXG5cdFwidmVnYS1mb3JtYXRcIjogXCJ+MS4wLjRcIixcblx0XCJ2ZWdhLWZ1bmN0aW9uc1wiOiBcIn41LjEyLjFcIixcblx0XCJ2ZWdhLWdlb1wiOiBcIn40LjMuOFwiLFxuXHRcInZlZ2EtaGllcmFyY2h5XCI6IFwifjQuMC45XCIsXG5cdFwidmVnYS1sYWJlbFwiOiBcIn4xLjEuMFwiLFxuXHRcInZlZ2EtbG9hZGVyXCI6IFwifjQuNC4xXCIsXG5cdFwidmVnYS1wYXJzZXJcIjogXCJ+Ni4xLjRcIixcblx0XCJ2ZWdhLXByb2plY3Rpb25cIjogXCJ+MS40LjVcIixcblx0XCJ2ZWdhLXJlZ3Jlc3Npb25cIjogXCJ+MS4wLjlcIixcblx0XCJ2ZWdhLXJ1bnRpbWVcIjogXCJ+Ni4xLjNcIixcblx0XCJ2ZWdhLXNjYWxlXCI6IFwifjcuMS4xXCIsXG5cdFwidmVnYS1zY2VuZWdyYXBoXCI6IFwifjQuOS40XCIsXG5cdFwidmVnYS1zdGF0aXN0aWNzXCI6IFwifjEuNy4xMFwiLFxuXHRcInZlZ2EtdGltZVwiOiBcIn4yLjAuNFwiLFxuXHRcInZlZ2EtdHJhbnNmb3Jtc1wiOiBcIn40LjkuNFwiLFxuXHRcInZlZ2EtdHlwaW5nc1wiOiBcIn4wLjIyLjBcIixcblx0XCJ2ZWdhLXV0aWxcIjogXCJ+MS4xNy4wXCIsXG5cdFwidmVnYS12aWV3XCI6IFwifjUuMTAuMVwiLFxuXHRcInZlZ2Etdmlldy10cmFuc2Zvcm1zXCI6IFwifjQuNS44XCIsXG5cdFwidmVnYS12b3Jvbm9pXCI6IFwifjQuMS41XCIsXG5cdFwidmVnYS13b3JkY2xvdWRcIjogXCJ+NC4xLjNcIlxufTtcbnZhciBkZXZEZXBlbmRlbmNpZXMgPSB7XG5cdFwidmVnYS1zY2hlbWFcIjogXCIqXCJcbn07XG52YXIgZ2l0SGVhZCA9IFwiNzc0MTY1ZTI5ODUwYjY2ZWM4Yjc5YmE1MmE3OTU1ZjFhYjkzNmVhNlwiO1xudmFyIHBrZyA9IHtcblx0bmFtZTogbmFtZSxcblx0dmVyc2lvbjogdmVyc2lvbiQxLFxuXHRkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG5cdGtleXdvcmRzOiBrZXl3b3Jkcyxcblx0bGljZW5zZTogbGljZW5zZSxcblx0YXV0aG9yOiBhdXRob3IsXG5cdG1haW46IG1haW4sXG5cdG1vZHVsZTogbW9kdWxlLFxuXHR1bnBrZzogdW5wa2csXG5cdGpzZGVsaXZyOiBqc2RlbGl2cixcblx0dHlwZXM6IHR5cGVzLFxuXHRyZXBvc2l0b3J5OiByZXBvc2l0b3J5LFxuXHRzY3JpcHRzOiBzY3JpcHRzLFxuXHRkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcblx0ZGV2RGVwZW5kZW5jaWVzOiBkZXZEZXBlbmRlbmNpZXMsXG5cdGdpdEhlYWQ6IGdpdEhlYWRcbn07XG5cbi8vIC0tIFRyYW5zZm9ybXMgLS0tLS1cbmV4dGVuZCh0cmFuc2Zvcm1zLCB0eCwgdnR4LCBlbmNvZGUsIGdlbywgZm9yY2UsIGxhYmVsLCB0cmVlLCByZWcsIHZvcm9ub2ksIHdvcmRjbG91ZCwgeGYpOyAvLyAtLSBFeHBvcnRzIC0tLS0tXG5cbmNvbnN0IHZlcnNpb24gPSBwa2cudmVyc2lvbjtcblxuZXhwb3J0IHsgdmVyc2lvbiB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==